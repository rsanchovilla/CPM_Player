;***************************************************************************
;	GRAPHICS CONTROL PACKAGE FOR MAGIC DA SYSTEM
;	THESE ROUTINES ARE PROTECTED BY SOFTWARE LICENSING
;	AGREEMENTS AND MAY NOT BE USED OR COPIED WITHOUT
;	WRITTEN PERMISSION OF DASOFT.
;	  COPYRIGHT 1981 DASOFT DESIGN SYSTEMS, INC.

;	THESE PROGRAMS MUST NOT BE LONGER THAN 1K (1024) BYTES LONG
;	 AND  MUST BE ORIGINED AT 1800 HEX

;	**** SPECIAL CONSOLE TERMINAL GRAPHICS PACKAGE **********
;			*** REV 2.4 ***

MATRIX	EQU	2500H	;  START OF DATA


VERS	EQU	0032H	;  
REV	EQU	0034H	;  
EDIT	EQU	0064H	;  
	                    
WBOOT	EQU	0000H	;  WARM BOOT ADDRESS
TYPEF	EQU	0002H	;  BDOS PRINT COMMAND NUMBER
BDOS	EQU	0005H	;  ADDRESS  OF BDOS JUMP POINT
BUFF	EQU	0080H	;  ADDRESS OF DISK INPUT BUFFER
DMA	EQU	001AH	;  SET DMA ADDRESS FUNCT NUMB
READF	EQU	0014H	;  DISK READ FUNCTION
WRITEF	EQU	0015H	;  WRITE FILE TO DISK NUM
OPENS	EQU	000FH	;  OPEN FILE FUNCT NUMBER
CLOSES	EQU	0010H	;  CLOSE  FILE FUNCT NUMBER
                
FCB	EQU	005CH	;  FILE CONTROL BLOCK ADRS
FCBDN	EQU	005CH	;  FCB DISK NAME
FCBFN	EQU	005DH	;  FILE NAME
FCBFT	EQU	0065H	;  FILE TYPE
FCBRL	EQU	0068H	;  CURRENT REEL NUMBER
FCBRC	EQU	006BH	;  FILE RECORD COUNT (0-128)
FCBCR	EQU	007CH	;  CURRENT (NEXT) RECORD NUMBER
FCBLN	EQU	007DH	;  FCB LENGTH
                
TOPPTR	EQU	0006H	;  WAS (AD00H) STACK START 48K
                
CLEAD	EQU	0001H	;  CURSOR POSITIONING STRING CODE
P3LINES	EQU	0003H	;  PRINT THREE LINES
CONTMSG	EQU	000BH	;  CONTINUE MESSAGE CODE
CLS	EQU	000CH	;  CLEAR SCREEN CODE
IVON	EQU	000EH	;  INVERSE ON CODE
IVOFF	EQU	000FH	;  INVERSE OFF CODE
                
CR	EQU	000DH	;  RETURN CHARACTER
LF	EQU	000AH	;  LINE FEED CHARACTER
BEEP	EQU	0007H	;  BEL CHARACTER
TAB	EQU	0009H	;  TAB CHARACTER
BS	EQU	0008H	;  BACK SPACE
ESC	EQU	001BH	;  ESCAPE
EOM	EQU	00EEH	;  END OF MESSAGE MARKER (OVERLAY FILE)
EOF	EQU	00FFH	;  END OF FILE MARKER    (OVERLAY FILE)
MSCNT	EQU	00F9H	;  1 MSEC SOFTWARE DELAY CONSTANT
                
OMOS16	EQU	0058H	; 
OMOS17	EQU	005FH	; 
OMOS18	EQU	0064H	; 
OMOS19	EQU	0065H	; 
OMOS20	EQU	0067H	; 
OMOS21	EQU	006CH	; 
OMOS22	EQU	006EH	; 
OMOS23	EQU	0073H	; 
OMOS24	EQU	0079H	; 
                
RDRL	EQU	0103H	;  LOADER KERNAL OR TEST PROG
                
DALN	EQU	0106H	;  END OF DASOFT FOR SAVE FROM INSTALL
                
CURSOR	EQU	010BH	;  ADDRESS CURSOR ROUTINE
PSTRNG	EQU	010EH	;  PRINT AN ASCII STRING
WRITE	EQU	0111H	;  WRITE CHAR IN A TO CONSOLE
INCHNE	EQU	011DH	;  ROUTINE TO READ CONSOLE NO ECHO
FSERR	EQU	012CH	;  PRINT MESSAGE IN ERR FIELD FS
DELAY	EQU	0153H	;  DELAY ROUTINE


	ORG 1C00H

GINIT	JMP	INIT		; GRAPHICS INITIALIZATION
PIXEL	JMP	PLOT		; PLOT POINT COMMAND
CURSER	JMP	SETCURS
INCHAR	JMP	CHARIN		; READ EXTERNAL CURSOR CONTROL
SIDE1	JMP	SID1		; IF 128 WIDE, SWITCH SIDES
SIDE2	JMP	SID2
USER3	JMP	USR3		; THIRD USER ROUTINE (ZOOM)

;	TEMP LOCATIONS

ACTIVE1	DB	00
ACTIVE2	DB	00		; CURRENTLY ACTIVE SIDE
XDOT	DB	00		; X COORDINATE
YDOT	DB	00		; Y COORDINATE
OTL	DB	00		; NON-ZERO MEANS OUTLINE IS USING TGRAPHS
CSIDE	DB	00		; NOT USED IN CGS-808
SHORT	DB	00		; SHORT MATRICES USED
TEMP1	DB	00
TEMP2	DB	00		; THESE ARE USED FOR MAX MIN
TEMP3	DB	00
TEMP4	DB	00		; THESE ARE USED FOR MATRIX SIZE
CURSID	DB	00		; 0=SIDE1 1=SIDE2 CURRENTLY DISPLAYED


;	**** THESE ARE KEY DEFINITIONS FOR DOING INTERACTIVE
;	GRAPHICS.  A 10-KEY PAD IS SHOWN SET UP HERE, USER MAY
;	CHANGE AS NECESSARY

CURUP	DB	'8'		; MOVE CURSOR UP
CURDN	DB	'2'		; MOVE CURSOR DOWN
CURLFT	DB	'4'
CURRT	DB	'6'
CURMOV	DB	','		; MOVE CURSOR ONLY, NO POINTS SET
SETPNT	DB	'.'		; CURSOR DEFINES A USED POINT
SETPAD	DB	'0'		; CURSOR DEFINES A PAD LOCATION
SIDX1	DB	'7'		; CURSOR IS ON SIDE 1
SIDX2	DB	'9'		; CURSOR IS ON SIDE 2
FUNCT	DB	'5'		; SPECIAL FUNCTION KEY

BLINK	JMP	DOBLINK		; SUBROUTINE FOR SETTING VIDEO

;	****** THE USER MAY CHANGE THESE TO NORMAL PRINT CHARACTERS
;	OR TO WHATEVER STRING IS NECESSARY TO TURN ON THE GRAPHICS 
;	CHARACTERS FOR THE TERMINAL.  NOTE THAT A 24H OR $ TERMINATOR
;	IS REQUIRED ON THE END OF THE STRING.  IF YOUR TERMINAL REQUIRES
;	A $ AS PART OF THE GRAPHICS STRING, MOST TERMINALS IGNORE THE 
;	UPPER ASCII BIT, SO AN 0A4H WILL ACCOMPLISH THE SAME THING.


QHORIZ	DB	'-',24H,0,0,0,0,0,0
QVERT	DB	07CH,24H,0,0,0,0,0,0
QULC	DB	'+',24H,0,0,0,0,0,0
QURC	DB	'+',24H,0,0,0,0,0,0
QLLC	DB	'+',24H,0,0,0,0,0,0
QLRC	DB	'+',24H,0,0,0,0,0,0


;	NOW SOME DEFINTIONS

XMAX	EQU	80		; MAX X SIZE
YMAX	EQU	24		; MAX Y XIZE
BACKG	EQU	' '		; BACKGROUND COLOR CODE

;	**** NOW A FEW TEMP VARIABLES USEED BY THE ROUTINES


CURXHI	DB	80		; CURRENT MAXIMUM DISPLAYED X VALUE
CURXLO	DB	00		; CURRENT MIN DISPLAYED X VALUE

CURYHI	DB	20		; CURRENT MAX Y DISPLAYED VALUE
CURYLO	DB	00		; CURRENT MIN Y DISPLAYED VALUE

XPOSX	DB	00
YPOSY	DB	00		; CURSOR LOC FOR PRINTING



;	*********** READ MATRIX CHARACYYER ROUTINE *************
;	WITH B=X, C=Y, DETERMINE WHAT CHARACTER SHOULD BE DISPLAYED
;	ALL REGS SAVED, EXITS WITH DE POINTING TO ASCII STRING TO
;	BEL KPRINTED. THIS IS FOR DIALOG 80 ESCAPE SEQUENCES JTO
;	DRAW GRAPHICS CHARACTERS ON THE SCREEN

QNORM	DB	00,24H

;	********** SUBROUTINES **************

RDMATX	PUSH	B
	PUSH	H

	CALL	COORD		; GET ADDRESS OF BYTE IN HL
	MOV	B,M		; READ MATRIX

	LDA	CURSID		; CURRENTLY DISPLAYED SIDE
	ORA	A
	JZ	XORECT		; CORRECT FOR SIDE 1

;	SIDE 2, STRIP OUT SIDE 1

	MOV	A,B
	ANI	0FH		; STRIP OFF SIDE 1
	JMP	DETERM		; DETERMINE ASCII EQUIVAAENT

XORECT	MOV	A,B
	RRC
	RRC
	RRC
	RRC			; SHIFT HHI TO LO NIBBLE
	ANI	0FH		; CLEAR OUT OTHER SIDE

DETERM	MOV	B,A

	LDA	OTL		; GET OUTLINE FLAG
	ORA	A		; TEST MODE 
	JZ	NORMDEC		; DECODE NORMALLY IF ZERO

	MOV	A,B		; GET CHARACTER BACK
	CPI	0		; TEST FOR ZERO
	JZ	NUTN		; NOTHING THERE IF ZERO

	CPI	10		; TEST FOR VIA OR PAD 
	JNC	NORMDEC		; GO DECODE NORMALLY

	ORI	30H		; MAKE INTO NUMBER
	JMP	OUTCX		; PRINT GRID NUMBER

NORMDEC	MOV	A,B
	CPI	1
	JZ	GRID

	CPI	2
	JZ	REGMARK

	CPI	4
	JZ	HLIN

	CPI	5
	JZ	VLIN

	CPI	6
	JZ	URCCORN

	CPI	7
	JZ	LRCCORN

	CPI	8
	JZ	ULCCORN

	CPI	9
	JZ	LLCCORN

	CPI	10
	JZ	VIAS

	CPI	11
	JZ	PADS

	CPI	12
	JZ	HOLE

	CPI	13
	JZ	BIGHOLE

	CPI	14		; EDGE MARKER
	JZ	EDGE		; 

	CPI	15		; MOUNTING HOLE
	JZ	MNTHOLE		; 

NUTN	MVI	A,BACKG
	JMP	OUTCX

GRID	MVI	A,'*'
	JMP	OUTCX

HLIN	LXI	D,QHORIZ
	JMP	OUTCX2

VLIN	LXI	D,QVERT
	JMP	OUTCX2

ULCCORN	LXI	D,QULC
	JMP	OUTCX2

URCCORN	LXI	D,QURC
	JMP	OUTCX2

LRCCORN	LXI	D,QLRC
	JMP	OUTCX2

LLCCORN	LXI	D,QLLC
	JMP	OUTCX2

VIAS	MVI	A,'o'
	JMP	OUTCX

PADS	MVI	A,'@'
	JMP	OUTCX

REGMARK	MVI	A,'X'
	JMP	OUTCX

HOLE	MVI	A,'O'
	JMP	OUTCX

EDGE	MVI	A,'E'		; EDGE MARK
	JMP	OUTCX		; 

MNTHOLE	MVI	A,'M'		; MOUNTING HOLE
	JMP	OUTCX		; 

BIGHOLE	MVI	A,'0'

OUTCX	STA	QNORM
	LXI	D,QNORM

OUTCX2	POP	H
	POP	B
	RET


;	******** CHARACTER INPUT ROUTINE *************
;	IF JOYSTICK AVAILABLE OR LIGHT PEN, THIS ROUTINE
;	COULD READ DEVICE AND SEND CODE. IF NOT, JUST
;	READ CONSOLE.
;	NO INPUTS, CHARACTER COMMAND EXPECTED IN A
;	NO OTHER REGS CHANGED

CHARIN	EQU	INCHNE		; READ MAGIC KERNAL CHAR IN

;	******** BLINK SUBROUTINE TO BLINK OR SET INVERSE VIDEO *****
;	WHEN CALLED, XDOT,YDOT,HAVE COORDINATE OF POINT, AND WHENEVER
;	THAT POINT IS GOING TO BE CALLED, INVERSE VIDEO OR BLINK IS
;	ADDED TO IT.  UP TO TWO POINTS MAY BE BLINKED A THE SAME TIME.
;	ALL REGS SAVED

BLINK1	DW	0		; XY OF FIRST BLINK POINT
BLINK2	DW	0		; XY OF SECOND BLINK POINT
B12	DB	0		; KEEPS TRACK OF WHERE TO STORE NEW BLNK

DOBLINK	PUSH	PSW
	PUSH	H
	LHLD	XDOT		; GET COORDINATE
	LDA	B12		; BLINK 1 OR BLINK 2?
	ORA	A
	JZ	BLK1

	SHLD	BLINK2
	JMP	ENDB

BLK1	SHLD	BLINK1

ENDB	INR	A
	ANI	1		; MAKE NON ZERO OR ZERO
	STA	B12

	POP	H
	POP	PSW
	RET




;	******* USER DEFINED PROGRAM 3 *************
;	WILL MOST LIKELY BE USED FOR ZOOM FUNCTION A
;	LITTLE  LATER, OR WHATEVER YOUR LITTLE HEART
;	DESIRES
;	JUST DON'T DESTROY ANY REGISTERS!
;	FOR THIS IMPLEMENTATION, THE ROUTINE WILL  DETERMIINE
;	A SQUARE AREA AROUND THE CURRENT XY 20 BY 80, SET THE
;	CORRECCT X AND Y MAX AND MIN, THEN CALL THE CORRECT SIDE
;	ROUTINE TO PRINT OUT THAT NEW AREA, ACCOMPLISHING SCROLL.


USR3	PUSH	PSW		; NO CHANGEE REGEE

	LDA	XDOT		; FIRST, IS IT ABOVE 10?
	CPI	40
	JC	NOT40		; NO, A<40, ZERO IS LEFT BOUNDARY

;	NEXT CHECK FOR HITTING RIGHT SIDE

	CPI	210
	JNC	NOT210		; NOT ENOUGH ROOM ON RIGHT

;	BOTH REGIONS OK

	SUI	40
	STA	CURXLO		; SET LEFT SIDE

	ADI	80
	STA	CURXHI		; SET RIGHT SIIDE
	JMP	CHECKYS

NOT40	MVI	A,0
	STA	CURXLO

	MVI	A,80
	STA	CURXHI
	JMP	CHECKYS

NOT210	MVI	A,170
	STA	CURXLO

	MVI	A,250
	STA	CURXHI

CHECKYS	LDA	YDOT
	CPI	10
	JC	NOT10		; A IS LESS THAN 10, 0 BOTTOM

	CPI	118
	JNC	NOT117		; A IS > 117, 127 TOP

;	BOTH BOUNDARIES OK

	SUI	10
	STA	CURYLO

	ADI	20
	STA	CURYHI
	JMP	OUT3

NOT10	MVI	A,0
	STA	CURYLO

	MVI	A,20
	STA	CURYHI
	JMP	OUT3

NOT117	MVI	A,108
	STA	CURYLO

	MVI	A,128
	STA	CURYHI

;	NOW CALL THE CORRECT DISPLAY FUNCTION,AND PUT THE CURSOR
;	TO ITS NEW POSITION WHATEVER THAT IS.

OUT3	LDA	CURSID
	ORA	A
	JZ	CALS1

	CALL	SIDE2
	JMP	CALCS

CALS1	CALL	SIDE1

CALCS	CALL	SETC		; GET CURSOR POSITION IN NEW SCRN
	PUSH	D

	LXI	D,XPOSX
	CALL	CURSOR

	POP	D
	POP	PSW
	RET


;	************* MULTIPLY ROUTINE *****************
;	MULTIPLY BC=C*D

MULT	PUSH	PSW
	PUSH	D

	MVI	B,0
	MVI	E,9

MULT0	MOV	A,C
	RAR
	MOV	C,A
	DCR	E
	JZ	MULT2

	MOV	A,B
	JNC	MULT1

	ADD	D

MULT1	RAR
	MOV	B,A
	JMP	MULT0

MULT2	POP	D
	POP	PSW
	RET





;	INITIALIZATION , JUST SET SOME INITIAL VARAIBLES

INIT	RET

;	******* PLOT POINT ROUTINE *****************
;	THIS ROUTINE PLOTS A POINT ON GRAPHICS SCREEN
;	BY DISPLAYING ONLY ONE SIDE BLACK&WHITE, AND CHECKING
;	THE ORIGINAL MEMORY MATRIX FOR THE EXACT CHARACTER PLACED.
;	NO OUTPUT, ENTRY PARMS ARE ACT1,2 AND XDOT,YDOT,OTL


PLOT	PUSH	PSW
	PUSH	B
	PUSH	D
	PUSH	H		; SAVE  MACHINE STATE

	CALL	SETC
	JMP	PLOT2		; DETERMINE IF WITHING RANGE THEN CONT


;	***** SETC ROUTINE DETERMINES  IF XDOT,YDOT IS WITHIN
;	SCREEN RANGE AND SETS XPOSY WITH CURRENT SCREEN CURSOR LOCATION
;	IF IT IS WITHIN RANGE. IF NOT WITHIN RANGE, CARRY SET

AUTOS	DB	0		; AUTO SCROLL ENABLED

SETC	LDA	AUTOS
	MOV	C,A

	LDA	CURXHI		; GET MAX X XOUNT
	MOV	B,A

	LDA	XDOT
	CMP	B		; IF X>= MAX, NO GO
	JNC	ENDP		; NO PLOT TODAY TOADY

;	NOW CHECK FOR AUTO SCROLL

	DCR	C		; CHECK IF AUTOSCROLL =1
	JNZ	NOSCR1

	CPI	249
	JZ	NOSCR1		; NO SCROLLING, ALREADY MAX

	DCR	B		; SEE IF ONE OFF
	CMP	B
	JZ	SCROLLQ		; SCROLL THE SCREEN AND TRY AGAIN

;	NOW TRY FOR X BELOW RANGE

NOSCR1	LDA	AUTOS
	MOV	C,A

	LDA	CURXLO		; MIN X COUNT
	MOV	B,A

	LDA	XDOT
	CMP	B
	JC	ENDP		; BELOW RANGE

;	CHECK FOR AUTO SCROLL

	DCR	C
	JNZ	NOSCR2

	CPI	1
	JZ	NOSCR2

	INR	B		; SEE IF ONE AWAY
	CMP	B
	JZ	SCROLLQ

	DCR	B		; PUT B BAK WHERE IT WAS

;	NOT TO FIND SCREEN LOCATION, SUBTRACT SCREEN LOW FROM XDOT

NOSCR2	SUB	B
	STA	XPOSX		; CURSOR LOCATION

;	NOW CHECK Y WITHIN RAGND

	LDA	AUTOS
	MOV	C,A

	LDA	CURYHI
	MOV	B,A

	LDA	YDOT		; TEMP STORAGE OF MAX Y WINDOW
	CMP	B
	JNC	ENDP

;	CHECK FOR AUTO SCROLL

	DCR	C
	JNZ	NOSCR3

	CPI	127
	JNC	NOSCR3

	DCR	B		; CHECK IF ALMOST THERE
	CMP	B
	JZ	SCROLLQ

;	NOW CHECK FOR Y UNDER RANGE

NOSCR3	LDA	AUTOS
	MOV	C,A

	LDA	CURYLO
	MOV	B,A

	LDA	YDOT
	CMP	B
	JC	ENDP

;	CHECK FOR AUTO SCROLL

	DCR	C
	JNZ	NOSCR4

	CPI	1
	JZ	NOSCR4

	INR	B
	CMP	B
	JZ	SCROLLQ

	DCR	B		; PUT B BACK WHERE IT WAS

;	FIND ACTURAL LOCATION

NOSCR4	SUB	B

;	THIS GIVES THE DISTANCE FROM SCREEN 0, BUT ON TERMINALS 0 IS TOP
;	SO NEED TO INVERT TO BOTTOM

	MOV	B,A
	MVI	A,23
	SUB	B
	STA	YPOSY

	XRA	A		; CLEAR CARRY
	RET

ENDP	STC
	RET

SCROLLQ	CALL	USER3		; DO THE SCROLL ROUTINE
	JMP	SETC




;	XY OK, GIVE COMMAND TO PLOT POINT

PLOT2	JC	ENDP2		; NO SET POINT
	LXI	D,XPOSX		; POINNT TO CURSOR LOC
	CALL	CURSOR		; MAGIC CURSOR MOVE RUTINE

	LDA	XDOT
	MOV	B,A

	LDA	YDOT
	MOV	C,A		; B=X C=Y

	CALL	RDMATX		; GET CHARACTER FROM MATRIX
	CALL	PSTRNG		; PRINT THE CHARACTER TO CONSOLE

ENDP2	POP	H
	POP	D
	POP	B
	POP	PSW
	RET			; GONZO WITH THE WINDO


;	******** CURSOR MOVEMENT ROUTINES ****************
;	SUBROUTINE TO DETERMINE THE MEMORY ADDRESS OF A
;	MATRIX COORDINATE IN NORMAL 32K ARRAY WHICH STARTS
;	AT 2000H AND DOES X BEFORE Y. INPUTS..B=X, C=Y
;	DE DESTROYED, AND A, HL=ADRS AT EXIT


COORD	PUSH	B		; SAVE XY
	MVI	D,250		; MULTIPLIER FOR Y
	CALL	MULT		; BC=MULTIPLY OF ROWS BY X BYTES

	LXI	H,MATRIX	; NORMAL MATRIX STARTING POINT
	DAD	B		; ADD BASE AND FIRST OFFSET (Y)
	POP	B		; GET XY BACK

CDND	MOV	E,B
	MVI	D,0		; MAKE X 16 BITS
	DAD	D
	RET			; HL NOW HAS ADDRESS



;	***** MOVE CURSOR ROUTINE ***************
;	NOTE:
;	IF A=1 ON ENTRY, THE  OLD CURSOR POSITION WILL BE MARKED.
;	FOR TERMINAL, SIMPLYY GET CORRCT CURSOR ADDRESS AND MOVE THERE.

LASTCUR	DW	0		; CURENT POS BEFORE MOVE

SETCURS	PUSH	PSW
	PUSH	B
	PUSH	D
	PUSH	H

	PUSH	PSW
	MVI	A,1
	STA	AUTOS		; TURN ON AUTOSCROLL

	CALL	SETC		; GET POSITION  IF ON SCREEN
	JC	NOCURS		; NOT ON  SCREEN

	POP	PSW		; GET A BACK, IF 1, SET CURRENTL POS
	ORA	A
	JZ	NOSTC		; DO NOT SET CURRENT POSSITION

	LHLD	XDOT		; GET CURRENT POSITION
	PUSH	H

	LHLD	LASTCUR		; GET POSITION WAS AT BUT NOT MOVED YET?
	SHLD	XDOT

	CALL	SETC
	JC	NOSTC

	PUSH	D
	LHLD	XDOT
	MOV	B,L
	MOV	C,H		; B=X, C=Y
	CALL	RDMATX

	PUSH	D
	LXI	D,XPOSX
	CALL	CURSOR
	POP	D

	CALL	PSTRNG
	POP	D
	POP	H

	SHLD	XDOT
	CALL	SETC

NOSTC	LXI	D,XPOSX
	CALL	CURSOR
	JMP	NOC2

NOCURS	POP	PSW

NOC2	LHLD	XDOT
	SHLD	LASTCUR		; SAVE CURRENT CURSOR LOCATION

	XRA	A
	STA	AUTOS		; TURN OFF AUTO SCROLL

	POP	H
	POP	D
	POP	B
	POP	PSW
	RET



;	************ SIDE1, SIDE2 COMMANDS ******************
;	THIS ROUTINES DISSPLAY TOP OR BOTTOM SIDE OR BOARD
;	SIDE1 =TOP, WITHIN SCREEN LIMITS SET BY CURSOR.  CURSOR
;	SCREEN POSISTIONS ARE MOVED BY FUNCTION 3.

;	B=CURRENT X
;	C=CURRENT Y

SXPOS	DB	0		; POS XY FOR CURSOR
SYPOS	DB	4		; Y STARTS AT 4

SID1	PUSH	PSW
	PUSH	B
	PUSH	D
	PUSH	H

	XRA	A		; ZERO
	STA	CURSID		; NOW ALL THINGS OCCUR ON S1

SRET	CALL	PRTSCRN
	CALL	SETC		; GET THE RIGHT CURSOR BACK

	LXI	D,XPOSX
	CALL	CURSOR

	POP	H
	POP	D
	POP	B
	POP	PSW
	RET

SID2	PUSH	PSW
	PUSH	B
	PUSH	D
	PUSH	H

	MVI	A,1
	STA	CURSID
	JMP	SRET


;	******* SRET SUBROUTINE PRINTS  OUT ONE PAGE  OF SCREEN INFO
;	BOUNDED BY CURXLO,CURYLO,  20 BY 80 USING RDMATX.

SIDCURS	DB	0,0		; CURSOR LOCATION

PRTSCRN	XRA	A
	STA	SIDCURS

	MVI	A,3
	STA	SIDCURS+1	; UPPER LEFT CORNER SCREEN

	LDA	CURXLO
	STA	SXPOS

	LDA	CURYHI
	STA	SYPOS		; INITIALIZE TEMP SCREEN COORD VARS

	MVI	E,20

;	NOW THE PRINT LOOP.  D IS INSIDE LOOP PRINTING 80 CHARACTERS,
;	E IS THE OUTSIDE LOOP PRINTING 20 LINES

PLINE	MOV	A,E		; CHECK ALL LINES DONE
	CPI	0		; LAST LINE?
	JNZ	CHEK0		; CHECK FOR ZERO

;	IF 1, THEN ONLY DO 79 CHARACTERS, DUE TO AUTO LF

	MVI	D,79
	JMP	CONT79

CHEK0	MVI	D,80		; SET NUMBER OF CHARACTERS

CONT79	PUSH	D
	LXI	D,SIDCURS	; MOVE CURSTO TO LOC
	CALL	CURSOR
	POP	D

PCHAR	MOV	A,D		; CHECK END OF LINE
	ORA	A
	JZ	ENDLIN		; END OF ONE LINE

	PUSH	D
	LDA	SXPOS
	MOV	B,A		; B=X

	LDA	SYPOS
	MOV	C,A		; C=Y

;	NOW SEE IF THESE MATCH THE BLINK POSITIONS, AND CALL THE
;	ROUTINE TO SET THAT ATTRIBUTE IF SO.

	LDA	BLINK1		; GET X
	CMP	B
	JNZ	NOBLINK

	LDA	BLINK1+1
	CMP	C
	MVI	A,'S'
	JZ	BLINKOK

NOBLINK	LDA	BLINK2
	CMP	B
	JNZ	NOBL

	LDA	BLINK2+1
	CMP	C
	JNZ	NOBL

	MVI	A,'D'

BLINKOK	PUSH	D

;	EXPLANATION:  SINCE THE TERMINAL CANNOT DISPLAY A BLINKING
;	CHARACTER WITHOUT THE ATTRIBUTE CHARACTERS VISIBLE JON EACH 
;	SIDE OF IT, WE WILL MARK ONLY WITH S AND D.  IF THE TERMINAL IS
;	CAPABLE OF BLINKING A SINGLE CHARACTER, PRINT A STRING WHICH 
;	WILL DO SO, (THEN REMEMEBER TO TURN BLINK OFF)
;	A CONTAINS THE BLINK CHARACTER

	CALL	WRITE
	POP	D
	JMP	NOBL2		; DO NOT PRINT NORMAL CHARACTER

NOBL	CALL	RDMATX
	CALL	PSTRNG		; PRINT THE CHARACTER

NOBL2	POP	D
	DCR	D
	LDA	SXPOS
	INR	A
	STA	SXPOS
	JMP	PCHAR		; LOOP FOR ONE LINE

ENDLIN	LDA	CURXLO
	STA	SXPOS

	LDA	SYPOS
	DCR	A
	STA	SYPOS

	LDA	SIDCURS+1	; GET CURSOR LOC NEXT L;LINE
	INR	A
	STA	SIDCURS+1

	MOV	A,E		; NOW CHEK END OF PRINT
	CPI	0
	RZ

	DCR	E
	JMP	PLINE		; PRINT ANOTHER LINE




	END
