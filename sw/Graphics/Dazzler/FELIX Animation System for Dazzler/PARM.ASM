; 7 SEPT,NIGHT.I RE-REPAIR CHARIN...
;
; FIX TO INCORPORATE TYPE 4 AND TYPE 7
; BY CHANDRA AND MCCHAREN ON AUGUST 25 '79
;
; PARM: INPARM & OUTPARM BY WITTENBERG. SOME
; FIXES (INCLUDING THE 'RESCALE' OP IMBEDDED) BY
; MOSHELL.
;
; INPUT CONDITIONS:
;
; PGMCTR ( OR FPC ) POINTS TO THE 'TYPE' BYTE OF THE PARAMETER.
;
; OUTPUT CONDITIONS:
;
; INPAR RETURNS THE VALUE OF THE PARAMETER IN D-E.
;
PGMCTR	EQU	110H
TYPBITS	EQU	0E0H
DATA5	EQU	01FH
CONSTAT	EQU	503FH
CPM	EQU	0H
DISPOFF	EQU	5057H
CHAR	EQU	5094H
CO	EQU	502AH
CI	EQU	5027H
CRLF	EQU	5024H
PRINT	EQU	502DH
HEXPRT	EQU	5042H
DISPHL	EQU	5045H
RANGTABL EQU	2F70H
STOP	EQU	'$'
INREG   EQU     4C06H
OUTREG   EQU     4D66H
*
	ORG	5700H
INPAR:	PUSH	H ! PUSH PSW
	LHLD	PGMCTR	;LOOK AT FIRST (TYPE) BYTE OF CURRENT PARM
	MOV	A,M
	ANI	TYPBITS	;REMOVE ALL BUT TYPE CODE BITS
	ADD	A	;ADJUST SO THAT TYPE BITS SET CY,SIGN,& PPARITY FLAGS
	JNC	ILESS4	;IF CY NOT SET, TYPE # < 4
	JP	ILESS6	;IF SIGN NOT SET, TYPE 4 OR 5
	ORA	A	;SET PARITY FLAG
	JPO	ITYPE6	;IF PARITY ODD, TYPE IS 6
*
*  TYPE4 IS ARRAY, INDEXED BY ONE OF THE REGISTER CONTENTS
* TYPE 7 REFERS TO REGISTER CONTENTS
* INPAR CALLS OUTREG WITH THE PARMETER HEADER IN REG C
* OUTREG RETURNS THE PARAMETER VALUE AS FOLLOWS:
* REG A - LOW ORDER BYTE
* REG B - HIGH ORDER BYTE
*
ITYPE47:   PUSH	B!	PUSH	H
	   MOV   C,M     ; PICK UP PARAMETER -HEADER.
           CALL  OUTREG  ; OUTREG RETURNS THE PARM-VALUE IN 
           MOV   E,A     ; A ( LOW ORDER BYTE ) & B ( HIGH ORDER BYTE )
           MOV   D,B
	   POP	H	!POP	B
	   INX	H
	   SHLD PGMCTR
           POP   PSW
           POP   H
           RET
* 
* TYPE 6 PARM IS A 16 BIT VARIABLE
ITYPE6:	INX	H	;GET ADDR. OF WORD WANTED TO RETURN
	MOV	E,M
	INX	H
	MOV	D,M
	INX	H	;SAVE NEW PROGRAM COUNTER
	SHLD	PGMCTR
	XCHG		;GET ADDRESS OF WANTED WORD INTO HL
	MOV	E,M	;GET WORD INNTO DE
	INX	H
	MOV	D,M
	POP	PSW	;RESTORE REGS AND RETURN
	STC		;TELL CALLER THAT VALUE IS 16 BITS
	POP	H
	RET
*
*  TYPE IS EITHER 4 OR 5
* 
ILESS6: ORA     A       ; SET THE PARITY FLAG
        JPE     ITYPE47 ; IF THE PARITY IS EVEN,TYPE 4.
*
* TYPE 5 IS 16 BIT CONSTANT.
*
ITYPE5: INX     H       ; GET NEXT 16 BITS INTO D-E
	MOV	E,M
	INX	H
	MOV	D,M
	INX	H	;UPDATE PROGRAM COUNTER
	SHLD	PGMCTR
	POP	PSW
	STC		;TELL CALLER THAT PPARM IS 16 BIT VALUE
	POP	H
	RET
*
* TYPE IS 0, 1, 2, OR 3
*
ILESS4:	JP	ILESS2	;IF SIGN NOT SET, MUST BE 0 OR 1
	ORA	A	;SET PARITY FLAG
	JPO	ITYPE2	;IF PARITY ODD, TYPE MUST BE 2
* TYPE 3 IS AN INPUT PORT
* THESE ARE "STANDARDIZED" AS BELOW IN ORDER TO ACCESS
* PORT INPUTS IN A MACHINE INDEPENDENT FASHION
*	0  CONSOLE CTRL & STATUS: BIT 0=1 IF IN-DATA IS READY, 0 ELSE
*	1  CONSOLE DATA (WAIT-LOOP AND ECHO BUILT IN)
*	8  X1 \
*	9  Y1  \
*	A  X2   A/D CONVERTER (JOYSTICKS)
*	B  Y2  /
*	C  Z1  (EXTRA A/D CHANNEL ON JS-1...UNUSED NOW)
*	D  Z2  ('POT' ON JS-2;USED FOR 'THETA')
*	E  AUXILIARY SWITCH REG. (E.G. ON JOYSTICKS)
*	F  SWITCH REGISTER
ITYPE3:	PUSH	H	;GET PROGRAM COUNTER OUT OF THE 0T OF FIRE
	MOV	A,M	;GET PORT NUMBER INTO A
	ANI	DATA5
	CALL	INPORT	;CALL PROPER INPUT ROUTINE
	POP	H	;GET PROGRAM COUNTER BACK
	INX	H	;UPDATE IT AND STORE IT
	SHLD	PGMCTR
	MOV	E,A	;PUUT RETURN VALUE INTO E
	MVI	D,0	;ZERO OUT HI-BYTE OF RESULT
	POP	PSW
	ORA	A	;TELL CALLER RETURNN VALUE IS 8 BITS
	POP	H
	RET
* TYPE 2 IS AN 8 BIT VARIABLE
ITYPE2:	INX	H	;GET ADDRESS OF BYTE WANTED INTO DE
	MOV	E,M
	INX	H
	MOV	D,M
	INX	H	;UPDATE AND SAVE PROGRAM COUNTER
	SHLD	PGMCTR
	XCHG		;GET BYTE'S ADDRESS INTO HL
	MOV	E,M	;GET BYTE INTO RETURN REG
	MVI	D,0
	POP	PSW
	ORA	A	;RETURN VALUE IS 8 BITS
	POP	H
	RET
*
*TYPE IS 0 OR 1
*
ILESS2:	ORA	A	;SET PARITY FLAG
	JPE	ITYPE0	;IF PARITY IS EVEN, TYPE IS 0
*TYPE 1 IS 8 BIT CONSTANT
ITYPE1:	INX	H
	MOV	E,M	;GET BYTE RIGHT AWAY
	MVI	D,0
	INX	H	;UPDATE AND STORE PROGRAM COUNTER
	SHLD	PGMCTR
	POP	PSW
	ORA	A	;RETURN VALUE IS 8 BITS; TELL CALLER
	POP	H
	RET
* TYPE 0 IS A 5 BIT CONSTANT
ITYPE0:	MOV	E,M	;GET CONSTANT
	MVI	D,0
	INX	H		;UPDATE AND SAVE PROGRAM COUNTER
	SHLD	PGMCTR
	POP	PSW
	ORA	A		;TELL CALLER THAT RETURN VALUE IS 8 BITS
	POP	H
	RET
*
* THIS ROUTINE TAKES A "STANDARD" PORT NUMBER IN A AND READS A BYTE
* FROM THAT PORT INTO A.
*
INPORT:	MOV	L,A	;MAKE HL A DISPLACEMENT VALUE
	STA	SELECT	;USED AT 'FIXRANGE' TIME .
	MVI	H,0
	DAD	H
	LXI	D,IPORTAB ;GET BASE ADDRESS
	DAD	D	;ADD BASE TO DISP
	MOV	E,M	;GET ROUTINE @ FROM TABLE
	INX	H
	MOV	D,M
	XCHG		;INTO HL
	PCHL		;JUMP TO DESIGNATED ROUTINE
* TABLE OF INPUT PORT ROUTINES
IPORTAB	EQU	$
	DW	CONSTAT,CHARIN,NOPORT,NOPORT
	DW	NOPORT,NOPORT,NOPORT,NOPORT
	DW	IJOY1X,IJOY1Y,IJOY2X,IJOY2Y
	DW	INJOY1Z,INJOY2Z,IAUXSW,ISWREG
	DW	NOPORT,NOPORT,NOPORT,NOPORT
	DW	NOPORT,NOPORT,NOPORT,NOPORT
	DW	NOPORT,NOPORT,NOPORT,NOPORT
	DW	NOPORT,NOPORT,NOPORT,NOPORT
* THIS ROUTINE IS CALLED WHEN A PORT IS ASKED FOR THAT DOESN'T
* EXIST.  A NICE ERROR MESSAGE IS PRINTED AND THE INPUT IS IGNORED
NOPORT:	LHLD	PGMCTR	;DISPLAY THE CCURRENT PROGRAM COUNTER
	CALL	DISPHL
	MOV	A,M	;GET PORT NUMBER
	ANI	DATA5
	PUSH	PSW	;SAVE IT
	LXI	H,PCEQ
	CALL	PRINT	;PRINT "=PC"
	LXI	H,PORMES
	CALL	PRINT	;PRINT "ILLEGAL USE OF PORT"
	POP	PSW	;RESTORE PORT NUMMBER
	CALL	HEXPRT	;PRINT PORT NUMMBER
	CALL	CRLF
	RET
PCEQ	DB	'=PC ',STOP
INMESS1	DB	'<--PARAMETER TYPE ',STOP
INMESS2	DB	' IS NOT YET IMPLEMENTED',STOP
PORMES	DB	'<--ILLEGAL USE OF PORT ',STOP
* THE FOLLOWING ROUTINES READ BYTES FROM DEVICES WHICH DO NOT
* ALREADY HAVE CP/M ROUTINES ASSIGNED TO THEM
*
X1	EQU	19H
Y1	EQU	1AH
X2	EQU	1BH
Y2	EQU	1CH
Z1	EQU	1DH
Z2	EQU	1EH
BUTTONS	EQU	18H
SWITCH	EQU	0FFH
CHARIN:	LDA	CHAR	;LOOK AT EXEC-TRAPPED CHARACTER.
	ORA	A	;IS IT ZERO?
	JZ	GETACHAR
	PUSH	PSW
	XRA	A	;SHOW WE GOT IT.
	STA	CHAR
	POP	PSW
	RET
GETACHAR:CALL	CI	;GET ONE
	CPI	03H	;CTRL/C?
	RNZ
	CALL	DISPOFF
	JMP	CPM
*
* GET THE X COORDINATE FROM JOYSTICK 1
*
IJOY1X:	IN	X1
	JMP	FIXRANGE
*
* GET THE Y COORDINATE FROM JOYSTICK 1
*
IJOY1Y:	IN	Y1
	JMP	FIXRANGE
*
* GET THE X COORDINATE FROM JOYSTICK 2
*
IJOY2X:	IN	X2
	JMP	FIXRANGE
*
* GET THE Y COORDINATE FROM JOYSTICK 2
*
IJOY2Y:	IN	Y2
	JMP	FIXRANGE
*
*
* GET THE Z COORDINATE FROM JS 1
INJOY1Z:IN	Z1
	JMP	FIXRANGE
* GET THE Z ('THETA')COORD FROM JS 2
INJOY2Z:IN	Z2
	JMP	FIXRANGE
* GET THE BYTE CORRESPONDING TO INPUT FROM THE JOYSTICK BUTTONS
*
IAUXSW:	IN	BUTTONS
	CMA		;"NORMALIZE" IT
	RET
*
* GET A BYTE FROM THE SWITCH REGISTER
*
ISWREG:	IN	SWITCH
	RET
; THIS 'RANGE' SET SYSTEM SCALES THE VARIOUS ANALOG (OR ANY OTHER)
; INPUTS IN THIS WAY: IF RANGE IS 0,NO SCALE;RANGE=1,DIVIDE BY
; 2 (SO MAX VAL. IS +-64)...UP TO RANGE=7,MAXVAL=+-1. THE
; RANGE IS SET BY THE 'RESCALE' OP,
;
FIXRANGE:PUSH	D
	LHLD	SELECT	;WHICH DEVICE'S SCALE-FACTOR?
	LXI	D,RANGTABL
	DAD	D	;HL POINTS INTO RANGE-TABLE.
	MOV	E,M	;E HAS RANGE(0-7)
;
DIVLOOP:DCR	E
	JM	GOTIT	;ENOUGH ALREADY
	ORA	A	;SIGN OF A?
	JM	NEGCASE
;POSCASE:
	ANA	A	;CLEAR CARRY
	RAR		;DIV BY 2
	JMP	DIVLOOP
NEGCASE:STC		;SIGN EXTENSION
	RAR
	JMP	DIVLOOP
GOTIT:	POP	D
	RET
SELECT	DB	0,0	;SELECTOR FOR WHICH DEVICE.
;
*
* <OUTPAR>
*
* INPUT CONDITIONS:
* 
* THE FPC POINTS TO THE TYPE BYTE OF THE PARAMETER
* THE VALUE TO BE ASSIGNED TO THE PARAMETER IS IN THE D-E PAIR
*
	ORG	58B0H
OUTPAR:	PUSH	H ! PUSH PSW
	LHLD	PGMCTR	;LOOK AT TYPE BYTE OF CURRENT PARMM
	MOV	A,M
	ANI	TYPBITS	;REMOVE ALL BUT TYPE CODE BITS
	ADD	A	;ADJUST AS IN "INPAR"
	JNC	OLESS4
	JP	OLESS6
	ORA	A	;SET PARITY
	JPO	OTYPE6
*
* TYPE 7 PARM REFERS TO REGISTER CONTENTS
* TYPE 4 IS A 16 BIT ARRAY, INDEXED BY THE REGISTER CONTENTS
* OUTPAR CALLS INREG, WHICH INSERTS THE CONTENTS OF THE D-E PAIR 
* INTO THE APPROPRIATE MEMORY LOCATION/REGISTER
*
OTYPE47: PUSH	B!	PUSH	H
	 MOV C,M      ; C HAS 'TYPE' BYTE.
         CALL INREG
	 POP	H!	POP	B
	 INX	H
	 SHLD	PGMCTR
         POP  PSW
         POP  H
         RET
*
* TYPE 6 IS A 16 BIT VARIABLE
OTYPE6:	PUSH	D	;SAVE VALUE
	INX	H	;GET ADDRESS OF WORD WANTED IN DE
	MOV	E,M
	INX	H
	MOV	D,M
	INX	H	;UPDATE AND SAVE PROGRAM COUNTER
	SHLD	PGMCTR
	XCHG		;GET WORD @ INTO HL
	POP	D	;GET VALUE BACK
	MOV	M,E	;STORE DE VALUE INTO SPECIFIED WORD
	INX	H
	MOV	M,D
	POP	PSW
	POP	H
	RET
*
* TYPE IS EITHER 4 OR 5
*
OLESS6:	ORA	A	;SET PARITY
	JPE	OTYPE47
* TYPE 5 IS A 16 BIT CONSTANT (ILLEGAL)
OTYPE5:	CALL	NOCONS
	INX	H	;UPDATE AND STORE THE PROGRAM COUNTER
	INX	H
	INX	H
	SHLD	PGMCTR
	POP	PSW
	POP	H
	RET
*
* TYPE IS 0, 1, 2, OR 3
*
OLESS4:	JP	OLESS2
	ORA	A	;SET PARITY
	JPO	OTYPE2
* TYPE 3 IS OUTPUT PORT
* THESE ARE "STANDARDIZED" AS BELOW IN ORDER TO ACCESS
* I/O PORTS IN A MACHINE INDEPENDENT FASHION
*	1  PRINT A CHARACTER ON THE CONSOLE
*	8  SPEAKER ON JOYSTICK 1
*	A  SPEAKER ON JOYSTICK 1
*	F  PANEL LIGHTS
OTYPE3:	PUSH	H	;GET PROGRAM COUNTER OUT OF WAY
	MOV	A,M	;GET PORT # INTO A
	ANI	DATA5
	CALL	OUTPORT	;CALL PROPER OUTPUT ROUTINE
	POP	H	;RETRIEVE PROGRAM COUNTER
	INX	H	;UPDATE AND STORE IT
	SHLD	PGMCTR
	POP	PSW
	POP	H
	RET
* TYPE 2 IS AN 8 BIT VARIABLE
OTYPE2:	PUSH	D	;SAVE VALUE
	INX	H	;GET ADDRESS OF WANTED BYTE INTO DE
	MOV	E,M
	INX	H
	MOV	D,M
	INX	H	;UPDATE AND SAVE PC
	SHLD	PGMCTR
	XCHG		;GET ADDRESS INTO HL
	POP	D	;GET VALUE BACK
	MOV	M,E	;PUT BYTE WHER IT BELONGS
	POP	PSW
	POP	H
	RET
*
* TYPE IS EITHER 1 OR 0
*
OLESS2:	ORA	A	;SET PARITY
	JPE	OTYPE0
* TYPE 1 IS AN 8 BIT CONSTANT (ILLEGAL)
OTYPE1:	CALL	NOCONS
	INX	H
	INX	H
	SHLD	PGMCTR
	POP	PSW
	POP	H
	RET
OTYPE0:	CALL	NOCONS
	INX	H
	SHLD	PGMCTR
	POP	PSW
	POP	H
	RET
*THIS ROUTINE HANDLES ILLEGAL "OUTS" (I.E. TO CONSTANTS)
NOCONS:	PUSH	H
	MOV	A,M	;GET FRESH COPY
	ANI	TYPBITS
	RLC	! RLC	! RLC	;GET TYPE CODE # INTO LO BITS OF A
	PUSH	PSW	;SAVE IT
	CALL	DISPHL	;PRINT THE PROGRAM COUNTER
	LXI	H,PCEQ
	CALL	PRINT	;PRINT "=PC"
	LXI	H,INMESS1
	CALL	PRINT	;PRINT "PARM TYPE"
	POP	PSW	;RETRIEVE PARM TYPE
	CALL	HEXPRT	;PRINT THE PARM TYPE #
	LXI	H,CONMES
	CALL	PRINT	;PRINT "IS A CONSTANT...ILLEGAL"
	XCHG
	CALL	DISPHL	;DISPLAY VALUE WANTING STORAGE
	XCHG
	LXI	H,CONMES2
	CALL	PRINT
	CALL	CRLF
	POP	H
	RET
CONMES	DB	' IS A CONSTANT.  ATTEMPT TO STORE VALUE ',STOP
CONMES2	DB	' ABORTED',STOP
* THIS ROUTINE TAKES A "STANDARD" OUTPUT PORT NUMBER IN A AND 
* WRITES THE BYTE IN E TO THE GIVEN DEVICE
OUTPORT: MOV	L,A	;MMAKE HL A DISPLACEMENT VALUE
	MVI	H,0
	DAD	H
	MOV	A,E	;GET OUTPUT VALUE INTO A
	LXI	D,OPORTAB ;GET BASE ADDRESS
	DAD	D	;ADD BASE TO DISP
	MOV	E,M	;GGET ROUTINE @ FROM TABLE
	INX	H
	MOV	D,M
	XCHG		;INTO HL
	PCHL		;JUMP TO PROPER ROUTINE
OPORTAB	EQU	$
	DW	NOPORT,CO,NOPORT,NOPORT
	DW	NOPORT,NOPORT,NOPORT,NOPORT
	DW	SPEAKR1,NOPORT,SPEAKR2,NOPORT
	DW	NOPORT,NOPORT,NOPORT,LIGHTS
	DW	NOPORT,NOPORT,NOPORT,NOPORT
	DW	NOPORT,NOPORT,NOPORT,NOPORT
	DW	NOPORT,NOPORT,NOPORT,NOPORT
	DW	NOPORT,NOPORT,NOPORT,NOPORT
SPEAKR1: OUT	X1
	RET
SPEAKR2: OUT	X2
	RET
PANEL	EQU	0FFH
LIGHTS:	CMA
	OUT	PANEL
	RET
