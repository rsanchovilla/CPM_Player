; 
; COBOL-80 INTERFACE ROUTINES FOR MICRO B+(tm). Version 4.4  4/23/81
;
;    (c) COPYRIGHT 1980, 1981 FairCom
;	 2606 Johnson Drive
;	 Columbia, MO 65201
;	 (314) 445-3304
;
;    ALL RIGHTS RESERVED.
;
;
; THIS CODE IS WRITTEN FOR THE MICROSOFT MACRO ASSEMBLER.
;
;
; ASSUMPTIONS:
;
;	1) MICRO B+ STRING parameters are defined as
;
;		a) DISPLAY fields for alphanumeric key values with a picture
;		   specifying a length exactly the same as the key length 
;		   passed in the corresponding ACCESS call;
;
;		b) binary COMPUTATIONAL fields for numeric keys.
;
;	2) All non-string MICRO B+ parameters are defined as COMPUTATIONAL
;	   fields.  
;
;	3) INDEX and DATA FILE NAME(S) (2nd parameter in calls to ACCESS,
;	   OPEND, OPENR) must be DISPLAY fields with a picture specifying 
;	   a length of 14. This allows for file names of the form 
;
;			x:12345678.123
;
;	4) COB80.REL will be linked with application program before MICROB.REL,
;	   and application program will issue CALLs to routines with names as
;	   given below in the "ENTRY" statements.
;
;	5) Note that COBOL stores (2-byte) integers with the Most Significant
;	   Byte (MSB) first. This is reversed from the normal 8080 internal 
;	   representation of 2-byte integers. The following COBOL interface
;	   automatically reverses the non-string (i.e., non-key value) 
;	   parameters. 
;
;	   HOWEVER, THE APPLICATION PROGRAM MUST REVERSE NUMERIC
;	   KEY VALUES (i.e., PUT INTO LSB,MSB FORMAT) PRIOR TO THEIR USE AS
;	   INPUT PARAMETERS IN MICRO B+ ROUTINES; AND THE APPLICATION 
;	   PROGRAM MUST REVERSE (i.e., PUT INTO MSB,LSB FORMAT) NUMERIC KEY
;	   VALUES AFTER BEING RETURNED BY MICRO B+.
;
;	   FURTHER, THE ERROR CODES RETURNED (IF ERROR TRAPPING HAS BEEN
;	   ENABLED VIA A CALL TO SETERR) MUST ALSO BE REVERSED TO CORRESPOND
;	   TO THE ERROR CODE VALUES IN SECTION 8.1 OF THE MANUAL.	
;
;	   These reversals can be performed by a procedure which separates
;	   each bytes' value, and then rearranges them. The following steps
;	   will suffice:
;
;		5.1	1st byte = value \  256 (where "\" represents in-
;						 teger division)
;
;		5.2	2nd byte = value - (256 * 1st byte)
;
;		5.3	reversed value = (256 * 2nd byte) + 1st byte
;
;	6) Note that as described in Section 6 of the Programmer's Guide,
;	   the third parameter for READD (READAT) and WRITED (WRTDAT) is 
;	   expected to be a pointer to the I/O area. However, since COBOL does
;	   not support pointers, the third parameter of READAT and WRTDAT
;	   should be the name of the data structure into (or from) which 
;	   the I/O will take place. The interface routines will set up the 
;	   pointer expected by MICRO B+(tm).
;
;
; Please note that you may want to remove portions of the interface code
; which call routines not required by your application program (e.g., the
; MICRO B+(tm) routines for sequential loading). If not, portions of the
; MICROB.REL library not actually required will be linked into your .COM
; files.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ENTRY POINTS AND EXTERNAL DECLARATIONS
;
; THE FOLLOWING ARE THE NAMES OF THE ROUTINES SUPPLIED IN THE MICROB.REL
; LIBRARY.
;
	EXTRN	INTREE,ACCESS,ENTER,RTRIEV,SEARCH,SUCESR,NMENTR,REMOVE
	EXTRN	RSTRCT,INTLOD,LOADKY,BLDIND,ACCES1,ACCES2,NMNODE,PRDESR
	EXTRN	OPEND,CLOSED,NEWDAT,RETDAT,READD,WRITED,DATAFS,DATAFU
	EXTRN	SETERR,OPENR
;
;
; THE FOLLOWING ARE THE NAMES OF THE ROUTINES TO BE USED BY THE COBOL-80
; APPLICATION PROGRAMS.
;
	ENTRY	SETUP,OPFILE,ADDKEY,GETKEY,SERKEY,NXTKEY,NOKEYS,DELKEY
	ENTRY	CLFILE,INLOAD,SEQKEY,BUILDX,OPFIL1,OPFIL2,NMNODS,PRVKEY
	ENTRY	OPDATA,CLDATA,NEWREC,RETREC,READAT,WRTDAT,GETDFS,GETDFU
	ENTRY	ERRVAR,OPRDAT

;
; FOR EXAMPLE, INSTEAD OF
;
;		CALL ENTER(KEY%,KEY.VALUE$,DATA.RECORD%,RET.CODE%)
;
; AS GIVEN IN THE PROGRAMMER'S GUIDE, USE THE FOLLOWING
;
;		CALL ADDKEY(KEY,KEY_VALUE,DATA_RECORD,RET_CODE)
;
;		(As noted in Assumption 5 above, if KEY_VALUE refers
;		 to a numeric key value, it must first be reversed before
;		 being passed to ADDKEY. However, the non-key value para-
;		 meters KEY and RET_CODE are automatically reversed.)
;
;
;		INTERFACE ROUTINES
;
	EXTRN	KEYLEN	;KEY LENGTH VECTOR IN MICRO B+
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; STORAGE SPACE FOR THREE-BYTE STRING DESCRIPTORS USED BY MICRO B+.
;
STRAD1:	DS	3	;1ST BYTE FOR LENGTH, 2ND & 3RD FOR ADDRESS
STRAD2:	DS	3	;OF STRING
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; STORAGE SPACE FOR "REVERSED" TWO-BYTE INTEGER PARAMETERS
; AND ADDRESSES OF OUTPUT TWO-BYTE PARAMETERS
;
TB1:	DW	0
TB2:	DW	0
TB3:	DW	0
TB4:	DW	0
TB5:	DW	0
RESULT:	DW	0	;ADDRESS OF OUTPUT PARAMETER
	DW	0	;ROOM FOR RECONSTRUCTED LIST OF PARAMETER
	DW	0	;  ADDRESSES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; DETERMINE LENGTH OF "STRING" PARAMETERS
;
; UPON ENTRY HL CONTAINS ADDRESS OF KEY.NO%
; UPON EXIT, HL,DE,BC RESTORED & ACC=KEY LENGTH
;
DETLEN:	PUSH	H
	PUSH	B
	MVI	B,00	;CLEAR B
	MOV	C,M	;C = KEY.NO%
	LXI	H,KEYLEN	;HL ORIGIN OF KEY LENGTH VECTOR
	DAD	B	;HL ADDRESS OF KEY LENGTH(KEY.NO%)
	MOV	A,M	;ACC = KEY LENGTH
	POP	B
	POP	H
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; CONVERT STRING ADDRESS TO THREE-BYTE FORMAT (WHEN STRING IS
; THE SECOND PARAMETER)
;
; UPON ENTRY, HL = ADDRESS OF KEY.NO
;	      DE = ADDRESS OF STRING
; UPON EXIT,  HL RESTORED
;	      DE = ADDRESS OF THREE-BYTE VECTOR
;	      ACC CLOBBERED
;			
SETAD1:	CALL	DETLEN	;SET ACC=KEY LENGTH
	STA	STRAD1	;SET 1ST BYTE OF THREE-BYTE VECTOR
SETAD2:	MOV	A,E	;SET ACC=LSB OF STRING ADDRESS
	STA	STRAD1+1
	MOV	A,D	;SET ACC=MSB OF ADDRESS
	STA	STRAD1+2
	LXI	D,STRAD1	;SET DE=ADDRESS OF THREE-BYTE VECTOR
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; CONVERT FIRST (INPUT) PARAMETER TO TWO-BYTE FORMAT:LSB,MSB
;
; ON ENTRY:	HL=ADDRESS OF FIRST PARAMETER IN FORMAT:MSB,LSB
; ON EXIT:	HL=ADDRESS OF REVERSED PARAMETER
;
REVFRS:	MOV	A,M	;ACC=MSB OF 1ST PARAMETER
	STA	TB1+1	;MOVE TO 2ND BYTE OF TB1 STORE
	INX	H	;HL=ADDRESS OF LSB OF 1ST PARAMETER
	MOV	A,M	;ACC=LSB OF 1ST PARAMETER
	STA	TB1	;MOVE TO 1ST BYTE OF TB1 STORE
	LXI	H,TB1	;RESET HL TO ADDRESS OF TB1
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; CONVERT SECOND (INPUT) PARAMETER TO TWO-BYTE FORMAT:LSB,MSB
;
; ON ENTRY:	DE=ADDRESS OF SECOND PARAMETER
;
; ON EXIT:	DE=ADDRESS OF REVERSED SECOND PARAMETER
;
REVSEC:	LDAX	D	;ACC=MSB OF 2ND PARAMETER
	STA	TB2+1	;MOVE TO 2ND BYTE OF TB2 STORE
	INX	D
	LDAX	D	;ACC=LSB OF 2ND PARAMETER
	STA	TB2	;MOVE TO 1ST BYTE OF TB2 STORE
	LXI	D,TB2
	RET	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; CONVERT THIRD (INPUT) PARAMETER TO TWO-BYTE FORMAT:LSB,MSB
;
; ON ENTRY:	BC=ADDRESS OF THIRD PARAMETER
;
; ON EXIT:	BC=ADDRESS OF REVERSED THIRD PARAMETER
;
REVTHR:	LDAX	B	;ACC=MSB OF 3RD PARAMETER
	STA	TB3+1	;MOVE TO 2ND BYTE OF TB3 STORE
	INX	B
	LDAX	B	;ACC=LSB OF 3RD PARAMETER
	STA	TB3	;MOVE TO 1ST BYTE OF TB3 STORE
	LXI	B,TB3
	RET	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; CHANGE RETURN CODE ADDRESSES FOR ENTER % REMOVE
;
; ON ENTRY:	BC=ADDRESS OF LIST OF ADDRESS
;		2ND ADDRESS ON THIS LIST POINTS TO RETURN CODE
;
; ON EXIT:	2ND ADDRESS ON THIS LIST POINTS TO TB4
;		AND ORIGINAL ADDRESS SAVED IN RESULT
;
CHGRET:	INX	B
	INX	B	;BC=ADDRESS OF RETURN CODE ADDRESS
	LDAX	B	;BYTE OF RETURN CODE ADDRESS
	STA	RESULT	;SAVE IN RESULT
	INX	B
	LDAX	B	;ACC=2ND BYTE OF ADDRESS
	STA	RESULT+1
	PUSH	H
	LXI	H,TB4
	MOV	A,H
	STAX	B	;RESET 2ND BYTE OF ADDRESS IN LIST
	DCX	B
	MOV	A,L
	STAX	B	;RESET 1ST BYTE OF ADDRESS IN LIST
	POP	H	;RESTORE HL
	DCX	B
	DCX	B	;RESTORE B
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; REVERSE RETURN CODE OUTPUT & STORE RESULT
;
; ON ENTRY:	TB4 CONTAINS RETURN CODE
;		RESULT CONTAINS ADDRESS OF ACTUAL RETURN CODE VARIABLE
;
; ON EXIT:	ACTUAL RETURN CODE SET:MSB,LSB
;
REVRET:	LHLD	RESULT	;HL=ADDRESS OF ACTUAL RETURN CODE
	LDA	TB4+1	;ACC=MSB OF RETURN CODE
	MOV	M,A	;SET 1ST BYTE OF ACTUAL RETURN CODE
	INX	H
	LDA	TB4	;ACC=LSB OF RETURN CODE
	MOV	M,A	;SET 2ND BYTE OF RETURN CODE
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; CHANGE ADDRESS OF OUTPUT PARAMETER FOR NMENTR & NMNODE TO TB4
; AND SAVE ACTUAL ADDRESS IN RESULT
;
; ON ENTRY:	DE=ADDRESS OF RESULT VARIABLE
;
; ON EXIT:	DE=ADDRESS OF TB4
;		AND ADDRESS OF ACTUAL RESULT STORED IN RESULT
;
CHGRSL:	MOV	A,E	;ACC=2ND BYTE OF ACTUAL RESULT ADDRESS
	STA	RESULT
	MOV	A,D	;ACC=1ST BYTE OF ACTUAL RESULT ADDRESS
	STA	RESULT+1
	LXI	D,TB4
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; REVERSE 3RD,4TH, & 5TH PARAMETERS (WHOSE ADDRESSES ARE IN LIST
; POINTED TO BY BC).
;
; ON ENTRY:	BC=ADDRESS OF PARAMETER LIST
; ON EXIT:	BC=ADDRESS OF RESULT
;		TB3=REVERSED 3RD PARAMETER
;		TB4=REVERSED 4TH PARAMETER
;		TB5=REVERSED 5TH PARAMETER
;
REV345:	PUSH	H	;SAVE ADDRESS OF 1ST PARAMETER
	LDAX	B	;ACC=LSB OF 3RD PARAMETER ADDRESS
	MOV	L,A
	INX	B
	LDAX	B	;ACC=MSB OF 3RD PARAMETER ADDRESS
	MOV	H,A	;HL=ADDRESS OF 3RD PARAMETER
	MOV	A,M	;ACC=MSB OF 3RD P
	STA	TB3+1
	INX	H
	MOV	A,M	;ACC=LSB OF 3RD P
	STA	TB3
	INX	B
	LDAX	B	;ACC=LSB OF 4TH P ADDRESS
	MOV	L,A
	INX	B
	LDAX	B	;ACC=MSB OF 4TH P ADDRESS
	MOV	H,A	;HL=ADDRESS OF 4TH P
	MOV	A,M	;ACC=MSB OF 4TH P
	STA	TB4+1
	INX	H
	MOV	A,M	;ACC=LSB OF 4TH P
	STA	TB4
	INX	B
	LDAX	B	;ACC=LSB OF 5TH P ADDRESS
	MOV	L,A
	INX	B
	LDAX	B	;ACC=MSB OF 5TH P ADDRESS
	MOV	H,A	;HL=ADDRESS OF 5TH P
	MOV	A,M	;ACC=MSB OF 5TH P
	STA	TB5+1
	INX	H
	MOV	A,M	;ACC=LSB OF 5TH P
	STA	TB5
	LXI	H,TB5	;HL=ADDRESS OF TB5
	SHLD	RESULT+4;RECONSTRUCT LIST OF PARAM ADDRESSES AT RESULT
	LXI	H,TB4	;
	SHLD	RESULT+2
	LXI	H,TB3
	SHLD	RESULT
	POP	H
	LXI	B,RESULT
	RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;
; B-TREE ROUTINES
;
SETUP:	CALL	FRSSEC
	CALL	REV345
	CALL	INTREE
	RET
OPFILE:	CALL	PCCESS
	CALL	ACCESS
	RET
OPFIL1:	CALL	PCCESS
	CALL	ACCES1
	RET
OPFIL2:	CALL	PCCESS
	CALL	ACCES2
	RET
;
; PCCESS SETS UP THE THREE-BYTE VECTOR FOR THE INDEX FILE NAME
; AS WELL AS REVERSING 2-BYTE PARAMETERS
;
PCCESS:	CALL	REVFRS
	MVI	A,0EH
	STA	STRAD1	;SET STRING LENGTH TO FOURTEEN FOR INDEX FILE NAME
			;ASSUMES NAME OF FORM x:12345678.123
	CALL	SETAD2
	CALL	REV345	;REVERSE FORMAT OF 3RD, 4TH, & 5TH PARAMETERS
	RET	
ADDKEY:	CALL	REVFRS
	CALL	CHGRET
	CALL	SETAD1
	CALL	ENTER
	CALL	REVRET
	RET
GETKEY:	CALL	REVFRS
	CALL	SETAD1
	CALL	RTRIEV
	RET
SERKEY:	CALL	REVFRS
	CALL	SETAD1
;
; MUST STILL CONVERT ADDRESS OF INDEX.KEY$ TO THREE-BYTE VECTOR FORMAT.
;	NOTE THAT INDEX.KEY$'S ADDRESS IS NOW THE 2ND ADDRESS IN THE LIST OF
;	ADDRESSES POINTED TO BY BC
;
	LDA	STRAD1	;ACC=KEY LENGTH
	STA	STRAD2	;SET 1ST BYTE OF STRAD2
	PUSH	H	;SAVE ADDRESS OF 1ST PARAMETER
	INX	B
	INX	B	;BC=ADDRESS OF POINTER TO INDEX.KEY$
	LDAX	B	;ACC=LSB OF ADDRESS OF INDEX.KEY$
	MOV	L,A
	INX	B
	LDAX	B	;ACC=MSB OF ADDRESS OF INDEX.KEY$
	MOV	H,A	;HL=ADDRESS OF 1ST BYTE OF INDEX.KEY$ 
	SHLD	STRAD2+1
			;SET 2ND & 3RD BYTES OF THREE-BYTE VECTOR STRAD2
	LXI	H,STRAD2
			;HL=ADDRESS OF THREE-BYTE VECTOR STRAD2
	MOV	A,H	;ACC=MSB OF STRAD2 ADDRESS
	STAX	B
	DCX	B
	MOV	A,L	;ACC=LSB OF STRAD2 ADDRESS
	STAX	B	;PARAMETER LIST POINTED TO BY BC HAS NOW BEEN UPDATED
			;TO INCLUDE ADDRESS OF SETAD2 INSTEAD OF ADDRESS OF
			;INDEX.KEY$
	DCX	B
	DCX	B	;RESTORE BC TO ADDRESS OF BEGINNING OF LIST OF
			;ADDRESSES
	POP	H	;RESTORE HL
;
	CALL	SEARCH
	RET
NXTKEY:	CALL	REVFRS
;
; MUST CONVERT ADDRESS OF INDEX.KEY$ TO THREE-BYTE VECTOR FORMAT. CANNOT USE
;	SETAD1 SINCE INDEX.KEY$ IS NOT IN THE SECOND POSITION.
	CALL	CNVPR3
	CALL	SUCESR
	RET
PRVKEY:	CALL	REVFRS
	CALL	CNVPR3
	CALL	PRDESR
	RET
;
; BC=ADDRESS OF INDEX.KEY$
;
CNVPR3:	CALL	DETLEN	;ACC=KEY LENGTH
	STA	STRAD1	;SET 1ST BYTE OF STRAD1
	MOV	A,C	;ACC=LSB OF INDEX KEY ADDRESS
	STA	STRAD1+1
	MOV	A,B	;ACC=MSB OF ADDRESS
	STA	STRAD1+2
	LXI	B,STRAD1
	RET
NOKEYS:	CALL	FRSRSL
	CALL	NMENTR
	CALL	REVRET
	RET
DELKEY:	CALL	REVFRS
	CALL	CHGRET
	CALL	SETAD1
	CALL	REMOVE
	CALL	REVRET
	RET
CLFILE:	CALL	REVFRS
	CALL	RSTRCT
	RET
INLOAD: CALL	FRSSEC
	CALL	DETLEN
	STA	STRAD1	;STORE KEY LENGTH FOR USE WITH CALLS TO SEQKEY
	
	CALL	INTLOD
	RET
SEQKEY:	
;
; MUST STILL CONVERT ADDRESS OF KEY.VALUE$ TO THREE-BYTE VECTOR FORMAT. CANNOT
; USE SETAD1 SINCE KEY.VALUE$ IS NOT THE 2ND PARAMETER.
;
; HL=ADDRESS OF KEY.VALUE$
;
	MOV	A,L	;LSB OF KEY VALUE ADDRESS
	STA	STRAD1+1
	MOV	A,H	;MSB OF ADDRESS
	STA	STRAD1+2 
	LXI	H,STRAD1	;WE HAVE ASSUMED THAT STRAD1 HAS BEEN SET 
				;TO KEY LENGTH IN INLOAD 
;
; MUST CHANGE ADDRESS OF RETURN CODE TO TB4 AND SAVE ADDRESS OF ACTUAL
; RETURN CODE IN RESULT
;
	MOV	A,B	;ACC=MSB OF ADDRESS OF ACTUAL RETURN CODE
	STA	RESULT+1
	MOV	A,C	;ACC=LSB OF ADDRESS OF ACTUAL RETURN CODE
	STA	RESULT
	LXI	B,TB4
	CALL	LOADKY
	CALL	REVRET	;REVERSE RETURN CODE AND STORES IN ACTUAL
			;RETURN CODE VARIABLE
	RET
BUILDX:	CALL	BLDIND
	RET
NMNODS:	CALL	FRSRSL
	CALL	NMNODE
	CALL	REVRET
	RET
OPDATA:	CALL	POPEN
	CALL	OPEND
	RET
CLDATA:	CALL	REVFRS
	CALL	CLOSED
	RET
NEWREC:	CALL	FRSRSL
	CALL	NEWDAT
	CALL	REVRET
	RET
RETREC:	CALL	FRSSEC
	CALL	RETDAT
	RET
READAT:	CALL	FRSSEC
	CALL	SETPTR
	CALL	READD
	RET
WRTDAT:	CALL	FRSSEC
	CALL	SETPTR
	CALL	WRITED
	RET
GETDFS:	CALL	FRSRSL
	CALL	DATAFS
	CALL	REVRET
	RET
GETDFU:	CALL	FRSRSL
	CALL	DATAFU
	CALL	REVRET
	RET
ERRVAR:	CALL	SETERR
	RET
OPRDAT:	CALL	POPEN
	CALL	OPENR
	RET
POPEN:	CALL	REVFRS
	MVI	A,0EH
	STA	STRAD1	;SET STRING LENGTH TO FOURTEEN FOR DATA FILE NAME
			;ASSUMES NAME OF FORM x:12345678.123
	CALL	SETAD2
	CALL	REVTHR
	RET
FRSRSL:	CALL	REVFRS
	CALL	CHGRSL
	RET
FRSSEC:	CALL	REVFRS
	CALL	REVSEC
	RET
SETPTR:	MOV	A,C
	STA	TB3	;STORE LSB OF I/O AREA ADDRESS
	MOV	A,B
	STA	TB3+1	;STORE MSB
	LXI	B,TB3	;ESTABLISH TBS AS THE POINTER VARIABLE FOR THE I/O AREA
	RET
	END


