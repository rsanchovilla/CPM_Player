
; 
; FORTRAN-80 INTERFACE ROUTINES FOR MICRO B+(tm). Version 4.3  4/23/81
;
;    COPYRIGHT (c) 1980, 1981 FairCom
;    2606 Johnson Drive
;    Columbia, MO 65201
;    (314) 445-3304
;
; ALL RIGHTS RESERVED.
;	
;
; THIS CODE IS WRITTEN FOR THE MICROSOFT MACRO ASSEMBLER.
;
;
; ASSUMPTIONS:
;
;	1) MICRO B+ STRING parameters which contain key values
;	   should be declared in FORTRAN as
;
;		a) INTEGERS for numeric key values. The key length
;		   must be set to TWO (2) in the call to ACCESS for keys
;		   defined as numeric.
;
;		b) Any type of scalar or one-dimensional array with sufficient
;		   storage allocated to contain the number of bytes specified
;		   by the key length parameter in the corresponding call to
;		   ACCESS for alphanumeric key values.
;
;		   NOTE THAT MICRO B+(tm) WILL ASSUME THAT THE KEY
;		   VALUES PASSED TO IT ARE OF THE EXACT KEY LENGTH SPECIFIED
;		   IN ACCESS. For example, if a double precision scalar is
;		   used to pass an alphanumeric key value whose length has
;		   been specified as six (6) bytes in the call to ACCESS,
;		   then MICRO B+(tm) will operate on the first six (6) bytes
;		   of the double precision scalar. MICRO B+(tm) will ignore
;		   the last two bytes of the scalar; nor will it attempt to
;		   pad the key value with blanks to ensure that it is at least
;		   six (6) bytes in length. 
; 
;	2) All non-string MICRO B+(tm) parameters are declared as integers.
;
;	3) INDEX and DATA FILE NAME(S) (2nd parameter in calls to ACCESS,
;	   OPEND, OPENR) must be assigned to a one-dimensional array with 
;	   at least 14 bytes of storage allocated. This allows for file 
;	   names of the form
;	  
;				 x:12345678.123
;
;	   If no "." appears in the file name, MICRO B+(tm) will use a full
;	   eight (8) bytes from the one-dimensional array to construct the
;	   index file name even if you have not properly initialized them.
;	   Therefore, either include a file extension or be careful to pad
;	   the name with blanks on the right.
;
;	4) FORT80.REL will be linked with the application program before 
;	   MICROB.REL, and the application program will issue CALLs to routines
;	   with names as given below in the "ENTRY" statements.
;
;
;	5) Note that as described in Section 6 of the Programmer's Guide,
;	   the third parameter for READD (READAT) and WRITED (WRTDAT) is 
;	   expected to be a pointer to the I/O area. However, since FORTRAN 
;	   does not support pointers, the third parameter of READAT and WRTDAT
;	   should be the name of the data structure into (or from) which 
;	   the I/O will take place. The interface routines will set up the 
;	   pointer expected by MICRO B+(tm).
;
;
; You may desire to remove portions of the interface which call routines
; not required by your application program. Otherwise, portions of MICROB.REL
; not actually used may be linked into your .COM file.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ENTRY POINTS AND EXTERNAL DECLARATIONS
;
; THE FOLLOWING ARE THE NAMES OF THE ROUTINES SUPPLIED IN THE MICROB.REL
; LIBRARY.
;
	EXTRN	INTREE,ACCESS,ENTER,RTRIEV,SEARCH,SUCESR,NMENTR,REMOVE
	EXTRN	RSTRCT,INTLOD,LOADKY,BLDIND,ACCES1,ACCES2,NMNODE,PRDESR
	EXTRN	OPEND,CLOSED,NEWDAT,RETDAT,READD,WRITED,DATAFS,DATAFU
	EXTRN	SETERR,OPENR
;
;
; THE FOLLOWING ARE THE NAMES OF THE ROUTINES TO BE USED BY THE FORTRAN-80
; APPLICATION PROGRAMS.
;
	ENTRY	SETUP,OPFILE,ADDKEY,GETKEY,SERKEY,NXTKEY,NOKEYS,DELKEY
	ENTRY	CLFILE,INLOAD,SEQKEY,BUILDX,OPFIL1,OPFIL2,NMNODS,PRVKEY
	ENTRY	OPDATA,CLDATA,NEWREC,RETREC,READAT,WRTDAT,GETDFS,GETDFU
	ENTRY	ERRVAR,OPRDAT
;
; FOR EXAMPLE, INSTEAD OF
;
;		CALL ENTER(KEY%,KEY.VALUE$,DATA.RECORD%,RET.CODE%)
;
; AS GIVEN IN THE PROGRAMMER'S GUIDE, USE THE FOLLOWING
;
;		CALL ADDKEY(KEY,KEYVAL,DATREC,RETCOD)
;
; WHERE KEY,DATREC, AND RETCODE ARE DECLARED AS INTEGERS; AND KEYVAL IS
; DECLARED AS A SCALAR OR ONE-DIMENSIONAL ARRAY WITH SUFFICIENT STORAGE
; TO CONTAIN THE KEY VALUES. IF THE KEY TYPE IS NUMERIC, THEN KEYVAL SHOULD
; ALSO BE DECLARED AS INTEGER.
;
;
;		INTERFACE ROUTINES
;
	EXTRN	KEYLEN	;KEY LENGTH VECTOR IN MICRO B+
;
; STORAGE SPACE FOR THREE-BYTE STRING DESCRIPTORS USED BY MICRO B+.
;
STRAD1:	DS	3	;1ST BYTE FOR LENGTH, 2ND & 3RD FOR ADDRESS
STRAD2:	DS	3	;OF STRING
BUFPTR:	DW	0	;LOCAL BUFFER POINTER REQUIRED BY READD (READAT)
			;AND WRITED (WRTDAT).
;
;
; DETERMINE LENGTH OF "STRING" PARAMETERS
;
; UPON ENTRY HL CONTAINS ADDRESS OF KEY.NO%
; UPON EXIT, HL,DE,BC RESTORED & ACC=KEY LENGTH
;
DETLEN:	PUSH	H
	PUSH	B
	MVI	B,00	;CLEAR B
	MOV	C,M	;C = KEY.NO%
	LXI	H,KEYLEN	;HL ORIGIN OF KEY LENGTH VECTOR
	DAD	B	;HL ADDRESS OF KEY LENGTH(KEY.NO%)
	MOV	A,M	;ACC = KEY LENGTH
	POP	B
	POP	H
	RET
;
; CONVERT STRING ADDRESS TO THREE-BYTE FORMAT (WHEN STRING IS
; THE SECOND PARAMETER)
;
; UPON ENTRY, HL = ADDRESS OF KEY.NO
;	      DE = ADDRESS OF STRING
; UPON EXIT,  HL RESTORED
;	      DE = ADDRESS OF THREE-BYTE VECTOR
;	      ACC CLOBBERED
;			
SETAD1:	CALL	DETLEN	;SET ACC=KEY LENGTH
	STA	STRAD1	;SET 1ST BYTE OF THREE-BYTE VECTOR
SETAD2:	MOV	A,E	;SET ACC=LSB OF STRING ADDRESS
	STA	STRAD1+1
	MOV	A,D	;SET ACC=MSB OF ADDRESS
	STA	STRAD1+2
	LXI	D,STRAD1	;SET DE=ADDRESS OF THREE-BYTE VECTOR
	RET 
;
; B-TREE ROUTINES
;
SETUP:	CALL	INTREE
	RET
OPFILE:	CALL	PCCESS
	CALL	ACCESS
	RET
OPFIL1:	CALL	PCCESS
	CALL	ACCES1
	RET
OPFIL2:	CALL	PCCESS
	CALL	ACCES2
	RET
;
; PCCESS SETS UP THE THREE-BYTE VECTOR FOR THE INDEX FILE NAME
;
PCCESS:	MVI	A,0EH
	STA	STRAD1	;SET STRING LENGTH TO FOURTEEN FOR INDEX FILE NAME
			;ASSUMES NAME OF FORM x:12345678.123
	CALL	SETAD2
	RET	
ADDKEY:	CALL	SETAD1
	CALL	ENTER
	RET
GETKEY:	CALL	SETAD1
	CALL	RTRIEV
	RET
SERKEY:	CALL	SETAD1
;
; MUST STILL CONVERT ADDRESS OF INDEX.KEY$ TO THREE-BYTE VECTOR FORMAT.
;	NOTE THAT INDEX.KEY$'S ADDRESS IS NOW THE 2ND ADDRESS IN THE LIST OF
;	ADDRESSES POINTED TO BY BC
;
	LDA	STRAD1	;ACC=KEY LENGTH
	STA	STRAD2	;SET 1ST BYTE OF STRAD2
	PUSH	H	;SAVE ADDRESS OF 1ST PARAMETER
	INX	B
	INX	B	;BC=ADDRESS OF POINTER TO INDEX.KEY$
	LDAX	B	;ACC=LSB OF ADDRESS OF INDEX.KEY$
	MOV	L,A
	INX	B
	LDAX	B	;ACC=MSB OF ADDRESS OF INDEX.KEY$
	MOV	H,A	;HL=ADDRESS OF 1ST BYTE OF INDEX.KEY$ 
	SHLD	STRAD2+1
			;SET 2ND & 3RD BYTES OF THREE-BYTE VECTOR STRAD2
	LXI	H,STRAD2
			;HL=ADDRESS OF THREE-BYTE VECTOR STRAD2
	MOV	A,H	;ACC=MSB OF STRAD2 ADDRESS
	STAX	B
	DCX	B
	MOV	A,L	;ACC=LSB OF STRAD2 ADDRESS
	STAX	B	;PARAMETER LIST POINTED TO BY BC HAS NOW BEEN UPDATED
			;TO INCLUDE ADDRESS OF SETAD2 INSTEAD OF ADDRESS OF
			;INDEX.KEY$
	DCX	B
	DCX	B	;RESTORE BC TO ADDRESS OF BEGINNING OF LIST OF
			;ADDRESSES
	POP	H	;RESTORE HL
;
	CALL	SEARCH
	RET
NXTKEY:	CALL	CNVPR3
	CALL	SUCESR
	RET
PRVKEY:	CALL	CNVPR3
	CALL	PRDESR
	RET
;
; MUST CONVERT ADDRESS OF INDEX.KEY$ TO THREE-BYTE VECTOR FORMAT. CANNOT USE
;	SETAD1 SINCE INDEX.KEY$ IS NOT IN THE SECOND POSITION.
;
; BC=ADDRESS OF INDEX.KEY$
;
CNVPR3:	CALL	DETLEN	;ACC=KEY LENGTH
	STA	STRAD1	;SET 1ST BYTE OF STRAD1
	MOV	A,C	;ACC=LSB OF INDEX KEY ADDRESS
	STA	STRAD1+1
	MOV	A,B	;ACC=MSB OF ADDRESS
	STA	STRAD1+2
	LXI	B,STRAD1
	RET
NOKEYS:	CALL	NMENTR
	RET
DELKEY:	CALL	SETAD1
	CALL	REMOVE
	RET
CLFILE:	CALL	RSTRCT
	RET
INLOAD:	CALL	DETLEN
	STA	STRAD1	;STORE KEY LENGTH FOR USE WITH CALLS TO SEQKEY
	CALL	INTLOD
	RET
SEQKEY:	
;
; MUST STILL CONVERT ADDRESS OF KEY.VALUE$ TO THREE-BYTE VECTOR FORMAT. CANNOT
; USE SETAD1 SINCE KEY.VALUE$ IS NOT THE 2ND PARAMETER.
;
; HL=ADDRESS OF KEY.VALUE$
;
	MOV	A,L	;LSB OF KEY VALUE ADDRESS
	STA	STRAD1+1
	MOV	A,H	;MSB OF ADDRESS
	STA	STRAD1+2 
	LXI	H,STRAD1	;WE HAVE ASSUMED THAT STRAD1 HAS BEEN SET 
				;TO KEY LENGTH IN INLOAD 
;
	CALL	LOADKY
	RET
BUILDX:	CALL	BLDIND
	RET
NMNODS:	CALL	NMNODE
	RET
OPDATA:	CALL	PCCESS
	CALL	OPEND
	RET
CLDATA:	CALL	CLOSED
	RET
NEWREC:	CALL	NEWDAT
	RET
RETREC:	CALL	RETDAT
	RET
READAT:	CALL	SETPTR
	CALL	READD
	RET
WRTDAT:	CALL	SETPTR
	CALL	WRITED
	RET
GETDFS:	CALL	DATAFS
	RET
GETDFU:	CALL	DATAFU
	RET
ERRVAR:	CALL	SETERR
	RET
OPRDAT:	CALL	PCCESS
	CALL	OPENR
	RET
SETPTR:	MOV	A,C
	STA	BUFPTR	;STORE LSB OF I/O AREA IN LOCAL BUFFER POINTER
	MOV	A,B
	STA	BUFPTR+1;STORE MSB
	LXI	B,BUFPTR
	RET
	END

