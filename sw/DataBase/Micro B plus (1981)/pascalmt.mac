; 
; PASCAL MT+ INTERFACE ROUTINES FOR MICRO B+(tm). VERSION 4.3  4/22/81
;    (c) COPYRIGHT 1980,1981 FairCom
;
; THIS CODE IS WRITTEN FOR THE MICROSOFT MACRO ASSEMBLER. THERE ARE SOME MINOR
; DIFFERENCES BETWEEN SOME OF THE PSUEDO-OP NAMES USED HERE AND THE DIGITAL
; RESEARCH MACRO ASSEMBLER. PLEASE MAKE CHANGES AS APPROPRIATE.
;
;
; ASSUMPTIONS:
;
;	1) MICRO B+ STRING parameters are declared as VAR STRINGs;
;
;	2) The MICRO B+ parameter INDEX.KEY$ is initialized to the
;		appropriate length by the application program (see Section
;		4.6 of the Programmer's Guide); 
;
;	3) INDEX.KEY$ is passed by name (as opposed to value) so that it
;		may be "filled-in" by MICRO B+. Note that if its
;		maximum length is greater than the key length, MICRO B+
;		will simply "fill-in" the beginning bytes; but MICRO B+
;		will NOT reduce the length of INDEX.KEY$;
;
;	4) ALL PARAMETERS ARE PASSED AS VAR (I.E, ADDRESSS ARE PASSED);
;
;	5) The application program will be linked with these interface 
;	   routines before being linked to MICROB.REL; and
;
;	6) MICROB.REL & PASCALMT.REL will be renamed with .ERL extents.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Please note that you may desire to remove portions of this interface
; which call routines not required by your application program. Otherwise,
; portions of MICROB.REL not actually used may be linked into your .COM
; file.
;
; ENTRY POINTS AND EXTERNAL DECLARATIONS
;
; THE FOLLOWING ARE THE NAMES OF THE ROUTINES SUPPLIED IN THE MICROB.REL
; LIBRARY.
;
	EXTRN	INTREE,ACCESS,ENTER,RTRIEV,SEARCH,SUCESR,NMENTR,REMOVE
	EXTRN	RSTRCT,INTLOD,LOADKY,BLDIND,ACCES1,ACCES2,NMNODE,PRDESR
	EXTRN	OPEND,CLOSED,NEWDAT,RETDAT,READD,WRITED,DATAFS,DATAFU
	EXTRN	SETERR,OPENR
;
;
; THE FOLLOWING ARE THE NAMES OF THE ROUTINES TO BE USED BY THE PASCAL/MT+(tm)
; APPLICATION PROGRAMS.
;
	ENTRY	SETUP,OPFILE,ADDKEY,GETKEY,SERKEY,NXTKEY,NOKEYS,DELKEY
	ENTRY	CLFILE,INLOAD,SEQKEY,BUILDX,OPFIL1,OPFIL2,NMNODS,PRVKEY
	ENTRY	OPDATA,CLDATA,NEWREC,RETREC,READAT,WRTDAT,GETDFS,GETDFU
	ENTRY	ERRVAR,OPRDAT
;
; FOR EXAMPLE, INSTEAD OF
;
;		CALL ENTER(KEY%,KEY.VALUE$,DATA.RECORD%,RET.CODE%)
;
; AS GIVEN IN THE PROGRAMMER'S GUIDE, USE THE FOLLOWING
;
;		ADDKEY(KEY,KEY_VALUE,DATA_RECORD,RET_CODE)
;
; WHERE ADDKEY HAS BEEN DEFINED AS
;
;	EXTERNAL PROCEDURE ADDKEY(VAR KEY:INTEGER;VAR KEY_VALUE:STRING;
;			VAR DATA_RECORD,RET_CODE:INTEGER);
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;		INTERFACE ROUTINES
;
; TEMPORARY STORAGE SPACE 
;
RETADR:	DW	0	;RETURN ADDRESS TO PASCAL ROUTINE
RETLDA:	DW	0	;RETURN ADDRESS FROM LDPAR# ROUTINE
STRAD1:	DS	3	;1ST BYTE FOR LENGTH, 2ND & 3RD FOR ADDRESS
STRAD2:	DS	3	;OF STRING
PARLST:	DS	6	;STORAGE FOR PARAMETER LIST ADDRESSES
;
; RETURN TO PASCAL ROUTINE
;
RETPAS:
	LHLD	RETADR
	PCHL
;
;
; CONVERT PARAMETER ADDRESSES TO MICRO B+ FORMAT
;
; UPON ENTRY, STACK CONTAINS RETURN ADDRESS & PARAMETER ADDRESSES
; UPON EXIT,  HL=ADDRESS OF 1ST PARAMETER
;	      DE=ADDRESS OF 2ND PARAMETER
;	      BC=ADDRESS OF 3RD PARAMETER, OR ADDRESS OF LIST OF REMAINING 
;		 PARAMETER ADDRESSES (FOR 4 OR MORE PARAMETERS)
;
;
LDPAR5:
	POP	H	;HL=LDPAR5 RET ADR
	SHLD	RETLDA
	POP	H	;HL=RET ADR
	SHLD	RETADR
	POP	H
	SHLD	PARLST+4;SAVE ADDRESS OF 5TH PARAMETER
	JMP	LDPR41
LDPAR4:
	POP	H	;HL=LDPAR4 RET ADR
	SHLD	RETLDA
	POP	H
	SHLD	RETADR
LDPR41:
	POP	H
	SHLD	PARLST+2;SAVE ADDRESS OF 4TH PARAMETER
	POP	H
	SHLD	PARLST	;SAVE ADDRESS OF 3RD PARAMETER
	LXI	B,PARLST;SET BC=ADR OF LIST OF ADDRESSES
	JMP	LDPR21
LDPAR3:
	POP	H	;HL=LDPAR3 RET ADR
	SHLD	RETLDA
	POP	H
	SHLD	RETADR
	POP	B	;BC=ADR OF 3RD PARAMETER
	POP	D	;DE=ADR OF 2ND PARAMETER
	LHLD	RETLDA	;HL=RET ADR
	XTHL		;HL=ADR OF 1ST PARAMETER  STACK = RET ADR
	RET
LDPAR2:
	POP	H	;HL=LDPAR2 RET ADR
	SHLD	RETLDA
	POP	H
	SHLD	RETADR
LDPR21:
	POP	D	;DE=ADR OF 2ND PARAMETER
	LHLD	RETLDA	;HL=RET ADR
	XTHL		;EXCHANGE RET ADR & 1ST PARAMETER ADDRESS
	RET
LDPAR1:
	POP	H	;HL=LDPAR1 RET ADR
	SHLD	RETLDA
	POP	H
	SHLD	RETADR
	LHLD	RETLDA
	XTHL
	RET
;
; CONVERT ADDRESS OF STRING PARAMETER (WHEN IT IS THE 2ND PARAMETER) TO THE
;	MICRO B+ THREE-BYTE VECTOR FORMAT
;
; UPON ENTRY, DE=ADDRESS OF 2ND PARAMETER
; UPON EXIT, DE=ADDRESS OF THREE-BYTE VECTOR WHICH NOW POINTS TO 2ND PARAMETER
;		AND HL & BC ARE UNCHANGED
;
SETAD1:	LDAX	D	;ACC=LENGTH OF STRING SINCE DE POINTS TO THE FIRST
			;BYTE OF A STRING PARAMETER DEFINED WITH THE VARYING
			;ATTRIBUTE
	STA	STRAD1	;SET 1ST BYTE OF THREE-BYTE STRING DESCRIPTOR VECTOR
	INX	D	;DE=ADDRESS OF 2ND BYTE OF STRING WHICH IS THE FIRST
			;CHARACTER
	MOV	A,E	;ACC=LSB OF STRING ADDRESS (LSB=LEAST SIGNIFICANT BYTE)
	STA	STRAD1+1
	MOV	A,D	;ACC=MSB OF STRING ADDRESS (MSB=MOST SIGNIFICANT BYTE)
	STA	STRAD1+2
			;TYHREE-BYTE VECTOR STRAD1 IS NOW SET
	LXI	D,STRAD1
			;DE NOW CONTAINS ADDRESS OF THREE-BYTE VECTOR
	RET
;
; B-TREE ROUTINES
;
SETUP:	CALL	LDPAR5
	CALL	INTREE
	JMP	RETPAS
OPFILE:	CALL	LDPAR5
	CALL	SETAD1
	CALL	ACCESS
	JMP	RETPAS
OPFIL1:	CALL	LDPAR5
	CALL	SETAD1
	CALL	ACCES1
	JMP	RETPAS
OPFIL2:	CALL	LDPAR5
	CALL	SETAD1
	CALL	ACCES2
	JMP	RETPAS
ADDKEY:	CALL	LDPAR4
	CALL	SETAD1
	CALL	ENTER
	JMP	RETPAS
GETKEY:	CALL	LDPAR3
	CALL	SETAD1
	CALL	RTRIEV
	JMP	RETPAS
SERKEY:	CALL	LDPAR4
	CALL	SETAD1
;
; MUST STILL CONVERT ADDRESS OF INDEX.KEY$ TO THREE-BYTE VECTOR FORMAT.
;	NOTE THAT INDEX.KEY$'S ADDRESS IS NOW THE 2ND ADDRESS IN THE LIST OF
;	ADDRESSES POINTED TO BY BC
;
	PUSH	H	;SAVE ADDRESS OF 1ST PARAMETER
	INX	B
	INX	B	;BC=ADDRESS OF POINTER TO INDEX.KEY$
	LDAX	B	;ACC=LSB OF ADDRESS OF INDEX.KEY$
	MOV	L,A
	INX	B
	LDAX	B	;ACC=MSB OF ADDRESS OF INDEX.KEY$
	MOV	H,A	;HL=ADDRESS OF 1ST BYTE OF INDEX.KEY$ (WHICH CONTAINS
			;THE LENGTH OF THE STRING)
	MOV	A,M	;ACC=LENGTH OF INDEX.KEY$
	STA	STRAD2	;SET 1ST BYTE OF THREE-BYTE VECTOR
	INX	H	;HL=ADDRESS OF 2ND BYTE OF INDEX.KEY$ (WHICH CONTAINS
			;THE FIRST CHARACTER)
	SHLD	STRAD2+1
			;SET 2ND & 3RD BYTES OF THREE-BYTE VECTOR STRAD2
	LXI	H,STRAD2
			;HL=ADDRESS OF THREE-BYTE VECTOR STRAD2
	MOV	A,H	;ACC=MSB OF STRAD2 ADDRESS
	STAX	B
	DCX	B
	MOV	A,L	;ACC=LSB OF STRAD2 ADDRESS
	STAX	B	;PARAMETER LIST POINTED TO BY BC HAS NOW BEEN UPDATED
			;TO INCLUDE ADDRESS OF SETAD2 INSTEAD OF ADDRESS OF
			;INDEX.KEY$
	DCX	B
	DCX	B	;RESTORE BC TO ADDRESS OF BEGINNING OF LIST OF
			;ADDRESSES
	POP	H	;RESTORE HL
;
	CALL	SEARCH
	JMP	RETPAS
NXTKEY:	CALL	LDPAR3
;
; MUST CONVERT ADDRESS OF INDEX.KEY$ TO THREE-BYTE VECTOR FORMAT. CANNOT USE
;	SETAD1 SINCE INDEX.KEY$ IS NOT IN THE SECOND POSITION.
	CALL	CNVPR3
;
	CALL	SUCESR
	JMP	RETPAS
PRVKEY:	CALL	LDPAR3
	CALL	CNVPR3
	CALL	PRDESR
	JMP	RETPAS
;
; BC=ADDRESS OF STRING PARAMETER IN 3RD POSITION
;
CNVPR3:
	LDAX	B
	STA	STRAD1
	INX	B
	MOV	A,C
	STA	STRAD1+1
	MOV	A,B
	STA	STRAD1+2
	LXI	B,STRAD1
	RET
NOKEYS:	CALL	LDPAR2
	CALL	NMENTR
	JMP	RETPAS
DELKEY:	CALL	LDPAR4
	CALL	SETAD1
	CALL	REMOVE
	JMP	RETPAS
CLFILE:	CALL	LDPAR1
	CALL	RSTRCT
	JMP	RETPAS
INLOAD:	CALL	LDPAR2
	CALL	INTLOD
	JMP	RETPAS
SEQKEY:	CALL	LDPAR3
;
; MUST STILL CONVERT ADDRESS OF KEY.VALUE$ TO THREE-BYTE VECTOR FORMAT. CANNOT
; USE SETAD1 SINCE KEY.VALUE$ IS NOT THE 2ND PARAMETER.
;
; HL=ADDRESS OF KEY.VALUE$
;
	MOV	A,M
	STA	STRAD1
	INX	H
	SHLD	STRAD1+1
	LXI	H,STRAD1
;
	CALL	LOADKY
	JMP	RETPAS
BUILDX:	CALL	BLDIND
	JMP	RETPAS
NMNODS:	CALL	LDPAR2
	CALL	NMNODE
	JMP	RETPAS
OPDATA:	CALL	LDPAR3
	CALL	SETAD1
	CALL	OPEND
	JMP	RETPAS
CLDATA:	CALL	LDPAR1
	CALL	CLOSED
	JMP	RETPAS
NEWREC:	CALL	LDPAR2
	CALL	NEWDAT
	JMP	RETPAS
RETREC:	CALL	LDPAR2
	CALL	RETDAT
	JMP	RETPAS
READAT:	CALL	LDPAR3
	CALL	READD
	JMP	RETPAS
WRTDAT:	CALL	LDPAR3
	CALL	WRITED
	JMP	RETPAS
GETDFS:	CALL	LDPAR2
	CALL	DATAFS
	JMP	RETPAS
GETDFU:	CALL	LDPAR2
	CALL	DATAFU
	JMP	RETPAS
ERRVAR:	CALL	LDPAR1
	CALL	SETERR
	JMP	RETPAS
OPRDAT:	CALL	LDPAR3
	CALL	SETAD1
	CALL	OPENR
	JMP	RETPAS
	END

