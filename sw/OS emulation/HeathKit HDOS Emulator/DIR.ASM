*
*			SDIR.ASM
*		     Revised 7/3/79
*
*		SORTED DIRECTORY PROGRAM
*		by Keith Petersen, W8SDZ
*
*PRINTS A 4-WIDE DIRECTORY, SORTED ALPHABETICALLY
*BASED ON 'FMAP' BY WARD CHRISTENSEN.
*
*SDIR FILENAME.FILETYPE or just SDIR
*
*ALLOWS '*' OR '?' TYPE SPECIFICATIONS
*DRIVE NAME BY ALSO BE SPECIFIED
*
*	MODIFIED FOR USE WITH HRUN BY P. SWAYNE, HUG 7-DEC-82
*
*	ENTER WITH ADDRESS OF FCB ON THE STACK, AND
*	SEARCH DESCRIPTOR IN THE FCB.

$CHL	EQU	30224A
$TYPTX	EQU	195EH
S.CUSOR	EQU	20D8H		;CURSOR POSITION
.SCOUT	EQU	2
BASE	EQU	0		;CP/M BASE
NPL	EQU	4	;NUMBER OF NAMES PER LINE
DELIM	EQU	7CH	;FENCE (DELIMITER) CHARACTER
*
	ORG	2280H
*
START	MVI	A,1		;ASSUME DRIVE SY0:
	STA	FCB		;SET IT UP
	LXI	H,0
	DAD	SP		;FIND STACK
	MOV	A,L
	CPI	200Q		;HAS IT CHANGED?
	JNZ	DIR1		;YES, GET ARGUMENT
DIRALL	MVI	A,' '
	STA	FCB+1		;SET UP EMPTY FCB
	JMP	RUNDIR		;AND RUN DIRECTORY
DIR1	MOV	A,M		;GET A CHARACTER
	CPI	' '		;SPACE
	JNZ	DIR1A		;NO
	INX	H
	JMP	DIR1		;SKIP SPACES
DIR1A	INX	H		;MOVE OVER POSSIBLE DEVICE
	INX	H
	INX	H
	MOV	A,M		;GET CHARACTER
	CPI	':'		;DEVICE SPECIFIED?
	JNZ	DIR2		;NO
	DCX	H		;BACK UP TO UNIT
	MOV	A,M		;GET IT
	SUI	'0'-1		;MAKE IT 1-N
	STA	FCB		;PUT IT IN FCB
	INX	H
	INX	H		;SKIP COLON
	JMP	DIR4
DIR2	DCX	H		;BACK UP TO BEGINNING OF NAME
	DCX	H
	DCX	H
DIR4	MOV	A,M		;GET FIRST NAME CHARACTER
	ORA	A		;IS IT ZERO
	JZ	DIRALL		;THEN PRINT ALL OF DIRECTORY
	MVI	C,8		;SET A COUNTER
	LXI	D,FCB+1	;PUT NAME HERE
DIR5	ORA	A		;END OF ENTRY?
	JZ	DIR7		;YES
	CPI	'*'		;WILD CARD NAME?
	JZ	DIR6		;YES
	CPI	'.'		;END OF NAME?
	JZ	DIR7		;YES
	STAX	D		;ELSE, STORE CHARACTER
	INX	D		;INCREMENT POINTERS
	INX	H
	MOV	A,M		;GET NEXT CHARACTER
	DCR	C		;DECREMENT COUNTER
	JNZ	DIR5
	JMP	DIR7
DIR6	MVI	A,'?'		;GET A QUESTION MARK
	STAX	D		;FILL NAME WITH THEM
	INX	D
	DCR	C
	JNZ	DIR6+2
	INX	H		;SKIP OVER "*"
DIR7	INR	C
DIR8	DCR	C		;SET FLAGS
	JZ	DIR9
	MVI	A,' '		;ELSE, FILL NAME
	STAX	D
	INX	D
	JMP	DIR8
DIR9	MOV	A,M		;GET NEXT CHARACTER
	CPI	'.'		;PERIOD?
	MVI	C,3		;SET A COUNTER
	JNZ	DIR12		;NOT A PERIOD
	INX	H		;ELSE, SKIP PERIOD
DIR10	MOV	A,M		;GET A CHARACTER
	ORA	A		;END OF ENTRY?
	JZ	DIR12		;YES
	CPI	'*'		;WILD CARD EXT.?
	JZ	DIR11		;YES
	STAX	D		;ELSE, STORE CHARACTER
	INX	D		;INCREMENT POINTERS
	INX	H
	DCR	C		;DECREMENT COUNTER
	JNZ	DIR10
	JMP	RUNDIR		;DONE, RUN THE DIRECTORY
DIR11	MVI	A,'?'		;FILL EXT WITH "?"
	STAX	D
	INX	D
	DCR	C
	JNZ	DIR11+2
	INX	H		;SKIP OVER "*"
DIR12	INR	C
DIR13	DCR	C		;SET FLAGS
	JZ	RUNDIR		;RUN DIRECTORY IF DONE
	MVI	A,' '
	STAX	D		;FILL EXT. WITH SPACES
	INX	D
	JMP	DIR13
RUNDIR	LDA	S.CUSOR
	DCR	A		;CURSOR IN FIRST COLUMN?
	JZ	START1		;YES
	MVI	A,10
	SCALL	.SCOUT		;ELSE, PRINT NEW-LINE
START1	MVI	C,FDMA
	LXI	D,80H
	CALL	BDOS		;SET DEFAULT DMA
	LXI	H,FCB+1
	MOV	A,M
	CPI	' '
	JNZ	GOTFCB
*NO FCB - MAKE FCB ALL '?'
	MVI	B,11	;FN+FT COUNT
QLOOP	MVI	M,'?'	;STORE '?' IN FCB
	INX	H
	DCR	B
	JNZ	QLOOP
*LOOK UP THE FCB IN THE DIRECTORY
GOTFCB	MVI	C,FSRCHF ;GET 'SEARCH FIRST' FNC
	LXI	D,FCB		;GET FCB ADDRESS
	CALL	BDOS	;READ FIRST
	INR	A	;WERE THERE ANY?
	JNZ	SOME	;GOT SOME
	JMP	BOTTOM
*
*READ MORE DIRECTORY ENTRIES
MOREDIR	MVI	C,FSRCHN ;SEARCH NEXT
	LXI	D,FCB
	CALL	BDOS	;READ DIR ENTRY
	INR	A	;CHECK FOR END (0FFH)
	JZ	SPRINT	;NO MORE - SORT & PRINT
*POINT TO DIRECTORY ENTRY 
SOME	DCR	A	;UNDO PREV 'INR A'
	ANI	3	;MAKE MODULUS 4
	ADD	A	;MULTIPLY...
	ADD	A	;..BY 32 BECAUSE
	ADD	A	;..EACH DIRECTORY
	ADD	A	;..ENTRY IS 32
	ADD	A	;..BYTES LONG
	LXI	H,81H	;POINT TO BUFFER
*			;(SKIP TO FN/FT)
	ADD	L	;POINT TO ENTRY
	MOV	L,A	;SAVE (CAN'T CARRY TO H)
*MOVE ENTRY TO TABLE
	XCHG		;ENTRY TO DE
	LHLD	NEXTT	;NEXT TABLE ENTRY TO HL
	MVI	B,11	;ENTRY LENGTH
TMOVE	LDAX	D	;GET ENTRY CHAR
	MOV	M,A	;STORE IN TABLE
	INX	D
	INX	H
	DCR	B	;MORE?
	JNZ	TMOVE
	SHLD	NEXTT	;SAVE UPDATED TABLE ADDR
	LDA	COUNT	;GET PREV COUNT
	INR	A
	STA	COUNT
	JMP	MOREDIR
*
*SORT AND PRINT
SPRINT	LDA	COUNT	;INIT THE ORDER TABLE
	STA	PCOUNT	;SAVE FOR PRINTING
	LXI	H,ORDER
	LXI	D,TABLE
	LXI	B,11	;ENTRY LENGTH
BLDORD	MOV	M,E	;SAVE LO ORD ADDR
	INX	H
	MOV	M,D	;SAVE HI ORD ADDR
	INX	H
	XCHG		;TABLE ADDR TO HL
	DAD	B	;POINT TO NEXT ENTRY
	XCHG
	DCR	A	;MORE?
	JNZ	BLDORD	;..YES
	LDA	COUNT	;GET COUNT
	STA	SCOUNT	;SAVE AS # TO SORT
	DCR	A	;ONLY 1 ENTRY?
	JZ	DONE	;..YES, SO SKIP SORT
SORT	XRA	A	;GET A ZERO
	STA	SWITCH	;SHOW NONE SWITCHED
	LDA	SCOUNT	;GET COUNT
	DCR	A	;USE 1 LESS
	STA	TEMP	;SAVE # TO COMPARE
	STA	SCOUNT	;SAVE HIGHEST ENTRY
	JZ	DONE	;EXIT IF NO MORE
	LXI	H,ORDER ;POINT TO ORDER TABLE
SORTLP	CALL	COMPR	;COMPARE 2 ENTRIES
	CM	SWAP	;SWAP IF NOT IN ORDER
	INX	H	;BUMP ORDER
	INX	H	;..TABLE POINTER
	LDA	TEMP	;GET COUNT
	DCR	A
	STA	TEMP
	JNZ	SORTLP	;CONTINUE
*ONE PASS OF SORT DONE
	LDA	SWITCH	;ANY SWAPS DONE?
	ORA	A
	JNZ	SORT
*SORT IS ALL DONE - PRINT ENTRIES
DONE	LXI	H,ORDER
	SHLD	NEXTT
*
*PRINT AN ENTRY
	MVI	C,NPL	;NR. OF NAMES PER LINE
ENTRY:	LHLD	NEXTT	;GET ORDER TABLE POINTER
	MOV	E,M	;GET LO ADDR
	INX	H
	MOV	D,M	;GET HI ADDR
	INX	H
	SHLD	NEXTT	;SAVE UPDATED TABLE POINTER
	XCHG		;TABLE ENTRY TO HL
	MVI	B,8	;FILE NAME LENGTH
	CALL	TYPEIT	;TYPE FILENAME
	CALL	PERIOD	;PERIOD AFTER FN
	MVI	B,3	;GET THE FILETYPE
	CALL	TYPEIT
	DCR	C	;ONE LESS ON THIS LINE
	PUSH	PSW
	CNZ	FENCE	;NO CR-LF NEEDED, DO FENCE
	POP	PSW
	CZ	CR	;CR-LF NEEDED
*SEE IF MORE ENTRIES
	LDA	COUNT
	DCR	A
	STA	COUNT
	JNZ	ENTRY	;YES, MORE
	JMP	BOTTOM
*
PERIOD	MVI	A,'.'
	JMP	TYPE
*
FENCE	CALL	TWOSPCE
	MVI	A,DELIM	;FENCE CHARACTER
	CALL	TYPE
*
TWOSPCE	CALL	SPACE
*
SPACE	MVI	A,' '
*
*TYPE CHAR IN A
TYPE	SCALL	.SCOUT
	RET
*
WRCON	MVI	C,PRINT
	JMP	BDOS
*
TYPEIT	MOV	A,M
	CALL	TYPE
	INX	H
	DCR	B
	JNZ	TYPEIT
	RET
*
CR	MVI	A,0AH
	SCALL	.SCOUT
	MVI	C,NPL	;NUMBER OF NAMES PER LINE
	RET
*
*COMPARE ROUTINE FOR SORT
COMPR	PUSH	H	;SAVE TABLE ADDR
	MOV	E,M	;LOAD LO
	INX	H
	MOV	D,M	;LOAD HI
	INX	H
	MOV	C,M
	INX	H
	MOV	B,M
*BC, DE NOW POINT TO ENTRIES TO BE COMPARED
	XCHG
CMPLP	LDAX	B
	CMP	M
	INX	H
	INX	B
	JZ	CMPLP
	POP	H
	RET		;COND CODE TELLS ALL
*
*SWAP ENTRIES IN THE ORDER TABLE
SWAP	MVI	A,1
	STA	SWITCH	;SHOW A SWAP WAS MADE
	MOV	C,M
	INX	H
	PUSH	H	;SAVE TABLE ADDR+1
	MOV	B,M
	INX	H
	MOV	E,M
	MOV	M,C
	INX	H
	MOV	D,M
	MOV	M,B
	POP	H
	MOV	M,D
	DCX	H	;BACK POINTER TO CORRECT LOC'N
	MOV	M,E
	RET

*BOTTOM - PRINT DISK SPACE DATA

BOTTOM	LDA	4
	STA	CURDSK		;SAVE CURRENT DISK
	LXI	H,FCB		;GET FCB ADDRESS
	MOV	A,M		;GET DISK WE'RE USING
	DCR	A		;MAKE IT 0-N
	MOV	E,A		;IN E
	MVI	C,SELECT
	CALL	BDOS		;SELECT DISK
	MVI	C,GDPB
	CALL	BDOS
	INX	H
	INX	H		;MOVE TO BLOCK SHIFT
	MOV	A,M		;GET IT
	DCR	A
	DCR	A
	DCR	A		;MAKE IT START AT ZERO
	PUSH	PSW		;SAVE IT
	INX	H		;MOVE TO DISK SIZE
	INX	H
	INX	H
	MOV	E,M		;PUT IT IN DE
	INX	H
	MOV	D,M
	INX	D		;ADD 1
	XCHG
	SHLD	DSIZE		;SAVE DISK SIZE
	XCHG
	INX	H		;MOVE TO ALLOCATION
	INX	H
	INX	H
	MOV	A,M		;GET IT
	STA	ALLOC		;SAVE IT
	POP	PSW		;GET BLOCK SHIFT (-3)
	LXI	H,1		;HL = 1 K
	ORA	A		;SET FLAGS
	JZ	BOT1		;GOT BLOCK SIZE
BLKLP	DAD	H		;DOUBLE BLOCK SIZE
	DCR	A		;IS THIS IT
	JNZ	BLKLP		;NO, DOUBLE AGAIN
BOT1	PUSH	H		;SAVE BLOCK SIZE
	MVI	C,GALLOC
	CALL	BDOS		;GET ALLOCATION MAP
	POP	D		;DE = BLOCK SIZE
BOT2	MVI	B,8		;8 BITS PER BYTE
	MOV	A,M		;GET A BYTE
	PUSH	H		;SAVE MAP ADDRESS
BOT3	RAL			;TEST FOR A BIT
	JC	BOT4		;IT IS SET
	LHLD	FREE		;INCREMENT FREE SPACE
	DAD	D
	SHLD	FREE
	JMP	BOT5
BOT4	LHLD	USED		;INCREMENT USED SPACE
	DAD	D
	SHLD	USED
BOT5	LHLD	DSIZE		;GET DISK SIZE
	DCX	H		;SUBTRACT THIS GROUP
	SHLD	DSIZE
	PUSH	PSW		;SAVE MAP BYTE
	MOV	A,H
	ORA	L		;DONE WITH DISK?
	JZ	BOT6		;IF SO, LEAVE
	POP	PSW		;ELSE RESTORE MAP BYTE
	DCR	B		;DONE WITH BYTE?
	JNZ	BOT3		;NO, TEST ANOTHER BIT
	POP	H		;ELSE, GET MAP ADDRESS
	INX	H		;INCREMENT IT
	JMP	BOT2		;GET NEXT BYTE
BOT6	POP	PSW		;RESTORE PSW
	POP	H		;AND HL
	XCHG			;HL = BLOCK SIZE
	CALL	$CHL		;COMPLEMENT IT
	XCHG			;PUT RESULT IN DE
	LHLD	USED		;GET USED SPACE
	LDA	ALLOC		;AND ALLOCATION VECTOR
	RAL			;TEST FOR A BIT
	JNC	BOT8		;NONE SET, NO ALLOCATED SPACE
BOT7	DAD	D		;SUBTRACK A BLOCK
	RAL			;TEST FOR A BIT
	JC	BOT7		;IT WAS SET, SUBTRACT BLOCK
BOT8	SHLD	USED		;SAVE UPDATED USED SPACE
	LDA	S.CUSOR		;GET CURSOR POSITION
	DCR	A		;IN FIRST COLUMN
	JZ	BOT9		;YES
	MVI	A,10
	SCALL	.SCOUT		;ELSE, PRINT NEW LINE
BOT9	LDA	PCOUNT		;GET FILE COUNT
	MOV	L,A
	MVI	H,0		;IN HL
	CALL	DECOUT		;PRINT COUNT
	CALL	$TYPTX
	DB	' Files.  Used =',' '+80H
	LHLD	USED		;GET USED SPACE
	CALL	DECOUT		;PRINT IT
	CALL	$TYPTX
	DB	'K, or',' '+80H
	LHLD	USED		;GET USED SPACE AGAIN
	DAD	H		;* 2
	DAD	H		;* 4
	CALL	DECOUT		;PRINT NO. OF SECTORS
	CALL	$TYPTX
	DB	' Sectors.  Free =',' '+80H
	LHLD	FREE
	CALL	DECOUT		;PRINT FREE SPACE
	CALL	$TYPTX
	DB	'K, or',' '+80H
	LHLD	FREE		;GET FREE AGAIN
	DAD	H		;* 2
	DAD	H		;* 4
	CALL	DECOUT		;PRINT FREE SECTORS
	CALL	$TYPTX
	DB	' Sectors.',8AH
	LDA	CURDSK		;GET CURRENT DISK
	MOV	E,A		;IN E
	MVI	C,SELECT
	CALL	BDOS		;SELECT IT
*
*EXIT - ALL DONE 
EXIT	XRA	A
	SCALL	0		;SCALL .EXIT

*DECOUT - PRINT HL IN DECIMAL

DECOUT	PUSH	B
	PUSH	D
	PUSH	H		;SAVE REGISTERS
	LXI	B,-10		;RADIX FOR CONVERSION
	LXI	D,-1
DX	DAD	B		;DIVIDE BY 10
	INX	D
	JC	DX
	LXI	B,10
	DAD	B
	XCHG			;DE = DIGIT, HL = NUMBER/10
	MOV	A,H
	ORA	L		;DONE?
	CNZ	DECOUT		;CALL RECURSIVELY UNTIL DONE
	MOV	A,E		;GET CHARACTER TO PRINT
	ADI	'0'		;ADD ASCII BIAS
	SCALL	.SCOUT		;PRINT IT
	POP	H		;RESTORE REGISTERS
	POP	D
	POP	B
	RET

*
CURDSK	DB	0	;CURRENT DISK
FCB	DB	0,0,0,0,0,0,0,0
	DB	0,0,0,0,0,0,0,0
NEXTT	DW	TABLE	;NEXT TABLE ENTRY
COUNT	DB	0	;ENTRY COUNT
PCOUNT	DB	0	;COUNT TO PRINT
SCOUNT	DB	0	;# TO SORT
SWITCH	DB	0	;SWAP SWITCH FOR SORT
DSIZE	DW	0	;DISK SIZE
USED	DW	0	;USED SPACE
FREE	DW	0	;FREE SPACE
ALLOC	DB	0	;ALLOCATION VECTOR
ORDER	DS	256	;ORDER TABLE (ROOM FOR LOTS OF NAMES)
TEMP	DS	1	;SAVE DIR ENTRY
	DS	31
TABLE	EQU	*	;READ ENTRIES IN HERE
*
* BDOS EQUATES
*
RDCHR	EQU	1	;READ CHAR FROM CONSOLE
WRCHR	EQU	2	;WRITE CHR TO CONSOLE
PRINT	EQU	9	;PRINT CONSOLE BUFF
CONST	EQU	11	;CHECK CONS STAT
SELECT	EQU	14	;SELECT DISK
FOPEN	EQU	15	;0FFH=NOT FOUND
FCLOSE	EQU	16	;   "	"
FSRCHF	EQU	17	;   "	"
FSRCHN	EQU	18	;   "	"
ERASE	EQU	19	;NO RET CODE
FREAD	EQU	20	;0=OK, 1=EOF
FWRTE	EQU	21	;0=OK, 1=ERR, 2=?, 255=NO DIR SPC
FMAKE	EQU	22	;255=BAD
FREN	EQU	23	;255=BAD
FDMA	EQU	26
GALLOC	EQU	27		;GET ALLOCATION ADDRESS
GDPB	EQU	31		;GET DISK PARAMETER ADDRESS
BDOS	EQU	BASE+5
*
	END	START
                                                                                                                                                   