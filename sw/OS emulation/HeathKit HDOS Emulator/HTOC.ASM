;		H T O C
;		=======
;
;	HTOC IS A UTILITY PROGRAM TO COPY FILES FROM
;	A HEATH HDOS FORMATTED DISK TO A CP/M DISK.
;
;	WRITTEN BY BOB MATHIAS, AUGUST 18, 1979.
;
;	adapted for CP/M 2.2 by William W. Moss - 8/9/81
;
;	Modified for 8-inch drives by P. Swayne, HUG  26-AUG-81
;	Additional modifications by P. Swayne, HUG  5-APR-82  20-DEC-82
;
FALSE	EQU	0		;TRUE/FALSE DEFINITION
TRUE	EQU	NOT FALSE
;
MAXDRV	EQU	'F'		;MAXIMUM DRIVE CODE
;
BASE	EQU	0		;BASE FOR HEATH H8 CP/M
BOOT	EQU	BASE		;WARM BOOT ADDRESS
;
;	HDOS DIRECTORY DEFINITION
;	=========================
;
	ORG	0
DIR$1B	DS	1		;ENTRY 1ST BYTE
DIR$EMP	EQU	377Q		;THIS ENTRY EMPTY
DIR$CLR	EQU	376Q		;THIS ENTRY EMPTY AND
;				;..NO MORE IN DIRECTORY
	ORG	0
DIR$NAM	DS	8		;NAME
DIR$EXT	DS	3		;EXTENTSION
DIR$PRO	DS	1		;PROJECT
DIR$VER	DS	1		;VERSION
DIR$IDS	EQU	$		;FILE ID LENGTH
;
DIR$CLU	DS	1		;CLUSTER FACTOR
DIR$FLG	DS	1		;FLAGS
	DS	1		;RESERVED
DIR$FGN	DS	1		;FIRST GROUP NUMBER
DIR$LGN	DS	1		;LAST GROUP NUMBER
DIR$LSI	DS	1		;LAST SECTOR INDEX (IN LAST GROUP)
DIR$CRD	DS	2		;CREATION DATE
DIR$ALD	DS	2		;LAST ALTERATION DATE
DIRELEN	EQU	$		;DIRECTORY ENTRY LENGTH
;
;
;
;	S T A R T    O F    P R O G R A M
;	=================================
;
	ORG	BASE+100H	;TPA
START	DS	0		;START OF PROGRAM
	LXI	H,0		;SETUP STACK POINTER
	DAD	SP
	SHLD	STACK
	LXI	SP,STACK
;
;SETUP LOCAL JUMPS TO BIOS
;
	LHLD	BASE+1
	LXI	D,27
	DAD	D		;DE = ADDR OF SET TRACK
	SHLD	VSETTRK+1	;MODIFY OUR JUMP TO SET TRACK
	LXI	D,3
	DAD	D		;DE = ADDR OF SET SECTOR ROUTINE
	SHLD	VSETSEC+1	;MODIFY OUR JUMP TO SET SECTOR
	DAD	D		;DE = ADDR OF SET DMA
	SHLD	VSETDMA+1	;MODIFY OUR JUMP TO SET DMA
	DAD	D		;DE = ADDR OF DISK READ
	SHLD	VREAD+1		;MODIFY OUR JUMP TO DISK READ
;
;Introduction
;
	CALL	PRTMSG
	DB	'HTOC for CP/M 2.2 as of 17/12/82 - WWM/PWS',CR,LF,CR,LF
	DB	'This utility allows the user to transfer files '
	DB	CR,LF,'from a HDOS disk'
	DB	' to a CP/M disk.',CR,LF,CR,LF+EL
;
	JMP	MOUNT		;GO MOUNT DISKS
;
;
;			M E N U
;			=======
;
MENU	DS	0
	CALL	PRTMSG		;PRINT MENU
	DB	'FUNCTIONS:',CR,LF,CR,LF
	DB	'C - CP/M DISK DIRECTORY',CR,LF
	DB	'H - HDOS DISK DIRECTORY',CR,LF
	DB	'I - INSERT NEW DISKS',CR,LF
	DB	'T - TRANSFER HDOS FILE TO CP/M DISK',CR,LF
	DB	'X - RETURN TO CP/M VIA WARM BOOT',CR,LF,CR,LF
	DB	'Enter function code:',' '+EL
;
	MVI	C,RDCON		;GET FUNCTION..
	CALL	BDOS		;..CODE
	PUSH	PSW		;SAVE IT
	CALL	PRTMSG		;RESET CONSOLE
	DB	CR,LF,CR,LF+EL
	POP	PSW		;FETCH FUNCTION CODE FROM STACK
	ANI	5FH		;STRIP PARITY AND CONVERT TO UPPER CASE
	CPI	'C'		;IF 'C'
	JZ	CPMDIR		;..GO TO CPMDIR
	CPI	'H'		;IF 'H'
	JZ	H8DIR		;..GO TO H8DIR
	CPI	'I'		;IF 'I'
	JZ	MOUNT		;..GO TO MOUNT
	CPI	'T'		;IF 'T'
	JZ	TRANSFR		;.. GO TO TRANSFR
	CPI	'X'		;IF 'X'
	JZ	XIT		;..GO TO XIT
;
;	IF FUNCTION CODE NOT = TO ANY OF THE ABOVE, WE HAVE AN ERROR
;
	CALL	PRTMSG		;PRINT ERROR MSG
	DB	'xxx INVALID OPTION xxx',CR,LF+EL
	JMP	MENU		;GO TRY AGAIN
;
;
;			E X I T    R O U T I N E
;			========================
;
XIT	DS	0
	CALL	PRTMSG		;PRINT MSG
	DB	'Insert CP/M system disk in drive A',CR,LF
	DB	'Press RETURN to exit:',CR,LF+EL
WAICR	MVI	C,RDCON
	CALL	BDOS		;WAIT FOR CR
	CPI	CR
	JNZ	WAICR
	MVI	C,STDMA
	LXI	D,BASE+80H
	CALL	BDOS		;RESET DMA
	MVI	C,SELDK
	MVI	E,0
	CALL	BDOS		;SELECT DRIVE A:
	JMP	BOOT		;JUMP TO WARM BOOT
;
;
;			M O U N T    R O U T I N E
;			==========================
;
MOUNT	DS	0
	CALL	PRTMSG
	DB	'Enter drive used for HDOS disk (B-',MAXDRV,'):',' '+EL
	MVI	C,RDCON
	CALL	BDOS		;GET ANSWER
	PUSH	PSW		;SAVE IT
	CALL	PRTMSG
	DB	CR,LF,CR,LF+EL
	POP	PSW
	CPI	3		;CONTROL-C?
	JZ	MENU
	ANI	5FH		;CAPITALIZE ANSWER
	CPI	'B'		;LESS THAN B?
	JC	MOUNT		;IF SO, TRY AGAIN
	CPI	MAXDRV+1	;GREATER THAN MAXIMUM
	JNC	MOUNT		;IF SO, TRY AGAIN
	STA	HDRV		;STORE IT
	SUI	41H		;REMOVE ASCII +1
	STA	HDRIVE		;STORE DRIVE NO.
MOUNT1	CALL	PRTMSG
	DB	'Enter drive used for CP/M disk (A-',MAXDRV,'):',' '+EL
	MVI	C,RDCON
	CALL	BDOS		;GET ANSWER
	PUSH	PSW		;SAVE IT
	CALL	PRTMSG
	DB	CR,LF,CR,LF+EL
	POP	PSW
	CPI	3
	JZ	MENU
	ANI	5FH		;CAPITALIZE ANSWER
	CPI	'A'		;LESS THAN A?
	JC	MOUNT1		;TRY AGAIN
	CPI	MAXDRV+1	;GREATER THAN MAXIMUM
	JNC	MOUNT1		;TRY AGAIN
	MOV	B,A		;SAVE ANSWER
	LDA	HDRV		;GET HDOS DRIVE
	CMP	B		;SAME AS CP/M?
	JZ	MOUNT1		;NOT ALLOWED!
	MOV	A,B		;RESTORE ANSWER
	STA	CDRV		;STORE IT
	SUI	41H		;REMOVE ASCII+1
	STA	CDRIVE		;STORE DRIVE NO.
	CALL	PRTMSG		;PRINT MOUNT MSG
	DB	'Insert the CP/M disk in drive '
CDRV	DB	'A,',CR,LF
	DB	'and insert a CP/M disk of equal sides and density',CR,LF
	DB	'to the HDOS disk you wish to read in drive '
HDRV	DB	'B.',CR,LF,CR,LF
	DB	'Press RETURN when ready:',CR,LF+EL
;
WAICR1	MVI	C,RDCON
	CALL	BDOS		;WAIT FOR RETURN
	CPI	3
	JZ	MENU
	CPI	CR
	JNZ	WAICR1
	MVI	C,RESETDK
	CALL	BDOS		;LOGIN A:
	LXI	D,80H
	MVI	C,STDMA
	CALL	BDOS		;SET STANDARD DMA
	LDA	HDRIVE
	MOV	E,A		;E = HDOS DRIVE
	MVI	C,SELDK		;SELECT IT
	CALL	BDOS
	LXI	H,FCB		;POINT TO DEFAULT FCB
	MVI	M,'?'		;INSERT "?"
	XCHG			;DE = FCB
	MVI	C,SFF		;USE SFF TO AUTO-SELECT DISK
	CALL	BDOS
	LDA	HDRV		;GET HDOS ASCII DRIVE
	STA	HDRV1		;PUT IT IN NEW MESSAGE
	CALL	PRTMSG
	DB	CR,LF
	DB	'Insert HDOS disk in drive '
HDRV1	DB	'B,',CR,LF
	DB	'Press RETURN when ready:',CR,LF+EL
WAICR2	MVI	C,RDCON
	CALL	BDOS		;READ CONSOLE
	CPI	3
	JZ	MENU
	CPI	CR
	JNZ	WAICR2
	CALL	BH8DIR		;BUILD H8 DIRECTORY IN RAM
	JMP	MENU		;GO TO MENU
CDRIVE	DS	1
HDRIVE	DS	1
SIZE	DS	1
;
;
;
;			T R A N S F E R
;			===============
;
TRANSFR	DS	0
	XRA	A
	STA	WCFLG		;CLEAR WILD CARD FLAGS
	LXI	H,DIRECT+DIR$NAM-DIRELEN
	SHLD	DIRPTR		;SET DIRECTORY POINTER
	CALL	PRTMSG		;ASK FOR FILENAME
	DB	'Enter filename -->',' '+EL
	LXI	D,RBUF
	MVI	A,80
	STAX	D		;MOVE LENGTH (80) TO RBUF 1ST BYTE
	MVI	C,10
	CALL	BDOS		;READ BUFFER
	CALL	PRTMSG		;MOVE CURSOR TO START OF LINE
	DB	CR,LF+EL
	LDA	RBUF+1		;GET LENGTH OF MSG ENTERED
	INR	A
	INR	A		;ADD 2 TO LENGTH
	LXI	H,RBUF
	ADD	L
	MOV	L,A		;HL:=ADDR(RBUF)+LENGTH(MSG ENTERED)
	MVI	M,CR		;PUT CR AT END OF MSG ENTERED
;
;	MOVE FILENAME ENTERED TO SNAME
	LXI	H,SNAME
	MVI	B,11
	CALL	ZERO		;MOVE ZEROS TO SNAME
	LXI	H,RBUF+2
	LXI	D,SNAME
	MVI	B,8		;SET A COUNTER
TRAN001	DS	0
	MOV	A,M		;GET NEXT CHAR FROM RBUF
	CPI	'*'		;NAME OR EXT WILD CARD?
	JNZ	TRAN0A0		;NO
	MVI	A,'?'		;ELSE, GET "?"
TRANLP	STAX	D		;AND FILL NAME OR EXT
	INX	D
	DCR	B
	JNZ	TRANLP
	MVI	A,1
	STA	WCFLG		;FLAG WILD CARD
	INX	H
	JMP	TRAN001		;GET NEXT CHARACTER
TRAN0A0	CPI	'?'		;WILD CARD?
	JNZ	TRAN0A1		;NO
	PUSH	PSW		;ELSE, SAVE CHARACTER
	MVI	A,1
	STA	WCFLG		;SET WILD CARD FLAG
	POP	PSW
	JMP	TRAN002
TRAN0A1	CALL	LOWUP		;CONVERT TO UPPER CASE /08.81.WWM/
	CPI	CR		;IF A CR
	JZ	TRAN003		;..GO TO TRAN003
	CPI	'.'		;IF NOT A PERIOD
	JNZ	TRAN002		;..GO TO TRAN002
	INX	H		;BUMP RBUF POINTER
	MVI	B,3		;SET COUNTER TO 3
	LXI	D,SEXT		;POINT DE TO EXTENTION OF SNAME
	JMP	TRAN001		;GO DO NEXT CHARACTER
TRAN002	DS	0
	STAX	D		;MOVE CHAR FROM RBUF TO NEXT SNAME SPOT
	INX	H		;BUMP RBUF POINTER
	INX	D		;BUMP SNAME POINTER
	DCR	B
	JMP	TRAN001		;DO UNTIL CR FOUND
TRAN003	DS	0
	CALL	FNSEAR		;SEARCH HDOS DIRECTORY FOR FILENAME
	JNC	TRAN005		;IF FOUND, GO TO TRAN005
	CALL	PRTMSG		;PRINT ERROR MSG
	DB	'xxx FILE NOT FOUND xxx',CR,LF+EL
TRAN004	DS	0
	CALL	PRTMSG		;ASK IF ANY MORE?
	DB	'Do you have more files to copy? (Y or N) <N>:',' '+EL
	MVI	C,RDCON
	CALL	BDOS		;GET ANSWER
	PUSH	PSW		;SAVE IT
	CALL	PRTMSG		;RESET CONSOLE
	DB	CR,LF+EL
	POP	PSW		;REFETCH ANSWER
	ANI	5FH
	CPI	'Y'		;IF YES
	JZ	TRANSFR		;..GO TO TRANSFR
	JMP	MENU		;ELSE GO TO MENU
TRAN005	DS	0
	PUSH	H		;SAVE HDOS DIR ENTRY INDEX
	CALL	H8FILEN		;GET LENGTH OF FILES (# OF RECORDS)
	ANI	0FCH
	RAR
	RAR
	INR	A
	MOV	C,A		;C:=<FILE LENGTH IN K BYTES>
	STA	SH8FL		;SAVE FILE LENGTH
;
TRAN006	DS	0
	POP	H
	PUSH	H		;GET DIRECTORY POINTER
	CALL	OPENH8		;SETUP FOR READING HDOS DISK
	POP	H
	PUSH	H
	CALL	OPENCPM		;OPEN CP/M FILE
	POP	H		;GET FILE NAME
	MVI	B,11		;11 CHARACTERS LONG
PNAME	MOV	A,M		;GET A CHARACTER
	PUSH	H		;SAVE REGISTERS
	PUSH	B
	MOV	E,A		;E = CHAR
	MVI	C,WRCON
	CALL	BDOS		;PRINT CHARACTER
	POP	B
	DCR	B		;DECREMENT COUNTER
	MOV	A,B
	CPI	3
	JNZ	PNAME1
	MVI	E,'.'
	MVI	C,WRCON
	PUSH	B
	CALL	BDOS
	POP	B
PNAME1	POP	H
	INX	H
	XRA	A
	ORA	B		;DONE?
	JNZ	PNAME
	CALL	PRTMSG
	DB	'  Is this file for HRUN? (Y or N) <Y>:',' '+EL
	MVI	C,RDCON
	CALL	BDOS
	PUSH	PSW		;SAVE ANSWER
	CALL	PRTMSG
	DB	CR,LF+EL
	POP	PSW
	CPI	3
	JZ	MENU
	ANI	5FH		;CAPITALIZE
	CPI	'N'		;NO
	JNZ	TRAN007		;NOT NO, GO TRANSFER FILE
	CALL	PRTMSG		;ASH FOR FILE TRANSLATION
	DB	'Do you want ASCII file translation? (Y or N) <Y>:',' '+EL
	MVI	C,RDCON
	CALL	BDOS		;GET ANSWER
	PUSH	PSW		;SAVE IT
	CALL	PRTMSG		;MOVE CURSOR TO START OF NEXT LINE
	DB	CR,LF+EL
	POP	PSW		;RETRIEVE ANSWER
	CPI	3
	JZ	MENU
	ANI	5FH		;STRIP PARITY AND CONVERT TO UPPER
	CPI	'N'
	JNZ	TRAN020		;GO TO TRAN020 UNLESS N
TRAN007	DS	0
	MVI	C,SELDK
	LDA	HDRIVE		;GET HDOS DRIVE
	MOV	E,A		;PUT IT IN E
	CALL	BDOS		;SELECT HDOS DRIVE
	LXI	H,H8REC
	CALL	LH8READ		;READ HDOS REC INTO H8REC
	JC	TRAN009		;AT EOF, GO TO TRAN009
	MVI	C,SELDK
	LDA	CDRIVE		;GET CP/M DRIVE
	MOV	E,A		;PUT IT IN E
	CALL	BDOS		;SELECT CP/M DRIVE
	MVI	C,STDMA
	LXI	D,H8REC
	CALL	BDOS		;SET DMA TO HREC
	MVI	C,WRITE
	LXI	D,FCB
	CALL	BDOS		;WRITE 1ST HALF OF H8REC
	ANA	A		;IF WRITE OK
	JZ	TRAN008		;..GO TO TRAN008
TRANERR	DS	0
	CALL	PRTMSG		;PRINT ERROR MSG
	DB	'xxx TRANSFER ERROR xxx',CR,LF+EL
	JMP	TRAN010		;GO CLOSE FILES
TRAN008	DS	0
	MVI	C,STDMA
	LXI	D,H8REC+128
	CALL	BDOS		;SETUP DMA FOR 2ND HALF OF H8REC
	MVI	C,WRITE
	LXI	D,FCB
	CALL	BDOS		;WRITE 2ND HALF OF H8REC
	ANA	A		;IF BAD WRITE
	JNZ	TRANERR		;..GO TO TRANERR
	JMP	TRAN007		;DO UNTIL EOF ON HDOS FILE
TRAN009	DS	0
TRAN010	DS	0
	MVI	C,SELDK
	LDA	CDRIVE		;GET CP/M DRIVE
	MOV	E,A		;PUT IN A
	CALL	BDOS		;SELECT CP/M DRIVE
	MVI	C,CLOSE
	LXI	D,FCB
	CALL	BDOS		;CLOSE CP/M FILE
	MVI	C,STDMA
	LXI	D,BASE+80H
	CALL	BDOS		;RESET DMA ADDRESS
	LDA	WCFLG		;GET WILD CARD FLAG
	ORA	A		;IS IT SET?
	JNZ	TRAN003		;IF SO, LOOP
	JMP	TRAN004		;ELSE, GO ASK FOR ANY MORE
MBAFLG	DB	0		;FLAG IF MBASIC PROGRAM
ATFLAG	DB	0		;FLAG IF "@" FOUND (MBASIC)
TRAN020	DS	0
	XRA	A
	STA	MBAFLG		;CLEAR MBASIC FLAG
	STA	ATFLAG		;CLEAR "@" FLAG
	CALL	PRTMSG
	DB	'Is this an MBASIC file? (Y or N) <N>:',' '+EL
	MVI	C,RDCON
	CALL	BDOS		;GET ANSWER
	PUSH	PSW		;SAVE IT
	CALL	PRTMSG
	DB	CR,LF+EL
	POP	PSW
	CPI	3
	JZ	MENU
	ANI	5FH		;CAPITALIZE ANSWER
	CPI	'Y'		;YES?
	JNZ	TRAN20A		;IF NOT, GO ON
	STA	MBAFLG		;FLAG MBASIC FILE
TRAN20A	XRA	A
	STA	H8NDX		;SET H8REC INDEX TO ZERO
	STA	CPMNDX		;SET CP/M BUFFER INDEX TO ZERO
TRAN025	DS	0
	CALL	TRAN060		;GET NEXT H8REC CHARACTER
	JC	TRAN030		;AT EOF, GO TO TRAN030
	JZ	TRAN030		;IF NULL, GO TO TRAN030
	CALL	TRAN080		;PUT NEXT CPM BUFFER CHARACTER
	JMP	TRAN025		;LOOP UNTIL EOF
TRAN030	DS	0
	LDA	CPMNDX
	ANA	A
	JZ	TRAN009		;IF BUFFER IS EMPTY, BRANCH
	MVI	A,07FH
	STA	CPMNDX		;FORCES LAST WRITE
	MVI	A,01AH
	CALL	TRAN120		;WRITE LAST RECORD
	JMP	TRAN009		;GO CLOSE FILES
TRAN060	DS	0
	LDA	H8NDX		;GET H8REC INDEX
	ANA	A		;IF ZERO
	CZ	TRAN070		;.. READ NEXT RECORD
	RC			;.. AT END, RETURN
	LXI	H,H8REC		;HL = ADDR(H8REC)
	LDA	H8NDX		;GET INDEX
	MVI	B,0
	MOV	C,A		;BC = INDEX
	DAD	B		;HL = ADDR(H8REC)+INDEX
	MOV	A,M		;A  = H8REC[H8NDX]
	LXI	H,H8NDX
	INR	M		;BUMP H8NDX
	ANA	A		;CLEAR CARRY
	RET			;RETURN TO CALLER WITH CARRY CLEAR
TRAN070	DS	0
	MVI	C,SELDK
	LDA	HDRIVE
	MOV	E,A		;GET HDOS DRIVE NO.
	CALL	BDOS		;SELECT HDOS DRIVE
	LXI	H,H8REC
	CALL	LH8READ		;READ HDOS FILE INTO H8REC
	RET			;RETURN TO CALLER
TRAN080	DS	0
	PUSH	PSW		;SAVE CHAR TO WRITE
	LDA	CPMNDX		;GET CPM BUFFER POINTER
	ANA	A		;IF CPM INDEX = 0
	CZ	TRAN100		;.. FILL BUFFER WITH CTL-Z'S
	POP	PSW		;SAVE CHAR TO WRITE
	PUSH	PSW		;RESAVE IT
	CPI	'@'		;IS CHARACTER "@"?
	JNZ	TRAN80A		;NO, CONTINUE
	LDA	MBAFLG
	ORA	A		;IS FILE MBASIC?
	JZ	TRAN80A		;NO
	MVI	A,LF		;YES, REPLACE "@" WITH LF
	STA	ATFLAG		;FLAG "@" FOUND
	CALL	TRAN120		;WRITE LF
	POP	PSW		;FIX STACK
	RET
TRAN80A	POP	PSW		;RESTORE CHARACTER
	PUSH	PSW		;SAVE AGAIN
	CPI	LF		;IF IT IS NOT A LF
	JNZ	TRAN085		;.. GO TO TRAN085
	MVI	A,CR
	CALL	TRAN120		;WRITE A CR
	LDA	ATFLAG
	ORA	A		;IS "@" FLAG SET?
	JZ	TRAN085		;IF NOT, GO ON
	XRA	A
	STA	ATFLAG		;IF SO, CLEAR IT
	POP	PSW		; FIX STACK
	RET			; AND RETURN
TRAN085	DS	0
	POP	PSW		;RETRIEVE CHAR TO WRITE
	CALL	TRAN120		;WRITE IT
	RET			;RETURN TO CALLER
TRAN100	DS	0		;FILL BUFFER WITH CONTROL-Z'S
	MVI	C,128
	MVI	A,01AH
	LXI	H,BASE+80H
TRAN103	DS	0
	MOV	M,A
	INX	H
	DCR	C
	JNZ	TRAN103
	RET
;
TRAN120	DS	0
	PUSH	PSW		;SAVE CHAR TO WRITE
	LDA	CPMNDX		;GET CPM BUFFER INDEX
	MVI	B,0
	MOV	C,A		;BC = INDEX
	LXI	H,BASE+80H	;HL = BUFFER ADDR
	DAD	B		;HL = ADDR(BUFFER)+INDEX
	POP	PSW		;GET CHAR TO WRITE
	MOV	M,A		;MOVE IT TO BUFFER
	LDA	CPMNDX
	INR	A
	STA	CPMNDX		;BUMP CPM BUFFER INDEX
	CPI	080H		;IF IT IS NOT AT END OF BUFFER
	RNZ			;.. RETURN
	XRA	A
	STA	CPMNDX		;RESET INDEX
	MVI	C,SELDK
	LDA	CDRIVE		;GET CP/M DRIVE
	MOV	E,A		;PUT IN E
	CALL	BDOS		;SELECT CP/M DRIVE
	MVI	C,STDMA
	LXI	D,BASE+80H
	CALL	BDOS		;SET DMA ADDRESS
	MVI	C,WRITE
	LXI	D,FCB
	CALL	BDOS		;WRITE BUFFER
	ANA	A
	POP	H		;SAVE RETURN ADDR IN HL
	JNZ	TRANERR		;IF ERROR, GO TO TRANERR
	PUSH	H		;RESTORE RETURN ADDR
	RET
	;
;
;			C P M     D I R E C T O R Y
;			===========================
;
CPMDIR	DS	0
	LXI	H,0
	SHLD	KLEFT		;ZERO FREE DISK SPACE
	MOV	A,L
	STA	NAMCNT		;ZERO NAME COUNT
	LDA	CDRIVE		;GET CP/M DRIVE
	INR	A		;MAKE DRIVE 1-N
	STA	FCB
;MAKE FCB ALL ?
	LXI	H,FCB+1
	MVI	B,11
CPMDIR1	DS	0
	MVI	M,'?'
	INX	H
	DCR	B
	JNZ	CPMDIR1
;LOOKUP THE FCB IN THE DIRECTORY
CPMDIR2	DS	0
	MVI	A,0
	STA	FCBEXT
	MVI	C,17
	LXI	D,FCB
	CALL	BDOS		;GET 1ST DIRECTORY ENTRY
	INR	A		;WERE THERE ANY?
	JNZ	CPMDIR4		;..IF YES, GO TO CPMDIR4
	CALL	PRTMSG		;PRINT MSG
	DB	'xxx NO ENTRIES FOUND IN CP/M DIRECTORY xxx',CR,LF+EL
	JMP	CPMSIZ		;GO TO MENU
;READ MORE DIRECTORY ENTRIES
CPMDIR3	DS	0
	MVI	C,18
	LXI	D,FCB
	CALL	BDOS		;READ NEXT ENTRY
	INR	A		;CHECK FOR END
	JNZ	CPMDIR4		;IF NOT END..GO TO CPMDIR4
CPMSIZ	LDA	CDRIVE		;GET CP/M DRIVE
	MOV	E,A		;IN E
	MVI	C,SELDK
	CALL	BDOS		;SELECT DRIVE
	MVI	C,GDPB
	CALL	BDOS		;GET DISK PARAMETERS
	INX	H		;MOVE TO BLOCK SHIFT
	INX	H
	MOV	A,M		;GET IT
	SUI	3		;SUBTRACT 3
	INX	H		;MOVE TO DISK SIZE
	INX	H
	INX	H
	MOV	E,M		;PUT IT IN DE
	INX	H
	MOV	D,M
	INX	D		;ADD 1
	XCHG
	SHLD	DSIZE		;SAVE IT
	LXI	H,1		;HL = 1K
	ORA	A		;SET FLAGS
	JZ	CPMSIZ1		;GOT BLOCK SIZE
BLKLP	DAD	H		;DOUBLE BLOCK SIZE
	DCR	A		;IS THIS IT?
	JNZ	BLKLP		;NO, DOUBLE AGAIN
CPMSIZ1	PUSH	H		;SAVE BLOCK SIZE
	MVI	C,GALLOC
	CALL	BDOS		;GET ALLOCATION MAP
	POP	D		;DE = BLOCK SIZE
CPMSIZ2	MVI	B,8		;SET A COUNTER
	MOV	A,M		;GET A BYTE FROM MAP
	PUSH	H		;SAVE MAP ADDRESS
CPMSIZ3	RAL			;TEST FOR A BIT
	JC	CPMSIZ4		;IT IS SET
	LHLD	KLEFT		;ELSE, INCREMENT FREE SPACE
	DAD	D
	SHLD	KLEFT
CPMSIZ4	LHLD	DSIZE		;DECREMENT DISK SIZE
	DCX	H
	SHLD	DSIZE
	PUSH	PSW		;SAVE MAP BYTE
	MOV	A,H
	ORA	L		;DONE WITH DISK?
	JZ	CPMSIZ5		;YES, EXIT
	POP	PSW		;ELSE, RESTORE MAP BYTE
	DCR	B		;DONE WITH BYTE?
	JNZ	CPMSIZ3		;NO
	POP	H		;ELSE, RESTORE MAP ADDR
	INX	H		;INCREMENT IT
	JMP	CPMSIZ2		;AND TEST NEXT BYTE
CPMSIZ5	POP	PSW		;RESTORE REGISTERS
	POP	H
	LHLD	KLEFT		;GET FREE SPACE
	MOV	B,H
	MOV	C,L		;(BC) = KLEFT
	MVI	A,4		;# OF DIGITS TO UNPACK
	LXI	H,MKLEFT	;(HL)=DEST. ADDR OF UNPACK
	CALL	UDD		;CONVERT BINARY TO ASCII
	LXI	H,MKLEFT
	MVI	C,3
	CALL	ZEROSUP		;ZERO SUPPRESS KLEFT
	CALL	PRTMSG		;PRINT BYTES LEFT ON DISK
	DB	CR,LF,'Free space on disk = '
MKLEFT	DS	4
	DB	'K',CR,LF,CR,LF+EL
	JMP	MENU		;GO TO MENU
;
;POINT TO DIRECTORY ENTRY
CPMDIR4	DS	0
	DCR	A		;UNDO PREV 'INR A'
	ANI	3		;MAKE MODULUS 4
	ADD	A		;MULTIPLY..
	ADD	A		;..BY 32 BECAUSE
	ADD	A		;..EACH DIRECTORY
	ADD	A		;..ENTRY IS 32
	ADD	A		;..BYTES LONG
	LXI	H,BASE+81H	;POINT TO BUFFER
	ADD	L		;POINT TO ENTRY
	MOV	L,A		;SAVE (CAN'T CARRY TO H)
;PRINT ENTRY
	MVI	C,8
	LXI	D,CNAME
CPMDIR5	DS	0
	MOV	A,M		;MOVE NAME TO CNAME
	STAX	D
	INX	H
	INX	D
	DCR	C
	JNZ	CPMDIR5		;LOOP UNTIL DONE
	MVI	A,'.'
	STAX	D		;MOVE PERIOD
	INX	D
	MVI	C,3
CPMDIR6	DS	0
	MOV	A,M		;MOVE EXTENTION
	ANI	177Q		;REMOVE R/O AND SYS FLAGS /08.81.WWM/
	STAX	D
	INX	H
	INX	D
	DCR	C
	JNZ	CPMDIR6		;LOOP UNTIL DONE
;
CPMDIR8	DS	0
	CALL	PRTMSG
CNAME	DS	12
	DB	'     ',' '+EL
	LDA	NAMCNT		;GET NAME COUNT
	INR	A		;INCREMENT IT
	STA	NAMCNT
	CPI	4		;4 NAMES?
	JNZ	CPMDIR3		;NO, CONTINUE
	XRA	A		;ELSE, ZERO COUNTER
	STA	NAMCNT
	CALL	PRTMSG
	DB	CR,LF+EL
	JMP	CPMDIR3		;GO GET NEXT ENTRY
;
;
;			H 8    D I R E C T O R Y
;			========================
;
H8DIR	DS	0
	XRA	A
	STA	NAMCNT		;ZERO NAME COUNT
	LDA	VOLREC		;GET HDOS VOLUME NUMBER
	MOV	C,A
	MVI	B,0		;(BC)=VOL#
	MVI	A,3
	LXI	H,VOLNO
	CALL	UDD		;UNPACK VOL# INTO VOLNO
	CALL	PRTMSG
	DB	CR,LF
	DB	'Volume: '
VOLNO	DS	3
	DB	'  Label:',' '+EL
	LXI	H,VOLREC+17
PLAB	MOV	A,M
	ORA	A		;END OF LABEL?
	JZ	ELAB
	INX	H
PLAB1	PUSH	H
	PUSH	PSW
	MOV	E,A
	MVI	C,WRCON
	CALL	BDOS
	POP	PSW
	POP	H
	CPI	LF
	JNZ	PLAB
	MVI	A,CR
	JMP	PLAB1
ELAB	CALL	PRTMSG
	DB	CR,LF
	DB	CR,LF
	DB	'Name     Ext  Sec  K    '
	DB	'Date',CR,LF,CR,LF+EL
;
	LXI	H,DIRECT-DIRELEN
	PUSH	H		;PUT NEXT DIRECT. ENTRY ADDR IN STACK
H8DIR1	DS	0
	POP	H		;GET NEXT ENTRY ADDR
	LXI	D,DIRELEN
	DAD	D		;BUMP TO NEXT ENTRY
	PUSH	H		;PUT IT BACK INTO STACK
	MOV	A,M
	ORA	A		;ZERO BYTE?
	JNZ	H8DIR1A		;IF NOT, GO ON
	LXI 	D,6
	POP	H		;GET POINTER
	DAD	D		;SKIP 6 BYTES
	PUSH	H		;SAVE POINTER
	MOV	A,M		;GET NEXT ENTRY
H8DIR1A	CPI	DIR$CLR		;IF NOT AT END OF DIRECTORY TABLE
	JNZ	H8DIR2		;..GO TO H8DIR2
	CALL	PRTMSG
	DB	CR,LF+EL
	POP	H		;CLEAR STACK
	JMP	MENU		;RETURN TO MENU
H8DIR2	DS	0
	CPI	DIR$EMP		;IF ENTRY NOT NULL
	JNZ	H8DIR4		;..GO TO H8DIR4
H8DIR3	DS	0
	JMP	H8DIR1		;GO LOOK AT NEXT ENTRY
H8DIR4	DS	0
	LXI	D,HNAME
	MVI	C,8
H8DIR5	DS	0
	MOV	A,M		;MOVE NAME TO PRINT AREA
	ANA	A
	JNZ	$+5
	MVI	A,' '
	STAX	D
	INX	H
	INX	D
	DCR	C
	JNZ	H8DIR5		;LOOP UNTIL MOVE DONE
	LXI	D,HEXT
	MVI	C,3
H8DIR6	DS	0
	MOV	A,M		;MOVE EXTENTION NAME
	ANA	A
	JNZ	$+5
	MVI	A,' '
	STAX	D
	INX	H
	INX	D
	DCR	C
	JNZ	H8DIR6		;LOOP UNTIL MOVE COMPLETED
	POP	H		;GET DIRECTORY POINTER
	PUSH	H		;RESAVE IT
	CALL	H8FL		;CALCULATE LENGTH OF FILE
	POP	H
	PUSH	H
	LXI	D,DIR$CRD
	DAD	D
	LXI	D,HCDATE
	CALL	H8DATE		;MOVE CREATION DATE TO PRINT AREA
	CALL	PRTMSG		;PRINT DIRECTORY ENTRY
HNAME	DS	8
	DB	'.'
HEXT	DS	3
	DB	' '
HREC	DS	3
	DB	' '
HKBYTE	DS	3
	DB	'  '
HCDATE	DS	8
	DB	'     ',' '+EL
;
	LDA	NAMCNT		;INCREMENT NAME COUNT
	INR	A
	STA	NAMCNT
	CPI	2
	JNZ	H8DIR1		;NO CR
	XRA	A
	STA	NAMCNT
	CALL	PRTMSG
	DB	CR,LF+EL
	JMP	H8DIR1		;GO DO NEXT ENTRY
;
;
;H8DATE routine prints the date. The date is stored in the
;following format:
;    1st 7 bits :2 digit year (base year is 70)
;    Next 4 bits:Month
;    Next 5 bits:Day
;
H8DATE	DS	0
	MOV	C,M
	INX	H
	MOV	B,M		;BC = (HL)
	MOV	A,B
	ANI	0FEH
	RAR			;ISOLATE 1ST SEVEN BITS
	ADI	70		;ADDIN BASE YEAR - 70
	PUSH	PSW		;SAVE YEAR
	MOV	A,C
	ANI	1FH		;ISOLATE LAST 5 BITS
	PUSH	PSW		;SAVE DATE
	MOV	A,B
	RAR			;LOAD CARRY WITH LAST BIT OF B
	MOV	A,C		;GET C
	RAR			;INSERT CARRY BIT OF B
	ANI	0F0H		;TURN OFF LAST 4 BITS
	RAR! RAR! RAR! RAR	;ISOLATE 1ST 4 BITS
	MOV	C,A
	MVI	B,0
	XCHG			;HL = DEST ADDR
	MVI	A,2
	CALL	UDD		;MOVE MONTH TO PRINT AREA
	MVI	A,'-'
	MOV	M,A
	INX	H
	POP	PSW		;GET DAY
	MOV	C,A
	MVI	B,0		;BC = DAY IN BINARY
	MVI	A,2
	CALL	UDD		;MOVE DAY TO PRINT AREA
	MVI	A,'-'
	MOV	M,A
	INX	H
	POP	PSW		;GET YEAR
	MOV	C,A
	MVI	B,0
	MVI	A,2
	CALL	UDD		;MOVE YEAR TO PRINT AREA
	RET			;RETURN TO CALLER
;
;
;			H 8 F L
;			=======
;
;H8FL prints an HDOS file length
;
H8FL	DS	0
	CALL	H8FILEN		;GET H8 FILE LENGTH
	PUSH	H		;SAVE REC COUNT
	MOV	C,L
	MOV	B,H		;BC = REC COUNT
	LXI	H,HREC
	MVI	A,3
	CALL	UDD		;CONVERT IT TO ASCII
	LXI	H,HREC
	MVI	C,2
	CALL	ZEROSUP		;ZERO SUPPRESS 1ST TWO DIGITS OF HREC
	POP	H
	LXI	B,3
	DAD	B		;ADD 3
	MOV	A,L
	ANI	0FCH		;MASK
	MOV	L,A
	MVI	B,2		;SET COUNT
DIVLP	MOV	A,H
	RAR			;DIVIDE BY 2
	MOV	H,A
	MOV	A,L
	RAR
	MOV	L,A
	DCR	B		;DECREMENT COUNT
	JNZ	DIVLP		;DO IT AGAIN FOR DIVIDE BY 4
	MOV	C,L
	MOV	B,H
	LXI	H,HKBYTE
	MVI	A,3
	CALL	UDD		;MOVE K BYTES TO PRINT AREA
	LXI	H,HKBYTE
	MVI	C,2
	CALL	ZEROSUP		;ZERO SUPPRESS 1ST TWO DIGITS OF HKBYTE
	RET			;RETURN TO CALLER
H8FILEN	DS	0
	LXI	D,DIR$LSI
	DAD	D
	MOV	A,M		;GET LAST SECTOR INDEX
	PUSH	PSW		;SAVE IT
	DCX	H
	DCX	H
	MOV	A,M		;GET FGN
	MVI	C,-1 AND 0FFH		;C = -1 (GROUP COUNTER)
H8FILE1	DS	0
	INR	C		;INCREMENT GROUP COUNTER
	LXI	D,GRT
	MOV	L,A
	MVI	H,0
	DAD	D
	MOV	A,M
	ANA	A
	JNZ	H8FILE1
	MOV	L,C		;GET GROUP COUNT
	MVI	H,0
	DAD	H		;MULTIPLY BY 2
	LDA	SIZE		;GET DISK SIZE
	CPI	4		;4 SECTORS/CLUSTER?
	JNZ	NOT8		;NO
	DAD	H		;MULTIPLY BY 2 AGAIN
NOT8	POP	PSW		;GET LSI
	MOV	C,A
	MVI	B,0		;BC = LSI
	DAD	B		;ADD TO RECORD COUNT
	RET			;RETURN TO CALLER
;
;
;				Z E R O S U P
;				=============
;
ZEROSUP	DS	0
	MOV	A,M
	CPI	'0'
	RNZ
	MVI	M,' '
	INX	H
	DCR	C
	JNZ	ZEROSUP
	RET
;
;
;			B H 8 D I R
;			===========
;BH8DIR builds HDOS directory in RAM.
;
BH8DIR	DS	0
	MVI	A,4		;LOAD GROUP ADDR OF VOLREC
	LXI	H,H8BUF		;(HL) = BUF ADDR FOR READ
	CALL	READH8		;READ CLUSTER CONTAINING VOLREC
	LXI	D,256		;VOLREC IS IN 2ND REC OF CLUSTER
	DAD	D
	XCHG			;(DE) = ADDR OF 2ND SECTOR
	LXI	H,VOLREC	;(HL) = DEST OF MOVE
	LXI	B,256		;(BE) = COUNT
	CALL	BMOVE		;MOVE H8BUF+256 TO VOLREC FOR 256 BYTES

	LDA	VOLREC+7	;GET SECTORS/GROUP
	STA	SIZE
	CPI	2
	JZ	GOODSZ		;VALID SIZE
	CPI	4
	JZ	GOODSZ		;4 IS ALSO VALID
	CALL	PRTMSG
	DB	CR,LF,'Illegal HDOS disk size.',CR,LF+EL
	POP	H		;FIX STACK
	JMP	MOUNT		;TRY AGAIN
GOODSZ	MVI	C,31
	CALL	BDOS		;GET DISK PARAMETERS
	MOV	A,M		;GET SECTORS/TRACK
	INR	A
	STA	SPERT2		;SET UP PROGRAM
	DCR	A
	ORA	A
	RAR			;DIVIDE BY 2
	STA	SPERT1		;SET HDOS SECTORS/TRACK
	CMA
	INR	A		;GET NEGATIVE
	MOV	L,A
	MVI	H,0FFH		;HL = -SECTORS/TRACK
	SHLD	SPERT
	LHLD	VOLREC+5	;(HL) = SECTOR # OF GRT.SYS
	MOV	A,H
	RAR
	MOV	A,L
	RAR			;(A) = CLUSTER OF GRT.SYS
	LXI	H,H8BUF
	CALL	READH8
	XCHG			;(DE) = ADDR OF H8BUF
	LXI	H,GRT
	LXI	B,256
	CALL	BMOVE		;MOVE IT TO GRT
	LHLD	VOLREC+3	;(HL) = FIRST SECTOR # OF DIRECT.SYS
	MOV	A,H
	RAR
	MOV	A,L
	RAR			;(A) = FIRST CLUSTER OF DIRECT.SYS
	MOV	E,A
	MVI	D,0		;(DE) = # OF 1ST CLUSTER
	LXI	H,DIRECT
	CALL	READH8		;READ 1ST CLUSTER OF DIRECT.SYS
	LDA	SIZE
	CPI	4		;4 SECTORS/CLUSTER?
	JNZ	BH8DIRA		;NO
	MOV	A,E		;GET LAST GROUP NO.
	INR	A		;ADD 1
	JMP	BH8DIRB		;GO READ NEXT HALF GROUP
BH8DIRA	LXI	H,GRT
	DAD	D
	MOV	A,M		;(A) = 2ND CLUSTER # OF DIRECT.SYS
	MOV	E,A		;SAVE 2ND CLUSTER NUMBER
BH8DIRB	LXI	H,DIRECT+512
	CALL	READH8		;READ 2ND CLUSTER OF DIRECT.SYS
	LXI	H,GRT
	LDA	SIZE
	CPI	4		;4 SECTORS/CLUSTER?
	JNZ	BH8DIRC		;NO
	MOV	A,E
	RAR			;DIVIDE CLUSTER NO. BY 2
	MOV	E,A
BH8DIRC	DAD	D
	MOV	A,M		;GET NEXT CLUSTER NUMBER
	STA	NGA		;AND SAVE IT FOR NEXT READ
	LXI	D,6+DIRECT+42*DIRELEN
	LXI	H,KCDIR
	MVI	C,11
	CALL	COMPARE		;IF 42ND ENTRY = 'DIRECT.SYS'
	JZ	BH8DIR1		;..GO TO BH8DIR1
;
;This program assumes that the 42nd entry is DIRECT.SYS.
;This might not be correct all the time.  Since Heath
;has not released any info on this, this program is forced
;to abort if this assumption is not true.
;
	CALL	PRTMSG		;PRINT ERROR MSG
	DB	'xxx DID NOT FIND DIRECT.SYS IN 42ND ENTRY xxx',CR,LF
	DB	'    ABORTING.... xxx',CR,LF+EL
;
	JMP	XIT		;EXIT PROGRAM
;
BH8DIR1	LDA	6+DIRECT+43*DIRELEN
	CPI	DIR$CLR		;TEST 43RD ENTRY FOR DIR END
	RZ			;..RETURN IF AT DIR END
;HE'S GOT A LOT OF FILES..WELL, LETS GO GET REST OF DIR
	LDA	6+DIRECT+42*DIRELEN+DIR$LGN
	STA	LGA		;STORE LGA OF DIRECTORY
	LDA	6+DIRECT+42*DIRELEN+DIR$LSI
	STA	LGSI		;STORE LAST GROUP SECTOR INDEX
	XRA	A
	STA	H8BUFPT		;RESET H8BUFPT
	STA	R8COUNT		;RESET 8-INCH READ COUNT
	LXI	H,DIRECT+1024
BH8DIR3	CALL	LH8READ		;GET REST OF DIRECTORY
	RC
	LXI	D,256
	DAD	D
	JMP	BH8DIR3
;
;
;			H 8 R E A D
;			===========
;
;READH8 - reads a cluster (2 full HDOS sectors)
;	  from a HDOS A disk.
;
;	  ENTRY (A) = SECTOR INDEX IN GROUP CODE
;		(HL) = BUFFER ADDR FOR READ
;
READH8	DS	0
	ANA	A		;CLEAR CARRY
	RAL			;MULTIPLY SECTOR INDEX BY 2
READH8A	DS	0
	PUSH	B! PUSH D! PUSH H ;SAVE REGISTERS
	MOV	L,A
	RAL			;GET CARRY
	ANI	1		;..AND PUT IT
	MOV	H,A		;..INTO H......(HL) = SECTOR INDEX
READH82	LXI	B,-10		;HDOS SECTORS PER TRACK
SPERT	EQU	$-2
	MOV	A,B		;(A) = -1
READH8B	DS	0
	INR	A
	DAD	B
	JC	READH8B		;DIVIDE INDEX BY 10
	STA	H8TRK		;SAVE TRACK
	MOV	A,L
	ADI	10		;GET SECTOR
SPERT1	EQU	$-1
	ANA	A
	RLC			;ADJUST FOR CP/M
	INR	A
	STA	H8SEC		;SAVE IT
	POP	B		;GET BUFFER ADDR
	PUSH	B		;SAVE IT BACK
	CALL	VSETDMA		;SET BUFFER ADDR FOR READ
	LDA	H8TRK
	MOV	C,A
	CALL	VSETTRK		;SET TRK ADDR
	LDA	H8SEC
	MOV	C,A
	CALL	VSETSEC		;SET SECTOR ADDR
	CALL	VREAD		;READ HDOS DISK
	ANA	A
	JNZ	ABORTR		;ABORT ON ERROR
	POP	B		;GET BUFFER ADDR
	PUSH	B		;RESAVE IT
	LXI	H,128
	DAD	B
	MOV	B,H
	MOV	C,L
	CALL	VSETDMA		;SET DMA ADDR
	CALL	INRSEC		;INCREMENT SECTOR
	CALL	VREAD
	ANA	A 
	JNZ	ABORTR
	POP	B
	PUSH	B
	LXI	H,128*2
	DAD	B
	MOV	B,H
	MOV	C,L
	CALL	VSETDMA
	CALL	INRSEC		;INCREMENT SECTOR
	CALL	VREAD
	ANA	A
	JNZ	ABORTR
	POP	B
	PUSH	B
	LXI	H,128*3
	DAD	B
	MOV	B,H
	MOV	C,L
	CALL	VSETDMA
	CALL	INRSEC		;INCREMENT SECTOR
	CALL	VREAD
	POP	H! POP D! POP B! ; RESTORE REGISTERS
	ANA	A
	RZ			;RETURN ON GOOD READ
ABORTR	DS	0
	CALL	PRTMSG
	DB	'xxx ABORTING DUE TO BAD HDOS READ xxx',CR,LF+EL
	JMP	XIT
INRSEC	LDA	H8SEC
	INR	A		;INCREMENT SECTOR
	CPI	27		;PAST 26?
SPERT2	EQU	$-1
	JZ	INRTRK		;IF SO, INCREMENT TRACK
	STA	H8SEC		;UPDATE SECTOR
	JMP	READSC		;READ IT
INRTRK	MVI	A,1
	STA	H8SEC		;RESET SECTOR TO 1
	LDA	H8TRK		;GET H8 TRACK
	INR	A
	STA	H8TRK		;ADD 1 TO IT
	MOV	C,A
	CALL	VSETTRK		;SET IT
READSC	LDA	H8SEC
	MOV	C,A
	CALL	VSETSEC		;SET SECTOR
	RET
;
;READH81 -- SAME AS READH8, EXCEPT
;
;	DE = SECTOR INDEX
;	HL = BUFFER
;
READH81	PUSH	B! PUSH D! PUSH H ;SAVE REGISTERS
	XCHG			;HL = SECTOR INDEX
	DAD	H		;MULTIPLY SECTOR INDEX BY 2
	JMP	READH82
;
;
;			L H 8 R E A D
;			=============
;
;LH8READ does a logical read using the DIRECTORY and GRT
;        to determine which record to read.
;
LH8READ	DS	0
	LDA	SIZE		;GET DISK SIZE
	CPI	4		;4 SECTORS/CLUSTER?
	JZ	R8INCH		;IF SO, USE 8-INCH READ
LH8RDA	PUSH	B! PUSH D!	;SAVE REGISTERS
	LDA	H8BUFPT		;GET BUFFER SWITCH
	ANA	A		;IF TRUE
	JZ	LH8R010		;.. GO READ NEXT CLUSTER
	XRA	A
	STA	H8BUFPT		;SET BUFFER SWITCH TO FALSE
	LDA	LGA		;GET LAST GROUP ADDR
	MOV	B,A		;MOVE IT TO B
	LDA	NGA		;GET NEXT GROUP ADDR
	CMP	B		;IF NEXT BLOCK NOT = LAST
	JNZ	LH8R004		;.. GO MOVE 2ND HALF OF BUFFER
	LDA	LGSI		;GET LAST SECTOR INDICATOR
	CPI	2		;IF 2 IN LAST CLUSTER
	JNC	LH8R004		;.. GO MOVE 2ND HALF
LH8R002	DS	0		;EOF ROUTINE
	POP	D! POP B	;RESTORE REGISTERS
	STC			;SET CARRY
	RET			;RETURN TO CALLER
LH8R004	DS	0		;GETS NEXT FORWARD LINK..
;				;..AND SETS UP TO MOVE 2ND HALF OF BUFFER
	PUSH	H		;SAVE REC ADDR
	LXI	H,GRT		;GET ADDR OF GROUP RESERVATION TABLE
	LDA	NGA
	MVI	D,0
	MOV	E,A
	DAD	D
	MOV	A,M
	STA	NGA		;NGA:=GRT[NGA]  STORES NEXT LINK
	LXI	H,H8BUF+256	;POINT TO 2ND HALF OF BUFFER
	JMP	LH8R020		;GO MOVE BUFFER TO REC
LH8R010	DS	0
	MVI	A,0FFH		;SET BUFFER SWITCH TO TRUE
	STA	H8BUFPT
	LDA	NGA
	ANA	A		;IF NGA = 0
	JZ	LH8R002		;.. GO TO EOF ROUTINE
	PUSH	H		;SAVE REC ADDR
	LXI	H,H8BUF		;POINT TO BUFFER
	CALL	READH8		;READ CLUSTER INTO BUFFER
LH8R020	DS	0		;MOVES EITHER 1ST OR 2ND HALF
;				;..OF BUFFER INTO THE RECORD
	XCHG			;DE = ADDR OF BUFFER
	POP	H		;HL = ADDR OF RECORD
	PUSH	H		;RESAVE IT
	LXI	B,256		;LENGTH OF MOVE
	CALL	BMOVE		;MOVE HALF OF BUFFER TO RECORD
	POP	H! POP D! POP B ; RESTORE REGISTERS
	ANA	A		;CLEAR CARRY
	RET			;RETURN TO CALLER
;
;R8INCH -- READ 8-INCH HDOS DISK (SINGLE D) (PWS)
;
R8INCH	DS	0
	PUSH	B! PUSH D!	;SAVE BC, DE
	LDA	R8COUNT
	ORA	A		;TIME TO READ AGAIN?
	JZ	R8INCH4		;YES
	DCR	A		;DECREMENT SWITCH
	STA	R8COUNT		;STORE IT
	CPI	2		;SECOND HALF OF FIRST READ?
	JZ	R8INCH3		;YES
	CPI	1		;SECOND READ?
	JZ	R8INCH2
;				;SECOND HALF OF SECOND READ
	LDA	LGA		;GET LAST GROUP ADDR
	MOV	B,A		;SAVE IN B
	LDA	NGA		;NEXT GROUP ADDR
	CMP	B		;END OF GROUP?
	JNZ	R8INCH1		;NO
	LDA	LGSI		;LAST GROUP INDEX
	CPI	4		;4 SECTORS IN IT?
	JNC	R8INCH1		;IF SO, GET LAST ONE
R8EXIT	POP	D! POP B	;RESTORE REGISTERS
	STC			;MARK EOF
	RET
R8INCH1	PUSH	H		;SAVE RECORD ADDR
	LXI	H,GRT		;POINT TO GRT
	LDA	NGA		;GET NEXT GROUP ADDR
	MVI	D,0
	MOV	E,A		;DE = NGA
	DAD	D
	MOV	A,M		;A = NEXT GA
	STA	NGA		;NGA UPDATED
	LXI	H,H8BUF+256	;2ND HALF OF BUFFER
	JMP	R8INCH5		;MOVE TO REC BUFFER
R8INCH2	LDA	NGA		;GET NGA
	MOV	B,A		;SAVE IN B
	LDA	LGA		;GET LAST GROUP
	CMP	B		;LAST GROUP?
	JNZ	R8INCHB		;IF NOT, GO ON
	LDA	LGSI		;GET LAST GROUP
	CPI	3		;AT LEAST 3 SECTORS LEFT?
	JNC	R8INCHB		;IF SO, READ THEM
	JMP	R8EXIT		;ELSE, EXIT
R8INCHB	PUSH	H
	LDA	NGA		;GET NEXT GROUP
	MOV	L,A
	MVI	H,0		;HL = NGA
	DAD	H		;MULTIPLY BY 2
	INX	H		;ADD 1
	XCHG			;DE = NGA * 2 + 1
	JMP	R8INCHR		;READ THE SECTORS
R8INCH3	LDA	LGA		;GET LAST GROUP
	MOV	B,A
	LDA	NGA		;AND NEXT GROUP
	CMP	B		;AT LAST GROUP
	PUSH	H		;SAVE HL
	LXI	H,H8BUF+256	;SECOND HALF OF BUFFER
	JNZ	R8INCH5		;MOVE TO REC BUFFER
	LDA	LGSI		;GET LAST GROUP
	CPI	2		;2 SECTORS LEFT?
	JNC	R8INCH5		;MOVE THE BUFFER
	POP	H		;RESTORE HL
	JMP	R8EXIT		;ELSE, LEAVE
R8INCH4	MVI	A,3
	STA	R8COUNT		;SET UP COUNTER
	LDA	NGA		;GET NGA
	ORA	A		;IS IT ZERO?
	JZ	R8EXIT		;IF SO, LEAVE
	PUSH	H		;SAVE HL
	MOV	L,A
	MVI	H,0		;HL = NGA
	DAD	H		;MULTIPLY BY 2
	XCHG			;DE = NGA
R8INCHR	LXI	H,H8BUF		;POINT TO BUFFER
	CALL	READH81		;READ IN 2 HDOS SECTORS
R8INCH5	XCHG			;DE = ADDR OF BUFFER
	POP	H		;GET RECORD ADDR
	PUSH	H
	LXI	B,256		;MOVE 256 BYTES
	CALL	BMOVE
	POP	H! POP D! POP B ;RESTORE REGISTERS
	ORA	A		;CLEAR CARRY
	RET
;
;			F N S E A R
;			===========
;
;FNSEAR is used to search the HDOS Directory.
;
FNSEAR	DS	0
	LHLD	DIRPTR
	PUSH	H
FNSEAR1	DS	0
	POP	H
	LXI	D,DIRELEN
	DAD	D
	PUSH	H
	MOV	A,M
	ORA	A		;ZERO BYTE?
	JNZ	FNSER1A		;IF NOT, GO ON
	LXI	D,6
	POP	H
	DAD	D		;ADD 6
	PUSH	H
	MOV	A,M
FNSER1A	CPI	0FFH		;EMPTY ENTRY?
	JZ	FNSEAR1		;YES, GET ANOTHER
	CPI	DIR$CLR
	JNZ	FNSEAR2
	POP	H
	STC
	RET
FNSEAR2	DS	0
	LXI	D,SNAME
	MVI	C,11
	CALL	COMPARE
	JNZ	FNSEAR1
	POP	H
	SHLD	DIRPTR
	ANA	A
	RET
;
;
;			O P E N H 8
;			===========
;
OPENH8	DS	0
	PUSH	H
	LXI	D,DIR$LGN
	DAD	D
	MOV	A,M
	STA	LGA
	POP	H
	PUSH	H
	LXI	D,DIR$FGN
	DAD	D
	MOV	A,M
	STA	NGA
	POP	H
	LXI	D,DIR$LSI
	DAD	D
	MOV	A,M
	STA	LGSI
;
	XRA	A
	STA	H8BUFPT
	STA	R8COUNT
	RET
;
;
;			O P E N    C P M   F I L E
;
OPENCPM	DS	0
	PUSH	H
	LXI	H,FCB
	MVI	B,33
	CALL	ZERO
	POP	D		;DE = FILE NAME
	LXI	H,FCB+1
	MVI	C,11
OCPM005	DS	0
	LDAX	D
	ANA	A
	JNZ	$+5
	MVI	A,' '
	MOV	M,A
	INX	H
	INX	D
	DCR	C
	JNZ	OCPM005
	MVI	C,SELDK
	LDA	CDRIVE
	MOV	E,A		;E = CP/M DRIVE
	CALL	BDOS
	LXI	D,FCB		;POINT TO CTL BLOCK
	MVI	C,17		;SEE IF FILE
	CALL	BDOS		;..EXISTS
	INR	A		;FOUND?
	JZ	OCPM050		;NO--GO MAKE FILE
	CALL	PRTMSG		;PRINT WARNING
	DB	'xxx FILE EXISTS, TYPE Y TO ERASE:',' '+EL
	MVI	C,RDCON
	CALL	BDOS		;GET ANSWER
	PUSH	PSW		;SAVE IT
	CALL	PRTMSG		;PRINT CR LF
	DB	CR,LF+EL
	POP	PSW		;RETRIEVE ANSWER
	ANI	05FH		;CONVERT IT TO UPPER CASE
	CPI	'Y'		;IF YES
	JZ	OCPM020		;.. GO ERASE FILE
	POP	H		;THROW AWAY RETURN ADDR OF OPENCPM
	JMP	MENU		;GO TO MENU
OCPM020	DS	0		;ERASE FILE ROUTINE
	LXI	D,FCB		;POINT TO FCB
	MVI	C,ERASE		;LOAD FUNCTION CODE
	CALL	BDOS		;DO THE ERASE
OCPM050	DS	0		;MAKE FILE ROUTINE
	MVI	C,MAKE
	LXI	D,FCB
	CALL	BDOS
	INR	A
	RNZ
	CALL	PRTMSG
	DB	'xxx ERROR ON CP/M FILE OPEN xxx',CR,LF+EL
	JMP	MENU
;
;
;
;			P R T M S G
;			===========
;
;PRTMSG - This routine prints a message and then returns to the
;	  instruction after the last character in the message.
;	  The last character will have the parity bit on to 
;	  signify end of message.
;
PRTMSG	DS	0
	XTHL			;SAVE HL, HL=ADDR OF MSG
PRTMSG1	DS	0
	MOV	A,M		;GET MSG CHAR
	CALL	CONOUT		;PRINT IT
	MOV	A,M		;REFETCH IT
	INX	H		;BUMP MSG POINTER
	RLC			;IF PARITY BIT NOT ON
	JNC	PRTMSG1		;..GO DO NEXT CHAR
	XTHL			;RESTORE HL AND RETURN ADDR
	RET			;RETURN TO CALLER
;
;
CONOUT	DS	0
	PUSH	H! PUSH D! PUSH B! ; SAVE REGISTERS
	MVI	C,WRCON
	ANI	07FH
	MOV	E,A
	CALL	BDOS
	POP	B! POP D! POP H	;RESTORE REGISTERS
	RET			;RETURN TO CALLER
;
;
;		CONVERT LOWER TO UPPER CASE
;		===========================
;
LOWUP	CPI	141Q		;'a'
	RC
	CPI	173Q		;'z'+1
	RNC
	ANI	137Q
	RET
;
;
;		COPIES OF HDOS ROM ROUTINES
;		===========================
;
;	COMPARE - $COMP MODIFIED TO ALLOW ? WILDCARD
;
COMPARE	LDAX	D
	CPI	'?'		;WILD CARD?
	JZ	COMP1		;IF SO, AUTOMATIC MATCH
	CMP	M
	RNZ
COMP1	INX	D
	INX	H
	DCR	C
	JNZ	COMPARE
	RET
;
;
ZERO	XRA	A		;$ZERO IN H17 ROM
ZRO1	MOV	M,A
	INX	H
	DCR	B
	JNZ	ZRO1
	RET
;
;
BMOVE	MOV	A,B		;$MOVE IN H17 ROM
	ORA	C
	RZ
	MOV	A,L
	SUB	E
	MOV	A,H
	SBB	D
	JC	MOV2
	DCX	B
	DAD	B
	PUSH	H
	XCHG
	DAD	B
	PUSH	H
MOV1	MOV	A,M
	STAX	D
	DCX	D
	DCX	H
	DCX	B
	MOV	A,B
	ANA	A
	JP	MOV1
	POP	D
	POP	H
	INX	D
	INX	H
	RET
;
MOV2	LDAX	D
	MOV	M,A
	INX	H
	INX	D
	DCX	B
	MOV	A,B
	ORA	C
	JNZ	MOV2
	RET
;
;
UDD	CALL	DADA		;$UDD IN H17 ROM
	PUSH	H
UDD1	PUSH	PSW
	PUSH	H
	LXI	D,10
	CALL	DU66
	PUSH	H
	POP	B
	POP	H
	MVI	A,'0'
	ADD	E
	DCX	H
	MOV	M,A
	POP	PSW
	DCR	A
	JNZ	UDD1
	POP	H
	RET
;
;
DADA	PUSH	D		;$DADA IN H17 ROM
	MOV	E,A
	MVI	D,0
	DAD	D
	POP	D
	RET
;
;
DU66	MOV	A,D		;$DU66 IN H17 ROM
	CMA
	MOV	D,A
	MOV	A,E
	CMA
	MOV	E,A
	INX	D
	MOV	A,D
	ORA	E
	JZ	DU665
	XRA	A
DU661	MOV	H,D
	MOV	L,E
	DAD	B
	JNC	DU662
	INR	A
	MOV	H,D
	MOV	L,E
	DAD	H
	XCHG
	JC	DU661
	XCHG
	DCR	A
DU662	MOV	H,B
	MOV	L,C
	LXI	B,0
DU663	PUSH	PSW
	DAD	D
	JC	DU664
	MOV	A,L
	SUB	E
	MOV	L,A
	MOV	A,H
	SBB	D
	MOV	H,A
DU664	MOV	A,C
	RAL
	MOV	C,A
	MOV	A,B
	RAL
	MOV	B,A
	STC
	MOV	A,D
	RAR
	MOV	D,A
	MOV	A,E
	RAR
	MOV	E,A
	POP	PSW
	DCR	A
	JP	DU663
DU665	XCHG
	MOV	H,B
	MOV	L,C
	RET
;
;
;
;			B I O S    J U M P    V E C T O R 
;			=================================
;
VSETTRK	JMP	$-$		;THE ADDRESSES FOR THESE JMPS ARE
VSETSEC	JMP	$-$		;INITIALIZED AT THE BEGINNING OF
VSETDMA	JMP	$-$		;THE PROGRAM.  THESE ARE DIRECT
VREAD	JMP	$-$		;JUMPS TO CBIOS ROUTINES.
;
;
;
	DS	60H		;STACK AREA
STACK	DS 	2
DSIZE	DW	0		;DISK SIZE
KLEFT	DS	2		;K BYTES OF CP/M SPACE USED
NAMCNT	DS	1		;NAME COUNT
WCFLG	DS	1		;WILD CARD FLAG
DIRPTR	DS	2		;DIRECTORY POINTER
H8TRK	DS	1		;TRACK OF HDOS DISK
H8SEC	DS	1		;SECTOR OF HDOS DISK (ADJUSTED)
SH8FL	DS	1		;SAVED HDOS FILE LENGTH
H8NDX	DS	1		;INDEX TO H8REC BUFFER
CPMNDX	DS	1		;CPM BUFFER INDEX
KCDIR	DB	'DIRECT',0,0,'SYS'
NGA	DS	1		;NEXT GROUP ADDR
LGA	DS	1		;LAST GROUP ADDR
LGSI	DS	1		;LAST GROUP SECTOR INDICATOR
H8BUFPT	DS	1		;BUFFER POINTER
R8COUNT	DS	1		;8-INCH DISK READ COUNT
SNAME	DS	8
SEXT	DS	3
;
;
;			E Q U A T E S
;			=============
;
CR	EQU	0DH		;CARRIAGE RETURN
LF	EQU	0AH		;LINE FEED
EL	EQU	80H		;END LINE
;
;
;BUFFERS
;
RBUF	EQU	BASE+80H
H8REC	EQU	$
H8BUF	EQU	H8REC+256
VOLREC	EQU	H8BUF+512
GRT	EQU	VOLREC+256
DIRECT	EQU	GRT+256
;
;
;WARD'S BDOS/CBIOS EQUATES (VERSION 6)
;
RDCON	EQU	1
WRCON	EQU	2
PRINT	EQU	9
RESETDK	EQU	13
SELDK	EQU	14
OPEN	EQU	15
CLOSE	EQU	16
SFF	EQU	17
ERASE	EQU	19
READ	EQU	20
WRITE	EQU	21
MAKE	EQU	22
STDMA	EQU	26
GALLOC	EQU	27
GDPB	EQU	31
BDOS	EQU	BASE+5
FCB	EQU	BASE+5CH
FCBEXT	EQU	FCB+12
FCBSNO	EQU	FCB+32
	END	START
;
MA	EQU	26
GALLOC	EQU	27
GDPB	EQ