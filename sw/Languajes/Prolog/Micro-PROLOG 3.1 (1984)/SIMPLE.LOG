query-mod
( "FIND:" "?VARTRANS?"
APPEND CONS ON 
Parse-of-S Parse-of-ConjC Parse-of-SS Parse-of-Cond Parse-of-CC
# @ + - ~ * % defined true-of reserved save load not forall isall =
all is one which)
(Expression-Parse end dict func function
"?DECL?" postfix infix & and if then vars  either or : )
((COPYRIGHT 1984 LPA LTD V3-8))
((defined x)(CON x)(DEF (x|y)))
((Parse-of-S X1 Z)
  (IF ( VAR Z) (("?VARTRANS?" Y X1)(P-S Y Z))
               ((P-S Y Z)("?VARTRANS?" Y X1))))
((P-S (X|Y) Z)
  (IF (VAR Z) ()  ((find (if) Z y x) ))
  (Parse-of-SS X Z x)
  (is-body (if) Y x () z))
(("?VARTRANS?" x (X1 (/* vars |Z1)|Y1))
  (OR ((VAR X1)/(APPEND X ((vars |Z)) x)(listvars Z Z1)
        ( sub  X Z1 (X1 |Y1)))
      ((shrink Z1 Z)(APPEND (X1|Y1) ((vars Z)) x))
  )/)
(("?VARTRANS?" x x))
((listvars ()())/)
((listvars (x) z)
  (LST x)/
  (listvars x z))
((listvars (X|Y) ((x |X)|Y1))
  (listvars Y Y1))
((sub X Z X1)(CON X)(ON (X1 |X ) Z)/)
((sub  X Z X)(VAR X)/)
((sub X Z X)(NOT LST X)/)
((sub () Z ())/)
((sub (x|y) X (x1|y1))
  (sub x X x1)(sub y X y1))
((shrink ()())/)
((shrink ((X |x)|Y) (X|Y1))
  (EQ X x)(shrink Y Y1))
((is-body X () (x|y) (x) (x|y)) 
   /)
((is-body X () () x ()) 
   /)
((is-body (x) () (x) z ())/)
((is-body X (Y|Z) (x|y) x1 y1)
  (ON x X) /
  (IF (VAR Z) ((find (and &|x1) y x2 z)) ())
  (Parse-of-Cond Y y z)
  (is-body (and &) Z z x1 y1))
((Parse-of-ConjC X Y) 
  (is-body (?) X (?|Y) () ())) 
((Parse-of-Cond X Z x)
  (Parse-of-CC X Z x)
  /)
((Parse-of-Cond X Z x)
  (Parse-of-SS X Z x))
((Parse-of-CC (NOT ? X) (x1 (x2|Y)|Z) Z)
  ("?CEQ?" X x1 not)
  (OR ((VAR x2)/) ((NOT ON x2 (either forall))))
  (is-body (?) X (? x2|Y) () z)/)
((Parse-of-CC (NOT|X) (x1 Y|Z1) Z)
  ("?CEQ?" X x1 not)
  (Parse-of-Cond X (Y|Z1) Z)/)
((Parse-of-CC (! x1|X) (x1 Y Z1|Z) Z)
  ("?CEQ?" X Y !)/(EQ X Z1))
((Parse-of-CC (OR X Y) ((x1| x)  |Z) Z)
  ("?CEQ?" X x1 either)
  (is-body (either) X (x1|x) (or) y) 
  (is-body (or) Y y () z)/)
((Parse-of-CC (FORALL X Y) ((x1|x)|Z) Z)
  ("?CEQ?" X x1 forall)
  (is-body (forall) X (x1|x) (then) y)
  (is-body (then) Y y () z)/) 
((Parse-of-CC (ISALL X Y | Z) (X x1 X1|y) y)
  ("?CEQ?" Z x1 isall)
  ("FIND:" X1 Y x isall) 
  (is-body (:) Z x () z)/)
((Parse-of-CC (# (EQ X1 Z1)Z2) (X x1 Z|y) y)
  ("?CEQ?" Z2 x1 =)("?EQNTEST?" Z2)
  (Expression-Parse (X Z) (X1 Z1) Z2) /)
((Parse-of-CC (# (X|Y1)Y2) (X x1 Y|y) y)
  (CON X)("?CEQ?" Y2 x1 #)("?EQNTEST?" Y2)
  (Expression-Parse Y Y1 Y2)/)
((Parse-of-CC (# (X|Y1)Y2) (X1 x1 Z|y) y)
  ("?CEQ?" Y2 x1 #)(Parse-of-SS (X|Y1) X1 ())
  (Parse-of-ConjC Y2 Z))
(("?EQNTEST?" X)(VAR X)/)
(("?EQNTEST?" X)(defined Expression-Parse))
((find X () () ())
  /)
((find X (Y|Z) () (Y1|Z))
  (Mem1 Y X)(EQ Y Y1)
  /)
((find X (Y|Z) (Y|Z1) x)
  (find X Z Z1 x))
(("?CEQ?" y x z)
  (OR ((VAR y)/(NOT VAR x)(EQ x z)) ((EQ x z)) ))
(("FIND:" (Y x1 |Z) Y (:|Z) isall)
  (OR ((VAR Z)) ((NOT VAR x1)))
  (EQ x1 :)/)
(("FIND:" Z1 Y Z X)
  (find (:) Z1 Y Z)
  (OR ((EQ Z  (:|Y1))/) ((P "Syntax error: ")(PP missing colon in)
		         (PP Z1)ABORT)))
((Parse-of-SS (X|Y) (X  Y|y) y) 
  (VAR Y)(CON X)/)
((Parse-of-SS (X Y Z) (Y X Z|y) y)
  (inf y X)/)
((inf y X)(testit infix y X))
((post y X)(ON X (dict vars infix postfix))/)
((post y X)(testit postfix y X))
((testit Z y X)(CON X)
  (OR ((VAR y)/(CL((Z X)))) 
      (("?DECL?" X Z))
  )) 
((Parse-of-SS (X Y) (Y X|y) y)
  (post y X)/)
((Parse-of-SS (x1) (x1|y) y)(CON x1)/) 
((Parse-of-SS (X |Z) (X Z|y) y) 
  (CON X)(LST Z)   
  /)
((Parse-of-SS X Y Y)
  (VAR X)/(P "Syntax error: ")(PP redundant & or and)ABORT)
((Parse-of-SS X Z x)
  (IF (VAR X) ((find y Z x1 x) (P "Syntax error: ")(PP| x1)
               (PP not a valid sentence form)
                ABORT)
              (FAIL)) 
  ) 
((all X) (which X))
((which X1)
  ("FIND:" X1 X Y which) 
  (is-body (:)  Z Y () z) 
  (Whichex X Z) )
((one X1)
  ("FIND:" X1 X Y one)(EQ Y (:|z))
  (Parse-of-ConjC   Z z)
  (Oneex X Z))
((Whichex X Y)
  (? Y)
  (PP| X)
  FAIL)
((Whichex X Y)
  (PP No (more) answers))
((Oneex X Y)
  (? Y)
  (PP | X)(P "more?(y/n)")
  (R Z)
  (IF (EQ Z "y") (FAIL) ()))
((Oneex|X)
  (PP No (more) answers))
((is X)
  (Parse-of-ConjC  Y X)
  (IF (? Y) ((PP YES)) ((PP NO))))
((Mem1 X Y)
  (NOT VAR X)
  (ON X Y)/)
((APPEND () X X))
((APPEND (X|Y) Z (X|x))
  (APPEND Y Z x))
((CONS X Y (X|Y)))
((ON x (x|y)))
((ON x (y|z))
  (ON x z))
((save X)(SAVE X))
((load x)(LOAD x))
((reserved (dict func data-rel infix postfix|Y))(DICT x1 y Y|Z))
((@ x| y) (x|y))
((true-of x y)(x|y))
((# X)
  (Expression-Parse X X1 X2)
  (? X2)/
  (PP X1))
((# X Y)
 (? Y)/
 X)
((%  Y Z X)
  (TIMES X Z Y))
(("-" Y Z X)
  (SUM Z X Y))
((+ Y Z X)
  (SUM Y Z X))
((* Y Z X)
  (TIMES Y Z X))
CLMOD
errmess-mod ("?ERROR?") (data-rel)
(("?ERROR?" 4 (ADDCL ((X|Y)|Z)|x))/
  (PP Cannot add sentences for X)
  ABORT)
(("?ERROR?" 4 (Z X|x))/
  (IF (CON X) ((EQ X Y)) ((EQ X ((Y|y)|z))))
  (PP Cannot delete sentences for Y)ABORT)
(("?ERROR?" 2 (X|Y))
  (CL ((data-rel X)))/FAIL)
(("?ERROR?" X (Y|Y1))
  (E-code X Z)
  (P Evaluation error X: Z )(PP)(PP trying : Y Y1)
  ABORT)
((E-code 0 "Arithmetic overflow"))
((E-code 1 "Arithmetic underflow"))
((E-code 2 "No definition for relation"))
((E-code 3 "Invalid form of use"))
((E-code 5 "File error"))
((E-code 6 "Too many files opened at once"))
((E-code 7 "Close all files first"))
((E-code 8 "Bad data in file"))
((E-code 9 "Write error"))
((E-code 10 "Disk or directory is full"))
((E-code 11 "Break !"))
((E-code 12 "Illegal use of modules"))
((E-code X " "))
CLMOD
program-mod (add delete list kill edit cedit accept function
"?REV-P?" "?DECL?")
(Parse-of-S Parse-of-SS Parse-of-Cond CON ON APPEND which :
Expression-Parse infix postfix "?VARTRANS?" dict func end yes all =)
((function x)
  (CON x)
  ("?DECL?" x func))
((add X)
  (NUM X)
  /(LESS 0 X)
  (R Y)
  (add X Y))
((add X)
  /
  (add 32767 X))
((add X Y)
  (Parse-of-S Z Y)
  (SUM X1 1 X)
  (ADDCL Z X1)
  ("?DECLARE?" Z))
(("?REV-P?"  X1 Z)
  ("?VARTRANS?" (X|Y) X1)
  (Parse-of-SS X Z x)
  (Rev-body Y x "if~M~J    "))
((Rev-body () () X))
((Rev-body (X|Y)  (Z|x) Z)
  (Parse-of-Cond X x y)
  (Rev-body Y y "and~M~J    "))
(("?DECLARE?" ((X|Y)|Z))
  ("?DECL?" X dict))
(("?DECL?" X Y)
  (OR ((CL ((Y X)))/) ((ADDCL ((Y X))))))
((edit X)(R Y)(edit X Y))
((cedit X)(R Y)(cedit X Y))
((edit X Y)(gedit X Y DELCL))
((cedit X Y)(gedit X Y /*))
((gedit X Y x1)
  (CON X)(CL ((dict X)))
  (CL ((X|Z)|x) Y Y)
  (Parse-of-S ((X|Z)|x) z) (RFILL (Y z) X3)(INT X3) (R X1)
  (Parse-of-S y1 X1)(EQ y1 ((X4|Y4)|Z4))
  (SUM 1 X6 X3)(NOT SYS (X4|Y4))(x1 X Y)(ADDCL y1 X6)
  (IF (EQ X4 X) () ((PP relation changed to X4)("?DECLARE?" y1)))
  )
((Acceptin X)
  (P X)
  (R Y)
  (OR ((LST Y) (ADDCL ((X |Y))) (Acceptin X)) 
      ((OR ((EQ Y end)) ((P " " Y not a list)(PP)(Acceptin X)))) 
  ))
((accept X)
  ("?DECL?" X dict)
  (Acceptin X))
((delete (X|Y))
  /
  (Parse-of-S Z (X|Y))
  (OR ((DELCL Z)) ((PP No sentence (X|Y)))))
((delete X)
  (CON X)
  (R Y)
  (delete X Y))
((delete X Y)
  (IF (DELCL X Y) () ((PP No  sentence Y for X))))
((kill all)/
  (P Entire program "?(yes/no)")
  (R y)(EQ y yes)(KILL ALL)  
  (PP Entire program deleted))
((kill X)(CON X)
  (CL ((X|Y)|Z))/
  (KILL X)(remove dict X)(remove func X)(remove infix X)(remove postfix X)    
  (PP Definition for X deleted))
((remove Y X)(OR ((DELCL ((Y X)))) ()))
((kill X)(OPMOD X)/ CLMOD
  (KILL X)
  (PP Module X deleted))
((kill X)(P "No sentences for ")(PP X))
(("?LIST-PRED?" X)(NOT DEF X)/(P "No sentences for ")(PP X)) 
(("?LIST-PRED?" X )
  (CL ((X|Y)|Z))
  ("?REV-P?" ((X|Y)|Z)  y)
  (P  | y)(PP)
  FAIL)
(("?LIST-PRED?" X))
((list all)/
  (FORALL ((CL ((dict X)))) (("?LIST-PRED?" X))))
((list X)
  (OR ((CL ((dict X)))) ((ON X (infix postfix dict func)))) 
  /("?LIST-PRED?" X))
((list X)(P X "definition has not been entered in sentence form")(PP))
CLMOD
 postfix dict func)))) 
  /("?LIST-PRED?" X))
((list X)(P X "definition has not been 