micro-mod
(which all is one add kill edit cedit space delete list true-of
accept function # save load dir defined 
ON APPEND CONS reserved @ % = ~ - + *)
(yes c func end help vars Expression-Parse )
((COPYRIGHT 1984 LPA LTD V3-15))
((dir x)(DIR x X)(PP X))
((save x)(SAVE x))
((load x)(LOAD x)(SPACE X)(PP X K free))
((defined x)(CON x)(DEF (x|y)))
((which (X|Y))(exp-parse Y Y1)
  (? Y1)
  (PP X)
  FAIL)
((which X)(PP No (more) answers))
((all X)(which X))
((one (X|Y))(exp-parse Y Y1)
  (? Y1)
  (PP X)(P "more?(y/n)")
  (R Z)
  (NOT EQ Z "y" ))
((one X)(PP No (more) answers))
((is X)(exp-parse X X1)(IF (? X1)((PP YES))((PP NO))))
((add X Z)
  (SUM 1 X1 X)(CL-parse Z Z1)
  (ADDCL Z1 X1))
((add X)
  (INT X)
  /(LESS 0 X)
  (R Z)(add X Z))
((add Z)(add 32767 Z))
((CL-parse Y X)
  (OR ((VAR Y)/(exp-parse Z X)(vartrans Y Z))
      ((vartrans Y Z)(exp-parse Z X))))
((listvars ()())/)
((listvars (X|Y) ((x |X)|Y1))
  (listvars Y Y1))
((sub X Z X1)(CON X)(ON (X1 |X ) Z)/)
((sub  X Z X)(VAR X)/)
((sub X Z X)(NOT LST X)/)
((sub () Z ())/)
((sub (x|y) X (x1|y1))
  (sub x X x1)(sub y X y1))
((shrink ()())/)
((shrink ((X |x)|Y) (X|Y1))
  (EQ X x)(shrink Y Y1))
((vartrans x (X1 (/* vars |Z1)|Y1))
  (OR ((VAR x)/(shrink Z1 Z)(APPEND (X1|Y1) ((vars |Z)) x))
      ((APPEND X ((vars |Z)) x)(listvars Z Z1)
       (sub  X Z1 (X1 |Y1))))/)
((vartrans x x))
((exp-parse x x) (VAR x)/)
((exp-parse (x|y) (x|y1))
  (VAR x)/
  (exp-parse y y1))
((exp-parse ((x|y)|z) ((x|y)|z1))
  (VAR x)/
  (exp-parse z z1))
((exp-parse ()())/)
((exp-parse ((= x y)|Z) ((# (EQ x1 y1) Y)|Z1))
  ("?EQNTEST?" Y)/
  (Expression-Parse (x y) (x1 y1) Y)(exp-parse Z Z1))
((exp-parse ((# x|y)|Z) ((# (x| y1) Y)|Z1))
  (NOT LST x)("?EQNTEST?" Y)/
  (Expression-Parse y y1 Y)(exp-parse Z Z1))
((exp-parse (X|Y) (X|Z))(exp-parse Y Z))
(("?EQNTEST?" X)(VAR X)/)
(("?EQNTEST?" X)(DEF Expression-Parse))
((kill all)
  /
  (P Whole program "?(yes/no)")
  (R X)
  (EQ X yes)
  (KILL ALL)(SPACE Y)
  (PP Whole program deleted  Y K free))
((kill X)
  (OPMOD X)
  /
  CLMOD
  (KILL X)(SPACE Y)
  (PP Module X deleted  Y K free))
((kill X)
  (KILL X)
  (PP All clauses for X deleted))
((delete X)
  (CON X)/(R Y)(delete X Y)(PP Clause deleted))
((delete X Y)
  (IF (DELCL X Y) ((PP Clause deleted)) ((PP No  clause Y for X))))
((delete X)(CL-parse X X1)
  (OR ((DELCL X1)) ((PP No clause X))))
((list all)/(LIST ALL))
((list X)(LIST X))
((accept X)
  (CON X)(P X)
  (R Y)
  (OR ((LST Y) (ADDCL ((X |Y))) /(accept X)) 
      ((OR ((EQ Y end)) ((P " " Y not a list)(PP)(accept X)))) 
  ))
((function x)(CON x)(OR ((CL ((func x)))/) ((ADDCL ((func x))))))
((reserved (func data-rel|Y))(DICT x1 y Y|Z))
((cedit X)(R Y)(cedit X Y))
((edit X)(R Y)(edit X Y))
((cedit X Y) (ed X Y /*))
((edit X Y) (ed X Y DELCL))
((ed X Y X5)
  (CON X)
  (CL ((X|Z)|x) Y Y)(CL-parse Z1 ((X|Z)|x))
  (RFILL (Y Z1) y1) (INT y1)(R Z3)(LESS 0 y1)
  (CL-parse Z3 Z2)(EQ Z2 ((z|X1)|y))
  (NOT SYS (z|X1))(NOT VAR z)(SUM 1 y2 y1) (X5 X Y)(ADDCL Z2 y2)
  (IF (EQ X z)() ((PP relation changed to z))))
((space X)
  (SPACE Y)
  (P Y)
  (PP K left))
((# X)
  (Expression-Parse X X1 X2)
  (? X2)/
  (PP X1))
((# X Y)
 (? Y)/
 X)
((APPEND () X X))
((APPEND (X|Y) Z (X|x))
  (APPEND Y Z x))
((ON X (X|Y)))
((ON X (Y|Z))
  (ON X Z))
((CONS X Y (X|Y)))
((@ x |y) (x|y))
((true-of x y)(x|y))
((%  Y Z X)
  (TIMES X Z Y))
(("-" Y Z X)
  (SUM Z X Y))
((+ Y Z X)
  (SUM Y Z X))
((* Y Z X)
  (TIMES Y Z X))
CLMOD
errtrap-mod ("?ERROR?") (q e s f c is-told tell data-rel) 
((P-code 0 "Arithmetic overflow"))
((P-code 1 "Arithmetic underflow"))
((P-code 2 "No clauses for relation"))
((P-code 3 "Invalid form of use"))
((P-code 4 "Error in adding or deleting clause"))
((P-code 5 "File error"))
((P-code 6 "Too many files opened at once"))
((P-code 7 "Close all files first"))
((P-code 8 "Bad data in file"))
((P-code 9 "Write error"))
((P-code 10 "Disk or directory is full"))
((P-code 11 "Break !"))
((P-code 12 "Illegal use of modules"))
((P-code X " "))
(("?ERROR?" 2 (X|Y))
  (CL ((data-rel X)))/FAIL)
(("?ERROR?" X Y)
  (P-code X Z)/
  (P Error X Z)(PP)(PP trying Y)
  (P "error&(? for info)") RCLEAR (INTOK "CON:" x)(respond x Y))
((respond q X)
  (ABORT))
((respond e X)
  /(RFILL (X) Y)Y)
((respond c X)
 / X)
((respond tell (X|X1))/
  (ADDCL ((X|X2) (is-told (X X2))))
  (X|X1))
((respond f X)/FAIL)
((respond s X)/)
((respond / X)/
  (R x)(R Y)
  (x Y)
  (P "error&") (INTOK "CON:" Z)
  (respond Z X))
((respond y (Y|Y1))
  (PP to quit enter: q )
  (PP to fail call enter:f)
  (PP to succeed call enter:s)
  (PP to line edit call and resume enter:e)
  (P or enter / "<any command>" (eg / add "<clause>",/ LOAD file))(PP)
  (PP or enter:tell(see manual))
  (PP to resume enter: c)
  (P "error&")(INTOK "CON:" x)
  (respond x (Y|Y1)))
CLMOD
P)
  (PP or enter:tell(see manual))
 