simtrace-mod (is-trace all-trace) ("y" n s f Parse-of-ConjC APPEND
Parse-of-SS : "FIND:" Parse-of-Cond dict q #)
((COPYRIGHT 1984 LPA LTD V2-16))
((ENTER x "y" (X|Y)) / (CL ((X|Y1)|Z) 1 x5)
  (Parse-of-SS (X|Y) X1 ()) 
 (Parse-of-SS (X|Y1) X2 ())
 (APPEND  (matching x:| X1) (with head of x5 : |X2)X6)(PP |X6)
 (IF (EQ Y Y1) 
     ((P "  match succeeds: ")(PP |X1)) ((P "  match fails")(PP)FAIL))
 (effect (NOT EQ Z ()) (Parse-of-ConjC Z Z1)(PP  new query :| Z1))  
 (OR () ((PP retrying x)FAIL)) 
 (??(1 |x) Z z)|z)
((ENTER x / X)/
  (R Y)(R Z)(Y Z)
  (effect (Parse-of-Cond X X1 ()) (P x : |X1))  
  (test x X))
((ENTER x n X) / X (OR () ((PP retrying x)FAIL)))
((ENTER x s X)/)
((ENTER x f X) / FAIL)
((ENTER x q X) ABORT)
((ENTER x X Y) (P ENTER "y" n s(to succeed) f(to fail) q (to quit) or / 
followed by a command) (INTOK "CON:" Z)
  (ENTER x Z Y))
((all-trace X1)("FIND:" X1 X (:|Y) which-trace) 
  (Parse-of-ConjC  Y1 Y)  (whichex X Y1))
((whichex X Y1)
  (??( 1) Y1 z) 
   (IF (EQ z ()) ((P| X)(PP)(PP backtracking ...) FAIL) 
	((PP No (more)answers))))
((whichex X Y1) (PP No (more) answers))
((is-trace X)
  (Parse-of-ConjC  Y X)
  (IF (?? (1)Y ()) ((PP Yes)) ((PP No))))
((?? x () ()))
((?? x ((? X)) ())/
  (?? x X z1))
((?? (x| x1)(X|Y) z) 
  (effect (Parse-of-Cond X  X1 ())(P (x |x1)  :  |X1))    
  (test (x |x1) X) 
  (EQ X (y|y1))
  (OR ((EQ y #)/(EQ y1 (Z Z1))(Parse-of-Cond Z X1 ()))
      ((Parse-of-Cond X X1 ())))
  (PP  (x |x1)solved :| X1)(SUM x 1 x2)
  (??( x2|x1) Y z))
((?? x ((/)|Y) (/FAIL))/)
((?? x (X|Y) z) (Parse-of-Cond X Z ())
(PP x failing :|Z ) 
  FAIL)
((test x (# X Y))/
  (response Z1)
  (IF (EQ Z1 "y") ((PP evaluating expressions using relations ...)
                   (?? (1|x) Y z1)/(Parse-of-SS X X2 ())
          (PP evaluating x :|X2)(IF (SYS X) (X) ((ENTER x "y" X)))) 
        ((# X Y)))) 
((test x (FORALL X Y))/
  (response Z1)
  (IF (EQ Z1 "y") ((FORALL ((PP trying generator of x)(?? (1 gen |x)
					          X z1)|z1)
			   ((PP trying test condition of x)
				(IF (?? (1 test|x) Y z2)
				    ((PP test of x succeeds ...
					  retrying generator))
				    ((PP test of x fails)FAIL)
				)
			   )
		  ))
		  ((FORALL X Y))))
((test x (ISALL X Y |Z))/
  (response y)
  (IF (EQ y "y") ((effect (Parse-of-ConjC Z Z1)
			  (PP finding all Y such that:|Z1))
		   (ISALL X Y (?? (1|x) Z z1)(PP found answer Y to x)|z1))  
		 ((ISALL X Y|Z))))
((test x  (NOT ? X3))/
  (response Z1)
  (IF (EQ Z1 "y") ((PP x unnegated)
                   (IF (?? (1|x) X3 ()) ((PP unnegated x solved so ...) FAIL) 
			((PP unnegated x failed so ...))))
		  ((NOT ? X3))
  ))
((test z (!|X))/
  (P " trace?")(INTOK "CON:" x)(ENTER z x X)/) 
((test x (NOT|X3))/
  (response Z1)
  (IF (EQ Z1 "y")
    ((PP x unnegated)(IF (?? (1|x) (X3) ()) ((PP unnegated x solved so ...)FAIL)
				 ((PP unnegated x failed so ...))))
    ((NOT |X3))))
((test x (OR X1 X2))/
  (response Z1)
  (IF (EQ Z1 "y") ((OR ((PP x either branch)(?? (1 |x) X1 y)|y) 
                                   ((PP x  or branch)
					(?? (1| x) X2 y))))
                  ((OR X1 X2))
  ))
((test x X)(EQ X (y|z))
  (NOT CL ((dict y)))(DEF X)/
  (PP) X (OR () ((NOT SYS X)(PP retrying x)FAIL)))
 ((test x X)
  (DEF X)/
  (P " trace?")(INTOK "CON:" Z1)
  (ENTER x Z1 X))
((test x X)
  (P " No definition for relation")(PP)
  (ENTER x e X))
((response Z1)
  (P " trace?(y/n) ")(R Z1))
((effect|X) (? X) FAIL)
((effect |X))
CLMOD
