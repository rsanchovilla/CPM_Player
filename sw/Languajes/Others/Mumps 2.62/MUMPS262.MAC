	.Z80
	ASEG
	ORG	100H
	JP	FREE
;
GREET:	DEFB	'8080 MUMPS   VERSION 2.62',0
ENDIN:	DEFW	FREE+STRLN+1+STRLN+STKLN+SYNLN+PTRLN
PATSZ:	DEFW	4096		;PARTITION SIZE
NGBUF:	DEFB	6		;NUMBER OF GLOBAL BUFFERS
ERFCB:	DEFB	0,'ERRORS  DAT',0,0,0,0
	DEFS	20
GLFCB:	DEFB	0,'GLOBALS DAT',0,0,0,0
	DEFS	20
AUTO:	DEFB	0
RLENG:	DEFS	1		;LENGTH OF DATA READ IN
BDATA:	DEFS	255		;DATA READ IN
	DEFS	1		;ROOM FOR <CR>
;
MUMPS:
	LD	HL,FREE		;INITIALIZE LBUFF
	LD	(LBUFF),HL
	LD	DE,STRLN+1
	ADD	HL,DE
	LD	(DRBUF),HL
	LD	DE,STRLN
	ADD	HL,DE
	LD	(XSTK),HL
	LD	(TOS),HL	;INITIALIZE TOS
	LD	DE,STKLN
	ADD	HL,DE
	LD	DE,SYNLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	(SSTK),HL	;INITIALIZE SSTK
;*
;* SET UP GLOBAL BUFFERS
;*
	LD	(GLBTA),HL
	LD	A,(NGBUF)
	LD	(IT),A
	LD	(PTR1),HL
MMPA:	LD	HL,(PTR1)	;MOVE PTR1 PAST THE GLOBAL TABLE
	LD	DE,GBTSZ
	ADD	HL,DE
	LD	(PTR1),HL
	LD	HL,IT
	DEC	(HL)
	LD	A,(IT)
	OR	A
	JP	NZ,MMPA
	LD	A,(NGBUF)
	LD	(IT),A
MMPB:	LD	HL,IT
	DEC	(HL)
	LD	HL,(PTR)	;INITIALLY A NIL POINTER
	LD	DE,NIL
	CALL	SETD
	LD	HL,(PTR)	;MOVE PTR TO BUFFER AGE
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(IT)
	LD	(HL),A
	INC	HL		;MOVE PTR TO DIRTY FLAG
	LD	(HL),0
	INC	HL		;MOVE PTR TO BUFFER POINTER
	LD	(PTR),HL
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)	;PTR TO NEXT TABLE ENTRY
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(PTR1)	;PTR1 TO NEXT BUFFER
	LD	DE,BLKSZ
	ADD	HL,DE
	LD	(PTR1),HL
	OR	A
	JP	NZ,MMPB
;*
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PRGAD),HL
	LD	(PRGPT),HL
	LD	(PRGEN),HL	;SET PRGEN
	LD	HL,(PRGPT)
	LD	(HL),EOR
	LD	HL,(PRGEN)	;INITIALIZE PTEND
	LD	(PTEND),HL
	LD	HL,(PATSZ)
	EX	DE,HL
	LD	HL,(PTEND)
	ADD	HL,DE
	LD	(PTEND),HL
	LD	(SYMPT),HL
	LD	(SYMEN),HL
	LD	HL,NREF
	LD	(NLAST),HL
	LD	HL,(SYMPT)	;NULL SYMBOL TABLE
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(SSTK)
	LD	SP,HL
	CALL	SSCHK
	XOR	A
	LD	(IT),A
	CALL	SETDE		;MAKE TERMINAL CURRENT DEVICE
	CALL	CKCHR		;SEE IF GETTING OUT OF AUTO-MODE
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,MMPD
	LD	A,(CHR)
	CP	CTRLC
	JP	NZ,MMPD
	XOR	A
	LD	(AUTO),A
MMPD:	LD	A,(AUTO)
	CP	1
	JP	Z,MMPC
	LD	HL,GREET	;WRITE GREETING
	CALL	MSG
	CALL	CRLF
MMPC:	LD	HL,0
	LD	(INDX),HL
	XOR	A
	LD	(FLG1),A
	LD	(GLBDR),A
	LD	(RTDRV),A
	LD	(XTDRV),A
	LD	(GLOPN),A
	LD	(DMF),A
	LD	(COLD),A
MMP0:	LD	A,NAMLN
	LD	(IT),A
	LD	HL,PRG
	LD	(PTR),HL
MMP1:	LD	HL,(PTR)	;BLANK OUT ROUTINE NAME
	LD	(HL),BLANK
	INC	HL
	LD	(PTR),HL
	LD	HL,IT
	DEC	(HL)
	LD	A,(IT)
	OR	A
	JP	NZ,MMP1
MMP1A:	XOR	A
	LD	(RESUL),A
	LD	(CASE),A
	LD	(ACTFL),A
	LD	(TOKEN),A
	LD	(SETF),A
	LD	(INDFL),A
	LD	(INDSW),A
	LD	(DOSW),A
	LD	(FORSW),A
	LD	(FLAG),A
	LD	A,1
	LD	(MODE),A
	XOR	A
	LD	(IODVC),A
	LD	A,2
	LD	(SWIF),A
	XOR	A
	LD	(LEVEL),A
	LD	(DJ),A
	LD	(KILF),A
	LD	(PF),A
	LD	(GLB),A
	LD	A,FALSE
	LD	(SETSW),A
	LD	(GOTOF),A
MMP2:	CALL	INPUT		;GET NEXT LINE
	LD	A,(AUTO)	;AUTO-MODE HAS PASSED INPUT
	OR	2
	LD	(AUTO),A
	LD	A,(FLAG)
	CP	4
	JP	NZ,MMP5
	XOR	A
	LD	(FLAG),A
	LD	A,(INDSW)
	OR	A
	JP	Z,MMP3
	CALL	XECRE
	RET
MMP3:	LD	A,(DOSW)
	OR	A
	JP	C,$+6
	JP	NZ,MMP4
	LD	A,1
	LD	(MODE),A
	JP	MMP2
MMP4:	CALL	DORET
	RET
MMP5:	LD	A,(ACTFL)	;RESET LINACT
	LD	B,A
	LD	A,2
	CPL
	AND	B
	LD	(ACTFL),A
MMP55:	XOR	A
	LD	(FORSW),A
	LD	A,(ACTFL)	;RESET COMACT
	LD	B,A
	LD	A,1
	CPL
	AND	B
	LD	(ACTFL),A
	XOR	A
	LD	(INDFL),A
MMP6:	LD	A,(TOKEN)
	CP	38
	JP	Z,MMP10
MMP7:	LD	A,(TOKEN)
	CP	29
	JP	NZ,MMP9
MMP8:	CALL	GTOKN		;GET FIRST TOKEN
	LD	A,(TOKEN)
	CP	38
	JP	Z,MMP10
	CP	36
	JP	C,$+6
	JP	NZ,E18
	JP	MMP8
MMP9:	LD	A,(ACTFL)	;RESET COMACT
	LD	B,A
	LD	A,1
	CPL
	AND	B
	LD	(ACTFL),A
	XOR	A
	LD	(FNC),A
	LD	(FLAG),A
	CALL	GTCOM
	LD	A,(FLAG)
	CP	1
	JP	Z,MMP7
MMP10:	XOR	A		;RESET LINACT AND COMACT
	LD	(ACTFL),A
	LD	A,(FORSW)
	OR	A
	JP	Z,MMP2
	RET
;*
;*
;*
INPUT:	;GET INPUT LINE FROM TERMINAL
	CALL	SSCHK
	LD	A,(GOTOF)
	CP	TRUE
	JP	Z,INP0
	LD	A,(INDSW)
	OR	A
	JP	NZ,INP10
	LD	A,(AUTO)
	CP	1
	JP	Z,INP3
INP0:	LD	A,(MODE)
	OR	A
	JP	Z,INP7
	LD	A,(AUTO)
	CP	3
	JP	Z,A0551
INP1:	CALL	CRLF
	LD	A,PROMT		;DIRECT MODE--WRITE PROMPT
	CALL	TRMOT
	LD	A,(COLD)	;SEE IF NEED TO INITIALIZE RANDOM SEED
	CP	1
	JP	Z,INP2
	CALL	RDSEE
	LD	A,1
	LD	(COLD),A
INP2:	CALL	TRMIN		;READ COMMAND LINE
	CALL	CRLF
	LD	A,(RLENG)
	OR	A
	JP	Z,INP1
INP3:	LD	HL,BDATA	;MOVE LINE TO LINE EXECUTION BUFFER
	EX	DE,HL
	LD	HL,(LBUFF)
	LD	A,(RLENG)
	LD	B,A
	CALL	MOVE
	LD	HL,BDATA	;SAVE LINE IN DIRECT MODE BUFFER
	EX	DE,HL
	LD	HL,(DRBUF)
	LD	A,(RLENG)
	LD	B,A
	CALL	MOVE
	LD	A,(RLENG)	;SAVE LENGTH
	LD	(DRLNG),A
	LD	HL,(LBUFF)
	LD	(PTR),HL
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(TPP),HL
	LD	(HL),EOL	;SET EOL
	LD	HL,(PTR)
	DEC	HL
	LD	(INDX),HL
	CALL	CKLS		;CHECK FOR LS
	LD	A,(RESUL)
	OR	A
	JP	Z,INP85
	CALL	LININ		;INSERT LINE
	JP	INP1		;GET NEXT LINE SINCE THIS WAS STORED
INP7:	LD	HL,(PRGPT)
	LD	A,(HL)
	CP	EOR
	JP	Z,INP10
	LD	(PRGLS),HL
	LD	A,(HL)		;GET LINE LENGTH
	LD	(SLENG),A
	INC	HL
	LD	A,(HL)		;GET LABEL LENGTH
	LD	(NLENG),A
	INC	HL
	LD	(PRGPT),HL
	EX	DE,HL
	LD	HL,(LBUFF)
	LD	A,(SLENG)
	LD	B,A
	CALL	MOVE
	LD	HL,(PRGPT)
	LD	A,(SLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PRGPT),HL
	LD	HL,(LBUFF)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR),HL
	LD	(HL),EOL
	LD	HL,(LBUFF)	;INITIALIZE INDX PAST LS
	LD	A,(NLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(INDX),HL
INP85:	CALL	GTOKN
	LD	HL,(INDX)
	LD	A,(HL)
	CP	EOL
	JP	Z,INP9
	RET
INP9:	LD	A,2
	LD	(FLAG),A
	RET
INP10:	LD	A,4		;END OF ROUTINE
	LD	(FLAG),A
	RET
;*
;********************     COMMAND TABLE     ********************
;*
;*
;*****  STANDARD COMMANDS  *****
;*
;** BREAK COMMAND
BREAK:	CALL	POSTC		;BEGINNING OF BREAK COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C1C
	CP	1
	JP	NZ,C1A
C1:	CALL	STREX		;BREAK WITH ARGUMENTS
	CALL	COMEN
C1A:	LD	A,(FLAG)
	OR	1
	LD	(FLAG),A
	LD	A,(ACTFL)	;SAVE LOCATION; BREAK TO DIRECT MODE
	OR	A
	CALL	Z,AC48
	LD	A,(CASE)
	CP	1
	JP	NZ,C1D
	LD	A,(RESUL)
	CP	1
	JP	NZ,C1
	JP	C1D
C1C:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C1
C1D:	RET
;*
;** CLOSE COMMAND
CLOSE:	CALL	POSTC		;BEGINNING OF CLOSE COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C4
	CP	1
	JP	NZ,E14
C2:	CALL	EXPR		;CHECK FOR CLOSE DEVICE EXPRESSION
	LD	A,(ACTFL)	;SAVE DEVICE NUMBER
	OR	A
	CALL	Z,AC117
	LD	A,(TOKEN)	;LOOK FOR COLON
	CP	22
	JP	NZ,C3
	CALL	GTOKN
	CALL	PARAM		;CHECK FOR DEVICE PARAMETERS
C3:	LD	A,(ACTFL)	;CLOSE DEVICE LISTED
	OR	A
	CALL	Z,AC77
C4:	CALL	COMEN
	LD	A,(RESUL)
	OR	A
	JP	Z,C2
	LD	A,(FLAG)	;END OF CLOSE COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** DO COMMAND
DO:	CALL	POSTC		;BEGINNING OF DO COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C6
	CP	1
	JP	NZ,E14
C5:	CALL	TRANS		;CHECK FOR DO-ABLE BRANCH POINT
	LD	A,(CASE)
	OR	A
	JP	Z,C6
	LD	A,(ACTFL)	;STACK DO INFORMATION; DO TRANSPT
	OR	A
	CALL	Z,AC73
C6:	CALL	COMEN
	LD	A,(RESUL)
	OR	A
	JP	Z,C5
	LD	A,(FLAG)	;END OF DO COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** ELSE COMMAND
ELSE:	CALL	ARGUM		;BEGINNING OF ELSE COMMAND
	LD	A,(CASE)	;ELSE AT END OF LINE; NO ACTION
	CP	2
	JP	Z,C7
	CP	3
	JP	NZ,E14
	LD	A,(ACTFL)	;INTERROGATE IFSWITCH; SET LINACT
	OR	A
	CALL	Z,AC59
C7:	LD	A,(FLAG)	;END OF ELSE COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** FOR COMMAND
FOR:	LD	A,(TOKEN)	;BEGINNING OF FOR COMMAND
	CP	31
	JP	NZ,E14
	CALL	GTOKN
	CALL	LVN		;CHECK FOR LOCAL VARIABLE
	LD	A,(RESUL)
	OR	A
	JP	Z,E23
	LD	HL,(TOS)
	LD	(VPTR),HL
	LD	A,(ACTFL)	;INCREMENT FORSW; SCAN TO B-O-S
	OR	A
	CALL	Z,AC99
	LD	A,(TOKEN)
	CP	17
	JP	NZ,E27
	CALL	GTOKN
C8:	CALL	EXPR		;CHECK FOR NEXT VALUE IN FOR LIST
	LD	A,(TOKEN)	;LOOK FOR COLON
	CP	22
	JP	Z,C9
	LD	A,(ACTFL)	;SET VARIABLE TO VALUE; ZERO T-O-S
	OR	A
	CALL	Z,AC51
	LD	A,(ACTFL)	;EXECUTE SCOPE (EOL HANDLES RETURN)
	OR	A
	CALL	Z,AC82
	JP	C13
C9:	CALL	GTOKN
	LD	A,(ACTFL)	;SAVE VALUE IN FREAL
	OR	A
	CALL	Z,AC79
	LD	HL,(TOS)
	LD	(IPTR),HL
	CALL	NUMEX		;CHECK FOR NUMERIC INCREMENT
	LD	A,(TOKEN)	;LOOK FOR SECOND COLON
	CP	22
	JP	Z,C11
	LD	A,1
	LD	(FCASE),A
	LD	A,(ACTFL)	;SET FOR VARIABLE TO VALUE
	OR	A
	CALL	Z,AC124
C10:	LD	A,(ACTFL)	;EXECUTE SCOPE (EOL HANDLES RETURN)
	OR	A
	CALL	Z,AC82
	LD	A,4
	LD	(CASE),A
	LD	A,(ACTFL)	;SETRIEVE B-O-S; INCREMENT FOR VAR;
	OR	A
	CALL	Z,AC83
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C13
	JP	C10
C11:	CALL	GTOKN
	LD	HL,(TOS)
	LD	(FPTR),HL
	CALL	NUMEX		;CHECK FOR (NUMERIC) FINAL VALUE
	LD	A,2
	LD	(FCASE),A
	LD	A,(ACTFL)	;SET FOR VARIABLE TO VALUE
	OR	A
	CALL	Z,AC124
	LD	A,4
	LD	(CASE),A
	LD	A,(ACTFL)	;TEST LVN AGAINST FINAL VALUE;
	OR	A
	CALL	Z,AC87
	LD	A,(CASE)	;FINISHED WITH THIS LOOP
	CP	1
	JP	NZ,C13
C12:	LD	A,(ACTFL)	;EXECUTE SCOPE (EOL HANDLES RETURN)
	OR	A
	CALL	Z,AC82
	LD	A,4
	LD	(CASE),A
	LD	A,(ACTFL)	;RETRIEVE VALUES, DO TEST; X OR Y
	OR	A
	CALL	Z,AC88
	LD	A,(CASE)
	CP	1
	JP	Z,C12
C13:	LD	A,(ACTFL)	;RETRIEVE POSITION; CLEAN OFF STACK
	OR	A
	CALL	Z,AC89
	LD	A,(TOKEN)	;LOOK FOR COMMA
	CP	21
	JP	NZ,C135
	CALL	GTOKN
	JP	C8
C135:	LD	A,(ACTFL)	;CLEAN LVN OFF STACK; DECREMENT FORSW
	OR	A
	CALL	Z,AC90
	CALL	FOREN		;SCAN OFF SPACE OR EOL
	LD	A,(FLAG)	;END OF FOR COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** GOTO COMMAND
GOTO:	CALL	POSTC		;BEGINNING OF GOTO COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C15
	CP	1
	JP	NZ,E14
C14:	CALL	TRANS		;CHECK FOR FIRST TRUE BRANCH POINT
	LD	A,(CASE)
	OR	A
	JP	Z,C15
	LD	A,(ACTFL)	;BRANCH TO TRANSPT (SETS EOL)
	OR	A
	CALL	Z,AC72
C15:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C14
	LD	A,(FLAG)	;END OF GOTO COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** HALT COMMAND
HALT:	CALL	POSTC		;BEGINNING OF HALT COMMAND
	LD	A,(CASE)	;HALT AT END OF LINE
	CP	2
	JP	Z,C16
	CP	3
	JP	NZ,E14
C16:	LD	A,(ACTFL)	;TERMINATE EXECUTION;DIRECT MODE
	OR	A
	CALL	Z,AC55
	LD	A,(FLAG)	;END OF HALT COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** HANG COMMAND
HANG:	CALL	POSTC		;BEGINNING OF HANG COMMAND
HENTR:	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C18
	CP	1
	JP	NZ,E14
C17:	CALL	INTEX		;CHECK FOR INTEGER HANG EXPRESSION
	LD	A,(ACTFL)	;SUSPEND EXECUTION FOR EXPR SECONDS
	OR	A
	CALL	Z,AC60
C18:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C17
	LD	A,(FLAG)	;END OF HANG COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** IF COMMAND
FI:	CALL	ARGUM		;BEGINNING OF IF COMMAND
	LD	A,(CASE)	;IF AT END OF LINE; NO ACTION
	CP	2
	JP	Z,C22
	CP	4		;SYNTAX CHECKING ONLY
	JP	Z,C21
	CP	1		;ARGUMENTS PRESENT
	JP	Z,C19
	LD	A,(ACTFL)	;NO CONDITIONS; CHECK IFSWITCH; LINACT
	OR	A
	CALL	Z,AC58
	JP	C22
C19:	LD	A,(ACTFL)	;SET DIF ON
	OR	A
	CALL	Z,AC57
C20:	CALL	TVEXP		;CHECK FOR BOOLEAN EXPRESSION
	LD	A,(CASE)	;CONDITION TRUE; CONTINUE
	CP	1
	JP	Z,C21
	LD	A,(ACTFL)	;CONDITION FALSE; IFSWITCH OFF, LINACT
	OR	A
	CALL	Z,AC56
C21:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C20
C22:	LD	A,(DIF)
	LD	(SWIF),A
	LD	A,(FLAG)	;END OF IF COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** KILL COMMAND
KILL:	CALL	POSTC		;BEGINNING OF KILL COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C28
	CP	1		;ARGUMENTS PRESENT
	JP	Z,C23
	LD	A,(ACTFL)	;KILL ALL LOCAL VARIABLES
	OR	A
	CALL	Z,AC61
	JP	C29
C23:	LD	A,(TOKEN)	;LOOK FOR LEFT PARENTHESIS
	CP	25
	JP	NZ,C27
	XOR	A
	LD	(FNDF),A
C235:	CALL	GTOKN
C24:	CALL	LVN		;CHECK FOR LOCAL VARIABLE
	LD	A,(RESUL)
	CP	1
	JP	Z,C25
	LD	A,(ACTFL)	;UNMARK SYMBOL TABLE
	OR	A
	CALL	Z,AC76
	JP	E23
C25:	LD	A,(ACTFL)	;MARK VARIABLE IN SYMBOL TABLE
	OR	A
	CALL	Z,AC62
	LD	A,(TOKEN)	;LOOK FOR COMMA
	CP	21
	JP	Z,C235
	CP	26		;LOOK FOR RIGHT PARENTHESIS
	JP	Z,C26
	LD	A,(ACTFL)	;UNMARK SYMBOL TABLE
	OR	A
	CALL	Z,AC76
	JP	E12
C26:	CALL	GTOKN
	LD	A,(ACTFL)	;KILL EXCLUSIVE OF MARKED LVN'S
	OR	A
	CALL	Z,AC63
	JP	C28
C27:	CALL	GLVN		;CHECK FOR VARIABLE
	LD	A,(ACTFL)	;KILL VARIABLE
	OR	A
	CALL	Z,AC64
C28:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C23
C29:	LD	A,(FLAG)	;END OF KILL COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** LOCK COMMAND
LOCK:	CALL	POSTC		;BEGINNING OF LOCK COMMAND
	LD	A,1
	LD	(LOCKS),A
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C31
	CP	1		;ARGUMENTS PRESENT
	JP	Z,C30
	LD	A,(ACTFL)	;RELEASE ALL LOCKED RESOURCES
	OR	A
	CALL	Z,AC102
	JP	C32
C30:	CALL	VARLI		;CHECK FOR ONE VARIABLE OR A LIST
	CALL	TIMEO		;CHECK FOR TIMEOUT EXPRESSION
	LD	A,(ACTFL)	;LOCK RESOURCES
	OR	A
	CALL	Z,AC101
C31:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C30
C32:	XOR	A
	LD	(LOCKS),A
	LD	A,(FLAG)	;END OF LOCK COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** OPEN COMMAND
OPEN:	CALL	POSTC		;BEGINNING OF OPEN COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C35
	CP	1
	JP	NZ,E14
C33:	CALL	EXPR		;CHECK FOR OPEN DEVICE EXPRESSION
	LD	A,(ACTFL)	;SAVE DEVICE NUMBER
	OR	A
	CALL	Z,AC117
	LD	A,(TOKEN)	;LOOK FOR COLON
	CP	22
	JP	NZ,C34
	CALL	GTOKN
	CALL	TIMEO		;CHECK FOR TIMEOUT EXPRESSION
	LD	A,(RESUL)
	CP	1
	JP	Z,C34
	CALL	PARAM		;CHECK FOR DEVICE PARAMETERS
	CALL	TIMEO		;CHECK FOR TIMEOUT EXPRESSION
C34:	LD	A,(ACTFL)	;PERFORM OPEN ON NAMED DEVICE
	OR	A
	CALL	Z,AC78
C35:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C33
	LD	A,(FLAG)	;END OF OPEN COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** QUIT COMMAND
QUIT:	CALL	POSTC		;BEGINNING OF QUIT COMMAND
	LD	A,(CASE)	;QUIT AT END OF LINE
	CP	2
	JP	Z,C36
	CP	3
	JP	NZ,E14
C36:	LD	A,(ACTFL)	;EXECUTE QUIT
	OR	A
	CALL	Z,AC75
	LD	A,(FLAG)	;END OF QUIT COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** READ COMMAND
READ:	CALL	POSTC		;BEGINNING OF READ COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C40
	CP	1
	JP	NZ,E14
C37:	LD	A,(TOKEN)	;LOOK FOR ASTERISK (DEVICE SPECIFIC )
	CP	7
	JP	NZ,C38
	CALL	GTOKN
	CALL	LVN		;CHECK FOR LOCAL VARIABLE
	LD	A,(RESUL)
	CP	1
	JP	NZ,E23
	XOR	A
	LD	(TIMF),A
	CALL	TIMEO		;CHECK FOR TIMEOUT EXPRESSION
	LD	A,(ACTFL)	;GET INPUT VARIABLE AS ONE DEVICE-SPECIFIC CODE
	OR	A
	CALL	Z,AC66
	JP	C40
C38:	CALL	FORMA		;CHECK FOR FORMAT EXPRESSION
	LD	A,(RESUL)
	CP	1
	JP	Z,C40
	CALL	AC6		;TEST FOR STRING LITERAL
	LD	A,(RESUL)
	CP	1
	JP	NZ,C39
	LD	A,(ACTFL)	;OUTPUT STRING LITERAL
	OR	A
	CALL	Z,AC67
	JP	C40
C39:	CALL	LVN		;CHECK FOR LOCAL VARIABLE
	LD	A,(RESUL)
	CP	1
	JP	NZ,E18
	LD	A,1
	LD	(TIMF),A
	CALL	TIMEO		;CHECK FOR TIMEOUT EXPRESSION
	LD	A,(ACTFL)	;GET INPUT VARIABLE AS STRING
	OR	A
	CALL	Z,AC68
C40:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C37
	LD	A,(FLAG)	;END OF READ COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** SET COMMAND
TES:	CALL	POSTC		;BEGINNING OF SET COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C42
	CP	1
	JP	NZ,E14
C41:	CALL	VARLI		;CHECK FOR ONE VARIABLE OR A PARENTHESIZED LIST
	LD	A,(TOKEN)	;LOOK FOR EQUAL SIGN
	CP	17
	JP	NZ,E27
	CALL	GTOKN
	CALL	EXPR		;CHECK FOR ASSIGNMENT EXPRESSION
	LD	A,(ACTFL)	;SET LOCAL,GLOBAL VARIABLES(S) TO VALUE
	OR	A
	CALL	Z,AC47
C42:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C41
	LD	A,(FLAG)	;END OF SET COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;** USE COMMAND
USE:	CALL	POSTC		;BEGINNING OF USE COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C45
	CP	1
	JP	NZ,E14
C43:	CALL	EXPR		;CHECK FOR USE DEVICE EXPRESSION
	LD	A,(ACTFL)	;SAVE DEVICE NUMBER
	OR	A
	CALL	Z,AC117
	LD	A,(TOKEN)	;LOOK FOR COLON
	CP	22
	JP	NZ,C44
	CALL	GTOKN
	CALL	PARAM		;CHECK FOR DEVICE PARAMETERS
C44:	LD	A,(ACTFL)	;MAKE DEVICE LISTED THE 'CURRENT' DEVICE
	OR	A
	CALL	Z,AC65
C45:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C43
	LD	A,(FLAG)
	OR	1
	LD	(FLAG),A
	RET			;END OF USE COMMAND
;*
;** VIEW COMMAND
VIEWS:	CALL	POSTC		;BEGINNING OF VIEW COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C45B
	CP	1		;NO ARGUMENTS--LOCALS ONLY
	JP	Z,C45A
	XOR	A
	LD	(VF),A
	LD	A,(ACTFL)
	OR	A
	CALL	Z,AC37
	JP	C45C
C45A:	CALL	INTEX		;ARGUMENTS TO EVALUATE
	LD	A,(ACTFL)	;WRITE OUT VALUES
	OR	A
	CALL	Z,AC39
C45B:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C45A
C45C:	LD	A,(FLAG)
	OR	1
	LD	(FLAG),A
	RET
;*
;** WRITE COMMAND
WRITE:	CALL	POSTC		;BEGINNING OF WRITE COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C48
	CP	1
	JP	NZ,E14
C46:	LD	A,(TOKEN)	;LOOK FOR DEVICE-SPECIFIC WRITE
	CP	7
	JP	NZ,C47
	CALL	GTOKN
	CALL	INTEX		;CHECK FOR INTEGER OUTPUT CODE
	LD	A,(ACTFL)	;OUTPUT DEVICE-SPECIFIC CODE
	OR	A
	CALL	Z,AC53
	JP	C48
C47:	CALL	FORMA		;CHECK FOR FORMAT EXPRESSION
	LD	A,(RESUL)
	CP	1
	JP	Z,C48
	CALL	EXPR		;CHECK FOR GENERAL OUTPUT EXPRESSION
	LD	A,(ACTFL)	;OUTPUT VALUE
	OR	A
	CALL	Z,AC54
C48:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C46
	LD	A,(FLAG)
	OR	1
	LD	(FLAG),A
	RET			;END OF WRITE COMMAND
;*
;** XECUTE COMMAND
XECUT:	CALL	POSTC		;BEGINNING OF XECUTE COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,C51
	CP	1
	JP	NZ,E14
C49:	CALL	STREX		;CHECK FOR INDIRECT STRING
	CALL	ARGCO		;CHECK FOR ARGUMENT CONDITIONAL
	LD	A,(CASE)
	CP	1
	JP	Z,C50
	LD	A,(ACTFL)	;REMOVE STRING FROM STACK
	OR	A
	CALL	Z,AC26
	JP	C51
C50:	LD	A,(ACTFL)	;INCREMENT INDSW,STACK XECUTE INFO; EXECUTE STACK
	OR	A
	CALL	Z,AC103
C51:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,C49
	LD	A,(FLAG)
	OR	1
	LD	(FLAG),A
	RET			;END OF XECUTECOMMAND
;*
;** Z (ESCAPE COMMANDS)
;*
ZARG:	CALL	POSTC		;BEGINNING OF ZARG COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,ZA2
	CP	1
	JP	NZ,E14
ZA1:	CALL	STREX		;CHECK FOR STRING PARAMETER
	LD	A,(ACTFL)	;SET STRING PARAMETER
	OR	A
	CALL	Z,AC121
ZA2:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,ZA1
	LD	A,(FLAG)	;END OF ZARG COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;*
ZCALL:	CALL	POSTC		;BEGINNING OF ZCALL COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,ZCA1
	CP	1
	JP	Z,E14
	LD	A,(ACTFL)	;TRANSFER CONTROL TO ROUTINE
	OR	A
	CALL	Z,AC120
ZCA1:	LD	A,(FLAG)	;END OF ZCALL COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;*
ZDELE:	CALL	POSTC
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,ZR2
	CP	1
	JP	NZ,E14
ZR1:	CALL	ROUTI		;CHECK FOR ROUTINE NAME
	LD	A,(ACTFL)	;REMOVE NAMED ROUTINE
	OR	A
	CALL	Z,AC111
ZR2:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,ZR1
	LD	A,(FLAG)	;END OF ZREMOVE COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;*
ZGO:	LD	A,(FLG1)	;ONLY DURING BREAK
	AND	BRAKE
	JP	Z,E45
	LD	A,(ACTFL)	;RETURN FROM BREAK
	OR	A
	CALL	Z,AC49
	LD	A,(FLAG)	;END OF ZXECUTE COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;*
ZINSE:	LD	A,(FLG1)	;NO INSERTS IN BREAK MODE
	AND	BRAKE
	JP	NZ,E44
	CALL	POSTC
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,ZI3
	CP	1
	JP	NZ,E14
ZI1:	CALL	STREX		;CHECK FOR STRING EXPRESSION
	LD	A,(TOKEN)	;CHECK FOR LABEL
	CP	22
	JP	NZ,ZI2
	CALL	GTOKN
	CALL	LINER
	LD	A,(ACTFL)	;MOVE ROUTINE POINTER
	OR	A
	CALL	Z,AC96
ZI2:	LD	A,(ACTFL)	;INSERT STRING AT CURRENT LINE
	OR	A
	CALL	Z,AC118
ZI3:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,ZI1
	LD	A,(FLAG)	;END OF ZINSERT COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;*
ZLOAD:	LD	A,(FLG1)	;ILLEGAL DURING BREAK
	AND	BRAKE
	JP	NZ,E44
	CALL	POSTC
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,ZG2
	CP	1
	JP	NZ,E14
ZG1:	CALL	ROUTI		;CHECK FOR ROUTINE NAME
	LD	A,(ACTFL)	;LOAD ROUTINE
	OR	A
	CALL	Z,AC94
ZG2:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,ZG1
	LD	A,(FLAG)	;END OF ZGET COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;*
ZMOVE:	LD	A,(FLG1)	;NO MOVES IN BREAK MODE
	AND	BRAKE
	JP	NZ,E44
	CALL	POSTC
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,ZM4
	CP	1		;ARGUMENTS PRESENT
	JP	Z,ZM1
	LD	A,(ACTFL)	;MOVE ROUTINE PTR TO TOP OF ROUTINE
	OR	A
	CALL	Z,AC95
	JP	ZM5
ZM1:	LD	A,(TOKEN)	;CHECK FOR COLON
	CP	22
	JP	NZ,ZM2
	CALL	GTOKN
	LD	A,(ACTFL)	;MOVE ROUTINE PTR TO END OF ROUTINE
	OR	A
	CALL	Z,AC112
	JP	ZM4
ZM2:	CALL	LINER		;CHECK FOR LABEL[+OFFSET]
	LD	A,(ACTFL)	;MOVE ROUTINE POINTER
	OR	A
	CALL	Z,AC96
ZM4:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,ZM2
ZM5:	LD	A,(FLAG)
	OR	1
	LD	(FLAG),A
	RET
;*
;*
ZOPTI:	CALL	POSTC		;BEGINNING OF ZOPTION COMMAND
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,ZO2
	CP	1
	JP	Z,ZO1
	LD	A,(ACTFL)	;WRITE OUT CURRENT DRIVES
	OR	A
	CALL	Z,AC44
	JP	ZO3
ZO1:	LD	A,(ACTFL)
	OR	A
	CALL	Z,AC20
	CALL	PARAM		;CHECK FOR DRIVE OPTIONS
	LD	A,(ACTFL)	;SET OPTIONS
	OR	A
	CALL	Z,AC119
ZO2:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,ZO1
ZO3:	LD	A,(FLAG)	;END OF ZOPTION COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;*
ZPRIN:	CALL	POSTC
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,ZL2
	CP	1		;ARGUMENTS PRESENT
	JP	Z,ZL1
	LD	A,(ACTFL)	;LIST ENTIRE ROUTINE
	OR	A
	CALL	Z,AC97
	JP	ZL3
ZL1:	LD	A,(TOKEN)	;CHECK FOR ASTERISK
	CP	7
	JP	NZ,ZL15
	CALL	GTOKN
	LD	A,(ACTFL)	;LIST CURRENT LINE
	OR	A
	CALL	Z,AC113
	JP	ZL2
ZL15:	CALL	GETLA		;CHECK FOR LABEL(S)
	LD	A,(ACTFL)	;PRINT SPECIFIED PART
	OR	A
	CALL	Z,AC98
ZL2:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,ZL1
ZL3:	LD	A,(FLAG)	;END OF ZLIST COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;*
ZREMO:	LD	A,(FLG1)	;NO DELETES IN BREAK MODE
	AND	BRAKE
	JP	NZ,E44
	CALL	POSTC
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,ZD2
	CP	1		;ARGUMENTS PRESENT
	JP	Z,ZD1
	LD	A,(ACTFL)	;DELETE ENTIRE ROUTINE
	OR	A
	CALL	Z,AC92
	JP	ZD3
ZD1:	LD	A,(TOKEN)	;CHECK FOR ASTERISK
	CP	7
	JP	NZ,ZD15
	CALL	GTOKN
	LD	A,(ACTFL)	;DELETE CURRENT LINE
	OR	A
	CALL	Z,AC114
	JP	ZD2
ZD15:	CALL	GETLA		;CHECK FOR LABEL(S)
	LD	A,(ACTFL)	;DELETE SPECIFIED PORTION
	OR	A
	CALL	Z,AC93
ZD2:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,ZD1
ZD3:	LD	A,(FLAG)
	OR	1
	LD	(FLAG),A
	RET
;*
;*
ZSAVE:	CALL	POSTC
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,ZS3
	CP	1		;NAME PRESENT
	JP	Z,ZS1
	LD	A,(ACTFL)	;SAVE AS CURRENT NAME
	OR	A
	CALL	Z,AC30
	JP	ZS4
ZS1:	CALL	ROUTI		;CHECK FOR ROUTINE NAME
ZS2:	LD	A,(ACTFL)	;SAVE ROUTINE
	OR	A
	CALL	Z,AC23
ZS3:	CALL	COMEN
	LD	A,(RESUL)
	CP	1
	JP	NZ,ZS1
ZS4:	LD	A,(FLAG)	;END OF ZSAVE COMMAND
	OR	1
	LD	(FLAG),A
	RET
;*
;*
;*****  AMBIGUOUS SINGLE LETTER COMMANDS  *****
;*
;** H-COMMAND
HS:	CALL	POSTC		;MUST DECIDE BETWEEN HALT AND HANG
	LD	A,(CASE)	;HALT, AT END OF LINE
	CP	2
	JP	Z,C52
	CP	3		;ARGUMENTS PRESENT; MUST BE HANG
	JP	NZ,HENTR
C52:	LD	A,(ACTFL)	;TERMINATE PROGRAM EXECUTION; RETURN TO DIRECT MODE
	OR	A
	CALL	Z,AC55
	LD	A,(FLAG)
	OR	1
	LD	(FLAG),A
	RET			;END OF HALT
;*
;*
;**********     END OF COMMANDS     **********
;*
;********************     COMMAND SUBROUTINE TABLE     ********************
;*
;** TRANSFER POINT PRIMITIVE
TRANS:
	CALL	SSCHK
	CALL	ENTRY		;CHECK FOR LABEL[ ROUTINE]
	LD	A,(ACTFL)	;SAVE RETURN VALUE TOP OF STACK (T-O-S)
	OR	A
	CALL	Z,AC71
	CALL	ARGCO		;CHECK FOR ARGUMENT CONDITIONAL
	LD	A,(CASE)	;X RETURN; TRANSFER POINT EXECUTABLE
	CP	1
	JP	Z,S1
	LD	A,(ACTFL)	;REMOVE LABEL[^ROUTINE] FROM STACK
	OR	A
	CALL	Z,AC69
S1:	LD	A,1
	LD	(RESUL),A
	RET
;*
;** VARIABLE LIST PRIMITIVE
VARLI:
	CALL	SSCHK
	LD	A,TRUE
	LD	(SETSW),A
	LD	A,(ACTFL)	;ZERO T-O-S (END OF VARIABLE CHAIN)
	OR	A
	CALL	Z,AC20
	LD	A,(TOKEN)	;LOOK FOR LEFT PARENTHESIS
	CP	25
	JP	Z,S2
	CALL	GLVN		;CHECK FOR VARIABLE
	CALL	AC18		;TEST FOR LOCK CASE; SET OFFSET TO NEW VALUE
	JP	S3
S2:	CALL	GTOKN
	CALL	GLVN		;CHECK FOR VARIABLE
	CALL	AC18		;TEST FOR LOCK CASE; SET OFFSET TO NEW VALUE
	LD	A,(TOKEN)	;LOOK FOR COMMA
	CP	21
	JP	Z,S2
	CP	26		;LOOK FOR RIGHT PARENTHESIS
	JP	NZ,E12
	CALL	GTOKN
S3:	LD	A,1
	LD	(RESUL),A
	LD	A,FALSE
	LD	(SETSW),A
	RET
;*
GETLA:
	CALL	SSCHK
	CALL	LINER		;CHECK FOR LABEL[+OFFSET]
	LD	A,1		;ONE LABEL
	LD	(CASE),A
	LD	A,(TOKEN)	;LOOK FOR COLON
	CP	22
	JP	NZ,S5
	CALL	GTOKN
	LD	A,(TOKEN)
	CP	31
	JP	Z,S35
	CP	38
	JP	NZ,S4
S35:	LD	A,3		;LABEL AND COLON PRESENT
	LD	(CASE),A
	JP	S5
S4:	CALL	LINER
	LD	A,2		;TWO LABELS PRESENT
	LD	(CASE),A
S5:	LD	A,1
	LD	(RESUL),A
	RET
;*
;**********     END OF COMMAND SUBROUTINES     **********
;*
;********************     ERROR MESSAGE TABLE     ********************
E0:	XOR	A		;MISSING LINESTART CHARACTER
	CALL	ERROR
E1:	LD	A,1		;STACK OVERFLOW
	CALL	ERROR
E2:	LD	A,2		;ARITHMETIC OVERFLOW
	CALL	ERROR
E3:	LD	A,3		;UNDEFINED LOCAL VARIABLE
	CALL	ERROR
E4:	LD	A,4		;ILLEGAL FUNCTION NAME
	CALL	ERROR
E5:	LD	A,5		;ILLEGAL COMMAND NAME
	CALL	ERROR
E6:	LD	A,6		;UNDEFINED PROGRAM NAME
	CALL	ERROR
E7:	LD	A,7		;UNDEFINED GLOBAL NAME
	CALL	ERROR
E8:	LD	A,8		;GLOBAL+VALUE TOO LONG
	CALL	ERROR
E9:	LD	A,9		;DIRECTORY FULL
	CALL	ERROR
E10:	LD	A,10		;PROGRAM LARGER THAN PARTITION
	CALL	ERROR
E11:	LD	A,11		;STRING TOO LONG
	CALL	ERROR
E12:	LD	A,12		;UNMATCHED PARENTHESES
	CALL	ERROR
E13:	LD	A,13		;ILLEGAL USE OF NOT OPERATOR
	CALL	ERROR
E14:	LD	A,14		;ILLEGAL COMMAND TERMINATOR
	CALL	ERROR
E15:	LD	A,15		;NAKED REFERENCE TOO LONG
	CALL	ERROR
E16:	LD	A,16		;UNAUTHORIZED GLOBAL ACCESS
	CALL	ERROR
E17:	LD	A,17		;DIVISION BY ZERO
	CALL	ERROR
E18:	LD	A,18		;ILLEGAL CHARACTER
	CALL	ERROR
E19:	LD	A,19		;SYNTAX STACK OVERFLOW
	CALL	ERROR
E20:	LD	A,(ACTFL)	;UNMARK SYMBOL TABLE (NOP UNLESS IN EXCLUSIVE KILL)
	OR	A
	CALL	Z,AC76
	LD	A,20		;ILLEGAL EXPRESSION
	CALL	ERROR
E21:	LD	A,21		;ILLEGAL PATTERN
	CALL	ERROR
E22:	LD	A,22		;MISSING COMMA
	CALL	ERROR
E23:	LD	A,23		;ILLEGAL VARIABLE NAME
	CALL	ERROR
E24:	LD	A,24		;ILLEGAL USE OF INDIRECTION
	CALL	ERROR
E25:	LD	A,25		;UNDEFINED ROUTINE LINE NUMBER
	CALL	ERROR
E26:	LD	A,26		;ILLEGAL NUMERIC LITERAL
	CALL	ERROR
E27:	LD	A,27		;MISSING EQUAL SIGN
	CALL	ERROR
E28:	LD	A,28		;ILLEGAL ROUTINE OR LABEL NAME
	CALL	ERROR
E29:	LD	A,29		;INVALID NAME SYNTAX
	CALL	ERROR
E30:	LD	A,30		;UNIMPLEMENTED COMMAND/FUNCTION
	CALL	ERROR
E31:	LD	A,31		;SYMBOL TABLE OVERFLOW
	CALL	ERROR
E32:	LD	A,32		;TOO MANY LEVELS OF NESTING
	CALL	ERROR
E33:	LD	A,33		;DUPLICATE LABEL
	CALL	ERROR
E34:	LD	A,34		;INVALID LINE REFERENCE
	CALL	ERROR
E35:	LD	A,35		;NO TRUE VALUE IN $SELECT
	CALL	ERROR
E36:	LD	A,36		;NAKED GLOBAL REFERENCE ILLEGAL
	CALL	ERROR
E37:	LD	A,37		;DISK WRITE ERROR
	CALL	ERROR
E38:	LD	A,38		;ROUTINE OR GLOBAL FILE NOT IN LIBRARY
	CALL	ERROR
E39:	LD	A,39		;DISK READ ERROR
	CALL	ERROR
E40:	LD	A,40		;ROUTINE IS UNNAMED
	CALL	ERROR
E41:	LD	A,41		;ROUTINE ALREADY IN LIBRARY
	CALL	ERROR
E42:	LD	A,42		;DELETE OR SAVE ROUTINE
	CALL	ERROR
E43:	LD	A,43		;INDIRECT MODE COMMAND ONLY
	CALL	ERROR
E44:	LD	A,44		;ILLEGAL WHILE IN BREAK
	CALL	ERROR
E45:	LD	A,45		;ONLY DURING BREAK
	CALL	ERROR
E46:	LD	A,46		;MISSING SUBSCRIPT
	CALL	ERROR
E47:	LD	A,47		;INVALID SUBSCRIPT
	CALL	ERROR
E48:	LD	A,48		;TOO MANY PARAMETERS
	CALL	ERROR
E49:	LD	A,49		;DEVICE NOT OPEN YET
	CALL	ERROR
E50:	LD	A,50		;INVALID DRIVE
	CALL	ERROR
E51:	LD	A,51		;WRITE ONLY DEVICE
	CALL	ERROR
E52:	LD	A,52		;INVALID DEVICE NUMBER
	CALL	ERROR
;*
;**********     END OF ERROR MESSAGES     **********
;*
;********************     COMMAND PRIMITIVES TABLE     ********************
;*
;**  ARGUMENT CONDITIONAL  **
ARGCO:
	CALL	SSCHK
	LD	A,1		;SET X RETURN
	LD	(CASE),A
	LD	A,(TOKEN)	;LOOK FOR COLON
	CP	22
	JP	NZ,P1
	CALL	GTOKN
	CALL	TVEXP		;CHECK FOR BOOLEAN EXPRESSION
P1:	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  COMMAND POSTCONDITIONAL AND DELIMITER  **
POSTC:
	CALL	SSCHK
	CALL	ARGCO		;CHECK FOR POSTCONDITIONAL EXPRESSION
	LD	A,(CASE)
	CP	1
	JP	Z,ARGUM
	LD	A,(ACTFL)	;SET SEMANTIC ACTION FLAG COMACT ON
	OR	A
	CALL	Z,AC29
ARGUM:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR SPACE
	CP	31
	JP	Z,P2
	CP	38		;LOOK FOR EOL
	JP	NZ,E14
	LD	A,(FLAG)	;SET END OF LINE
	OR	2
	LD	(FLAG),A
	LD	A,2		;Y-RETURN (NO ARGUMENTS, END OF LINE)
	LD	(CASE),A
	JP	P5
P2:	CALL	GTOKN
	LD	A,(TOKEN)	;LOOK FOR SECOND SPACE
	CP	31
	JP	NZ,P3
	CALL	GTOKN
	LD	A,3		;Z-RETURN (NO ARGS, MORE COMMANDS)
	LD	(CASE),A
	JP	P5
P3:	CALL	INDAR		;CHECK FOR INDIRECTION ON 1ST ARGUMENT
	LD	A,(RESUL)
	CP	1
	JP	NZ,P4
	LD	A,(CASE)	;W-RETURN (SYNTAX ONLY, 1ST ARG INDIR)
	CP	4
	JP	Z,P5
P4:	LD	A,1		;X-RETURN (ARGS PRESENT TO EVALUATE)
	LD	(CASE),A
P5:	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  COMMAND ARGUMENT ENDING  **
COMEN:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR COMMA
	CP	21
	JP	NZ,P7
	CALL	GTOKN
	CALL	INDAR		;CHECK FOR INDIRECTION ON NEXT ARGUMENT
	LD	A,(RESUL)
	CP	1
	JP	NZ,P6
	LD	A,(CASE)	;SYNTAX CHECKING ONLY, INDIR ARG
	CP	4
	JP	Z,COMEN
P6:	XOR	A
	LD	(RESUL),A
	RET
P7:	CALL	AC1		;TEST FOR EOI AND CLEAN OFF INDIRECTION
	LD	A,(RESUL)
	CP	1
	JP	Z,COMEN
FOREN:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR SPACE
	CP	31
	JP	Z,P8
	CP	38		;LOOK FOR EOL
	JP	NZ,E22
	LD	A,(FLAG)	;SET END OF LINE
	OR	2
	LD	(FLAG),A
	JP	P85
P8:	CALL	GTOKN
P85:	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  ARGUMENT LEVEL INDIRECTION  **
INDAR:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR AT SIGN
	CP	24
	JP	Z,P9
	XOR	A
	LD	(RESUL),A
	RET			;NO INDIRECTION
P9:	CALL	GTOKN
	CALL	EXPRA		;CHECK FOR EXPRESSION ATOM
	CALL	AC9		;TEST IF ARGUMENT INDIRECTION; SET FLAGS,CASE
	LD	A,(CASE)	;SYNTAX CHECKING OR NAME-LEVEL INDIR
	CP	1
	JP	NZ,P10
	LD	A,(TOKEN)	;LOOK FOR ANOTHER AT SIGN
	CP	24
	JP	Z,P9
P10:	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  NAME LEVEL INDIRECTION  **
INDNA:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR AT SIGN
	CP	24
	JP	Z,P11
	CALL	AC16		;TEST FOR FLAG FROM ARGUMENT LEVEL; SET CASE
	JP	P12
P11:	CALL	GTOKN
	CALL	EXPRA		;CHECK FOR EXPRESSION ATOM
	LD	A,4		;IN CASE SEMANTIC EXECUTION INHIBITED
	LD	(CASE),A
	LD	A,(ACTFL)	;SET NAMIND; EXECUTE STACK; SET CASE
	OR	A
	CALL	Z,AC109
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	1
	JP	NZ,P12
	LD	A,(TOKEN)	;LOOK FOR ANOTHER AT SIGN
	CP	24
	JP	Z,P11
P12:	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  FORMAT EXPRESSION  **
FORMA:
	CALL	SSCHK
	CALL	FRMAT		;CHECK FOR ONE FORMAT ATOM
	LD	A,(RESUL)
	CP	1
	JP	Z,P13
	CALL	TAB		;CHECK FOR TAB EXPRESSION
	LD	A,(RESUL)
	CP	1
	JP	Z,P14
	XOR	A
	LD	(RESUL),A
	RET			;NOT A FORMAT STATEMENT
P13:	CALL	FRMAT		;CHECK FOR ANOTHER FORMAT ATOM
	LD	A,(RESUL)
	CP	1
	JP	Z,P13
	CALL	TAB		;CHECK FOR FINAL TAB EXPRESSION
P14:	LD	A,1
	LD	(RESUL),A
	RET
;* FORMAT ATOM PRIMITIVE
FRMAT:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR LINE-FEED
	CP	12
	JP	NZ,P15
	CALL	GTOKN
	LD	A,(ACTFL)	;PERFORM CR-LF; RESET $X, INCREMENT $Y
	OR	A
	CALL	Z,AC24
	JP	P17
P15:	LD	A,(TOKEN)	;LOOK FOR PAGE-FEED
	CP	9
	JP	Z,P16
	XOR	A
	LD	(RESUL),A
	RET
P16:	CALL	GTOKN
	LD	A,(ACTFL)	;PREFORM CR-FF; RESET $X AND $Y
	OR	A
	CALL	Z,AC25
P17:	LD	A,1
	LD	(RESUL),A
	RET
;* TAB EXPRESSION PRIMITIVE
TAB:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR TAB
	CP	30
	JP	Z,P18
	XOR	A
	LD	(RESUL),A
	RET
P18:	CALL	GTOKN
	CALL	INTEX		;CHECK FOR INTEGER EXPRESSION
	LD	A,(ACTFL)	;TAB ACCORDING TO EXPRESSION VALUE, INC $X
	OR	A
	CALL	Z,AC28
	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  TIMEOUT CONDITIONAL  **
TIMEO:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR COLON
	CP	22
	JP	Z,P19
	XOR	A
	LD	(RESUL),A
	RET
P19:	CALL	GTOKN
	CALL	NUMEX		;CHECK FOR TIMEOUT EXPRESSION
	LD	A,(ACTFL)	;TEST EXPR AND SET TIMEOUT
	OR	A
	CALL	Z,AC91
	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  ROUTINE ENTRY  **
ENTRY:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR CARAT
	CP	20
	JP	NZ,P20
	CALL	GTOKN
	CALL	ROUTI		;CHECK FOR ROUTINE NAME
	LD	A,1		;ROUTINE NAME ONLY CASE
	LD	(CASE),A
	JP	P21
P20:	CALL	LINER		;CHECK FOR LABEL NAME[+OFFSET]
	XOR	A		;LABEL ONLY CASE
	LD	(CASE),A
	LD	A,(TOKEN)	;LOOK FOR CARAT
	CP	20
	JP	NZ,P21
	CALL	GTOKN
	CALL	ROUTI		;CHECK FOR ROUTINE NAME
	LD	A,2		;LABEL AND ROUTINE NAME CASE
	LD	(CASE),A
P21:	LD	A,1
	LD	(RESUL),A
	RET
;* ROUTINE NAME PRIMITIVE
ROUTI:
	CALL	SSCHK
	CALL	INDNA		;CHECK FOR ROUTINE NAME INDIRECTION
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,P22
	CALL	AC15		;TEST FOR ROUTINE NAME
	LD	A,(RESUL)
	CP	1
	JP	NZ,E28
	LD	A,(ACTFL)
	OR	A
	CALL	Z,AC123
	LD	A,(ACTFL)	;CHECK FOR END OF ALL LEVELS OF NAME INDIRECTION
	OR	A
	CALL	Z,AC110
P22:	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  LABEL OFFSET  **
LINER:
	CALL	SSCHK
	CALL	LABEL		;CHECK FOR LABEL NAME
LINOF:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR PLUS
	CP	5
	JP	Z,P23
	LD	A,(ACTFL)	;ZERO T-O-S (ZERO OFFSET)
	OR	A
	CALL	Z,AC20
	XOR	A
	LD	(RESUL),A
	RET
P23:	CALL	GTOKN
	CALL	INTEX		;CHECK FOR INTEGER OFFSET EXPRESSION
	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  LABEL  **
LABEL:
	CALL	SSCHK
	CALL	INDNA		;CHECK FOR LABEL INDIRECTION
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,P244
	CALL	AC15		;TEST FOR A NAME LABEL
	LD	A,(RESUL)
	CP	1
	JP	Z,P24
	CALL	AC17		;TEST FOR AN INTEGER LITERAL LABEL
	LD	A,(RESUL)
	CP	1
	JP	NZ,E28
P24:	LD	A,(ACTFL)
	OR	A
	CALL	Z,AC123
	LD	A,(ACTFL)	;CHECK FOR END OF ALL LEVELS OF NAME INDIRECTION
	OR	A
	CALL	Z,AC110
P244:	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  DEVICEPARAMETERS  **
PARAM:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR LEFT PARENTHESIS
	CP	25
	JP	Z,P245
	CALL	EXPR		;CHECK FOR SINGLE DEVICE PARAMETER
	LD	A,(ACTFL)	;CONVERT EXPR APPROPRIATELY AND INCREMENT COUNTER
	OR	A
	CALL	Z,AC106
	JP	P27
P245:	CALL	GTOKN
	JP	P26
P25:	CALL	EXPR		;CHECK FOR NEXT DEVICE PARAMETER
	LD	A,(ACTFL)	;CONVERT EXPR APPROPRIATELY AND INCREMENT COUNTER
	OR	A
	CALL	Z,AC106
	CALL	NXTPA		;CHECK FOR COLON OR RIGHT PARENTHESIS
	LD	A,(RESUL)	;NEIGHER PRESENT; MUST BE PARAM EXPR
	CP	1
	JP	NZ,P25
	LD	A,(CASE)	;RIGHT PARENTHESIS FOUND; DONE
	CP	2
	JP	Z,P27
P26:	CALL	NXTPA		;CHECK FOR ANOTHER COLON; OR RIGHT PARENTHESIS
	LD	A,(RESUL)	;NEITHER PRESENT; MUST BE PARAM EXPR
	CP	1
	JP	NZ,P25
	LD	A,(CASE)	;RIGHT PARENTHESIS FOUND; DONE
	CP	2
	JP	Z,P27
	LD	A,(ACTFL)	;SET TO DEFAULT PARAMETER
	OR	A
	CALL	Z,AC107
	JP	P26		;CONTINUE CHECKING FOR PARAMETERS
P27:	LD	A,1
	LD	(RESUL),A
	RET
;* NEXT PARAMETER DELIMITER
NXTPA:
	CALL	SSCHK
	LD	A,1		;COLON FOUND CASE
	LD	(CASE),A
	LD	A,(TOKEN)
	CP	22
	JP	Z,P28
	LD	A,2		;RIGHT PARENTHESIS FOUND CASE
	LD	(CASE),A
	LD	A,(TOKEN)	;LOOK FOR RIGHT PARENTHESIS
	CP	26
	JP	Z,P28
	XOR	A
	LD	(RESUL),A
	RET
P28:	LD	A,1
	LD	(RESUL),A
	CALL	GTOKN
	RET
;*
;**********     END OF COMMAND PRIMITIVES     **********
;*
;*
;********************     EXPRESSION TABLE     ********************
;*
;**  STRING-VALUE EXPRESSION  **
STREX:
	CALL	SSCHK
	CALL	EXPR		;CHECK FOR EXPRESSION
	LD	A,(ACTFL)	;CONVERT TO STRING VALUE
	OR	A
	CALL	Z,AC33
	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  NUMERIC-VALUE EXPRESSION  **
NUMEX:
	CALL	SSCHK
	CALL	EXPR		;CHECK FOR EXPRESSION
	LD	A,(ACTFL)	;CONVERT TO NUMERIC VALUE
	OR	A
	CALL	Z,AC34
	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  INTEGER-VALUE EXPRESSION  **
INTEX:
	CALL	SSCHK
	CALL	EXPR		;CHECK FOR EXPRESSION
	LD	A,(ACTFL)	;CONVERT TO INTEGER VALUE
	OR	A
	CALL	Z,AC32
	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  TRUTH-VALUE EXPRESSION  **
TVEXP:
	CALL	SSCHK
	CALL	EXPR		;CHECK FOR EXPRESSION
	LD	A,1		;IN CASE SEMANTIC EXECUTION INHIBITED
	LD	(CASE),A
	LD	A,(ACTFL)	;CONVERT TO TRUTH VALUE; SET X (1) OR Y (0) CASE
	OR	A
	CALL	Z,AC31
	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  EXPRESSION  **
EXPR:
	CALL	SSCHK
	CALL	EXPRA		;CHECK FOR EXPRESSION ATOM
X1:	CALL	AC4		;TEST FOR BINARYOP;STACK CODE IF FOUND
	LD	A,(RESUL)
	CP	1
	JP	Z,X5
	LD	A,(TOKEN)	;LOOK FOR APOSTROPHE (NOT)
	CP	4
	JP	Z,X3
	CP	30		;LOOK FOR QUESTION MARK (PATTERN)
	JP	NZ,X2
	LD	A,(FLG1)
	LD	B,A
	LD	A,NOTFL
	CPL
	AND	B
	LD	(FLG1),A
	CALL	GTOKN
	JP	X4
X2:	LD	A,1
	LD	(RESUL),A
	RET
X3:	CALL	GTOKN
	CALL	AC2		;TEST FOR TRUTHOP; COSE T-O-S
	LD	A,(RESUL)
	CP	1
	JP	Z,X5
	LD	A,(TOKEN)	;LOOK FOR QUESTION MARK (PATTERN)
	CP	30
	JP	NZ,E13
	CALL	GTOKN
	LD	A,(FLG1)
	OR	NOTFL
	LD	(FLG1),A
X4:	CALL	PATTE		;CHECK FOR PATTERN; PERFORM PATTERN MATCH
	LD	A,(ACTFL)
	OR	A
	CALL	Z,AC86
	JP	X1
X5:	CALL	EXPRA		;CHECK FOR SECOND EXPRESSION ATOM
	LD	A,(ACTFL)	;PERFORM OPERATION; RESULT T-O-S
	OR	A
	CALL	Z,AC43
	JP	X1
;*
;**  PATTERN EXPRESSION  **
PATTE:
	CALL	SSCHK
	LD	A,(ACTFL)	;CONVERT T-O-S TO STRING
	OR	A
	CALL	Z,AC33
	LD	HL,(TOS)
	LD	(TARPT),HL
	CALL	INDNA		;CHECK FOR PATTERN INDIRECTION
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,X7
	CALL	PATAT		;CHECK FOR ONE PATTERN ATOM
	LD	A,(RESUL)
	CP	1
	JP	NZ,E21
X6:	CALL	PATAT		;CHECK FOR PATTERN ATOM
	LD	A,(RESUL)
	CP	1
	JP	Z,X6
	LD	A,(ACTFL)	;TEST FOR END OF ALL LEVELS OF NAME INDIRECTION
	OR	A
	CALL	Z,AC110
X7:	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  PATTERN ATOM  **
PATAT:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR PERIOD
	CP	28
	JP	NZ,X8
	CALL	GTOKN
	LD	A,(ACTFL)	;MINUS ONE T-O-S (ANY NUMBER OF PATTERNS)
	OR	A
	CALL	Z,AC115
	JP	X9
X8:	CALL	AC11		;TEST FOR AN INTEGER LITERAL; STACK IF FOUND
	LD	A,(RESUL)
	CP	1
	JP	Z,X9
	XOR	A
	LD	(RESUL),A
	RET
X9:	CALL	AC7		;TEST FOR PATTERN CODE(S); INTO PATWRD IF FOUND
	LD	A,(RESUL)
	CP	1
	JP	Z,X10
	CALL	AC6		;TEST FOR A STRING LITERAL; STACK IF FOUND
	LD	A,(RESUL)
	CP	1
	JP	NZ,E21
X10:	LD	A,1
	LD	(RESUL),A
	RET
;*
;**********     END OF EXPR CONSTRUCTS     **********
;*
;*
;********************     EXPRESSION ATOM TABLE     ********************
;*
;**  EXPRESSION ATOM  **
EXPRA:
	CALL	SSCHK
	LD	A,(ACTFL)	;ZERO T-O-S (NO. OF UNARYOPS)
	OR	A
	CALL	Z,AC20
	CALL	AC8		;TEST FOR UNARYOP(S); STACK IF FOUND
	LD	A,(TOKEN)	;LOOK FOR LEFT PARENTHESIS
	CP	25
	JP	NZ,A2
	CALL	GTOKN
	CALL	EXPR		;CHECK FOR EXPRESSION
	LD	A,(TOKEN)	;LOOK FOR RIGHT PARENTHESIS
	CP	26
	JP	NZ,E12
	CALL	GTOKN
A1:	LD	A,(ACTFL)	;APPLY UNARYOPS TO VALUE; RESULT T-O-S
	OR	A
	CALL	Z,AC19
	LD	A,1
	LD	(RESUL),A
	RET
A2:	CALL	AC10		;TEST FOR NUMERIC LITERAL; STACK IF FOUND
	LD	A,(RESUL)
	CP	1
	JP	Z,A1
	CALL	AC6		;TEST FOR A STRING LITERAL; STACK IF FOUND
	LD	A,(RESUL)
	CP	1
	JP	Z,A1
	CALL	FUNCT		;CHECK FOR FUNCTION REFERENCE
	LD	A,(RESUL)
	CP	1
	JP	Z,A1
	CALL	LVN		;CHECK FOR LOCAL VARIABLE
	LD	A,(RESUL)
	CP	1
	JP	NZ,A3
	LD	A,(ACTFL)	;SEARCH SYMBOL TABLE FOR LVN; VALUE T-O-S
	OR	A
	CALL	Z,AC81
	JP	A1
A3:	CALL	GVN		;CHECK FOR GLOBAL VARIABLE
	LD	A,(RESUL)	;ERROR, NOT AN EXPRESSION ATOM
	CP	1
	JP	NZ,E20
	LD	A,(ACTFL)	;SEARCH GLOBAL FILE FOR GVN; VALUE T-O-S
	OR	A
	CALL	Z,AC85
	JP	A1
;*
;**  VARIABLE  **
GLVN:
	CALL	SSCHK
	CALL	LVN		;CHECK FOR LOCAL VARIABLE
	LD	A,(RESUL)
	CP	1
	JP	NZ,A4
	LD	A,(ACTFL)	;ONE T-O-S (LOCAL VARIABLE)
	OR	A
	CALL	Z,AC35
	JP	A5
A4:	CALL	GVN		;CHECK FOR GLOBAL VARIABLE
	LD	A,(RESUL)
	CP	1
	JP	NZ,E23
	LD	A,(ACTFL)	;MINUS ONE T-O-S (GLOBAL VARIABLE)
	OR	A
	CALL	Z,AC70
A5:	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  LOCAL VARIABLE NAME  **
LVN:
	CALL	SSCHK
	CALL	INDNA		;CHECK FOR LOCAL VARIABLE INDIRECTION
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,A10
	XOR	A
	LD	(GLB),A
	CALL	AC15		;TEST FOR VARIABLE NAME
	LD	A,(RESUL)
	CP	1
	JP	Z,SUBSC
	XOR	A
	LD	(RESUL),A
	RET			;NOT A LOCAL REFERENCE
;*
;**  GLOBAL VARIABLE NAME  **
GVN:
	CALL	SSCHK
	CALL	INDNA		;CHECK FOR GLOBAL VARIABLE INDIRECTION
	LD	A,(CASE)	;SYNTAX CHECKING ONLY
	CP	4
	JP	Z,A10
	LD	A,(TOKEN)	;LOOK FOR CARAT
	CP	20
	JP	Z,A6
	XOR	A		;NOT A GLOBAL REFERENCE
	LD	(RESUL),A
	RET
A6:	CALL	GTOKN
	LD	A,1
	LD	(GLB),A
	LD	A,(TOKEN)	;LOOK FOR LEFT PARENTHESIS
	CP	25
	JP	NZ,A7
	CALL	GTOKN
	CALL	AC5		;TEST FOR LOCK; CARAT,ZERO T-O-S (NAKED REFERENCE)
	JP	A8
A7:	CALL	AC15		;TEST FOR VARIABLE NAME
	LD	A,(RESUL)
	CP	1
	JP	NZ,E23
;* SUBSCRIPT LIST PRIMITIVE
SUBSC:	LD	A,(ACTFL)
	OR	A
	CALL	Z,AC27
	LD	A,(ACTFL)	;ZERO T-O-S (NO. OF SUBSCRIPTS)
	OR	A
	CALL	Z,AC20
	LD	A,(TOKEN)	;LOOK FOR LEFT PARENTHESIS
	CP	25
	JP	NZ,A9
A75:	CALL	GTOKN
A8:	LD	A,(ACTFL)
	OR	A
	CALL	Z,AC100
	CALL	EXPR		;CHECK FOR SUBSCRIPT EXPRESSION
	LD	A,(ACTFL)	;STACK EXPRESSION VALUE AS INTEGER
	OR	A
	CALL	Z,AC22
	LD	A,(TOKEN)	;LOOK FOR COMMA (MORE SUBSCRIPTS)
	CP	21
	JP	Z,A75
	CP	26		;LOOK FOR RIGHT PARENTHESIS
	JP	NZ,E12
	CALL	GTOKN
A9:	LD	A,(ACTFL)	;CHECK END OF ONE OR MORE LEVELS OF NAME INDIRECTION
	OR	A
	CALL	Z,AC108
	XOR	A
	LD	(GLB),A
A10:	LD	A,1
	LD	(RESUL),A
	RET
;*
;**  FUNCTION  **
FUNCT:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR DOLLAR SIGN
	CP	27
	JP	Z,A11
	XOR	A		;NOT A FUNCTION OR SPECIAL VARIABLE
	LD	(RESUL),A
	RET
A11:	CALL	GTOKN
	CALL	AC3		;GET FUNCTION/SPECIAL VARIABLE NAME
	LD	A,1
	LD	(RESUL),A
	RET
;*     AC3 SCANS OFF THE LEFT PARENTHESIS FOR FUNCTIONS; RETURNS WITH
;*     THE SPECIAL VARIABLE VALUE ON THE STACK, OR BRANCHES TO FUNCTION
;*
;**********     END OF EXPRATOM CONSTRUCTS     *****
;*
;*
;********************     FUNCTION TABLE     ********************
;*
;** ASCII FUNCTION
ASCII:	CALL	FSIEX		;CHECK FOR STRING-INTEGER EXPRESSION
	LD	A,(ACTFL)	;STORE ASCII CODE OF POSITION T-O-S
	OR	A
	CALL	Z,AC36
	JP	FEND
;*
;** CHARACTER FUNCTION
CHAR:	LD	A,(ACTFL)	;CHARACTER FUNCTION
	OR	A
	CALL	Z,AC20
F1:	CALL	INTEX		;CHECK FOR NEXT (INTEGER) EXPRESSION
	LD	A,(ACTFL)	;CONVERT TO TEXT; STORE NEW STRING T-O-S
	OR	A
	CALL	Z,AC46
	LD	A,(TOKEN)	;LOOK FOR COMMA
	CP	21
	JP	NZ,F05
	CALL	GTOKN
	JP	F1
F05:	LD	A,(ACTFL)	;COMPRESS CHARACTER STRING ON STACK
	OR	A
	CALL	Z,AC104
	JP	FEND
;*
;** DATA FUNCTION
DATA:	CALL	GLVN		;CHECK FOR VARIABLE
	LD	A,(ACTFL)	;FIND VARIABLE; RETURN CHARACTERIZATION
	OR	A
	CALL	Z,AC38
	JP	FEND
;*
;** EXTRACT FUNCTION
EXTRA:	CALL	FSIEX		;CHECK FOR STRING-INTEGER EXPRESSION
	LD	A,(RESUL)
	CP	1
	JP	NZ,E22
	CALL	FIEXP		;CHECK FOR THIRD (INTEGER) EXPRESSION
	LD	A,(ACTFL)	;EXTRACT CHARACTERS; STORE T-O-S
	OR	A
	CALL	Z,AC40
	JP	FEND
;*
;** FIND FUNCTION
FIND:	CALL	FSSEX		;CHECK FOR STRING-STRING-INTEGER EXPR
	LD	A,(ACTFL)	;PERFORM SEARCH; RETURN NUMBER T-O-S
	OR	A
	CALL	Z,AC41
	JP	FEND
;*
;** JUSTIFY FUNCTION
JUSTI:	CALL	EXPR		;CHECK FOR EXPRESSION TO BE JUSTIFIED
	CALL	FIEXP		;CHECK FOR SECOND (INTEGER) EXPRESSION
	LD	A,(RESUL)
	CP	1
	JP	NZ,E22
	CALL	FIEXP		;CHECK FOR THIRD (INTEGER) EXPRESSION
	LD	A,(ACTFL)	;JUSTIFY 1ST EXPR ACCORDING TO 2ND (AND 3RD) EXPR
	OR	A
	CALL	Z,AC21
	JP	FEND
;*
;** LENGTH FUNCTION
LENGT:	CALL	STREX		;CHECK FOR (STRING) EXPRESSION
	LD	A,(ACTFL)	;RETURN LENGTH OF STRING T-O-S
	OR	A
	CALL	Z,AC42
	JP	FEND
;*
;** NEXT FUNCTION
NEXT:	LD	A,1
	LD	(DN),A
	CALL	GLVN		;CHECK FOR VARIABLE
	LD	A,(ACTFL)	;FIND NEXT VARIABLE SUBSCRIPT; RETURN VALUE
	OR	A
	CALL	Z,AC50
	XOR	A
	LD	(DN),A
	JP	FEND
;*
;** ORDER FUNCTION
ORDER:	LD	A,1
	LD	(DOR),A
	CALL	GLVN		;CHECK FOR VARIABLE
	LD	A,(ACTFL)	;FIND NEXT VARIABLE SUBSCRIPT; RETURN VALUE
	OR	A
	CALL	Z,AC50
	XOR	A
	LD	(DOR),A
	JP	FEND
;*
;** PIECE FUNCTION
PIECE:	CALL	FSSEX		;CHECK FOR STRING-STRING-INTEGER EXPR
	LD	A,(RESUL)
	CP	1
	JP	NZ,E22
	CALL	FIEXP		;CHECK FOR FOURTH (INTEGER) EXPRESSION
	LD	A,(ACTFL)	;GET PIECES; PLACE RESULT T-O-S
	OR	A
	CALL	Z,AC45
	JP	FEND
;*
;** RANDOM FUNCTION
RANDO:	CALL	INTEX		;CHECK FOR INTEGER EXPRESSION
	LD	A,(ACTFL)	;COMPUTE "RANDOM" INTEGER; STORE VALUE T-O-S
	OR	A
	CALL	Z,AC52
	JP	FEND
;*
;** SELECT FUNCTION
SELEC:	CALL	AC12		;SAVE LINACT AND COMACT
F2:	CALL	TVEXP		;CHECK FOR BOOLEAN EXPRESSION
	LD	A,(TOKEN)	;LOOK FOR COLON
	CP	22
	JP	NZ,E18
	CALL	GTOKN
	LD	A,(ACTFL)
	OR	A
	JP	NZ,F25
	LD	A,(CASE)	;BOOLEAN TRUE
	CP	1
	JP	Z,F3
	LD	A,(ACTFL)	;TURN COMACT ON
	OR	A
	CALL	Z,AC29
F25:	CALL	EXPR		;CHECK FOR SECOND EXPRESSION
	CALL	AC13		;TURN COMACT OFF
	JP	F4
F3:	CALL	EXPR		;CHECK FOR RESULT EXPRESSION
	LD	A,(ACTFL)	;TURN LINACT ON
	OR	A
	CALL	Z,AC105
F4:	LD	A,(TOKEN)	;LOOK FOR COMMA
	CP	21
	JP	NZ,F45
	CALL	GTOKN
	JP	F2		;MOVE EXPRESSIONS
F45:	CALL	AC14		;RESTORE LINACT AND COMACT
	JP	FEND
;*
;** TEXT FUNCTION
TEXT:	CALL	LINOF		;CHECK FOR LINE NUMBER
	LD	A,(RESUL)
	CP	1
	JP	NZ,F5
	LD	A,(ACTFL)	;RETURNS NTH LINE OF ROUTINE
	OR	A
	CALL	Z,AC84
	JP	FEND
F5:	CALL	LINER		;CHECK FOR LABEL[+OFFSET]
	LD	A,(ACTFL)	;RETURNS LINE TEXT OF LABEL[+OFFSET]
	OR	A
	CALL	Z,AC74
	JP	FEND
;*
;** VIEW FUNCTION
VIEW:	JP	E30		;NOT IMPLEMENTED
	JP	FEND
;*
;** Z (ESCAPE) FUNCTIONS
;*     IMPLEMENTATION SPECIFIC FUNCTIONS ARE ADDED HERE
ZGRA:	CALL	INTEX		;CHECK FOR INTEGER EXPRESSION
	LD	A,(ACTFL)	;GET ARG BYTE; STORE T-0-S AS INTEGER
	OR	A
	CALL	Z,AC122
	JP	FEND
;*
;**********     END OF FUNCTIONS     **********
;*
;*
;********************     FUNCTION PRIMITIVE TABLE     ********************
;*
;** TWO STRINGS, THEN INTEGER EXPRESSION PRIMITIVE
FSSEX:
	CALL	SSCHK
	CALL	STREX		;CHECK FOR 1ST (STRING) EXPRESSION
	LD	A,(TOKEN)	;LOOK FOR COMMA
	CP	21
	JP	NZ,E22
	CALL	GTOKN
;*
;** STRING THEN INTEGER EXPRESSION PRIMITIVE
FSIEX:
	CALL	SSCHK
	CALL	STREX		;CHECK FOR STRING EXPRESSION
;*
;** INTEGER EXPRESSION PRIMITIVE
FIEXP:
	CALL	SSCHK
	LD	A,(TOKEN)	;LOOK FOR COMMA
	CP	21
	JP	Z,FP1
	XOR	A
	LD	(RESUL),A
	RET
FP1:	CALL	GTOKN
	CALL	INTEX		;CHECK FOR ITEGER EXPRESSION
	LD	A,1
	LD	(RESUL),A
	RET
;*
;** FUNCTION ENDING PRIMITIVE
FEND:	LD	A,(TOKEN)	;LOOK FOR RIGHT PARENTHESIS
	CP	26
	JP	NZ,E12
	CALL	GTOKN
	LD	A,1
	LD	(RESUL),A
	RET
;*
;**********     END OF FUNCTION PRIMITIVES     **********
;*
;** END OF INTERP.TDL
;* BEGINNING OF TDL ACTION ROUTINES
;*
AC1:	;CHECK FOR ARGUMENT LEVEL INDIRECTION
	CALL	SSCHK
	XOR	A
	LD	(RESUL),A
	LD	A,(INDFL)
	CP	2
	JP	NZ,A0011
	LD	A,(TOKEN)
	CP	40
	JP	NZ,E24
	CALL	INDRE		;RETURN FROM INDIRECTION
	LD	A,1
	LD	(RESUL),A
A0011:	RET
;*
;*
AC2:
	CALL	SSCHK
	XOR	A		;CHECK FOR TRUTH OP
	LD	(RESUL),A
	LD	A,(TOKEN)
	CP	11
	JP	C,A0022
	CP	17
	JP	C,$+6
	JP	NZ,A0022
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0021
	LD	A,(TOKEN)
	CP	14
	JP	C,$+6
	JP	NZ,A0020
	CALL	AC34		;CONVERT OP #1 TO REAL EXPR
	JP	A002A
A0020:	CALL	AC33		;CONVERT OP #1 TO STRING
A002A:	LD	A,(TOKEN)	;SET NOT
	ADD	A,50
	LD	(TOKEN),A
	LD	HL,TOKEN	;SAVE OP ON STACK
	LD	B,1
	CALL	PUSHT
A0021:	LD	A,1
	LD	(RESUL),A
	CALL	GTOKN		;GET NEXT TOKEN
A0022:	RET
;*
;*
AC3:	;CHECK FOR FUNCTION AND SPECIAL VARS
	CALL	SSCHK
	LD	HL,(INDX)	;SAVE INDX
	LD	(PTR1),HL
A0031:	LD	A,(TOKEN)	;MOVE PAST NAME
	CP	2
	JP	NZ,A0032
	CALL	GTOKN
	JP	A0031
A0032:	LD	A,(TOKEN)	;CHECK FOR (
	CP	25
	JP	Z,A0033
	LD	A,2		;SPECIAL VARIABLE
	LD	(FNC),A
	JP	A0034
A0033:	LD	A,1		;FUNCTION
	LD	(FNC),A
A0034:	LD	HL,(PTR1)	;PUT INDX BACK
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	CALL	GTCOM
	RET
;*
;*
HOROL:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0037
	CALL	GETTI		;GET CURRENT TIME
	LD	HL,DAYS		;SAVE DAYS
	CALL	ITS
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I1		;GET DAYS LENGTH
	LD	B,1
	CALL	POPIT
	LD	A,','		;PUSH HOROLOG DELIMITER
	CALL	CPUSH
	LD	HL,SECS		;SAVE SECONDS
	CALL	ITS
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I2		;GET SECONDS LENGTH
	LD	B,1
	CALL	POPIT
	LD	A,(I1)		;ADD SECONDS AND DAYS LENGTH
	LD	HL,I2
	ADD	A,(HL)
	LD	(I1),A
	LD	HL,I1		;ALLOW FOR ,
	INC	(HL)
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	RET
;*
IO:	LD	A,(IODVC)	;$IO
	LD	(IT),A
	JP	A0036
;*
JOB:	LD	A,(JOBNM)	;$JOB
	LD	(IT),A
	JP	A0036
;*
STORA:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0037
	CALL	GARBG
	LD	HL,(SYMEN)	;$STORAGE
	LD	(TPP),HL
	LD	HL,(PRGEN)
	EX	DE,HL
	LD	HL,(TPP)
	CALL	PSUB
	LD	(TPP),HL
	CALL	PTS
	RET
;*
TEST:	LD	A,(SWIF)	;$TEST
	CP	2
	JP	Z,E3
	LD	(IT),A
	JP	A0036
;*
X:	LD	DE,INT1		;$X
	LD	HL,(DEVX)
	EX	DE,HL
	CALL	SETI
	JP	A0035
;*
Y:	LD	DE,INT1		;$Y
	LD	HL,(DEVY)
	EX	DE,HL
	CALL	SETI
	JP	A0035
;*
ZNAME:	LD	A,(ACTFL)	;$ZNAME
	OR	A
	JP	NZ,A0037
	XOR	A
	LD	(IT),A
	LD	HL,PRG
	LD	(PTR),HL
ZN1:	LD	HL,(PTR)
	LD	A,(HL)
	CP	BLANK
	JP	Z,ZN2
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,IT
	INC	(HL)
	JP	ZN1
ZN2:	LD	HL,IT
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	RET
;*
A0035:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0037
	LD	HL,INT1
	CALL	ITS
	RET
A0036:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0037
	LD	A,(IT)
	CALL	CTS
A0037:	RET
;*
;*
AC4:	;BINARY OPERATOR
	CALL	SSCHK
	XOR	A
	LD	(RESUL),A
	LD	A,(TOKEN)
	CP	5
	JP	C,A0044
	CP	18
	JP	C,$+6
	JP	NZ,A0044
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0043
	LD	A,(TOKEN)
	CP	14
	JP	C,$+6
	JP	NZ,A0041
	CALL	AC34		;CONVERT OP #1 TO NUMBER
	JP	A0042
A0041:	CALL	AC33		;CONVERT OP #1 TO STRING
A0042:	LD	HL,TOKEN	;SAVE OP
	LD	B,1
	CALL	PUSHT
A0043:	LD	A,1
	LD	(RESUL),A
	CALL	GTOKN
A0044:	RET
;*
AC5:	;NAKED REFERENCE
	CALL	SSCHK
	LD	A,(LOCKS)
	CP	1
	JP	Z,E36
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0051
	LD	A,1
	LD	(NR),A
	XOR	A
	CALL	CPUSH
	CALL	AC27
	XOR	A
	CALL	CPUSH
A0051:	RET
;*
;*
AC6:
	CALL	SSCHK
	XOR	A		;TEST FOR STRING LITERAL
	LD	(RESUL),A
	LD	A,(TOKEN)
	CP	23
	JP	NZ,A0064
	LD	A,1		;IT IS A STRING
	LD	(RESUL),A
	XOR	A		;INITIALIZE CHARACTER COUNT
	LD	(NUMBR),A
	LD	A,(PF)
	OR	A
	JP	Z,A0061
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0061
	LD	HL,INT1
	CALL	STI
	LD	HL,(TOS)
	LD	DE,INT1
	CALL	SETI
	LD	HL,(TOS)
	LD	DE,INTLN
	ADD	HL,DE
	LD	(TOS),HL
	LD	(TPP),HL
	LD	DE,INTLN
	ADD	HL,DE
	LD	(TOS),HL
A0061:	CALL	GTOKN
	LD	A,(TOKEN)
	CP	23
	JP	NZ,A0062
	CALL	GTOKN
	LD	A,(TOKEN)	;IS IT END OF STRING?
	CP	23
	JP	NZ,A0063
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0061
	LD	A,'"'
	CALL	CPUSH
	LD	HL,NUMBR
	INC	(HL)
	JP	A0061
A0062:	LD	A,(TOKEN)	;IF GRAPHIC CHARACTER, PUSH IT
	CP	1
	JP	C,E18
	CP	36
	JP	C,$+6
	JP	NZ,E18
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0061
	LD	HL,(INDX)
	LD	B,1
	CALL	PUSHT
	LD	HL,NUMBR
	INC	(HL)
	JP	A0061
A0063:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0064
	LD	A,(PF)
	OR	A
	JP	Z,A006A
	LD	HL,INT1
	LD	A,(NUMBR)
	CALL	CTI
	LD	HL,(TPP)
	LD	DE,INT1
	CALL	SETI
	JP	A0064
A006A:	LD	HL,NUMBR	;SAVE LENGTH OF STRING
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
A0064:	XOR	A
	LD	(PF),A
	RET
;*
AC7:	;CHECK FOR PATATOM
	CALL	SSCHK
	XOR	A
	LD	(RESUL),A
	LD	(PATF),A
A0070:	LD	A,(TOKEN)
	CP	2
	JP	Z,A0071
	LD	A,1		;SET FLAG FOR AC6
	LD	(PF),A
	JP	A007I
A0071:	LD	HL,(INDX)
	LD	A,(HL)
	CP	'U'
	JP	NZ,A0072
	LD	A,(PATF)
	OR	1
	LD	(PATF),A
	JP	A0078
A0072:	LD	HL,(INDX)
	LD	A,(HL)
	CP	'L'
	JP	NZ,A0073
	LD	A,(PATF)
	OR	2
	LD	(PATF),A
	JP	A0078
A0073:	LD	HL,(INDX)
	LD	A,(HL)
	CP	'A'
	JP	NZ,A0074
	LD	A,(PATF)
	OR	4
	LD	(PATF),A
	JP	A0078
A0074:	LD	HL,(INDX)
	LD	A,(HL)
	CP	'N'
	JP	NZ,A0075
	LD	A,(PATF)
	OR	8
	LD	(PATF),A
	JP	A0078
A0075:	LD	HL,(INDX)
	LD	A,(HL)
	CP	'P'
	JP	NZ,A0076
	LD	A,(PATF)
	OR	16
	LD	(PATF),A
	JP	A0078
A0076:	LD	HL,(INDX)
	LD	A,(HL)
	CP	'C'
	JP	NZ,A0077
	LD	A,(PATF)
	OR	32
	LD	(PATF),A
	JP	A0078
A0077:	LD	HL,(INDX)
	LD	A,(HL)
	CP	'E'
	JP	NZ,E21
	LD	A,(PATF)
	OR	64
	LD	(PATF),A
A0078:	CALL	GTOKN
	LD	A,(TOKEN)	;GET NEXT ONE
	CP	2
	JP	Z,A0071
	LD	A,1
	LD	(RESUL),A
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A007I
	LD	HL,INT1
	CALL	STI
	LD	HL,(TOS)
	LD	DE,INT1
	CALL	SETI
	LD	HL,(TOS)
	LD	DE,INTLN
	ADD	HL,DE
	LD	(TOS),HL
	LD	(TPP),HL
	XOR	A
	LD	(COUNT),A
	LD	DE,INTLN
	ADD	HL,DE
	LD	(TOS),HL
	LD	A,(PATF)
	AND	64
	JP	Z,A0079
	LD	A,(PATF)	;ONLY SET E BIT IF AN E
	LD	B,A
	LD	A,63
	CPL
	AND	B
	LD	(PATF),A
	JP	A007G
A0079:	LD	A,(PATF)
	AND	1
	JP	Z,A007A
	LD	A,(PATF)
	AND	2
	JP	Z,A007A
	LD	A,(PATF)	;BOTH L AND U SET SO SET A
	LD	B,A
	LD	A,3
	CPL
	AND	B
	OR	4
	LD	(PATF),A
A007A:	LD	A,(PATF)
	AND	1
	JP	Z,A007B
	LD	A,'U'
	CALL	CPUSH
	LD	HL,COUNT
	INC	(HL)
A007B:	LD	A,(PATF)
	AND	2
	JP	Z,A007C
	LD	A,'L'
	CALL	CPUSH
	LD	HL,COUNT
	INC	(HL)
A007C:	LD	A,(PATF)
	AND	4
	JP	Z,A007D
	LD	A,'A'
	CALL	CPUSH
	LD	HL,COUNT
	INC	(HL)
A007D:	LD	A,(PATF)
	AND	8
	JP	Z,A007E
	LD	A,'N'
	CALL	CPUSH
	LD	HL,COUNT
	INC	(HL)
A007E:	LD	A,(PATF)
	AND	16
	JP	Z,A007F
	LD	A,'P'
	CALL	CPUSH
	LD	HL,COUNT
	INC	(HL)
A007F:	LD	A,(PATF)
	AND	32
	JP	Z,A007G
	LD	A,'C'
	CALL	CPUSH
	LD	HL,COUNT
	INC	(HL)
A007G:	LD	A,(PATF)
	AND	64
	JP	Z,A007H
	LD	A,'E'
	CALL	CPUSH
	LD	HL,COUNT
	INC	(HL)
A007H:	LD	HL,INT1
	LD	A,(COUNT)
	CALL	CTI
	LD	A,(HL)
	XOR	0F0H
	LD	(HL),A
	LD	HL,(TPP)
	LD	DE,INT1
	CALL	SETI
A007I:	RET
;*
;*
AC8:	;UNARY OPERATOR
	CALL	SSCHK
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0081
	LD	HL,IT		;GET UNARY OP COUNT
	LD	B,1
	CALL	POPIT
A0081:	LD	A,(TOKEN)
	CP	4
	JP	C,A0083
	CP	6
	JP	C,$+6
	JP	NZ,A0083
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0082
	LD	HL,TOKEN	;SAVE UNARY OP
	LD	B,1
	CALL	PUSHT
A0082:	LD	HL,IT		;INCREMENT COUNT
	INC	(HL)
	CALL	GTOKN
	JP	A0081
A0083:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0084
	LD	HL,IT		;SAVE COUNT
	LD	B,1
	CALL	PUSHT
A0084:	RET
;*
;*
AC9:	;CHECK FOR NAME LEVEL INDIRECTION
	CALL	SSCHK
	LD	A,1
	LD	(IT),A
	LD	A,4
	LD	(CASE),A
	LD	A,(TOKEN)	;CHECK FOR COMMA
	CP	21
	JP	Z,A0091
	CP	31		;CHECK FOR SPACE
	JP	Z,A0091
	CP	38		;CHECK FOR EOL
	JP	Z,A0091
	CP	40		;CHECK FOR EOI
	JP	NZ,A0092
A0091:	LD	A,2
	LD	(IT),A
A0092:	LD	A,(ACTFL)
	OR	A
	JP	Z,A0094
	LD	A,(IT)
	CP	2
	JP	Z,A0093
	LD	A,255		;SET FLAG FOR AC16
	LD	(TOKEN),A
	LD	A,3
	LD	(CASE),A
A0093:	RET
A0094:	CALL	AC33
	LD	HL,TYPE
	LD	B,1
	CALL	POPIT
A009A:	LD	HL,SLENG
	LD	B,1
	CALL	POPIT
	LD	A,(SLENG)
	LD	(N),A
	LD	HL,(TOS)
	LD	(PTR),HL
	XOR	A
	LD	(I1),A
A0095:	LD	A,(N)
	OR	A
	JP	Z,A0096
	LD	HL,(PTR)
	DEC	HL
	LD	(PTR),HL
	LD	HL,N
	DEC	(HL)
	LD	HL,(PTR)
	LD	A,(HL)
	CP	EOL
	JP	Z,E24
	LD	A,(HL)
	CP	EOI
	JP	Z,E24
	LD	A,(HL)
	CP	BLANK
	JP	Z,A009B
	LD	A,(HL)
	CP	'"'
	JP	NZ,A0095
	LD	A,1		;TOGGLE I1 (INSIDE A STRING = 1)
	LD	HL,I1
	SUB	(HL)
	LD	(I2),A
	LD	(I1),A
	JP	A0095
A009B:	LD	A,(I1)		;QUOTE NOT INSIDE A STRING
	OR	A
	JP	Z,E24
	JP	A0095
A0096:	LD	HL,SLENG	;SAVE INDIRECT STRING
	INC	(HL)
	LD	HL,LEVEL
	INC	(HL)
	LD	A,(LEVEL)
	CP	MXLVL
	JP	Z,E32
	LD	A,EOI
	CALL	CPUSH
	LD	HL,SLENG
	LD	B,1
	CALL	PUSHT
	LD	HL,INDX
	LD	B,2
	CALL	PUSHT
	LD	HL,(PTR)
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	LD	A,(IT)
	CP	2
	JP	Z,A0097
	LD	A,(TOKEN)	;CHECK FOR NUMBERS AND LETTERS
	CP	4
	JP	C,A0097
	CP	19		;CHECK FOR PER CENT
	JP	Z,A0097
	CP	20		;CHEC2 FOR CIRCUMFLEX
	JP	NZ,E24
A0097:	LD	HL,INDFL
	LD	B,1
	CALL	PUSHT
	LD	A,(IT)
	LD	(INDFL),A
	LD	A,3
	LD	HL,IT
	SUB	(HL)
	LD	(CASE),A
	RET
;*
;*
AC10:	;CHECK FOR NUMLIT
	CALL	SSCHK
	XOR	A		;MINUS FLAG
	LD	(SGN1),A
	LD	A,255		;SET DIGIT COUNT
	LD	(I1),A
	XOR	A		;IT=1 IF IT'S A NUMBER
	LD	(IT),A
	LD	(I2),A		;SIZE OF INTEGER PART
	LD	(I3),A		;SIZE OF DECIMAL FRACTION
	LD	A,(FLG1)
	AND	STRNG
	JP	Z,A0100
	LD	A,(SLENG)	;IF FROM STRING BET DIGIT COUNT
	LD	(I1),A
A0100:	LD	A,TRUE		;DELETE LEADING ZEROS
	LD	(DELET),A
	LD	HL,(TOS)	;SAVE START OF INTEGER
	LD	(PTRX1),HL
	CALL	AC11		;CHECK FOR INTLIT
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,A101A
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0101
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I2		;GET SIZE OF INTEGER PART
	LD	B,1
	CALL	POPIT
A0101:	LD	A,1		;IT'S A NUMLIT
	LD	(IT),A
A101A:	LD	HL,(TOS)	;SAVE DECIMAL PLACE
	LD	(PTRX2),HL
	LD	A,(TOKEN)	;CHECK IF #.
	CP	28
	JP	NZ,A0103
	CALL	GTOKN
	LD	HL,I1
	DEC	(HL)
	LD	A,(I1)
	OR	A
	JP	Z,A010E
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A101B
	LD	A,(I2)
	CP	1
	JP	NZ,A101E
	LD	HL,(PTRX1)
	LD	A,(HL)
	CP	'0'
	JP	NZ,A101E
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	XOR	A
	LD	(I2),A
	LD	HL,(PTRX2)
	DEC	HL
	LD	(PTRX2),HL
A101E:	LD	A,'.'		;ADD DECIMAL PLACE
	CALL	CPUSH
A101B:	CALL	AC11		;CHECK IF #.#
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,A0102
	LD	A,TRUE		;IT'S A NUMLIT
	LD	(IT),A
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0103
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I3		;GET COUNT OF DECIMAL DIGITS
	LD	B,1
	CALL	POPIT
A101C:	LD	HL,CHR		;GET RID OF TRAILING ZEROS
	LD	B,1
	CALL	POPIT
	LD	A,(CHR)
	CP	'0'
	JP	NZ,A101D
	LD	HL,I3
	DEC	(HL)
	LD	A,(I3)
	OR	A
	JP	NZ,A101C
	JP	A0102
A101D:	LD	HL,CHR		;PUT LAST DIGIT BACK
	LD	B,1
	CALL	PUSHT
	JP	A0103
A0102:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0103
	LD	HL,(TOS)	;GET RID OF DECIMAL PLACE
	DEC	HL
	LD	(TOS),HL
A0103:	LD	A,(SGN1)
	CP	1
	JP	Z,A010E
	LD	A,(IT)
	CP	TRUE
	JP	NZ,A010G
	LD	HL,(INDX)	;CHECK FOR EXPONENT
	LD	A,(HL)
	CP	'E'
	JP	NZ,A010E
	CALL	GTOKN
	LD	HL,I1
	DEC	(HL)
	LD	A,(I1)
	OR	A
	JP	Z,A010E
	LD	A,(TOKEN)	;CHECK FOR E+
	CP	5
	JP	Z,A0104
	CP	6
	JP	NZ,A0105
	LD	A,1		;SET MINUS FLAG
	LD	(SGN1),A
A0104:	LD	HL,I1
	DEC	(HL)
	LD	A,(I1)
	OR	A
	JP	Z,A010E
	CALL	GTOKN
A0105:	LD	A,TRUE
	LD	(DELET),A
	CALL	AC11		;GET EXPONENT
	LD	A,(RESUL)
	OR	A
	JP	Z,A010I
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A010G
	CALL	STC0		;GET EXPONENT AS CHARACTER
	LD	(I1),A
	LD	A,(RESUL)	;EXPONENT TOO BIG
	CP	FALSE
	JP	Z,E26
	LD	A,(I1)		;EXPONENT TOO BIG
	CP	99
	JP	C,$+6
	JP	NZ,E26
	LD	A,(I3)
	OR	A
	JP	NZ,A0106
	LD	A,(I2)
	OR	A
	JP	Z,A010E
	CP	1
	JP	NZ,A0106
	LD	HL,(PTRX1)
	LD	A,(HL)
	CP	'0'
	JP	Z,A010E
A0106:	LD	A,(SGN1)	;JUMP IF EXPONENT IS < 0
	CP	1
	JP	Z,A010A
	LD	HL,(PTRX2)	;PTR1 AT DECIMAL PLACE
	LD	(PTRX1),HL
	INC	HL
	LD	(PTRX2),HL
	LD	A,(I2)		;INCLUDE I1 DIGITS IN INTEGER PART
	LD	HL,I1
	ADD	A,(HL)
	LD	(I2),A
	LD	A,(I1)		;JUMP IF EXP IS < # OF FRACTION DIGITS
	LD	HL,I3
	CP	(HL)
	JP	C,A0109
	LD	HL,I2
	CP	(HL)
	JP	NZ,A0107
A1065:	LD	A,(I3)
	OR	A
	JP	Z,A0107
	LD	HL,(PTRX2)
	LD	A,(HL)
	CP	'0'
	JP	NZ,A0107
	INC	HL
	LD	(PTRX2),HL
	LD	HL,I3
	DEC	(HL)
	LD	HL,I2
	DEC	(HL)
	LD	HL,I1
	DEC	(HL)
	JP	A1065
A0107:	LD	HL,(PTRX1)	;SHIFT FRACTION OVER DP
	EX	DE,HL
	LD	HL,(PTRX2)
	LD	A,(I3)
	CALL	SHFD
	LD	A,(I1)		;AND ADD I1-I3 ZEROS
	LD	HL,I3
	SUB	(HL)
	LD	(I1),A
A108A:	LD	A,(I1)
	OR	A
	JP	Z,A108B
	LD	A,'0'
	CALL	CPUSH
	LD	HL,I1
	DEC	(HL)
	JP	A108A
A108B:	XOR	A
	LD	(I3),A
	JP	A010E
A0109:	LD	A,(I3)
	LD	HL,I1
	SUB	(HL)
	LD	(I3),A
A109A:	LD	HL,(PTRX2)
	LD	A,(HL)
	LD	HL,(PTRX1)
	LD	(HL),A
	INC	HL
	LD	(PTRX1),HL
	LD	HL,(PTRX2)
	INC	HL
	LD	(PTRX2),HL
	LD	HL,I1
	DEC	(HL)
	LD	A,(I1)
	OR	A
	JP	NZ,A109A
	LD	HL,(PTRX1)
	LD	(HL),'.'
	JP	A010E
A010A:	LD	A,(I1)
	OR	A
	JP	Z,A010E
	LD	A,(I2)		;JUMP IS INTEGER DIGITS < EXP
	LD	HL,I1
	CP	(HL)
	JP	C,A010B
	LD	HL,(PTRX2)
	LD	(PTRX1),HL
	DEC	HL
	LD	(PTRX2),HL
	LD	A,(I1)
	LD	(IXT),A
	LD	A,(I3)
	OR	A
	JP	NZ,A10A5
	XOR	A
	CALL	CPUSH
A10A5:	LD	HL,(PTRX2)
	LD	A,(HL)
	LD	HL,(PTRX1)
	LD	(HL),A
	DEC	HL
	LD	(PTRX1),HL
	LD	HL,(PTRX2)
	DEC	HL
	LD	(PTRX2),HL
	LD	HL,IXT
	DEC	(HL)
	LD	A,(IXT)
	OR	A
	JP	NZ,A10A5
	LD	HL,(PTRX1)
	LD	(HL),'.'
	LD	A,(I2)
	LD	HL,I1
	SUB	(HL)
	LD	(I2),A
	JP	A010D
A010B:	LD	HL,(PTRX1)
	INC	HL
	LD	(PTRX),HL
	EX	DE,HL		;SHIFT FRACTION OVER DP
	LD	HL,(PTRX1)
	LD	A,(I2)
	CALL	SHFU
	LD	HL,(PTRX)
	LD	(PTRX2),HL
	LD	HL,I3
	ADD	A,(HL)
	LD	(IXT),A
	LD	A,(I1)
	LD	HL,I2
	SUB	(HL)
	LD	(I4),A
	LD	HL,(PTRX2)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTRX2),HL
	EX	DE,HL
	LD	A,(IXT)
	CALL	SHFU
	LD	HL,(PTRX1)
	LD	(HL),'.'
A010C:	LD	HL,(PTRX1)
	INC	HL
	LD	(PTRX1),HL
	LD	(HL),'0'	;ADD ZEROS AFTER DP
	LD	HL,I4
	DEC	(HL)
	LD	A,(I4)
	OR	A
	JP	NZ,A010C
	XOR	A
	LD	(I2),A
A010D:	LD	A,(I3)
	LD	HL,I1
	ADD	A,(HL)
	LD	(I3),A
	OR	A
	JP	NZ,A101C
;*
A010E:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A010G
	LD	A,(I3)
	OR	A
	JP	Z,A010F
	LD	HL,I3		;INCLUDE DP
	INC	(HL)
A010F:	LD	A,(I3)		;TOTAL SIZE
	LD	HL,I2
	ADD	A,(HL)
	LD	(I3),A
	OR	A
	JP	NZ,A010H
	LD	A,'0'
	CALL	CPUSH
	LD	A,1
	LD	(I3),A
A010H:	LD	HL,I3
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
A010G:	LD	A,(IT)
	LD	(RESUL),A
	RET
A010I:	LD	A,(FLG1)
	AND	STRNG
	JP	Z,E26
	JP	A010E
;*
;*
AC11:	;INTERGER LITERAL
	CALL	SSCHK
	LD	A,(FLG1)
	AND	STRNG
	JP	NZ,A0110
	LD	A,255		;SET DIGIT COUNT
	LD	(I1),A
A0110:	XOR	A
	LD	(N),A
	LD	A,FALSE
	LD	(RESUL),A
	LD	A,(I1)
	OR	A
	JP	Z,A0113
	LD	A,(TOKEN)	;CHECK FOR DIGIT
	CP	3
	JP	NZ,A0113
	LD	A,TRUE		;IT IS A DIGIT
	LD	(RESUL),A
A0111:	LD	A,(I1)
	OR	A
	JP	Z,A0112
	LD	A,(DELET)
	CP	FALSE
	JP	Z,A011B
	LD	HL,(INDX)
	LD	A,(HL)
	CP	'0'
	JP	Z,A011C
	LD	A,FALSE
	LD	(DELET),A
A011B:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A011A
	LD	HL,(INDX)
	LD	B,1
	CALL	PUSHT
A011A:	LD	HL,N
	INC	(HL)
A011C:	LD	HL,I1
	DEC	(HL)
	CALL	GTOKN
	LD	A,(TOKEN)
	CP	3
	JP	Z,A0111
A0112:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0113
	LD	A,(N)
	OR	A
	JP	NZ,A011D
	LD	A,'0'
	CALL	CPUSH
	LD	HL,N
	INC	(HL)
A011D:	LD	HL,N
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
A0113:	LD	A,FALSE
	LD	(DELET),A
	RET
;*
;*
AC12:	;SAVE ACTFL
	LD	A,(ACTFL)
	LD	(SVACT),A
	LD	(DSF),A
	OR	A
	JP	Z,A0121
	LD	A,2
	LD	(ACTFL),A
A0121:	RET
;*
;*
AC13:	;SET COMACT FALSE FOR $SELECT
	LD	A,(ACTFL)
	LD	B,A
	LD	A,1
	CPL
	AND	B
	LD	(ACTFL),A
	RET
;*
;*
AC14:	;RESTORE ACTFL
	LD	A,(DSF)
	OR	A
	JP	Z,E35
	LD	A,(SVACT)
	LD	(ACTFL),A
	RET
;*
;*
AC15:
	CALL	SSCHK
	LD	A,(TOKEN)	;CHECK FOR A NAME LITERAL
	CP	2
	JP	Z,A0151
	CP	19
	JP	Z,A0151
	XOR	A		;NOT A NAME
	LD	(RESUL),A
	RET
A0151:	LD	A,1		;IT IS A NAME
	LD	(RESUL),A
	XOR	A
	LD	(NLENG),A
	LD	HL,(TOS)
	LD	(NAME),HL
A0152:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0153
	LD	A,(NLENG)
	CP	NAMLN-1
	JP	Z,A0153
	LD	HL,(INDX)	;PUSH THE CHARACTER
	LD	B,1
	CALL	PUSHT
	LD	HL,NLENG
	INC	(HL)
A0153:	CALL	GTOKN		;GET NEXT TOKEN VALUE
	LD	A,(TOKEN)
	CP	2
	JP	C,A0154
	CP	3
	JP	C,$+6
	JP	NZ,A0154
	JP	A0152
A0154:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0155
	LD	A,DELIM
	CALL	CPUSH
	LD	HL,NLENG
	INC	(HL)
	LD	B,1		;SAVE NAME LENGTH
	CALL	PUSHT
A0155:	RET
;*
;*
AC16:	;CHECK FOR NAME INDIR DURING ARG INDIR
	CALL	SSCHK
	LD	A,1
	LD	(CASE),A
	LD	A,(ACTFL)
	OR	A
	JP	Z,A0161
	LD	A,(TOKEN)
	CP	255
	JP	NZ,A0161
	LD	A,4
	LD	(CASE),A
	LD	HL,(INDX)
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
A0161:	RET
;*
;*
AC17:	;CHECK FOR INTLIT AS LABEL
	CALL	SSCHK
	LD	A,(TOKEN)
	CP	3
	JP	Z,A0171
	XOR	A		;NOT A DIGIT
	LD	(RESUL),A
	RET
A0171:	LD	A,1
	LD	(RESUL),A
	XOR	A
	LD	(COUNT),A
A0172:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0173
	LD	A,(COUNT)
	CP	8
	JP	Z,A0173
	LD	HL,(INDX)	;PUSH DIGIT
	LD	B,1
	CALL	PUSHT
	LD	HL,COUNT
	INC	(HL)
A0173:	CALL	GTOKN
	LD	A,(TOKEN)
	CP	3
	JP	Z,A0172
	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0174
	LD	A,DELIM
	CALL	CPUSH
	LD	HL,COUNT
	INC	(HL)
	LD	B,1
	CALL	PUSHT
A0174:	RET
;*
;*
AC18:	;RESET THE LOCK SWITCH
	CALL	SSCHK
A0181:	LD	A,(ACTFL)
	OR	A
	JP	NZ,A0186
	LD	A,1		;SET FLAG FOR AC47
	LD	(SETF),A
	LD	HL,TYPE		;LOCAL (1) OR GLOBAL (-1)
	LD	B,1
	CALL	POPIT
	LD	HL,IT		;# OF SUBSCRIPTS
	LD	B,1
	CALL	POPIT
	LD	HL,PTR3
	LD	B,2
	CALL	POPIT
	LD	HL,(TOS)
	LD	(TPP),HL
	LD	HL,(PTR3)
	EX	DE,HL
	LD	HL,(TPP)
	CALL	PSUB
	DEC	HL
	LD	(TPP),HL
A1825:	LD	HL,(TPP)	;NAME LENGTH
	LD	A,(HL)
	LD	(NLENG),A
	DEC	HL
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TPP),HL
	LD	A,(HL)
	LD	(COUNT),A
	OR	A
	JP	NZ,A1835
	LD	(SETBS),HL
A1835:	LD	HL,COUNT	;INCREMENT COUNT OF SET ITEMS
	INC	(HL)
	LD	A,(NLENG)
	LD	(N),A
	LD	A,(TYPE)
	CP	1
	JP	Z,A0184
	LD	A,(NLENG)	;GLOBAL SO SET BIT
	OR	128
	LD	(NLENG),A
A0184:	LD	HL,(TPP)
	LD	A,(NLENG)
	LD	(HL),A
	LD	A,(N)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	INC	HL
	LD	(TPP),HL
	LD	A,(IT)
	LD	(HL),A
	LD	HL,COUNT	;PUT # OF SETS ON STACK
	LD	B,1
	CALL	PUSHT
A0186:	RET
;*
;*
AC19:	;APPLY UNARY OPERATORS,STACK EXPRATOM
	CALL	SSCHK
	XOR	A
	LD	(I2X),A
	LD	HL,TYPE
	LD	B,1
	CALL	POPIT
	LD	A,(TYPE)
	CP	3
	JP	NZ,A0191
	LD	HL,NX
	LD	B,1
	CALL	POPIT
	JP	A0192
A0191:	LD	A,PTRLN
	LD	(NX),A
A0192:	LD	HL,(TOS)
	LD	A,(NX)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR2),HL
	DEC	HL
	LD	(PTR3),HL
	LD	A,(HL)
	LD	(ITX),A
	OR	A
	JP	Z,A019A
	LD	HL,NX
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
A0196:	CALL	AC34		;T-O-S TO REAL
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,NX
	LD	B,1
	CALL	POPIT
	LD	HL,(PTR2)
	LD	A,(HL)
	CP	'-'
	JP	NZ,A1962
	LD	A,1
	LD	(I2X),A
	LD	HL,NX
	DEC	(HL)
	LD	HL,(PTR2)
	INC	HL
	LD	(PTR2),HL
A1962:	LD	HL,(PTR3)	;PTR3 AT UNARY OP
	DEC	HL
	LD	(PTR3),HL
	XOR	A		;NO ' YET
	LD	(I4X),A
	LD	(CASE),A
A1965:	LD	HL,(PTR3)	;GET UNARY OP TOKEN
	LD	A,(HL)
	LD	(N),A
	CP	5
	JP	Z,A0199
	CP	6
	JP	NZ,A0197
	LD	A,(I2X)		;CHANGE SIGN
	XOR	1
	LD	(I2X),A
	JP	A0199
A0197:	LD	A,(I4X)		;JUMP IF ALREADY BEEN THROUGH HERE
	CP	1
	JP	Z,A0198
	LD	A,1
	LD	(I4X),A
	LD	HL,NX
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	CALL	AC31
A0198:	LD	A,(CASE)	;CHANGE NOT INDICATOR
	XOR	1
	LD	(CASE),A
	XOR	A
	LD	(I2X),A
A0199:	LD	HL,ITX
	DEC	(HL)
	LD	HL,(PTR3)	;MOVE TO PREVIOUS UNARY OP
	DEC	HL
	LD	(PTR3),HL
	LD	A,(ITX)
	OR	A
	JP	NZ,A1965
	INC	HL		;TPP TO FIRST AVAILABLE SPOT
	LD	(PTR3),HL
	LD	A,(I4X)		;JUMP IF EVER FOUND A NOT
	CP	1
	JP	Z,A019B
	LD	HL,(PTR2)	;JUMP IF NUMBER IS ZERO
	LD	A,(HL)
	CP	'0'
	JP	Z,A019B
	LD	A,(I2X)		;JUMP IF > 0
	OR	A
	JP	Z,A019A
	LD	HL,(PTR3)	;SET MINUS SIGN
	LD	(HL),'-'
	INC	HL
	LD	(PTR3),HL
A019A:	LD	HL,(PTR3)	;MOVE NUMBER DOWN
	EX	DE,HL
	LD	HL,(PTR2)
	LD	A,(NX)
	CALL	SHFD
	JP	A019E
A019B:	LD	HL,(PTR3)	;WE HAD A NOT
	LD	(TOS),HL
	LD	A,1
	LD	(NX),A
	LD	A,(CASE)	;JUMP IF WANT ZERO
	OR	A
	JP	Z,A019D
	LD	A,(I2X)		;JUMP IF > 0
	OR	A
	JP	Z,A019C
	LD	A,'-'
	CALL	CPUSH
A019C:	LD	A,'1'
	CALL	CPUSH
	JP	A019E
A019D:	LD	A,'0'
	CALL	CPUSH
	JP	A019F
A019E:	LD	A,(I2X)		;JUMP IF > 0
	OR	A
	JP	Z,A019F
	LD	HL,NX
	INC	(HL)
A019F:	LD	HL,NX
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	RET
;*
;*
AC20:
	CALL	SSCHK
	XOR	A		;ZERO T-O-S
	CALL	CPUSH
	RET
;*
;*
AC21:	;$JUSTIFY ACTION
	CALL	SSCHK
	LD	HL,INT2
	CALL	STI
	LD	A,(RESUL)
	CP	TRUE
	JP	Z,A0216
	CALL	AC33		;T-O-S TO STRING
A0211:	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,IT		;GET STRING LENGTH
	LD	B,1
	CALL	POPIT
	LD	HL,INT2
	LD	A,(HL)
	AND	0F0H
	JP	NZ,A0215
	LD	HL,INT1
	LD	A,(IT)
	CALL	CTI
	LD	DE,INT2		;JUMP IF NOT ENOUGH ROOM
	LD	C,INTLN
	LD	B,INTLN
	CALL	SCMP
	JP	C,A0215
	JP	Z,A0215
	LD	HL,INT2		;NUMBER OF BLANKS TO ADD
	LD	DE,INT1
	LD	C,INTLN
	CALL	BCDSB
	CALL	ITC
	LD	(N),A
	LD	A,(RESUL)	;TOO MANY BLANKS TO ADD
	CP	FALSE
	JP	Z,E20
	LD	HL,(TOS)
	LD	A,(IT)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR1),HL
	LD	A,(N)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR2),HL
	EX	DE,HL
	LD	HL,(PTR1)
	LD	A,(IT)
	CALL	SHFU
	LD	HL,N		;TOTAL LENGTH IN IT
	ADD	A,(HL)
	LD	(IT),A
A0214:	LD	HL,(PTR1)	;PUT IN N BLANKS
	LD	(HL),BLANK
	INC	HL
	LD	(PTR1),HL
	LD	HL,N
	DEC	(HL)
	LD	A,(N)
	OR	A
	JP	NZ,A0214
A0215:	LD	HL,IT
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	RET
A0216:	LD	HL,INT3		;GET FIELD SIZE
	CALL	STI
	CALL	AC34		;T-O-S TO NUMBER
	LD	HL,INT2		;NEGATIVE #'S NOT YET
	LD	A,(HL)
	AND	0F0H
	JP	NZ,E30
	CALL	ITC
	LD	(I6),A
	LD	A,(RESUL)	;TOO MANY DECIMAL PLACES
	CP	FALSE
	JP	Z,E20
	LD	A,1
	LD	(DJ),A
	CALL	DOLJ		;T-O-S TO STRING WITH DECIMAL PLACE
	XOR	A
	LD	(DJ),A
	LD	HL,INT2
	LD	DE,INT3
	CALL	SETI
	JP	A0211
;*
;*
AC22:	;EVALUATE AND STACK SUBSCRIPT EXPRESSION
	CALL	SSCHK
	LD	A,2		;SUBSCRIPT IS STRING (DEFAULT)
	LD	(CASE),A
	CALL	PAST
	LD	HL,PTR2		;GET BELOW T-O-S
	LD	B,2
	CALL	POPIT
	LD	HL,PTR3
	LD	B,2
	CALL	POPIT
	LD	HL,(PTR2)
	LD	(PTR3),HL
	LD	A,(HL)
	LD	(GLB),A
	DEC	HL
	LD	A,(HL)
	LD	(SETSW),A
	DEC	HL
	LD	A,(HL)
	LD	(NR),A
	DEC	HL
	LD	A,(HL)
	LD	(INDFL),A
	DEC	HL
	LD	A,(HL)		;GET SUB COUNT
	LD	(SCNT),A
	LD	BC,-(PTRLN)
	ADD	HL,BC
	LD	(PTR2),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR1),HL
	LD	HL,TYPE		;GET SUB TYPE
	LD	B,1
	CALL	POPIT
A0221:	LD	A,(TYPE)
	CP	3
	JP	Z,A0225
	LD	HL,TYPE
	LD	B,1
	CALL	PUSHT
	CALL	AC33		;CONVERT TO STRING
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
A0225:	LD	HL,SLENG
	LD	B,1
	CALL	POPIT
	CALL	CANON
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,A0227
	LD	A,1		;IT'S A NUMBER
	LD	(CASE),A
A0227:	LD	A,(CASE)
	CP	2
	JP	Z,A2273
	LD	HL,SLENG
	INC	(HL)
	LD	HL,(PTR3)
	LD	A,(IT)
	LD	(HL),A
	JP	A2275
A2273:	LD	HL,(PTR3)
	INC	HL
	LD	(PTR3),HL
A2275:	LD	A,(SLENG)
	OR	A
	JP	NZ,A0228
	LD	A,(DOR)		;INVALID SUBSCRIPT
	CP	1
	JP	NZ,E47
A0228:	LD	HL,(PTR3)
	EX	DE,HL
	LD	HL,(PTR2)
	LD	A,(SLENG)
	LD	B,A
	CALL	MOVE
A0229:	LD	HL,(PTR1)	;ADJUST SIZE
	LD	A,(SLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR1),HL
	INC	HL		;INCLUDE DELIMETER IN SIZE
	LD	(PTR1),HL
	LD	HL,(PTR2)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR2),HL
	LD	(TOS),HL
	LD	A,DELIM		;END STRING DELIMITER
	CALL	CPUSH
	LD	HL,SCNT
	INC	(HL)
	LD	HL,PTR1
	LD	B,2
	CALL	PUSHT
	LD	HL,SCNT
	LD	B,1
	CALL	PUSHT
	RET
;*
;*
AC23:	;SAVE ROUTINE (NAME ON STACK)
	CALL	SSCHK
	LD	A,(RTDRV)
	LD	(DRIVE),A
	LD	A,1
	LD	(FCBTY),A
	CALL	FSEAR		;CHECK ROUTINE ON STACK FOR DUPLICATED
	LD	A,(RESUL)
	CP	1
	JP	NZ,A0231
	LD	A,(FLG1)	;SAME NAME--IS IT DIRTY ?
	AND	DIRTY
	JP	Z,E41
	CALL	REMOV
A0231:	CALL	SAVEI
	LD	A,(FLG1)
	LD	B,A
	LD	A,DIRTY
	CPL
	AND	B
	LD	(FLG1),A
	RET
;*
;*
AC24:	;NEW LINE OPERATION, UPDATE $X & $Y
	CALL	SSCHK
	LD	A,CR
	LD	(CHR),A
	CALL	PUTCH
	LD	A,LF
	LD	(CHR),A
	CALL	PUTCH
	LD	HL,(DEVX)
	LD	DE,IZERO
	CALL	SETI
	LD	HL,(DEVY)
	LD	DE,IONE
	LD	C,INTLN
	CALL	BCDAD
	RET
;*
;*
AC25:	;TOP OF FORM OPERATION, UPDATE $X & $Y
	CALL	SSCHK
	LD	A,CR
	LD	(CHR),A
	CALL	PUTCH
	LD	A,FF
	LD	(CHR),A
	CALL	PUTCH
	LD	HL,(DEVX)
	LD	DE,IZERO
	CALL	SETI
	LD	HL,(DEVY)
	LD	DE,IZERO
	CALL	SETI
	RET
;*
;*
AC26:	;REMOVE STRING FROM STACK
	CALL	SSCHK
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,SLENG
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	RET
;*
;*
AC27:	;ZERO POINTER T-O-S
	CALL	SSCHK
	LD	HL,NULL
	LD	(PTR),HL
	LD	HL,PTR
	LD	B,2
	CALL	PUSHT
	RET
;*
;*
AC28:	;TAB OPERATION, UPDATE $X
	CALL	SSCHK
	LD	HL,INT1		;GET TAB VALUE
	CALL	STI
	LD	A,(HL)
	AND	0F0H
	JP	NZ,A0283
	LD	HL,(DEVX)	;JUMP IF AT/PAST TAB PLACE
	LD	DE,INT1
	LD	C,INTLN
	LD	B,INTLN
	CALL	SCMP
	JP	C,A0283
	JP	Z,A0283
	LD	HL,INT2
	CALL	SETI
	LD	HL,(DEVX)
	LD	DE,INT1
	EX	DE,HL
	LD	C,INTLN
	CALL	BCDSB
	LD	HL,(DEVX)
	LD	DE,INT2
	CALL	SETI
A0281:	LD	HL,INT1		;DONE
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A0283
	LD	C,INTLN
	CALL	SUB1
	LD	A,BLANK		;SEND SPACES
	LD	(CHR),A
	CALL	PUTCH
	JP	A0281
A0283:	RET
;*
;*
AC29:	;DISABLE EVALUATION
	LD	A,(ACTFL)	;SET COMACT
	OR	1
	LD	(ACTFL),A
	RET
;*
;*
AC30:	;SAVE ROUTINE (NAME AT PRG)
	CALL	SSCHK
	LD	HL,PRG
	LD	(PTR),HL
	LD	A,(HL)
	CP	BLANK
	JP	Z,E40
	XOR	A
	LD	(IT),A
A0301:	LD	HL,(PTR)	;PUSH NAME ON STACK
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,IT
	INC	(HL)
	LD	A,(IT)
	CP	NAMLN
	JP	Z,A0302
	LD	HL,(PTR)
	LD	A,(HL)
	CP	BLANK
	JP	NZ,A0301
A0302:	LD	HL,IT		;SAVE LENGTH
	LD	B,1
	CALL	PUSHT
	LD	A,(RTDRV)
	LD	(DRIVE),A
	LD	A,1
	LD	(FCBTY),A
	CALL	FSEAR
	LD	A,(RESUL)
	CP	1
	JP	NZ,A0303
	LD	A,(FLG1)	;IF CLEAN ALREADY SAVED
	AND	DIRTY
	JP	Z,A0304
	CALL	REMOV		;REMOVE OLD ONE
A0303:	CALL	SAVEI
	LD	A,(FLG1)
	LD	B,A
	LD	A,DIRTY
	CPL
	AND	B
	LD	(FLG1),A
A0304:	RET
;*
;*
AC31:	;CONVERT EXPRESSION TO TRUTH VALUE
	CALL	SSCHK
	CALL	AC34		;CONVERT EXPRESSION TO NUMBER
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,N		;GET NUMBER SIZE
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(N)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	A,(HL)
	CP	'0'
	JP	Z,A0312
	LD	A,1		;SET X RETURN, TRUE
	LD	(CASE),A
	RET
A0312:	XOR	A		;SET Y RETURN, FALSE
	LD	(CASE),A
	RET
;*
;*
AC32:	;CONVERT EXPRESSION TO INTEGER
	CALL	SSCHK
	CALL	AC34
	XOR	A		;IT'S AN INTEGER
	LD	(IT),A
	CALL	MKSTR		;MAKE NUMBER INTO STRING
	RET
;*
;*
AC33:	;CONVERT BINARY INTEGER TO STRING
	CALL	SSCHK
	LD	HL,TYPE		;GET TYPE OF T-O-S
	LD	B,1
	CALL	POPIT
	LD	A,(TYPE)
	CP	3
	JP	Z,A0335
	LD	HL,PTR		;IT'S A STRING POINTER
	LD	B,2
	CALL	POPIT
	LD	HL,(PTR)
	LD	A,(HL)
	LD	(COUNT),A
	LD	(N),A
A0333:	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	A,(COUNT)	;MOVE STRING FROM SYM TABLE TO STAKK
	OR	A
	JP	Z,A0334
	LD	B,1
	CALL	PUSHT
	LD	HL,COUNT
	DEC	(HL)
	JP	A0333
A0334:	LD	HL,N
	LD	B,1
	CALL	PUSHT
A0335:	LD	A,3
	CALL	CPUSH
	RET
;*
;*
AC34:	;CONVERT EXPRESSION TO NUMERIC VALUE
	CALL	SSCHK
	LD	A,1		;IT'S TO BE A REAL
	LD	(IT),A
	CALL	MKSTR
	RET
;*
;*
AC35:	;PUSH A ONE ON THE STACK
	CALL	SSCHK
	LD	A,1
	CALL	CPUSH
	RET
;*
;*
AC36:	;$ASCII ACTION
	CALL	SSCHK
	LD	A,1
	LD	(N),A
	LD	A,(RESUL)	;NO INTEGER
	CP	FALSE
	JP	Z,A0361
	LD	HL,INT1
	CALL	STI
	LD	A,(HL)		;NO GOOD NUMBERS
	AND	0F0H
	JP	NZ,A0363
	CALL	ITC
	LD	(N),A
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,A0363
	LD	A,(N)
	OR	A
	JP	Z,A0363
A0361:	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,SLENG	;GET STRING LENGTH
	LD	B,1
	CALL	POPIT
	LD	A,(SLENG)
	OR	A
	JP	Z,A0364
	LD	A,(N)
	LD	HL,SLENG
	CP	(HL)
	JP	C,$+6
	JP	NZ,A0364
	LD	HL,(TOS)
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	HL,N
	DEC	(HL)
	LD	HL,(TOS)	;PTR TO START OF STRING
	LD	A,(N)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR),HL
	LD	A,(HL)
	LD	(N),A
A0362:	LD	A,(N)
	CALL	CTS
	RET
A0363:	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,SLENG
	LD	B,1
	CALL	POPIT
A0364:	LD	HL,(TOS)
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	A,'-'
	CALL	CPUSH
	LD	A,'1'
	CALL	CPUSH
	LD	A,2
	CALL	CPUSH
	LD	A,3
	CALL	CPUSH
	RET
;*
;*
AC37:	;WRITE LOCAL VARS FOR VIEW
	CALL	SSCHK
	LD	HL,(SYMPT)
	LD	(PTR),HL
A0371:	LD	HL,(PTR)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(NEXTP),HL
	LD	DE,NULL
	CALL	JPEN
	JP	Z,A037B
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(HL)		;GET TYPE
	LD	(STYPE),A
	CP	128
	JP	C,$+6
	JP	NZ,A3790
	LD	DE,5		;PTR TO NAME LENGTH
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(HL)
	LD	(SLENG),A
	LD	HL,SLENG
	DEC	(HL)
	LD	A,(STYPE)
	CP	3
	JP	C,$+6
	JP	NZ,A0372
	LD	A,BLANK
	CALL	CPUSH
	JP	A0373
A0372:	LD	A,'*'
	CALL	CPUSH
A0373:	LD	A,BLANK
	CALL	CPUSH
	LD	A,13
	LD	HL,SLENG
	SUB	(HL)
	LD	(IT),A
A3735:	LD	HL,(PTR)	;STACK NAME
	INC	HL
	LD	(PTR),HL
	LD	B,1
	CALL	PUSHT
	LD	HL,SLENG
	DEC	(HL)
	LD	A,(SLENG)
	OR	A
	JP	NZ,A3735
A0374:	LD	A,BLANK		;PAD WITH BLANKS
	CALL	CPUSH
	LD	HL,IT
	DEC	(HL)
	LD	A,(IT)
	OR	A
	JP	NZ,A0374
	LD	HL,(PTR)
	INC	HL
	INC	HL
	LD	(PTR),HL
	XOR	A
	LD	(I7),A
	LD	A,(STYPE)
	CP	4
	JP	C,A0375
	SUB	4
	LD	(STYPE),A
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(DP),HL
	LD	A,1
	LD	(I7),A
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
A0375:	LD	A,15
	CALL	CPUSH
	LD	A,3
	CALL	CPUSH
	CALL	AC54
	LD	A,(STYPE)	;DONE
	OR	A
	JP	Z,A0379
A0377:	LD	HL,(PTR)
	LD	A,(HL)
	LD	(SLENG),A
	LD	(IT),A
	LD	HL,SLENG
	INC	(HL)
	INC	(HL)		;ALLOW FOR QUOTES
	LD	A,'"'
	CALL	CPUSH
A0378:	LD	A,(IT)		;SAVE STRING
	OR	A
	JP	Z,A0379
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	B,1
	CALL	PUSHT
	LD	HL,IT
	DEC	(HL)
	JP	A0378
A0379:	LD	A,'"'
	CALL	CPUSH
	LD	HL,SLENG
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
A037C:	CALL	AC54
	CALL	AC24
	LD	A,(VF)
	OR	A
	JP	Z,A3790
	LD	A,(I7)
	OR	A
	JP	Z,A3790
	CALL	LSUBS
A3790:	LD	HL,(NEXTP)
	LD	(PTR),HL
	JP	A0371
A037A:	CALL	AC33		;CONVERT T-O-S TO STRING
	JP	A037C
A037B:	RET
;*
;*
AC38:	;$DATA FUNCTION
	CALL	SSCHK
	LD	HL,IT		;GET GLOBAL OR LOCAL
	LD	B,1
	CALL	POPIT
	LD	HL,SCNT		;SUBSCRIPT COUNT
	LD	B,1
	CALL	POPIT
	LD	HL,NLEN		;GET SUBSCRIPT OFFSET
	LD	B,2
	CALL	POPIT
	LD	HL,(TOS)
	DEC	HL
	LD	(PTR3),HL
	LD	HL,(NLEN)
	EX	DE,HL
	LD	HL,(PTR3)
	CALL	PSUB
	LD	(PTR3),HL
	INC	HL
	LD	(PTR),HL
	LD	HL,(PTR3)	;GET NAME LENGTH
	LD	A,(HL)
	LD	(NLENG),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR3),HL
	LD	(NAME),HL	;NAME POINTS AT START OF NAME
	LD	(TPTR),HL
	LD	A,(IT)		;GLOBAL OR LOCAL
	CP	1
	JP	NZ,A0385
	CALL	SEARC		;LOOK FOR VAR
	XOR	A
	LD	(IT),A
	LD	A,(RESUL)	;DONE--NO ENTRY
	OR	A
	JP	Z,A0384
	LD	A,(CASE)	;DONE--TOO MANY SUBS
	CP	2
	JP	NZ,A0384
	LD	HL,(LAST)	;PTR1 TO START OF ENTRY
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR1),HL
	LD	A,(STYPE)
	CP	9
	JP	C,A0381
	LD	A,1
	LD	(IT),A
	LD	HL,(PTR1)	;DONE
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,NULL
	CALL	JPEN
	JP	Z,A0384
	LD	A,11
	LD	(IT),A
	JP	A0384
A0381:	LD	A,(STYPE)
	CP	8
	JP	NZ,A0382
	LD	HL,(PTR1)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,NULL
	CALL	JPEN
	JP	Z,A0384
	LD	A,10
	LD	(IT),A
	JP	A0384
A0382:	LD	A,(STYPE)
	CP	5
	JP	C,A0383
	LD	HL,(PTR)	;PTR TO DOWN POINTER
	LD	BC,-(PTRLN)
	ADD	HL,BC
	LD	(PTR),HL
	LD	A,1
	LD	(IT),A
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,NULL
	CALL	JPEN
	JP	Z,A0384
	LD	A,11
	LD	(IT),A
	JP	A0384
A0383:	LD	A,(STYPE)
	CP	4
	JP	NZ,A3835
	LD	A,10
	LD	(IT),A
	JP	A0384
A3835:	LD	A,1
	LD	(IT),A
A0384:	LD	HL,(TPTR)
	LD	(TOS),HL
	LD	A,(IT)
	CALL	CTS
	RET
;* GLOBAL SEARCH
A0385:	CALL	FNAKD
	CALL	FINDK		;SEARCH FOR ENTRY
	XOR	A
	LD	(II),A
	LD	A,(RESUL)	;DONE--NO ENTRY
	OR	A
	JP	Z,A0387
	LD	A,1
	LD	(II),A
A3855:	LD	HL,(PTR)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	CALL	VALSZ
	LD	HL,(TPP)	;SKIP OVER VALUE
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,FALSE		;SO GETNEXT DOESN'T SKIP
	LD	(RESUL),A
A0387:	CALL	GETNE
	LD	A,(II)
	LD	(IT),A
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,A0384
	LD	HL,(NAME)
	LD	(PTR3),HL
	CALL	FDDSC		;FIND DESCENDENT
	LD	A,(RESUL)
	CP	1
	JP	NZ,A0384
	LD	A,(IT)
	ADD	A,10
	LD	(IT),A
	JP	A0384
;*
;*
AC39:	;VIEW ACTION (WITH ARGUMENTS)
	CALL	SSCHK
	CALL	STC0
	LD	(I1),A
	LD	A,(RESUL)	;NUMBER TOO BIG
	CP	FALSE
	JP	Z,E20
	LD	A,(I1)
	OR	A
	JP	NZ,A0391
	XOR	A
	LD	(VF),A
	CALL	AC37		;LOCAL--NO SUBS
	JP	A0394
A0391:	LD	A,(I1)
	CP	1
	JP	NZ,A0392
	LD	A,1
	LD	(VF),A
	CALL	AC37		;LOCAL PLUS SUBS
	JP	A0394
A0392:	LD	A,(I1)
	CP	2
	JP	NZ,A0393
	CALL	LGLOB		;GLOBAL NAMES
	JP	A0394
A0393:	LD	A,(I1)
	CP	3
	JP	NZ,E20
	CALL	AC80		;ROUTINE NAMES
A0394:	RET
;*
;*
AC40:	;$EXTRACT FUNCTION
	CALL	SSCHK
	LD	HL,INT1		;GET INTEGER (START OR STOP)
	CALL	STI
	LD	HL,INT2
	LD	DE,INT1
	CALL	SETI
	LD	A,(RESUL)
	OR	A
	JP	Z,A0401
	LD	HL,INT1		;GET START LOCATION
	CALL	STI
A0401:	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,SLENG	;GET STRING LENGTH
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	(PTR),HL	;PTR AT START OF STRING
	LD	HL,INT3		;INT3--STRING LENGTH
	LD	A,(SLENG)
	CALL	CTI
	LD	HL,INT1
	LD	A,(HL)
	AND	0F0H
	JP	NZ,A4015
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A4015
	JP	A0402
A4015:	LD	A,(RESUL)	;IF START <= 0 AND RESULT=0, EMPTY ANSWER
	OR	A
	JP	Z,A0405
	LD	HL,INT1		;IF START<=0 AND RESULT=1, START AT 1
	LD	DE,IONE
	CALL	SETI
A0402:	LD	HL,INT3		;JUMP IF END < LENGTH
	LD	DE,INT2
	LD	C,INTLN
	LD	B,INTLN
	CALL	SCMP
	JP	C,A0403
	LD	HL,INT2		;END AT END
	LD	DE,INT3
	CALL	SETI
A0403:	LD	HL,INT1		;EMPTY RESULT, END BEFORE START
	LD	DE,INT2
	LD	C,INTLN
	LD	B,INTLN
	CALL	SCMP
	JP	C,A0405
	CALL	ITC
	LD	(I1),A
	LD	HL,INT2
	CALL	ITC
	LD	(I2),A
	LD	HL,I1
	DEC	(HL)
	LD	A,(I2)		;GET # OF CHARS
	SUB	(HL)
	LD	(I2),A
	LD	HL,(PTR)
	LD	A,(I1)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR),HL
	LD	HL,(TOS)	;MOVE STRING DOWN TO TOS
	EX	DE,HL
	LD	HL,(PTR)
	LD	A,(I2)
	CALL	SHFD
A0404:	LD	HL,I2		;SAVE LENGTH
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	RET
A0405:	XOR	A
	LD	(I2),A
	JP	A0404
;*
;*
AC41:	;$FIND ACTION
	CALL	SSCHK
	LD	A,(RESUL)
	CP	1
	JP	Z,A0411
A0410:	LD	A,1		;NO INTEGER EXPRESSION
	LD	(N),A
	JP	A0412
A0411:	LD	HL,INT1
	CALL	STI
	LD	A,(HL)
	AND	0F0H
	JP	NZ,A0410
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A0410
	CALL	ITC
	LD	(N),A
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,A4145
A0412:	LD	HL,(TOS)	;GET TYPE 3
	DEC	HL
	LD	(TOS),HL
	LD	HL,I2		;LENGTH OF STRING 2
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(I2)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	(PTR2),HL	;PTR2 TO START OF STRING 2
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I1		;LENGTH OF STRING 1
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(I1)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	(PTR1),HL	;PTR1 TO START OF STRING 1
	LD	A,(I2)
	OR	A
	JP	Z,A0417
	LD	A,(N)
	LD	HL,I1
	CP	(HL)
	JP	C,$+6
	JP	NZ,A0415
	LD	HL,N
	DEC	(HL)
	LD	HL,(PTR1)	;PTR1 TO SEARCH PLACE
	LD	A,(N)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR1),HL
	LD	A,(I1)
	LD	HL,N
	SUB	(HL)
	LD	(I1),A
A0414:	LD	A,(I1)		;FAILURE
	LD	HL,I2
	CP	(HL)
	JP	C,A0415
	LD	HL,(PTR1)	;SUCCESS
	EX	DE,HL
	LD	HL,(PTR2)
	LD	A,(I2)
	LD	C,A
	CALL	JSE
	JP	NZ,$+13
	LD	(PTR2),HL
	EX	DE,HL
	LD	(PTR1),HL
	JP	A0416
	LD	HL,(PTR1)	;TRY AGAIN
	INC	HL
	LD	(PTR1),HL
	LD	HL,I1
	DEC	(HL)
	LD	HL,N
	INC	(HL)
	JP	A0414
A4145:	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I2
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(I2)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I2
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(I2)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
A0415:	XOR	A		;HERE IF FAILED
	LD	(N),A
	JP	A0417
A0416:	LD	A,(N)
	LD	HL,I2
	ADD	A,(HL)
	LD	(N),A
	LD	HL,N
	INC	(HL)
A0417:	LD	A,(N)
	CALL	CTS
	RET
;*
;*
AC42:	;$LENGTH ACTION
	CALL	SSCHK
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,SLENG	;GET LENGTH
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)	;TOS BELOW STRING
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	A,(SLENG)
	CALL	CTS
	RET
;*
;*
AC43:	;EVALUATE BINARY OPERATORS
	CALL	SSCHK
	LD	A,(FLG1)	;RESET NOT FLAG
	LD	B,A
	LD	A,NOTFL
	CPL
	AND	B
	LD	(FLG1),A
	CALL	PAST		;MOVE PTR PAST T-O-S ITEM
	LD	HL,PTR
	LD	B,2
	CALL	POPIT
	LD	HL,TPP
	LD	B,2
	CALL	POPIT
	LD	HL,(PTR)	;GET OPERATOR
	LD	A,(HL)
	LD	(I6),A
	LD	(PTR2),HL	;SAVE PTR
	CP	50
	JP	C,A0431
	LD	A,(FLG1)	;SET NOT FLAG
	OR	NOTFL
	LD	(FLG1),A
	LD	A,(I6)
	SUB	50
	LD	(I6),A
A0431:	LD	A,(I6)		;IS IT STRING OP?
	CP	14
	JP	C,$+6
	JP	NZ,A0432
	CALL	AC34		;CONVERT T-O-S TO REAL
	JP	A0433
A0432:	CALL	AC33		;CONVERT T-O-S TO STRING
A0433:	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I2
	LD	B,1
	CALL	POPIT
	LD	HL,(PTR2)
	LD	(PTR1),HL
	INC	HL
	LD	(PTR2),HL
	LD	HL,(PTR1)
	DEC	HL
	DEC	HL
	LD	A,(HL)		;GET OP #1 LENGTH
	LD	(I1),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR1),HL
	LD	A,(I6)
	CP	14
	JP	C,$+6
	JP	NZ,A043H
	LD	(TOS),HL
	CALL	NUMOP		;DO NUMERIC OPERATION
	RET
A043A:	LD	A,(FLG1)
	AND	NOTFL
	JP	NZ,A43B5
A43A5:	LD	A,'1'
	LD	(CHR),A
	JP	A043C
A043B:	LD	A,(FLG1)
	AND	NOTFL
	JP	NZ,A43A5
A43B5:	LD	A,'0'
	LD	(CHR),A
A043C:	LD	HL,CHR
	LD	B,1
	CALL	PUSHT
	LD	A,1
	CALL	CPUSH
	LD	A,3
	CALL	CPUSH
	RET
A043H:	LD	A,(I6)
	CP	18
	JP	Z,A043N
	LD	HL,(PTR1)	;TOS TO RIGHT PLACE
	LD	(TOS),HL
	CP	15
	JP	NZ,A043J
	LD	A,(I2)		;IT'S A [
	OR	A
	JP	Z,A043A
	LD	A,(I1)
	LD	(I3),A
A043I:	LD	A,(I3)		;NOT ENOUGH STRING LEFT
	LD	HL,I2
	CP	(HL)
	JP	C,A043B
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(PTR2)
	LD	A,(I2)
	LD	C,A
	CALL	JSE
	JP	NZ,$+13
	LD	(PTR2),HL
	EX	DE,HL
	LD	(PTR1),HL
	JP	A043A
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	HL,I3		;DECREMENT STRING LEFT
	DEC	(HL)
	JP	A043I
A043J:	LD	A,(I6)
	CP	16
	JP	NZ,A043M
A043K:	LD	A,(I1)		;IT'S A ]
	OR	A
	JP	Z,A043B
	LD	A,(I2)
	OR	A
	JP	Z,A043A
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(PTR2)
	LD	A,(DE)
	CP	(HL)
	JP	Z,A043L
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(PTR2)
	LD	A,(DE)
	CP	(HL)
	JP	C,$+6
	JP	NZ,A043A
	JP	A043B
A043L:	LD	HL,(PTR1)	;THE STRING HEADS ARE EQUAL
	INC	HL
	LD	(PTR1),HL
	LD	HL,(PTR2)
	INC	HL
	LD	(PTR2),HL
	LD	HL,I1
	DEC	(HL)
	LD	HL,I2
	DEC	(HL)
	JP	A043K
A043M:	LD	A,(I1)		;IT'S A =
	LD	HL,I2
	CP	(HL)
	JP	NZ,A043B
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(PTR2)
	LD	C,A
	CALL	JSE
	JP	NZ,$+13
	LD	(PTR2),HL
	EX	DE,HL
	LD	(PTR1),HL
	JP	A043A
	JP	A043B
A043N:	LD	HL,INT1		;IT'S A _
	LD	A,(I1)
	CALL	CTI
	LD	HL,INT2
	LD	A,(I2)
	CALL	CTI
	LD	HL,INT1
	LD	DE,INT2
	LD	C,INTLN
	CALL	BCDAD
	CALL	ITC
	LD	(N),A
	LD	A,(RESUL)	;STRING TOO LONG
	CP	FALSE
	JP	Z,E11
	LD	HL,(PTR2)
	LD	BC,-(3)
	ADD	HL,BC
	LD	(PTR1),HL
	EX	DE,HL		;SHIFT STRING2 PAST OPERATOR
	LD	HL,(PTR2)
	LD	A,(I2)
	CALL	SHFD
	LD	HL,N
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	RET
;*
;*
AC44:	;RETURN CURRENT DRIVES
	CALL	SSCHK
	XOR	A
	LD	(T1),A
	LD	HL,ZOROU
	LD	(PTR),HL
A0440:	LD	A,1
	LD	(COUNT),A
A0441:	LD	HL,(PTR)
	LD	A,(HL)
	CP	DELIM
	JP	Z,A0442
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,COUNT
	INC	(HL)
	JP	A0441
A0442:	LD	A,(T1)
	CP	1
	JP	Z,A0443
	LD	A,(RTDRV)
	LD	(IT),A
	JP	A0444
A0443:	LD	A,(GLBDR)
	LD	(IT),A
A0444:	LD	A,(IT)
	ADD	A,'A'
	LD	(IT),A
	LD	HL,IT
	LD	B,1
	CALL	PUSHT
	LD	HL,COUNT
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	CALL	AC54		;WRITE OUT MESSAGE
	CALL	AC24
	LD	A,(T1)
	CP	1
	JP	Z,A0445
	LD	HL,ZOGLO
	LD	(PTR),HL
	LD	A,1
	LD	(T1),A
	JP	A0440
A0445:	RET
;*
;*
AC45:	;$PIECE ACTION
	CALL	SSCHK
	LD	A,(RESUL)
	OR	A
	JP	Z,A0450
	LD	HL,INT2		;GET "OPTIONAL" INTEGER
	CALL	STI
A0450:	LD	HL,INT1		;GET START INTEGER
	CALL	STI
	LD	A,(RESUL)
	CP	1
	JP	Z,A0451
	LD	HL,INT2		;SET END IF MISSING
	LD	DE,INT1
	CALL	SETI
A0451:	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I2		;LENGTH OF STRING #2
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(I2)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	(PTR2),HL	;PTR2 TO START OF STRING #2
	LD	(PTR3),HL
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I1		;LENGTH OF STRING #1
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(I1)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	(PTR1),HL	;PTR1 TO START OF STRING #1
	LD	A,(I2)		;EMPTY RESULT--STRING #2 EMPTY
	OR	A
	JP	Z,A045E
	LD	HL,INT2		;EMPTY RESULT--INT2 < 1
	LD	A,(HL)
	AND	0F0H
	JP	NZ,A045E
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A045E
	LD	HL,INT1
	LD	A,(HL)
	AND	0F0H
	JP	NZ,A0453
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A0453
A0452:	LD	HL,INT1		;EMPTY RESULT--INT1 > INT2
	LD	DE,INT2
	LD	C,INTLN
	LD	B,INTLN
	CALL	SCMP
	JP	C,A045E
	CALL	ITC
	LD	(I3),A
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,A045E
	LD	HL,I3
	DEC	(HL)
	JP	A0454
A0453:	XOR	A
	LD	(I3),A
A0454:	LD	A,(I3)		;FOUND START?
	OR	A
	JP	Z,A0457
A0455:	LD	A,(I1)		;EMPTY RESULT--NOT ENOUGH MATCHES
	LD	HL,I2
	CP	(HL)
	JP	C,A045E
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(PTR2)
	LD	A,(I2)
	LD	C,A
	CALL	JSE
	JP	NZ,$+13
	LD	(PTR2),HL
	EX	DE,HL
	LD	(PTR1),HL
	JP	A0456
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	HL,I1
	DEC	(HL)
	JP	A0455
A0456:	LD	HL,I3
	DEC	(HL)
	LD	A,(I1)
	LD	HL,I2
	SUB	(HL)
	LD	(I1),A
	LD	HL,INT2
	LD	C,INTLN
	CALL	SUB1
	LD	HL,(PTR3)
	LD	(PTR2),HL
	JP	A0454
A0457:	LD	HL,(PTR1)	;PTR1 IS AT STARTING LOCATION
	LD	(PTR),HL
	LD	A,(I1)
	LD	(IT),A
A0459:	LD	A,(I1)		;NOT ENOUGH LEFT, TAKE IT ALL
	LD	HL,I2
	CP	(HL)
	JP	C,A045B
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(PTR2)
	LD	A,(I2)
	LD	C,A
	CALL	JSE
	JP	NZ,$+13
	LD	(PTR2),HL
	EX	DE,HL
	LD	(PTR1),HL
	JP	A045A
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	HL,I1
	DEC	(HL)
	JP	A0459
A045A:	LD	A,(I1)
	LD	HL,I2
	SUB	(HL)
	LD	(I1),A
	LD	HL,INT2
	LD	C,INTLN
	CALL	SUB1
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A045C
	LD	HL,(PTR3)
	LD	(PTR2),HL
	JP	A0459
A045B:	XOR	A
	LD	(I1),A
	LD	(I2),A
A045C:	LD	A,(IT)
	LD	HL,I1
	SUB	(HL)
	LD	HL,I2
	SUB	(HL)
	LD	(IT),A
	LD	HL,(PTR)	;SHIFT RESULT TO T-O-S
	EX	DE,HL
	LD	HL,(TOS)
	LD	B,A
	CALL	MOVE
	LD	HL,(TOS)
	LD	A,(IT)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(TOS),HL
A045D:	LD	HL,IT
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	RET
A045E:	XOR	A
	LD	(IT),A
	JP	A045D
;*
;*
AC46:	;$CHAR ACTION
	CALL	SSCHK
	LD	HL,INT1		;GET INTEGER
	CALL	STI
	LD	HL,COUNT	;GET COUNT
	LD	B,1
	CALL	POPIT
	LD	HL,INT1		;IGNORE, < 0
	LD	A,(HL)
	AND	0F0H
	JP	NZ,A0461
	CALL	ITC
	LD	(N),A
	LD	HL,COUNT
	INC	(HL)
	LD	HL,N
	LD	B,1
	CALL	PUSHT
A0461:	LD	HL,COUNT
	LD	B,1
	CALL	PUSHT
	RET
;*
;*
AC47:	;SET VALUES
	CALL	SSCHK
	XOR	A
	LD	(STCNT),A
	LD	A,(SETF)
	CP	1
	JP	Z,A0471
	LD	A,1		;A FOR OR A READ
	LD	(STCNT),A
	LD	HL,(PTR)
	DEC	HL
	LD	A,(HL)
	LD	(SCNT),A
	LD	BC,-(PTRLN)
	ADD	HL,BC
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(TPP),HL
	EX	DE,HL
	LD	HL,(PTR)
	CALL	PSUB
	DEC	HL
	LD	A,(HL)
	LD	(NLENG),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR),HL
	LD	(SETBS),HL
	LD	(NAME),HL
A0471:	XOR	A
	LD	(NR),A
	LD	HL,(TOS)	;IT'S A SET
	LD	(TTPTR),HL
	CALL	PAST
	LD	HL,SSDP		;GET BASE OF T-O-S
	LD	B,2
	CALL	POPIT
	LD	HL,VSZ		;GET SIZE OF T-O-S
	LD	B,2
	CALL	POPIT
	LD	HL,I4		;GET TYPE IF T-O-S
	LD	B,1
	CALL	POPIT
	LD	A,(I4)
	CP	3
	JP	NZ,A4715
	LD	HL,SLENG
	LD	B,1
	CALL	POPIT
	LD	HL,SLENG
	LD	B,1
	CALL	PUSHT
A4715:	LD	HL,I4
	LD	B,1
	CALL	PUSHT
	LD	A,(I4)
	LD	(ST),A
	LD	HL,(VSZ)
	LD	(TPP),HL
	LD	A,(SETF)
	OR	A
	JP	Z,A4720
	LD	A,(STCNT)
	OR	A
	JP	NZ,A0472
	LD	HL,(SETBS)
	LD	(NAME),HL
	LD	HL,(SSDP)
	LD	A,(HL)
	LD	(STCNT),A
A0472:	LD	HL,(NAME)	;GET LENGTH OF NAME
	LD	A,(HL)
	LD	(NLENG),A
	INC	HL
	LD	(NAME),HL
	LD	(TNAME),HL
	LD	(PTR),HL
	XOR	A
	LD	(IT),A
	LD	A,(NLENG)
	AND	128
	JP	Z,A4719
	LD	A,1
	LD	(IT),A
	LD	A,(NLENG)
	LD	B,A
	LD	A,128
	CPL
	AND	B
	LD	(NLENG),A
A4719:	LD	HL,(PTR)
	LD	A,(NLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR),HL
	LD	A,(HL)		;GET SUB COUNT
	LD	(SCNT),A
	LD	A,(IT)
	CP	1
	JP	Z,A0478
A4720:	LD	HL,(NAME)
	LD	(SPTR),HL
	CALL	SEARC
	LD	HL,(NAME)
	LD	(PTR3),HL
	LD	HL,(SPTR)	;PUT NAME BACK
	LD	(NAME),HL
	LD	A,(ST)
	LD	(I3),A
	XOR	A
	LD	(I1),A
	LD	A,(SCNT)
	OR	A
	JP	Z,A4725
	LD	A,(RESUL)
	OR	A
	JP	Z,A4724
	LD	A,(CASE)
	OR	A
	JP	NZ,A4725
	LD	HL,(LAST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,2
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(HL)
	ADD	A,4
	LD	(I3),A
	INC	HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,2
	ADD	HL,DE
	LD	(TPP),HL
	CALL	INS25
	LD	HL,(LAST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR2),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR1)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(LAST)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	BC,-(2)
	ADD	HL,BC
	LD	(PTR),HL
	LD	(LAST),HL
	LD	HL,(PTR1)
	LD	(LPTR),HL
	LD	HL,(PTR)
	LD	DE,2
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(PTR2)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	A,(HL)
	OR	128
	LD	(HL),A
	LD	DE,5
	ADD	HL,DE
	LD	C,(HL)
	LD	B,0
	ADD	HL,BC
	INC	HL
	LD	(PTR2),HL
	LD	A,(I3)
	CP	5
	JP	NZ,A4721
	LD	A,4
	LD	(COUNT),A
	JP	A4723
A4721:	LD	A,(I3)
	CP	6
	JP	NZ,A4722
	LD	A,5
	LD	(COUNT),A
	JP	A4723
A4722:	LD	HL,(PTR2)
	LD	A,(HL)
	LD	(COUNT),A
	LD	HL,COUNT
	INC	(HL)
A4723:	LD	HL,(PTR2)
	EX	DE,HL
	LD	HL,(PTR)
	LD	A,(COUNT)
	LD	B,A
	CALL	MOVE
	JP	A0473
A4724:	LD	A,4
	LD	(I3),A
A4725:	LD	A,(RESUL)
	CP	1
	JP	Z,A0473
	CALL	INSER		;PUT IN NAME
	LD	HL,(SYMPT)	;LINK ENTRY IN
	EX	DE,HL
	LD	HL,(PTR1)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR1)
	LD	(SYMPT),HL
	LD	(LPTR),HL
	LD	DE,8
	ADD	HL,DE
	LD	A,(NLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(LAST),HL
A0473:	LD	A,(SCNT)
	OR	A
	JP	Z,A0475
	LD	A,8
	LD	(I3),A
	LD	A,(SCNT)
	CP	1
	JP	C,$+6
	JP	NZ,A0474
	LD	A,(ST)
	ADD	A,8
	LD	(I3),A
A0474:	XOR	A
	LD	(I9),A
	CALL	SINSR		;PUT IN SUBSCRIPT ENTRY
	LD	HL,(PTR1)	;LINK ENTRY IN
	EX	DE,HL
	LD	HL,(LAST)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR1)
	LD	(LAST),HL
	LD	(LPTR),HL
	LD	HL,SCNT
	DEC	(HL)
	JP	A0473
A0475:	CALL	SETVA		;PUT IN VALUE
A4755:	LD	A,(NR)		;SET IN FNAKD
	CP	1
	JP	NZ,A4757
	XOR	A
	LD	(NR),A
	LD	HL,(TNAME)
	LD	A,(HL)
	LD	(SCNT),A
	INC	HL
	LD	(PTR3),HL
A4756:	LD	HL,(PTR3)
	LD	A,(HL)
	CP	DELIM
	JP	Z,A4754
	INC	HL
	LD	(PTR3),HL
	JP	A4756
A4754:	LD	HL,(PTR3)	;SKIP INITIAL 1
	INC	HL
	LD	(PTR3),HL
	LD	HL,SCNT
	DEC	(HL)
	LD	A,(SCNT)
	OR	A
	JP	NZ,A4756
A4757:	LD	HL,STCNT
	DEC	(HL)
	LD	HL,(TTPTR)	;RESTORE TOS
	LD	(TOS),HL
	LD	HL,(PTR3)	;SET NAME
	LD	(NAME),HL
	LD	A,(STCNT)
	OR	A
	JP	NZ,A0471
	LD	HL,(SETBS)
	LD	(TOS),HL
	LD	A,(SETF)
	OR	A
	JP	Z,A0476
	XOR	A
	LD	(SETF),A
	RET
A0476:	LD	A,(RDF)
	CP	1
	JP	Z,A0477
	LD	HL,(NSTOS)
	LD	(TOS),HL
A0477:	RET
;* SET GLOBAL VALUE
A0478:	LD	A,(ST)
	LD	(I3),A
	LD	A,(SCNT)
	LD	(IT),A
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	(NLEN),HL
A4781:	LD	A,(IT)
	OR	A
	JP	Z,A4783
A478W:	LD	HL,(NLEN)
	LD	A,(HL)
	CP	DELIM
	JP	Z,A4782
	INC	HL
	LD	(NLEN),HL
	JP	A478W
A4782:	LD	HL,IT
	DEC	(HL)
	LD	HL,(NLEN)
	INC	HL
	LD	(NLEN),HL
	JP	A4781
A4783:	LD	HL,(PTR)
	EX	DE,HL
	LD	HL,(NLEN)
	CALL	PSUB
	LD	(NLEN),HL
	CALL	FNAKD
A4784:	LD	HL,(VSZ)	;PTR4 IS SIZE OF VALUE
	LD	(PTR4),HL
	LD	HL,(NLEN)	;PTR2 IS SIZE OF NAME + SUBS
	LD	A,(NLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	INC	HL
	LD	(PTR2),HL
	LD	HL,(NAME)
	LD	(NMPTR),HL
	LD	HL,(SSDP)
	INC	HL
	LD	(VLPTR),HL
	LD	A,1
	LD	(A47),A
	LD	HL,(NAME)
	LD	(PTR3),HL
	CALL	FINDK		;SEARCH FOR ENTRY
	CALL	GLSET
	XOR	A
	LD	(A47),A
	LD	HL,(NAME)
	LD	(PTR3),HL
	LD	HL,(NLEN)
	EX	DE,HL
	LD	HL,(PTR3)
	ADD	HL,DE
	LD	A,(NLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	INC	HL
	LD	(PTR3),HL
	JP	A4755
;*
;*
AC48:	;SAVE BREAK THINGS
	CALL	SSCHK
	LD	A,(MODE)	;INDIRECT MODE ONLY
	CP	DIREC
	JP	Z,E43
	CALL	CRLF
	LD	HL,BRKM		;WRITE OUT BREAK MESSAGE
	CALL	MSG
	LD	A,(IODVC)
	LD	(SDVC),A
	XOR	A
	LD	(I0),A
	CALL	SETDE
	LD	A,(CASE)
	CP	1
	JP	NZ,A0481
	CALL	AC54		;WRITE BREAK ARGUMENT
A0481:	CALL	CRLF
	LD	A,(INDSW)
	CP	1
	JP	C,$+6
	JP	NZ,A0482
	LD	HL,PRGLS	;SAVE LINE PTR
	LD	B,2
	CALL	PUSHT
A0482:	LD	HL,INDX		;SAVE INDX
	LD	B,2
	CALL	PUSHT
	LD	HL,INDFL	;SAVE INDIRECTION FLAG
	LD	B,1
	CALL	PUSHT
	LD	HL,FORSW
	LD	B,1
	CALL	PUSHT
	LD	HL,INDSW
	LD	B,1
	CALL	PUSHT
	LD	HL,DOSW
	LD	B,1
	CALL	PUSHT
	LD	HL,(TOS)
	LD	(BKPTR),HL
	XOR	A
	LD	(INDFL),A
	LD	(INDSW),A
	LD	(FORSW),A
	LD	(DOSW),A
	LD	A,(FLG1)
	OR	BRAKE
	LD	(FLG1),A
	LD	A,DIREC
	LD	(MODE),A
	LD	A,(FLAG)
	OR	2
	LD	(FLAG),A
	RET
;*
;*
AC49:	;RETURN FROM BREAK
	CALL	SSCHK
	LD	HL,DOSW
	LD	B,1
	CALL	POPIT
	LD	HL,INDSW
	LD	B,1
	CALL	POPIT
	LD	HL,FORSW
	LD	B,1
	CALL	POPIT
	LD	HL,INDFL	;RESTORE INDIRECTION FLAG
	LD	B,1
	CALL	POPIT
	LD	HL,SPTR		;GET INDX
	LD	B,2
	CALL	POPIT
	LD	A,(INDSW)
	CP	1
	JP	C,$+6
	JP	NZ,A0491
	LD	HL,PRGPT	;GET PROGRAM POINTER
	LD	B,2
	CALL	POPIT
A0491:	LD	A,INDIR
	LD	(MODE),A
	LD	A,(SDVC)
	LD	(IODVC),A
	LD	(IT),A
	CALL	SETDE
	LD	A,(INDSW)
	OR	A
	JP	NZ,A0492
	CALL	INPUT		;LOAD LINE INTO LINE EXECUTION BUFFER
A0492:	LD	HL,(SPTR)
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	LD	A,(FLG1)
	LD	B,A
	LD	A,BRAKE
	CPL
	AND	B
	LD	(FLG1),A
	LD	A,(TOKEN)
	CP	38
	JP	NZ,A0493
	LD	A,(FLAG)
	OR	2
	LD	(FLAG),A
A0493:	RET
;*
;*
AC50:	;$ORDER FUNCTION
	CALL	SSCHK
	LD	HL,IT		;LOCAL OR GLOBAL
	LD	B,1
	CALL	POPIT
	LD	HL,SCNT
	LD	B,1
	CALL	POPIT
	LD	A,(SCNT)	;MISSING SUBSCRIPT
	OR	A
	JP	Z,E46
	LD	(SSUB),A
	LD	HL,NLEN
	LD	B,2
	CALL	POPIT
	LD	HL,(TOS)
	DEC	HL
	LD	(PTR3),HL
	LD	HL,(NLEN)
	EX	DE,HL
	LD	HL,(PTR3)
	CALL	PSUB
	LD	(PTR3),HL
	INC	HL
	LD	(PTR),HL
	LD	HL,(PTR3)	;NAME LENGTH
	LD	A,(HL)
	LD	(NLENG),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR3),HL
	LD	(NAME),HL	;NAME TO START OF NAME
	LD	(TPTR),HL
	LD	A,(IT)		;GLOBAL
	CP	1
	JP	NZ,A050C
	CALL	SEARC
	LD	HL,(NAME)
	LD	(PTR3),HL
	LD	A,(RESUL)	;DONE--NO MATCH
	OR	A
	JP	Z,A050A
	LD	A,(CASE)	;PERFECT MATCH--FIND NEXT ONE
	CP	2
	JP	Z,A050B
	OR	A
	JP	Z,A050A
	LD	A,(SCNT)	;MORE THAN 1 SUB UNMATCHED
	CP	1
	JP	NZ,A050A
A0500:	LD	HL,(PTR3)
	LD	(PTR),HL
	LD	HL,(SDP)	;START OF ROW
	LD	(PTR3),HL
	LD	DE,NULL
	CALL	JPEN
	JP	Z,A050A
	LD	HL,PBIG
	LD	(PTR2),HL
	LD	HL,NULL
	LD	(LAST),HL
A0503:	LD	HL,(PTR3)	;CHECK ALL OF ROW
	LD	DE,PTRLN
	ADD	HL,DE
	LD	A,(HL)
	LD	(TYPE),A
	LD	DE,5		;TO ACROSS PTR
	ADD	HL,DE
	LD	(PTR3),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(AP),HL
	LD	HL,(PTR3)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR3),HL
	LD	(PTR5),HL
	LD	HL,(PTR)
	LD	(PTR4),HL
	CALL	COMPA
	LD	A,(CASE)	;TOO SMALL--TRY NEXT ONE
	CP	1
	JP	NZ,A0507
A5065:	LD	HL,(PTR2)
	LD	(PTR5),HL
	LD	HL,(PTR3)
	LD	(PTR4),HL
	CALL	COMPA
	LD	A,(CASE)	;TOO BIG--TRY NEXT ONE
	CP	1
	JP	NZ,A0507
	XOR	A
	LD	(I3),A
	LD	HL,(PTR3)	;OK--SAVE IT
	LD	(PTR2),HL
	LD	(LAST),HL
A0507:	LD	HL,(AP)		;GO TO NEXT ONE
	LD	(PTR3),HL
	LD	DE,NULL
	CALL	JPEN
	JP	NZ,A0503
	LD	HL,(LAST)	;NONE LARGER
	LD	DE,NULL
	CALL	JPEN
	JP	Z,A050A
A0508:	LD	HL,(LAST)
	LD	(PTR3),HL
	CALL	SUBSI
	LD	A,(I1)
	LD	(IT),A
	LD	A,FALSE
	LD	(ITX),A
	LD	HL,(LAST)
	LD	A,(HL)
	CP	31
	JP	C,$+6
	JP	NZ,A5085
	LD	A,(HL)
	CP	14
	JP	C,$+6
	JP	NZ,A5083
	LD	A,TRUE
	LD	(ITX),A
	LD	HL,(TPTR)
	INC	HL
	LD	(TPTR),HL
A5083:	LD	HL,(LAST)
	INC	HL
	LD	(LAST),HL
	LD	HL,IT
	DEC	(HL)
A5085:	LD	HL,(LAST)
	EX	DE,HL
	LD	HL,(TPTR)
	LD	A,(IT)
	LD	B,A
	CALL	MOVE
	LD	A,(ITX)
	CP	FALSE
	JP	Z,A5088
	LD	A,(IT)
	LD	(I2),A
	LD	HL,(TPTR)
	DEC	HL
	LD	(TPTR),HL
	LD	(PTR),HL
	LD	(HL),'-'
	LD	HL,IT
	INC	(HL)
A5086:	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	A,(HL)
	CP	'.'
	JP	Z,A5087
	LD	A,105
	SUB	(HL)
	LD	(I1),A
	LD	(HL),A
A5087:	LD	HL,I2
	DEC	(HL)
	LD	A,(I2)
	OR	A
	JP	NZ,A5086
	LD	HL,(PTR)
	INC	(HL)
A5088:	LD	HL,(TPTR)
	LD	A,(IT)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(TPTR),HL
	LD	(TOS),HL
A0509:	LD	HL,IT
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	RET
A050A:	LD	HL,(TPTR)	;ERROR RETURN
	LD	(TOS),HL
	LD	A,(DOR)
	CP	1
	JP	Z,A050X
	LD	A,'-'
	CALL	CPUSH
	LD	A,'1'
	CALL	CPUSH
	LD	A,2
	LD	(IT),A
	JP	A0509
A050X:	XOR	A
	LD	(IT),A
	JP	A0509
A050B:	LD	HL,(LAST)	;PERFECT MATCH FIXER
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,9
	ADD	HL,DE
	LD	(PTR3),HL
	JP	A0500
A050C:	CALL	FNAKD
	CALL	FINDK		;GLOBAL SEARCH
	LD	HL,(PTR1)
	LD	DE,NULL
	CALL	JPEN
	JP	Z,A050D
	LD	A,(I5)		;MORE THAN 1 SUB LEFT
	CP	1
	JP	C,$+6
	JP	NZ,A050A
A050D:	CALL	GETNE		;MOVE TO NEXT ENTRY
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,A050A
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(NAME)
	LD	(PTR3),HL
	LD	A,(SCNT)
	LD	(I5),A
	CALL	KEYCM
	LD	A,(I5)
	OR	A
	JP	NZ,A050E
	LD	HL,(PTR)
	LD	BC,-(PTRLN)
	ADD	HL,BC
	LD	(PTR),HL
	LD	A,TRUE
	LD	(RESUL),A
	JP	A050D
A050E:	LD	A,(I5)
	CP	1
	JP	NZ,A050A
	LD	A,(RESUL)
	CP	TRUE
	JP	NZ,A050A
	JP	A0508
;*
;*
AC51:	;SET VALUE IN FOR
	CALL	SSCHK
	LD	HL,(VPTR)
	LD	(PTR),HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(NSTOS),HL
	CALL	AC47		;SET VALUE
	XOR	A		;NO EXPRESSION VALUES SAVED
	CALL	CPUSH
	RET
;*
;*
AC52:	;$RANDOM ACTION
	CALL	SSCHK
	LD	HL,INT1		;GET RANGE
	CALL	STI
	LD	A,(HL)
	AND	0F0H
	JP	NZ,E20
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,E20
	CALL	NXTRN		;GET NEXT RANDOM NUMBER
	RET
;*
;*
AC53:	;DEVICE SPECIFIC WRITE
	CALL	SSCHK
	CALL	STC0
	LD	(IT),A
	LD	HL,IT
	LD	B,1
	CALL	PUSHT
	LD	A,1
	CALL	CPUSH
	LD	A,3
	CALL	CPUSH
	CALL	AC54		;WRITE IT OUT
	RET
;*
;*
AC54:
	CALL	SSCHK
	LD	HL,TYPE		;WRITE THE ITEM ON T-O-S
	LD	B,1
	CALL	POPIT
	LD	A,(TYPE)	;IS IT A NUMBER?
	CP	3
	JP	C,A0543
	CP	4		;IS IT STRING, BUT NOT ON STACK
	JP	Z,A0545
A0540:	LD	HL,COUNT
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(COUNT)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
A0542:	LD	HL,(TOS)
	DEC	HL
	LD	(TPP),HL
	JP	A5455
A0543:	LD	HL,TYPE
	LD	B,1
	CALL	PUSHT
	CALL	AC33		;CONVERT INTEGER TO STRING
	LD	HL,TYPE
	LD	B,1
	CALL	POPIT
	JP	A0540
A0545:	LD	HL,TPP		;GET PTR TO VALUE IN SYMBOL TABLE
	LD	B,2
	CALL	POPIT
	LD	HL,(TPP)	;STRING LENGTH
	LD	A,(HL)
	LD	(COUNT),A
A5455:	LD	A,(COUNT)
	LD	(IT),A
A0546:	LD	HL,(TPP)	;WRITE IT OUT
	INC	HL
	LD	(TPP),HL
	LD	A,(IT)
	OR	A
	JP	Z,A0547
	LD	A,(HL)
	LD	(CHR),A
	CALL	PUTCH
A5465:	LD	HL,IT
	DEC	(HL)
	JP	A0546
A0547:	LD	HL,INT1		;ADJUST $X
	LD	A,(COUNT)
	CALL	CTI
	LD	HL,(DEVX)
	LD	DE,INT1
	LD	C,INTLN
	CALL	BCDAD
	RET
;*
;*
AC55:	;HALT ACTION
	CALL	SSCHK
	LD	A,(FLG1)
	AND	DIRTY
	JP	NZ,E42
A0551:	CALL	GLBCL
	JP	BOOT
;*
;*
AC56:	;SET $TEST=0, LINACT FALSE
	XOR	A
	LD	(DIF),A
	LD	A,(ACTFL)
	OR	2
	LD	(ACTFL),A
	LD	A,(FLAG)	;IGNORE REST OF LINE
	OR	2
	LD	(FLAG),A
	RET
;*
;*
AC57:	;SET $TEST=1
	LD	A,1
	LD	(DIF),A
	RET
;*
;*
AC58:	;SET LINACT FALSE IF $TEST=0
	LD	A,(SWIF)	;$TEST UNDEFINED
	CP	2
	JP	Z,E3
	OR	A
	JP	NZ,A0581
	LD	A,(ACTFL)
	OR	2
	LD	(ACTFL),A
A0581:	RET
;*
;*
AC59:	;SET LINACT FALSE IF $TEST=1
	LD	A,(SWIF)	;$TEST UNDEFINED
	CP	2
	JP	Z,E3
	CP	1
	JP	NZ,A0591
	LD	A,(ACTFL)
	OR	2
	LD	(ACTFL),A
A0591:	RET
;*
;*
AC60:	;HANG ACTION
	CALL	SSCHK
	LD	HL,DTIME	;GET TIME TO HANG
	CALL	STI
	LD	A,(HL)
	AND	0F0H
	JP	NZ,A0603
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A0603
	LD	A,FALSE
	LD	(TIME),A
	LD	A,1
	LD	(WAIT),A
A0601:	LD	A,(TIME)
	CP	FALSE
	JP	Z,A0601
	XOR	A
	LD	(WAIT),A
A0603:	RET
;*
;*
AC61:	;KILL ALL
	LD	HL,(PTEND)
	LD	(SYMPT),HL
	LD	(SYMEN),HL
	RET
;*
;*
AC62:	;MARK FOR EXCLUSIVE KILL
	CALL	SSCHK
	LD	A,(KILF)
	CP	1
	JP	Z,A0621
	CALL	GARBG		;MAKE SURE NO MARKED ENTRIES
A0621:	LD	HL,SCNT
	LD	B,1
	CALL	POPIT
	LD	A,(SCNT)
	OR	A
	JP	Z,A0622
	CALL	AC76		;NO SUBSCRIPTS ALLOWED
	JP	E23
A0622:	LD	HL,TPP
	LD	B,2
	CALL	POPIT
	LD	HL,NLENG	;NAME LENGTH
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(NLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	(NAME),HL
	LD	A,1
	LD	(KILF),A
	CALL	SEARC
	LD	A,(RESUL)
	CP	1
	JP	Z,A0623
	RET
A0623:	LD	A,1
	LD	(FNDF),A
	LD	HL,(LAST)	;PTR1 TO START OF ENTRY
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR1),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(LAST)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(SYMPT)	;LINK TO HEAD OF LIST
	EX	DE,HL
	LD	HL,(PTR1)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR1)
	LD	(SYMPT),HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR1),HL
	LD	A,(HL)
	LD	(TYPE),A
	LD	A,(HL)
	OR	128
	LD	(HL),A
	LD	A,(TYPE)	;MOVE TO DOWN PTR
	CP	4
	JP	C,A0624
	LD	HL,(PTR)
	LD	BC,-(PTRLN)
	ADD	HL,BC
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR2),HL
	XOR	A
	LD	(IT),A
	CALL	MARKS		;MARK DESCENDENTS
A0624:	RET
;*
;*
AC63:	;KILL EXCLUSIVE OF MARKED VARIABLES
	CALL	SSCHK
	XOR	A		;RESET EXCLUSIVE KILL FLAG
	LD	(KILF),A
	LD	A,(FNDF)
	OR	A
	JP	NZ,A0630
	CALL	AC61
	RET
A0630:	LD	HL,(SYMPT)
	LD	(PTR),HL
A0631:	LD	HL,(PTR)
	EX	DE,HL
	LD	HL,(PTEND)
	CALL	JPEN
	JP	Z,A0635
	LD	HL,(PTR)	;SAVE START
	LD	(TPTR),HL
	LD	E,(HL)		;GET NEXT ONE
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(SPTR),HL
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(HL)
	LD	(TYPE),A
	LD	A,(HL)
	AND	128
	JP	NZ,A0632
	LD	A,(HL)		;RESET, SO SET IT
	OR	128
	LD	(HL),A
	XOR	A
	LD	(IT),A
	LD	HL,(PTEND)
	EX	DE,HL
	LD	HL,(PTR1)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	JP	A0633
A0632:	LD	HL,(PTR)	;SET, SO RESET IT
	LD	B,(HL)
	LD	A,128
	CPL
	AND	B
	LD	(HL),A
	LD	A,1
	LD	(IT),A
	LD	A,(TYPE)
	SUB	128
	LD	(TYPE),A
A0633:	LD	A,(TYPE)
	CP	4
	JP	C,A0634
	LD	HL,(PTR)	;DESCENDENTS SO (RE)SET THEM
	LD	DE,5
	ADD	HL,DE
	LD	A,(HL)
	LD	(I1),A
	LD	C,A
	LD	B,0
	ADD	HL,BC
	INC	HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR2),HL
	CALL	MARKS
A0634:	LD	HL,(TPTR)
	LD	(PTR1),HL
	LD	HL,(SPTR)
	LD	(PTR),HL
	JP	A0631
A0635:	RET
;*
;*
AC64:	;KILL VARIABLE + DESCENDENTS
	CALL	SSCHK
	LD	HL,TYPE		;LOCAL OR GLOBAL
	LD	B,1
	CALL	POPIT
	LD	HL,SCNT		;SUBSCRIPT COUNT
	LD	B,1
	CALL	POPIT
	LD	HL,NLEN		;SIZE OF SUBS
	LD	B,2
	CALL	POPIT
	LD	HL,(TOS)
	DEC	HL
	LD	(PTR3),HL
	LD	HL,(NLEN)
	EX	DE,HL
	LD	HL,(PTR3)
	CALL	PSUB
	LD	(PTR3),HL
	INC	HL
	LD	(PTR),HL
	LD	HL,(PTR3)	;NAME LENGTH
	LD	A,(HL)
	LD	(NLENG),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR3),HL
	LD	(NAME),HL
	LD	(TPTR),HL
	LD	A,(TYPE)	;LOCAL OR GLOBAL?
	CP	1
	JP	NZ,A0644
	CALL	SEARC
	LD	A,(RESUL)	;DONE--NO ENTRY
	OR	A
	JP	Z,A0643
	LD	A,(CASE)	;DONE--INCOMPLETE SUBSCRIPT MATCH
	CP	2
	JP	NZ,A0643
	LD	HL,(LAST)	;PTR1 TO START OF ENTRY
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR1),HL
	LD	(TPP),HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR1),HL
	LD	A,(HL)		;ANY DESCENDENTS?
	CP	3
	JP	C,$+6
	JP	NZ,A0641
	LD	A,(HL)		;MARK AS GARBAGE
	OR	128
	LD	(HL),A
	LD	HL,(TPP)	;UNLINK IT
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(LAST)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	JP	A0643		;DOEE
A0641:	LD	HL,(PTR1)	;ARRAY HEADER?
	LD	A,(HL)
	CP	7
	JP	C,$+6
	JP	NZ,A0642
	LD	A,(HL)		;MARK AS GARBAGE
	OR	128
	LD	(HL),A
	LD	HL,(TPP)	;UNLINK IT
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(LAST)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)	;MOVE TO DOWN PTR
	LD	BC,-(PTRLN)
	ADD	HL,BC
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR2),HL
	LD	HL,(PTR)	;ZERO OUT DOWN POINTER
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	XOR	A
	LD	(IT),A
	CALL	MARKS		;MARK DESCENDENTS
	JP	A0643		;DONE
A0642:	LD	HL,(TPP)	;GET PTR2 TO START FOR MARKS
	LD	(PTR2),HL
	LD	HL,(PTR1)
	INC	HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	DE,PTRLN	;MOVE TO ACROSS PTR
	ADD	HL,DE
	LD	(PTR1),HL
	LD	E,(HL)		;UNLINK ENTRY(S)
	INC	HL
	LD	D,(HL)
	LD	HL,(LAST)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR1)	;WIPE OUT ACROSS PTR
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	XOR	A
	LD	(IT),A
	CALL	MARKS
A0643:	LD	HL,(TPTR)
	LD	(TOS),HL
	RET
A0644:	LD	A,(GLBDR)
	LD	(DRIVE),A
	XOR	A
	LD	(FCBTY),A
	LD	A,(GLOPN)
	CP	1
	JP	Z,A6445
	CALL	FOPEN
	LD	A,1
	LD	(GLOPN),A
	CALL	RDROO
A6445:	LD	HL,ROOT
	LD	DE,NIL
	CALL	JDEN
	JP	Z,A0643
	CALL	FNAKD
	LD	A,(SCNT)
	LD	(SSCNT),A
	LD	HL,(TOS)
	LD	(TOP),HL
	CALL	FINDK		;SEARCH FOR ENTRY
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,A0646
A0645:	CALL	GLKIL		;KILL ENTRY
	LD	HL,(NAME)
	LD	(PTR3),HL
	LD	A,(SSCNT)
	LD	(SCNT),A
	CALL	FINDK		;SEARCH FOR ENTRY AGAIN
A0646:	CALL	GETNE
	CALL	FDDSC		;SEE IF ANY DESCEDENTS
	LD	A,(RESUL)
	CP	TRUE
	JP	Z,A0645
	JP	A0643
;*
;*
AC65:	;MAKE DEVICE CURRENT
	CALL	SSCHK
	LD	HL,COUNT	;GET COUNT OF PARAMS
	LD	B,1
	CALL	POPIT
	LD	A,(COUNT)	;TOO MANY PARAMETERS
	OR	A
	JP	NZ,E48
	LD	HL,DEVNO	;GET DEVICE NUMBER
	LD	B,1
	CALL	POPIT
	LD	A,(DEVNO)
	LD	(IT),A
	CALL	SETDE		;SET DEVICE PTRS
	LD	HL,(DEVOP)	;CHECK DEVICE OPEN
	LD	A,(HL)
	OR	A
	JP	NZ,A0651
	LD	A,(IODVC)	;NO, BACK TO CURRENT
	LD	(IT),A
	CALL	SETDE
	JP	E49
A0651:	LD	A,(DEVNO)
	LD	(IODVC),A
	RET
;*
;*
AC66:	;DEVICE SPECIFIC READ
	CALL	SSCHK
	LD	A,(RESUL)
	OR	A
	JP	Z,A0660
	LD	A,(SWIF)
	OR	A
	JP	Z,A0662
	JP	A0661
A0660:	LD	HL,(DEVRD)
	LD	A,(HL)
	CP	1
	JP	Z,A0662
	LD	A,(IODVC)
	OR	A
	JP	NZ,A6605
	LD	L,6
	CALL	BIOS
	LD	(CHR),A
	JP	A0661
BIOS:	LD	E,L
	LD	D,0
	LD	HL,(1)
	ADD	HL,DE
	JP	(HL)
A6605:	LD	HL,(DEVOP)
	LD	A,(HL)
	CP	2
	JP	Z,A6607
	LD	HL,(DVBSZ)
	LD	A,(HL)
	LD	HL,(DVBSU)
	LD	(HL),A
A6607:	CALL	GETCH
	LD	HL,(DEVOP)
	LD	(HL),2
A0661:	LD	HL,(TOS)
	LD	(PTR4),HL
	LD	A,(CHR)
	CALL	CTS
	LD	HL,(DEVX)
	LD	C,INTLN
	CALL	ADD1
A0662:	LD	HL,(PTR4)
	LD	(PTR),HL
	LD	A,1
	LD	(RDF),A
	CALL	AC47
	XOR	A
	LD	(RDF),A
	RET
;*
;*
AC67:	;WRITE STRING FROM A READ
	CALL	SSCHK
	CALL	AC54
	RET
;*
;*
AC68:	;READ VALUE FROM TERMINAL
	CALL	SSCHK
	LD	HL,(TOS)
	LD	(PTR4),HL
	LD	A,(IODVC)
	LD	(IT),A
	CALL	SETDE
	LD	A,(RESUL)
	OR	A
	JP	Z,A068A
	LD	A,(IODVC)
	OR	A
	JP	NZ,A0681
	LD	HL,(PTR4)
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR4),HL
	JP	A0682
A068A:	LD	HL,(DEVRD)	;DEVICE WRITE ONLY?
	LD	A,(HL)
	CP	1
	JP	Z,E51
	XOR	A
	LD	(SLENG),A
	LD	A,(IODVC)
	OR	A
	JP	Z,A0680
	LD	HL,(DEVOP)
	LD	A,(HL)
	CP	2
	JP	Z,A0681
A0680:	LD	HL,(DVBSZ)
	LD	A,(HL)
	LD	HL,(DVBSU)
	LD	(HL),A
A0681:	CALL	GETCH		;GET A CHARACTER
	LD	A,(CHR)
	CP	CR
	JP	Z,A0682
	LD	A,(SLENG)	;STRING TOO LONG
	CP	STRLN
	JP	Z,E11
	LD	HL,SLENG
	INC	(HL)
	LD	HL,CHR
	LD	B,1
	CALL	PUSHT
	LD	A,(CHR)
	CP	EOF
	JP	Z,A0682
	JP	A0681
A0682:	LD	HL,SLENG	;SAVE LENGTH
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	LD	A,(IODVC)
	OR	A
	JP	Z,A6825
	CALL	GETCH
A6825:	LD	HL,(DEVOP)
	LD	(HL),2
	LD	HL,INT1		;ADJUST $X
	LD	A,(SLENG)
	CALL	CTI
	LD	HL,(DEVX)
	LD	DE,INT1
	LD	C,INTLN
	CALL	BCDAD
	LD	HL,(PTR4)
	LD	(PTR),HL
	LD	A,1
	LD	(RDF),A
	CALL	AC47		;SET VALUE
	XOR	A
	LD	(RDF),A
A0683:	RET
;*
;*
AC69:	;CLEAR OFF TRANSPT INFO
	CALL	SSCHK
	LD	HL,IT		;GET TYPE
	LD	B,1
	CALL	POPIT
	LD	A,(IT)
	OR	A
	JP	Z,A0691
	LD	HL,SLENG	;GET ROUTINE NAME LENGTH
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
A0691:	LD	A,(IT)		;DONE
	CP	1
	JP	Z,A0693
	LD	HL,IT		;GET OFFSET
	LD	B,1
	CALL	POPIT
	LD	A,(IT)		;NO OFFSET
	OR	A
	JP	Z,A0692
	LD	HL,SLENG
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
A0692:	LD	HL,IT		;GET LABEL LENGTH
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(IT)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
A0693:	RET
;*
;*
AC70:	;PUT -1 ON STACK
	CALL	SSCHK
	LD	A,255
	CALL	CPUSH
	RET
;*
;*
AC71:	;SAVE VALUE OF CASE
	CALL	SSCHK
	LD	HL,CASE
	LD	B,1
	CALL	PUSHT
	RET
;*
;*
AC72:	;GOTO ACTION
	CALL	SSCHK
	CALL	GTTRN		;GET TRANSFER POINT LOADED
A0721:	LD	A,(INDFL)
	OR	A
	JP	Z,A0722
	CALL	INDRE		;RETURN FROM INDIRECTION
	JP	A0721
A0722:	LD	A,(FORSW)
	OR	A
	JP	Z,A0723
	POP	HL
	LD	(PTR1),HL
	POP	HL
	LD	(PTR2),HL
	CALL	AC89		;RETURN FROM FOR
	CALL	AC90
	POP	HL
	POP	HL
	LD	HL,(PTR2)
	PUSH	HL
	LD	HL,(PTR1)
	PUSH	HL
	JP	A0722
A0723:	CALL	AC105		;IGNORE REST OF LINE
	XOR	A
	LD	(MODE),A
	LD	A,FALSE
	LD	(GOTOF),A
	LD	A,(INDSW)
	OR	A
	JP	Z,A0724
	LD	A,TRUE
	LD	(GOTOF),A
A0724:	RET
;*
;*
AC73:	;DO ACTION
	CALL	SSCHK
	CALL	GTTRN		;GET TRANSFER POINT LOADED
	LD	A,(NLENG)
	LD	(IT),A
A0731:	LD	A,(IT)
	OR	A
	JP	Z,A0732
	LD	HL,(PTR4)
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR4)
	INC	HL
	LD	(PTR4),HL
	LD	HL,IT
	DEC	(HL)
	JP	A0731
A0732:	LD	HL,NLENG	;SAVE OLD NAME LENGTH
	LD	B,1
	CALL	PUSHT
	LD	HL,PRGLS	;SAVE START OF LINE
	LD	B,2
	CALL	PUSHT
	LD	HL,INDX		;SAVE LOCATION IN LINE
	LD	B,2
	CALL	PUSHT
	LD	HL,FORSW	;SAVE FOR COUNT
	LD	B,1
	CALL	PUSHT
	LD	HL,INDSW	;SAVE XECUTE COUNT
	LD	B,1
	CALL	PUSHT
	LD	HL,INDFL	;SAVE INDIRECTION FLAG
	LD	B,1
	CALL	PUSHT
	LD	HL,MODE
	LD	B,1
	CALL	PUSHT
	LD	HL,DOSW
	INC	(HL)
	LD	HL,LEVEL
	INC	(HL)
	LD	A,(LEVEL)	;NESTING TOO DEEPLY
	CP	MXLVL
	JP	Z,E32
	XOR	A
	LD	(FORSW),A
	LD	(INDSW),A
	LD	(INDFL),A
	LD	(MODE),A
	CALL	INPUT
	JP	MMP6
;*
;*
AC74:	;$TEST WITH LINEREF
	CALL	SSCHK
	CALL	MV2LN		;PTR1 TO LINE
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	CALL	LN2ST		;LINE TO STACK
	RET
;*
;*
AC75:	;QUIT ACTION
	CALL	SSCHK
	LD	A,(FORSW)
	OR	A
	JP	Z,A0751
	CALL	AC89		;RETURN FROM FOR
	CALL	AC90
	LD	A,(FORSW)
	OR	A
	JP	NZ,A0753
	LD	A,(FLAG)
	OR	2
	LD	(FLAG),A
	JP	A0753
A0751:	LD	A,(INDSW)
	OR	A
	JP	Z,A0752
	CALL	XECRE
	JP	A0754
A0752:	LD	A,(DOSW)
	OR	A
	JP	Z,A0755
	CALL	DORET		;RETURN FROM DO
	JP	A0754
A0753:	POP	HL
A0754:	POP	HL
	POP	HL
	JP	A0756
A0755:	LD	A,(AUTO)
	CP	3
	JP	Z,A0551
	LD	A,1
	LD	(MODE),A
	LD	A,2
	LD	(FLAG),A
A0756:	RET
;*
;*
AC76:	;UNMARK SYMBOL TABLE AFTER EXCLUSIVE KILL
	CALL	SSCHK
	LD	A,(KILF)	;DONE--NOTHING MARKED YET
	OR	A
	JP	Z,A0762
	XOR	A
	LD	(KILF),A
	LD	HL,(SYMEN)
	LD	(PTR),HL
A0761:	LD	HL,(PTR)
	EX	DE,HL
	LD	HL,(PTEND)
	CALL	JPEN
	JP	Z,A0762
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	B,(HL)		;RESET GARBAGE FLAG
	LD	A,128
	CPL
	AND	B
	LD	(HL),A
	INC	HL
	LD	(TPP),HL
	LD	E,(HL)		;GET SIZE
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(TPP),HL
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	(PTR),HL
	JP	A0761
A0762:	RET
;*
;*
AC77:	;CLOSE DEVICE--RELEASE
	CALL	SSCHK
	LD	HL,NUMBR	;GET COUNT OF PARAMS
	LD	B,1
	CALL	POPIT
	LD	A,(NUMBR)
	OR	A
	JP	Z,A0771
	CP	1		;TOO MANY PARAMS
	JP	NZ,E48
	LD	HL,INT1		;GET ARGUMENT
	CALL	STI
A0771:	LD	HL,DEVNO	;GET DEVICE NUMBER
	LD	B,1
	CALL	POPIT
	LD	A,(DEVNO)
	LD	(IT),A
	CALL	SETDE		;SET DEVICE PTRS
	LD	A,(DEVNO)	;CHECK IF DISK
	CP	2
	JP	C,A0772
	LD	HL,(DEVOP)	;LAST USED FOR A WRITE?
	LD	A,(HL)
	CP	3
	JP	NZ,A0772
	LD	HL,(DVPTR)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	(HL),EOF
	LD	A,(XTDRV)
	LD	(DRIVE),A
	LD	HL,(DEVPM)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(FCB),HL
	LD	HL,(DVBST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BUFFR),HL
	CALL	FWRIT
A0772:	LD	HL,(DEVOP)
	LD	A,(HL)
	OR	A
	JP	Z,E49
	LD	(HL),0
	LD	A,(NUMBR)
	OR	A
	JP	Z,A0775
	LD	A,(DEVNO)
	CP	2
	JP	C,A0775
	LD	A,(XTDRV)
	LD	(DRIVE),A
	LD	HL,(DEVPM)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(FCB),HL
	LD	HL,INT1
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A0774
A0773:	CALL	REMOV
	JP	A0775
A0774:	CALL	FCLOS
A0775:	LD	A,(DEVNO)
	LD	HL,IODVC
	CP	(HL)
	JP	NZ,A0776
	XOR	A
	LD	(IT),A
	LD	(IODVC),A
	CALL	SETDE
A0776:	RET
;*
;*
AC78:	;SEIZE OWNERSHIP OF DEVICE
	CALL	SSCHK
	LD	HL,COUNT	;GET COUNT OF PARAMS
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	(PTR),HL
	LD	A,(COUNT)
	OR	A
	JP	Z,A0781
	CP	2		;TOO MANY PARAMETERS
	JP	C,$+6
	JP	NZ,E48
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,IT		;GET NAME LENGTH
	LD	B,1
	CALL	POPIT
	LD	A,(IT)		;SEE IF DEFAULT
	OR	A
	JP	NZ,A078A
	LD	HL,SYSF		;DEFAULT NAME
	LD	(PTR),HL
A078B:	LD	HL,(PTR)
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,IT
	INC	(HL)
	LD	HL,(PTR)
	LD	A,(HL)
	CP	DELIM
	JP	NZ,A078B
A078A:	LD	HL,(TOS)
	LD	(PTR),HL
	LD	HL,IT
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR)	;PTR TO END OF NAME
	DEC	HL
	LD	(PTR),HL
	LD	A,(IT)		;PTR TO START OF NAME
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR),HL
	DEC	HL		;PTR TO LENGTH OF DRIVE
	LD	(PTR),HL
	LD	A,(HL)
	LD	(IT),A
	CP	1
	JP	C,$+6
	JP	NZ,E50
	OR	A
	JP	NZ,A078C
	XOR	A		;DEFAULT DRIVE IS A
	LD	(XTDRV),A
	JP	A0781
A078C:	LD	HL,(PTR)
	DEC	HL
	LD	(PTR),HL
	LD	A,(HL)		;GET DRIVE LETTER
	SUB	'A'
	LD	(XTDRV),A
A0781:	LD	HL,(PTR)
	DEC	HL
	LD	(PTR),HL
	LD	A,(HL)
	LD	(IT),A
	CALL	SETDE
	LD	A,(COUNT)
	OR	A
	JP	Z,A0784
	LD	A,2		;SET UP FCB
	LD	(FCBTY),A
	LD	A,(XTDRV)
	LD	(DRIVE),A
	CALL	FSEAR
	LD	A,(RESUL)	;FILE EXISTS
	CP	1
	JP	NZ,A0782
	CALL	FOPPL
	LD	HL,(DEVRD)
	LD	(HL),2
	JP	A0783
A0782:	CALL	MAKE
	LD	HL,(DEVRD)
	LD	(HL),1
A0783:	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
A0784:	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,(DEVOP)	;SET DEVICE OPEN
	LD	(HL),1
	LD	A,(IODVC)	;RETURN CURRENT
	LD	(IT),A
	CALL	SETDE		;DEVICE PARAMETERS
	RET
;*
;*
AC79:	;SET NUMERIC VALUE FOR FOR
	CALL	SSCHK
	CALL	AC34		;CONVERT T-O-S TO NUMERIC
	LD	HL,FREAL
	CALL	STN
	RET
;*
;*
AC80:	;WRITE OUT ROUTINE NAMES
	CALL	SSCHK
	XOR	A
	LD	(IT),A
	LD	(I4X),A
A0801:	CALL	SERCH		;LOOK FOR AN MMP FILE
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,A0805
	XOR	A
	LD	(COUNT),A
A0802:	LD	A,(COUNT)
	CP	8
	JP	Z,A0803
	LD	HL,(PTR)	;ROUTINE NAME ON STACK
	LD	B,1
	CALL	PUSHT
	LD	HL,COUNT
	INC	(HL)
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	A,(HL)
	CP	BLANK
	JP	NZ,A0802
A0803:	LD	A,12		;PAD NAME SO IT TAKES 12 SPACES
	LD	HL,COUNT
	SUB	(HL)
	LD	(ITX),A
A0804:	LD	A,' '		;'
	CALL	CPUSH
	LD	HL,ITX
	DEC	(HL)
	LD	A,(ITX)
	OR	A
	JP	NZ,A0804
	LD	A,12
	CALL	CPUSH
	LD	A,3
	CALL	CPUSH
	CALL	AC54		;WRITE OUT NAME
	LD	A,1		;AT LEAST SECOND TIME TO SERCH
	LD	(IT),A
	LD	HL,I4X
	INC	(HL)
	LD	A,(I4X)		;SEE IF NEED NEW LINE (5 PER LINE)
	CP	5
	JP	NZ,A0801
	CALL	AC24
	XOR	A
	LD	(I4X),A
	JP	A0801
A0805:	LD	A,(I4X)
	OR	A
	JP	Z,A0806
	CALL	AC24
A0806:	RET
;*
;*
AC81:	;SEARCH SYMBOL TABLE FOR NAME
	CALL	SSCHK
	LD	HL,SCNT		;GET SUBSCRIPT COUNT
	LD	B,1
	CALL	POPIT
	LD	HL,TPP		;GET POINTER TO BASE OF SUBS
	LD	B,2
	CALL	POPIT
	LD	HL,(TOS)
	LD	(PTR3),HL
	LD	DE,PTRLN+SHTLN
	ADD	HL,DE
	LD	(TOS),HL
	LD	HL,(PTR3)
	DEC	HL
	LD	(PTR3),HL
	LD	HL,(TPP)
	EX	DE,HL
	LD	HL,(PTR3)
	CALL	PSUB
	LD	A,(HL)
	LD	(NLENG),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR3),HL
	LD	(NAME),HL
	CALL	SEARC
	LD	A,(RESUL)	;NO MATCH
	OR	A
	JP	Z,E3
	LD	A,(STYPE)
	CP	4
	JP	Z,E3
	CP	8
	JP	Z,E3
	LD	A,(SCNT)
	OR	A
	JP	NZ,E3
	LD	A,(STYPE)
	CP	4
	JP	C,A8126
	SUB	4
	LD	(STYPE),A
	CP	4
	JP	C,A8126
	SUB	4
	LD	(STYPE),A
A8126:	LD	A,(STYPE)
	LD	(TYPE),A
	LD	A,(FORFL)
	CP	1
	JP	Z,A8127
	LD	HL,(PTR3)
	LD	(TOS),HL
	JP	A8128
A8127:	LD	HL,(TOPTR)
	LD	(TOS),HL
A8128:	LD	HL,(PTR)	;IT'S A STRING
	LD	A,(HL)
	LD	(SLENG),A
	INC	HL
	LD	(PTR),HL
	LD	(IT),A
A8129:	LD	A,(IT)
	OR	A
	JP	Z,A812A
	LD	HL,(PTR)
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,IT
	DEC	(HL)
	JP	A8129
A812A:	LD	HL,SLENG
	LD	B,1
	CALL	PUSHT
	LD	A,3
	LD	(TYPE),A
	JP	A0815
A0815:	LD	HL,TYPE
	LD	B,1
	CALL	PUSHT
	XOR	A
	LD	(FORFL),A
	RET
;*
;*
AC82:	;EXECUTE SCOPE OF FOR ONCE
	CALL	SSCHK
	LD	HL,INDX
	LD	B,2
	CALL	PUSHT
	LD	HL,(TOS)
	LD	BC,-(PTRLN+SHTLN)
	ADD	HL,BC
	LD	(PTR),HL
	LD	A,(HL)
	LD	(IT),A
A0821:	LD	A,(IT)
	OR	A
	JP	Z,A0822
	LD	HL,(PTR)
	DEC	HL
	DEC	HL
	LD	A,(HL)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR),HL
	LD	HL,IT
	DEC	(HL)
	JP	A0821
A0822:	LD	HL,(PTR)
	LD	BC,-(PTRLN)
	ADD	HL,BC
	LD	(PTR),HL
	LD	E,(HL)		;RETRIEVE B-O-S
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	JP	MMP6
;*
;*
AC83:	;ADD INCREMENT FOREVER
	CALL	SSCHK
	LD	HL,INDX		;GET VALUES OFF STACK
	LD	B,2
	CALL	POPIT
	LD	HL,(TOS)
	LD	(PTR1),HL
	LD	HL,(PTR1)	;PTR1 TO # OF EXPRESSIONS
	DEC	HL
	DEC	HL		;PTR1 TO STRING INDICATOR
	DEC	HL		;PTR TO LENGTH OF INCREMENT
	LD	(PTR1),HL
	LD	A,(HL)		;GET LENGTH TO I1
	LD	(I1X),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR1),HL
	LD	HL,(TOS)
	LD	(TOPTR),HL
	LD	(PTR2),HL
	LD	HL,(PTR1)
	LD	BC,-(PTRLN)
	ADD	HL,BC
	LD	(TOS),HL
	LD	(VPTR),HL
	LD	A,1
	LD	(FORFL),A
	CALL	AC81		;GET VALUE
	CALL	AC34
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I2
	LD	B,1
	CALL	POPIT
	LD	A,(I1X)
	LD	(I1),A
	LD	A,5		;MAKE IT +
	LD	(I6),A
	CALL	NUMOP
	LD	HL,(VPTR)
	LD	(PTR),HL
	LD	HL,(TOPTR)
	LD	(NSTOS),HL
	CALL	AC47		;SET CONTROL VALUE
	LD	A,2		;ENABLE SEMANTIC ACTIONS
	LD	(CASE),A
	RET
;*
;*
AC84:	;$TEXT WITH OFFSET
	CALL	SSCHK
	LD	A,1
	LD	(DT),A
	LD	HL,(PRGAD)
	LD	(PTR1),HL
	LD	HL,INT1
	CALL	STI
	LD	C,INTLN
	CALL	SUB1
	CALL	ITS
	CALL	MV2LN		;PTR1 TO LINE
	CALL	LN2ST		;LINE TO STACK
	XOR	A
	LD	(DT),A
	RET
;*
;*
AC85:	;RETURN GLOBAL VALUE ON STACK
	CALL	SSCHK
	LD	HL,SCNT		;GET SUBSCRIPT COUNT
	LD	B,1
	CALL	POPIT
	LD	HL,TPP		;GET POINTER TO BASE OF SUBS
	LD	B,2
	CALL	POPIT
	LD	HL,(TPP)
	LD	(NLEN),HL
	LD	HL,(TOS)
	DEC	HL
	LD	(PTR6),HL
	LD	HL,(TPP)	;PTR3 TO LENGTH OF NAME
	EX	DE,HL
	LD	HL,(PTR6)
	CALL	PSUB
	LD	(PTR6),HL
	INC	HL
	LD	(PTR),HL
	LD	HL,(PTR6)
	LD	A,(HL)
	LD	(NLENG),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR6),HL
	LD	(PTR3),HL
	LD	(NAME),HL
	CALL	FNAKD
	XOR	A
	LD	(NR),A
	CALL	FINDK		;SEARCH FOR KEY
	LD	A,(RESUL)	;NO SUCH NAME
	OR	A
	JP	Z,E7
	LD	HL,(PTR)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,PTRLN
	ADD	HL,DE
	LD	A,(HL)
	LD	(STYPE),A
	INC	HL
	LD	(PTR),HL
	LD	HL,(PTR6)
	LD	(TOS),HL
A0853:	LD	HL,(PTR)	;SET STRING LENGTH
	LD	A,(HL)
	LD	(SLENG),A
	INC	HL
	LD	(PTR),HL
	LD	(IT),A
A8532:	LD	A,(IT)
	OR	A
	JP	Z,A8535
	LD	HL,(PTR)
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,IT
	DEC	(HL)
	JP	A8532
A8535:	LD	HL,SLENG
	LD	B,1
	CALL	PUSHT
A0854:	LD	HL,STYPE
	LD	B,1
	CALL	PUSHT
	RET
;*
;*
AC86:	;PATTERN MATCHING
	CALL	SSCHK
	LD	HL,(INDX)
	LD	(TPP),HL
	LD	HL,(TOS)
	LD	DE,IMIN2
	CALL	SETI
	LD	HL,(TOS)
	LD	DE,INTLN
	ADD	HL,DE
	LD	(TOS),HL
	LD	HL,(TARPT)
	LD	(PTR1),HL
	DEC	HL
	DEC	HL
	LD	(INDX),HL
	LD	A,(HL)
	LD	(SLENG),A
	LD	(PTR2),HL	;MARK END OF STRING
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(INDX),HL
	LD	(PTR3),HL
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN		;SAVE START OF STRING
	LD	A,1
	LD	(RESUL),A
	XOR	A
	LD	(I1),A
A0861:	LD	DE,INT2		;GET REPITION COUNT
	LD	HL,(PTR1)
	EX	DE,HL
	CALL	SETI
	LD	HL,(PTR1)
	LD	DE,INTLN
	ADD	HL,DE
	LD	(PTR1),HL
	LD	HL,INT2
	LD	A,(HL)
	AND	0F0H
	JP	NZ,A8612
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A8612
	JP	A0864
A8612:	LD	HL,INT2
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A0862
	LD	DE,IMIN1
	LD	B,INTLN
	LD	C,INTLN
	CALL	SCMP
	JP	Z,A0862
	LD	HL,(INDX)
	EX	DE,HL
	LD	HL,(PTR2)
	CALL	JPEN
	JP	Z,A0868
	JP	A0865
A8615:	LD	HL,INT2
	LD	DE,IMIN1
	CALL	SETI
A0862:	LD	HL,I1		;INCREMENT LEVEL
	INC	(HL)
	LD	HL,PTR1		;SAVE CURRENT STATUS
	LD	B,2
	CALL	PUSHT
	LD	HL,INDX
	LD	B,2
	CALL	PUSHT
	LD	DE,INT3
	LD	HL,(PTR1)
	EX	DE,HL
	CALL	SETI
	LD	HL,(PTR1)
	LD	DE,INTLN
	ADD	HL,DE
	LD	(PTR1),HL
	LD	HL,INT3
	LD	A,(HL)
	AND	0F0H
	JP	NZ,A8625
	JP	A0863
A8625:	LD	HL,INT3
	LD	A,(HL)
	XOR	0F0H
	LD	(HL),A
A0863:	LD	HL,INT3
	CALL	ITC
	LD	(IT),A
	LD	HL,(PTR1)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR1),HL
	JP	A0861
A0864:	CALL	MATCH
	LD	HL,INT2
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A0861
	LD	HL,INT1
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A0861
A0865:	LD	A,(I1)
	OR	A
	JP	NZ,A0866
	XOR	A
	LD	(RESUL),A
	JP	A0868
A0866:	LD	HL,INDX
	LD	B,2
	CALL	POPIT
	LD	HL,PTR1
	LD	B,2
	CALL	POPIT
	LD	HL,I1
	DEC	(HL)
	LD	HL,INT2
	LD	DE,IMIN1
	CALL	SETI
	LD	HL,(INDX)
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	CALL	MATCH
	LD	HL,INT2
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A8615
	JP	A0865
A0868:	LD	HL,(PTR3)
	LD	(TOS),HL
	LD	A,(FLG1)
	AND	NOTFL
	JP	Z,A0869
	LD	A,(FLG1)
	LD	B,A
	LD	A,NOTFL
	CPL
	AND	B
	LD	(FLG1),A
	LD	A,(RESUL)
	XOR	1
	LD	(RESUL),A
A0869:	LD	A,(RESUL)
	CALL	CTS
	LD	HL,(TPP)
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	RET
;*
;*
AC87:	;CHECK IF ITERATION NEEDED
	CALL	SSCHK
	LD	HL,(TOS)
	LD	(TOPTR),HL
	LD	HL,(VPTR)
	LD	(TOS),HL
	LD	A,1
	LD	(FORFL),A
	CALL	AC81		;GET CONTROL VALUE
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,LVAL		;GET LENGTH OF VALUE
	LD	B,1
	CALL	POPIT
	LD	A,6		;DO A SUBTRACT
	LD	(I6),A
	LD	HL,(TOS)	;SAVE WHERE START OF SUBTRACT WILL BE
	LD	(PTR),HL
	LD	HL,(IPTR)
	LD	A,(HL)
	CP	'-'
	JP	Z,A0871
	LD	HL,(TOPTR)	;GET VALUE - FINAL
	LD	(PTR1),HL
	LD	HL,(FPTR)
	LD	(PTR2),HL
	LD	A,(LVAL)
	LD	(I1),A
	LD	A,(FSZ)
	LD	(I2),A
A0870:	CALL	NUMOP
	LD	HL,(TOPTR)
	LD	(TOS),HL
	LD	HL,(PTR)
	LD	A,(HL)
	CP	'-'
	JP	Z,A0872
	LD	A,(HL)
	CP	'0'
	JP	Z,A0872
	XOR	A		;NO ITERATIONS
	LD	(CASE),A
	LD	HL,INDX
	LD	B,2
	CALL	PUSHT
	RET
A0871:	LD	HL,(FPTR)
	LD	(PTR1),HL
	LD	HL,(TOPTR)
	LD	(PTR2),HL
	LD	A,(FSZ)
	LD	(I1),A
	LD	A,(LVAL)
	LD	(I2),A
	JP	A0870
A0872:	LD	A,1		;ITERATIONS
	LD	(CASE),A
	RET
;*
;*
AC88:	;ADD INCREMENT TO CONTROL VAR AND TEST
	CALL	SSCHK
	XOR	A
	LD	(CASE),A
	CALL	FORSE		;SET FOR POINTERS IN STACK
	LD	HL,(VPTR)
	LD	(TOS),HL
	LD	A,1
	LD	(FORFL),A
	CALL	AC81		;GET CONTROL VALUE
	CALL	AC34
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,LVAL		;GET LENGTH OF CONTROL VALUE
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	(PTR),HL
	LD	HL,(FPTR)
	LD	(PTR1),HL
	LD	A,(FSZ)
	LD	(I1),A
	LD	HL,(IPTR)
	LD	(PTR2),HL
	LD	A,(ISZ)
	LD	(I2),A
	LD	A,6
	LD	(I6),A
	CALL	NUMOP		;GET FINAL - INCREMENT
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I3
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	(PTR4),HL
	LD	HL,(IPTR)
	LD	A,(HL)
	CP	'-'
	JP	Z,A0881
	LD	HL,(PTR)
	LD	(PTR1),HL
	LD	A,(I3)
	LD	(I1),A
	LD	HL,(TOPTR)
	LD	(PTR2),HL
	LD	A,(LVAL)
	LD	(I2),A
A0880:	CALL	NUMOP		;TEST IF AT END
	LD	HL,(PTR4)
	LD	A,(HL)
	CP	'-'
	JP	Z,A0883
	JP	A0882
A0881:	LD	HL,(TOPTR)
	LD	(PTR1),HL
	LD	A,(LVAL)
	LD	(I1),A
	LD	HL,(PTR)
	LD	(PTR2),HL
	LD	A,(I3)
	LD	(I2),A
	JP	A0880
A0882:	LD	HL,(IPTR)
	LD	(PTR1),HL
	LD	A,(ISZ)
	LD	(I1),A
	LD	HL,(TOPTR)
	LD	(PTR2),HL
	LD	A,(LVAL)
	LD	(I2),A
	LD	A,5
	LD	(I6),A
	CALL	NUMOP		;GET INCREMENT + CONTROL VALUE
	LD	HL,(VPTR)
	LD	(PTR),HL
	LD	HL,(TOPTR)
	LD	(NSTOS),HL
	CALL	AC47		;ENTER VALUE IN SYMBOL TABLE
	LD	A,1
	LD	(CASE),A
	RET
A0883:	LD	HL,(TOPTR)
	LD	(TOS),HL
	LD	HL,INDX
	LD	B,2
	CALL	PUSHT
	RET
;*
;*
AC89:	;REMOVE FOR EXPRESSIONS FROM STACK
	CALL	SSCHK
	LD	HL,INDX
	LD	B,2
	CALL	POPIT
	LD	HL,TYPE
	LD	B,1
	CALL	POPIT
A0890:	LD	A,(TYPE)
	OR	A
	JP	Z,A0892
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I1
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(I1)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	HL,TYPE
	DEC	(HL)
	JP	A0890
A0892:	LD	HL,(INDX)
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	LD	HL,(TOS)
	LD	(PTR5),HL
	LD	BC,-(PTRLN)
	ADD	HL,BC
	LD	(VPTR),HL
	RET
;*
;*
AC90:	;REMOVE LAST OF FOR INFO
	CALL	SSCHK
	LD	HL,LEVEL
	DEC	(HL)
	LD	HL,FORSW
	DEC	(HL)
	LD	HL,(TOS)	;PAST B-O-S
	LD	BC,-(PTRLN)
	ADD	HL,BC
	LD	(TOS),HL
	DEC	HL		;PAST SUB COUNT
	LD	(TOS),HL
	LD	HL,PTR
	LD	B,2
	CALL	POPIT
	LD	HL,(PTR)	;PAST SUBSCRIPTS
	EX	DE,HL
	LD	HL,(TOS)
	CALL	PSUB
	LD	(TOS),HL
	LD	HL,(TOS)	;TO NAME LENGTH
	DEC	HL
	LD	(TOS),HL
	LD	A,(HL)		;PAST NAME
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
A0901:	LD	A,(TOKEN)
	CP	38
	JP	Z,A0902
	CALL	GTOKN
	JP	A0901
A0902:	RET
;*
;*
AC91:	;TIMEOUT ACTION
	CALL	SSCHK
	LD	HL,DTIME	;GET NUMBER OF SECONDS
	CALL	STI
	XOR	A
	LD	(SLENG),A
	LD	A,(LOCKS)
	CP	1
	JP	Z,A0916
	LD	A,(HL)
	AND	0F0H
	JP	NZ,A0913
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,A0913
	LD	A,(IODVC)
	OR	A
	JP	NZ,A0916
	LD	A,FALSE
	LD	(TIME),A
	LD	A,1
	LD	(WAIT),A
A0911:	LD	L,3
	CALL	BIOS
	OR	A
	JP	Z,A0912
	LD	L,6
	CALL	BIOS
	LD	(CHR),A
	LD	A,(TIMF)
	OR	A
	JP	Z,A0914
	LD	A,(CHR)
	CP	CR
	JP	Z,A0914
	CALL	TRMOT
	LD	HL,CHR
	LD	B,1
	CALL	PUSHT
	LD	HL,SLENG
	INC	(HL)
	LD	A,(SLENG)
	CP	STRLN
	JP	Z,A0913
A0912:	LD	A,(TIME)
	CP	FALSE
	JP	Z,A0911
A0913:	XOR	A
	LD	(SWIF),A
	LD	A,(TIMF)
	CP	1
	JP	Z,A0915
	LD	HL,(TOS)
	LD	(PTR4),HL
	LD	HL,IMIN1
	CALL	ITS
	JP	A0915
A0914:	LD	A,1
	LD	(SWIF),A
A0915:	XOR	A
	LD	(WAIT),A
	RET
A0916:	LD	A,1
	LD	(SWIF),A
	RET
;*
;*
AC92:	;DELETE ROUTINE
	LD	HL,(PRGAD)
	LD	(PRGEN),HL
	LD	(PRGPT),HL
	LD	HL,PRG		;CLEAR NAME
	LD	(PTR),HL
	LD	A,NAMLN
	LD	(IT),A
A0921:	LD	HL,(PTR)
	LD	(HL),BLANK
	LD	HL,IT
	DEC	(HL)
	LD	A,(IT)
	OR	A
	JP	NZ,A0921
	LD	A,(FLG1)	;NOT DIRTY
	LD	B,A
	LD	A,DIRTY
	CPL
	AND	B
	LD	(FLG1),A
	LD	HL,(PRGEN)
	LD	(HL),EOR
	RET
;*
;*
AC93:	;DELETE FROM LINE A TO LINE B
	CALL	SSCHK
	CALL	LINSE
	CALL	LINDE		;DELETE LINE
	RET
;*
;*
AC94:	;LOAD ROUTINE
	CALL	SSCHK
	CALL	LOADI
	LD	HL,(PRGEN)
	LD	(PRGPT),HL
	LD	A,(FLG1)
	LD	B,A
	LD	A,DIRTY
	CPL
	AND	B
	LD	(FLG1),A
	RET
;*
;*
AC95:	;PRGPT TO TOP
	LD	HL,(PRGAD)
	LD	(PRGPT),HL
	RET
;*
;*
AC96:	;MOVE PRGPT TO LINE
	CALL	SSCHK
	CALL	MV2LN		;MOVE PTR1 TO LINE
	LD	A,(RESUL)
	OR	A
	JP	Z,E34
	LD	HL,(PTR1)
	LD	(PRGPT),HL
	RET
;*
;*
AC97:	;LIST ENTIRE ROUTINE
	CALL	SSCHK
	LD	HL,(PRGAD)
	LD	(PTR),HL
A0971:	LD	HL,(PTR)
	LD	A,(HL)
	CP	EOR
	JP	Z,A0972
	CALL	LINWR		;WRITE OUT LINE
	JP	A0971
A0972:	RET
;*
;*
AC98:	;LIST FROM LINE A TO LINE B
	CALL	SSCHK
	CALL	LINSE
	LD	HL,(PTR1)	;PTR TO START OF LINE(S)
	LD	(PTR),HL
A0981:	CALL	LINWR		;LINE WRITE ROUTINE
	LD	HL,(PTR)
	EX	DE,HL
	LD	HL,(PTR3)
	CALL	JPEN
	JP	NZ,A0981
	RET
;*
;*
AC99:	;SCAN FOR B-O-S
	CALL	SSCHK
	LD	HL,FORSW
	INC	(HL)
	LD	HL,LEVEL
	INC	(HL)
	LD	A,(LEVEL)	;NEESTING TOO DEEPLY
	CP	MXLVL
	JP	Z,E32
	LD	HL,(INDX)	;SAVE INDX
	LD	(PTR),HL
	LD	A,(TOKEN)	;SAVE TOKEN
	LD	(IT),A
	XOR	A
	LD	(I1),A
A0991:	LD	A,(TOKEN)	;CHECK FOR SPACE
	CP	31
	JP	Z,A9915
	CP	38		;CHECK FOR EOL
	JP	Z,A0993
	CP	23
	JP	NZ,A9913
	LD	A,1
	LD	HL,I1
	SUB	(HL)
	LD	(I2),A
	LD	(I1),A
A9913:	CALL	GTOKN
	JP	A0991
A9915:	LD	A,(I1)
	CP	1
	JP	Z,A9913
A0992:	LD	HL,(INDX)
	INC	HL
	LD	(INDX),HL
A0993:	LD	HL,INDX		;SAVE B-O-S
	LD	B,2
	CALL	PUSHT
	LD	HL,(PTR)	;RETURN INDX
	LD	(INDX),HL
	LD	A,(IT)		;AND TOKEN
	LD	(TOKEN),A
	RET
;*
;*
AC100:	;PUSH GLB ON STACK
	CALL	SSCHK
	LD	HL,INDFL
	LD	B,1
	CALL	PUSHT
	LD	HL,NR
	LD	B,1
	CALL	PUSHT
	LD	HL,SETSW
	LD	B,1
	CALL	PUSHT
	LD	HL,GLB
	LD	B,1
	CALL	PUSHT
	XOR	A
	LD	(INDFL),A
	LD	A,FALSE
	LD	(SETSW),A
	RET
;*
;*
AC101:	;DUMMY ROUTINE TO FIX STABK FOR LOCK
	LD	HL,(SETBS)
	LD	(TOS),HL
	XOR	A
	LD	(SETF),A
	RET
;*
;*
AC102:	RET
;*
;*
AC103:	;XECUTE ACTION
	CALL	SSCHK
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,SLENG
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR),HL
	LD	HL,INDSW
	INC	(HL)
	LD	HL,LEVEL
	INC	(HL)
	LD	A,(LEVEL)	;NESTING TOO DEEPLY
	CP	MXLVL
	JP	Z,E32
	LD	HL,SLENG
	INC	(HL)
	LD	A,EOL
	CALL	CPUSH
	LD	HL,SLENG	;SAVE LENGTH
	LD	B,1
	CALL	PUSHT
	XOR	A
	LD	(N),A
	LD	HL,PRG
	LD	(PTR1),HL
A1031:	LD	HL,(PTR1)	;SAVE ROUTINE NAME
	LD	A,(HL)
	CP	BLANK
	JP	Z,A1032
	LD	B,1
	CALL	PUSHT
	LD	HL,N
	INC	(HL)
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	A,(N)
	CP	NAMLN
	JP	NZ,A1031
A1032:	LD	HL,N		;SAVE NAME5 LENGTH
	LD	B,1
	CALL	PUSHT
	LD	A,(INDSW)
	CP	1
	JP	C,$+6
	JP	NZ,A1033
	LD	HL,PRGLS	;SAVE LINE PTR IN ROUTINE
	LD	B,2
	CALL	PUSHT
A1033:	LD	HL,INDX
	LD	B,2
	CALL	PUSHT
	LD	HL,FORSW
	LD	B,1
	CALL	PUSHT
	LD	HL,INDFL
	LD	B,1
	CALL	PUSHT
	LD	HL,MODE
	LD	B,1
	CALL	PUSHT
	XOR	A
	LD	(FORSW),A
	LD	(INDFL),A
	LD	HL,(PTR)	;SET INDX TO START OF STRING
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	JP	MMP6
;*
;*
AC104:	;MAKE STACK T-O-S TO STRING FOR $CHAR
	CALL	SSCHK
	LD	A,3
	CALL	CPUSH
	RET
;*
;*
AC105:
	LD	A,1
	LD	(DSF),A
	LD	A,(ACTFL)	;SET LINACT
	OR	2
	LD	(ACTFL),A
	RET
;*
;*
AC106:	;CONVERT PARAM EXPR AND INCREMENT COUNT
	CALL	SSCHK
	CALL	AC33		;T-O-S TO STRING
	CALL	PAST		;GO PAST T-O-S ITEM
	LD	HL,PTR
	LD	B,2
	CALL	POPIT
	LD	HL,TPP
	LD	B,2
	CALL	POPIT
	LD	HL,(PTR)	;GET OLD COUNT
	LD	A,(HL)
	LD	(COUNT),A
	LD	(PTR2),HL	;SAVE PTR
	INC	HL
	LD	(PTR1),HL
A1061:	LD	HL,(PTR1)
	LD	A,(HL)
	LD	HL,(PTR)
	LD	(HL),A
	LD	HL,(TPP)
	DEC	HL
	LD	(TPP),HL
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	HL,(TPP)
	LD	DE,NULL
	CALL	JPEN
	JP	NZ,A1061
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,COUNT
	INC	(HL)
	LD	B,1		;SAVE NEW COUNT
	CALL	PUSHT
	RET
;*
;*
AC107:
	CALL	SSCHK
	LD	HL,COUNT
	LD	B,1
	CALL	POPIT
	XOR	A
	CALL	CPUSH
	LD	A,3
	CALL	CPUSH
A1072:	LD	HL,COUNT
	INC	(HL)
	LD	B,1
	CALL	PUSHT
	RET
;*
;*
AC108:	;CHECK FOR END OF NAME LEVEL INDIRECTION
	CALL	SSCHK
	LD	A,(INDFL)
	CP	1
	JP	NZ,A1082
	LD	A,(TOKEN)
	CP	40
	JP	NZ,E24
A1081:	CALL	INDRE		;RETURN FROM INDIRECTION
	LD	A,(INDFL)
	CP	2
	JP	NZ,A1082
	LD	A,(TOKEN)
	CP	40
	JP	Z,A1081
A1082:	RET
;*
;*
AC109:	;PUT INDIRECT STRING ON STACK
	CALL	SSCHK
	LD	A,4
	LD	(CASE),A
	LD	HL,TYPE
	LD	B,1
	CALL	POPIT
	LD	A,(TYPE)
	CP	3
	JP	Z,A1091
	CP	4
	JP	NZ,E24
	LD	HL,TYPE
	LD	B,1
	CALL	PUSHT
	CALL	AC33
	LD	HL,TYPE
	LD	B,1
	CALL	POPIT
A1091:	LD	HL,SLENG
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR),HL
	LD	HL,SLENG
	INC	(HL)
	LD	HL,LEVEL
	INC	(HL)
	LD	A,(LEVEL)
	CP	MXLVL
	JP	Z,E32
	LD	A,EOI
	CALL	CPUSH
	LD	HL,SLENG
	LD	B,1
	CALL	PUSHT
	LD	HL,INDX		;SAVE RETURN INFORMATION
	LD	B,2
	CALL	PUSHT
	LD	HL,INDFL
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR)	;GET READY TO DO INDIRECTION
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	LD	A,1
	LD	(INDFL),A
	LD	(CASE),A
A1092:	RET
;*
;*
AC110:	;CHECK FOR END OF ALL LEVELS OF NAME INDIR
	CALL	SSCHK
	LD	A,(INDFL)
	CP	1
	JP	NZ,A1102
A1101:	LD	A,(TOKEN)
	CP	40
	JP	NZ,E24
	CALL	INDRE
	LD	A,(INDFL)
	CP	1
	JP	Z,A1101
A1102:	RET
;*
;*
AC111:	;REMOVE ROUTINE FROM DISK
	CALL	SSCHK
	LD	A,(RTDRV)
	LD	(DRIVE),A
	LD	A,1
	LD	(FCBTY),A
	CALL	FSEAR
	CALL	REMOV
	RET
;*
;*
AC112:	;PRGPT TO END
	LD	HL,(PRGEN)
	LD	(PRGPT),HL
	RET
;*
;*
AC113:	;LIST CURRENT LINE
	CALL	SSCHK
	LD	HL,(PRGPT)	;NO CURRENT LINE
	EX	DE,HL
	LD	HL,(PRGEN)
	CALL	JPEN
	JP	Z,A1131
	LD	HL,(PRGPT)
	LD	(PTR),HL
	CALL	LINWR
A1131:	RET
;*
;*
AC114:	;DELETE CURRENT LINE
	CALL	SSCHK
	LD	HL,(PRGEN)	;NO CURRENT LINE
	EX	DE,HL
	LD	HL,(PRGPT)
	CALL	JPEN
	JP	Z,A1141
	LD	HL,(PRGPT)
	LD	(PTR1),HL
	LD	C,(HL)
	LD	B,0
	ADD	HL,BC
	LD	DE,2
	ADD	HL,DE
	LD	(PTR3),HL
	CALL	LINDE
A1141:	RET
;*
;*
AC115:	;PUT INTEGER -1 T-O-S
	CALL	SSCHK
	LD	HL,IMIN1
	CALL	ITS
	RET
;*
;*
AC117:	;CONVERT DEVICE # TO SHORT
	CALL	SSCHK
	CALL	STC0
	LD	(DEVNO),A
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,E52
	LD	A,(DEVNO)
	CP	MAXDV
	JP	C,$+6
	JP	NZ,E52
	LD	HL,DEVNO
	LD	B,1
	CALL	PUSHT
	CALL	AC20		;INITIALIZE PARAM COUNT
	RET
;*
;*
AC118:	;INSERT STRING AT PRGPT
	CALL	SSCHK
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,RLENG	;GET STRING LENGTH
	LD	B,1
	CALL	POPIT
	LD	A,(RLENG)
	OR	A
	JP	Z,E0
	LD	HL,(TOS)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR3),HL
	LD	A,(RLENG)
	LD	(IT),A
	LD	(TPP),HL
	XOR	A
	LD	(NLENG),A
	LD	(PTR4),HL
A1181:	LD	HL,(TPP)	;LOOK FOR LS
	LD	A,(HL)
	CP	BLANK
	JP	Z,A1182
	LD	A,(HL)
	CP	LS
	JP	Z,A1182
	INC	HL
	LD	(TPP),HL
	LD	HL,NLENG	;LABEL LENGTH
	INC	(HL)
	LD	HL,IT
	DEC	(HL)
	LD	A,(IT)
	OR	A
	JP	NZ,A1181
A1182:	LD	HL,(TPP)	;SET LS
	LD	(HL),LS
	LD	A,(IT)
	OR	A
	JP	Z,E0
	LD	HL,(PTR3)
	LD	(PTR),HL
	CALL	LININ		;INSERT LINE INTO ROUTINE
	LD	HL,(PTR4)
	LD	(TOS),HL
	RET
;*
;*
AC119:	;SET OPTIONS
	CALL	SSCHK
	LD	HL,COUNT	;GET PARAMETER COUNT
	LD	B,1
	CALL	POPIT
A1191:	LD	A,(COUNT)
	OR	A
	JP	Z,A1194
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,SLENG
	LD	B,1
	CALL	POPIT
	LD	A,(SLENG)	;IF DEFAULT, DON'T CHANGE ANYTHING
	OR	A
	JP	Z,A1193
	CP	1		;TOO LONG
	JP	NZ,E20
	LD	HL,CHR		;GET DRIVE
	LD	B,1
	CALL	POPIT
	LD	A,(CHR)
	SUB	'A'
	LD	(CHR),A
	LD	A,(COUNT)
	CP	1
	JP	NZ,A1192
	LD	A,(CHR)
	LD	(RTDRV),A
	JP	A1193
A1192:	LD	A,(GLBDR)
	LD	HL,CHR
	CP	(HL)
	JP	Z,A1193
	CALL	GLBCL		;CLOSE GLOBALS SINCE CHANGING DRIVES
	LD	A,(CHR)
	LD	(GLBDR),A
	XOR	A
	LD	(GLOPN),A
A1193:	LD	HL,COUNT
	DEC	(HL)
	JP	A1191
A1194:	RET
;*
;*
AC120:	;TRANSFER CONTROL TO ASSEMBLY LANGUAGE
	JP	ASROU
;*
;*
AC121:	;SET STRING PARAM
	CALL	SSCHK
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,SLENG	;GET STRING LENGTH
	LD	B,1
	CALL	POPIT
	LD	A,(SLENG)	;STRING TOO LONG
	CP	MAXAR
	JP	C,$+6
	JP	NZ,E20
	LD	HL,ARGPL	;PTR TO ARG START
	LD	C,A
	LD	B,0
	ADD	HL,BC
	DEC	HL
	LD	(PTR),HL
A1211:	LD	A,(SLENG)	;SET STRING
	OR	A
	JP	Z,A1212
	LD	HL,(PTR)
	LD	B,1
	CALL	POPIT
	LD	HL,SLENG
	DEC	(HL)
	LD	HL,(PTR)
	DEC	HL
	LD	(PTR),HL
	JP	A1211
A1212:	RET
;*
;*
AC122:	;GET ARG BYTE TO T-O-S
	CALL	SSCHK
	CALL	STC0
	LD	(IT),A
	LD	A,(RESUL)	;# TOO BIG
	OR	A
	JP	Z,E20
	LD	A,(IT)		;OFFSET TOO BIG
	CP	MAXAR
	JP	C,$+6
	JP	NZ,E20
	LD	HL,ARGPL	;PTR TO ARG START
	LD	C,A
	LD	B,0
	ADD	HL,BC
	DEC	HL
	LD	(PTR),HL
	LD	A,(HL)
	CALL	CTS
	RET
;*
;*
AC123:	;MAKE STRING LOOK LIKE NAME
	CALL	SSCHK
	LD	HL,COUNT
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,COUNT
	DEC	(HL)
	LD	B,1
	CALL	PUSHT
	RET
;*
;*
AC124:	;SET FOR VARIABLE TO FREAL
	CALL	SSCHK
	LD	HL,(VPTR)
	LD	(PTR),HL
	LD	HL,(TOS)
	LD	(NSTOS),HL
	LD	HL,FREAL
	CALL	NTS
	CALL	AC47
	LD	HL,(TOS)
	LD	(PTR),HL
	LD	A,(FCASE)
	LD	(I1),A
A1240:	LD	HL,(PTR)
	DEC	HL
	DEC	HL
	LD	(PTR),HL
	LD	A,(I1)
	CP	1
	JP	Z,A1241
	LD	A,(HL)
	LD	(FSZ),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR),HL
	LD	HL,I1
	DEC	(HL)
	JP	A1240
A1241:	LD	HL,(PTR)
	LD	A,(HL)
	LD	(ISZ),A
	LD	HL,FCASE
	LD	B,1
	CALL	PUSHT
	RET
;*
;*  END OF TDL ACTION ROUTINES
;**
;*UTILT.TDL
;**
;*        TDL UTILTY ROUTINES BEGIN HERE
;*
;*
CANON:	;CHECK FOR CANONICAL NUMBER
	CALL	SSCHK
	LD	HL,INDX
	LD	B,2
	CALL	PUSHT
	LD	HL,(PTR3)	;INDX TO START OF STRING
	LD	(INDX),HL
	CALL	GTOKN
	LD	A,(SLENG)	;I1 IS STRING LENGTH
	LD	(I1),A
	LD	A,15		;IT IS FAKE LENGTH
	LD	(IT),A
	LD	A,FALSE		;ITX IS NEGATIVE FLAG
	LD	(ITX),A
	LD	(RESUL),A
	LD	A,(I1)
	CP	1
	JP	NZ,CANO1
	LD	HL,(INDX)	;CHECK FOR SINGLE ZERO
	LD	A,(HL)
	CP	'0'
	JP	Z,CANOT
CANO1:	LD	A,(TOKEN)	;CHECK FOR MINUS SIGN
	CP	6
	JP	NZ,CANO2
	LD	A,TRUE		;IT'S NEGATIVE
	LD	(ITX),A
	LD	HL,(PTR3)	;MOVE START PAST '-'
	INC	HL
	LD	(PTR3),HL
	LD	HL,I1		;DECREMENT STRING SIZE
	DEC	(HL)
	LD	HL,SLENG
	DEC	(HL)
	LD	A,(I1)
	OR	A
	JP	Z,CANOF
	CALL	GTOKN
CANO2:	LD	HL,IT
	INC	(HL)
	LD	A,(TOKEN)	;CHECK FOR LEADING '.'
	CP	28
	JP	Z,CANO4
	CP	3		;CHECK FOR DIGITS
	JP	NZ,CANOF
	LD	HL,(INDX)	;NO LEADING ZEROS
	LD	A,(HL)
	CP	'0'
	JP	Z,CANOF
CANO3:	LD	A,(ITX)		;SEE IF < 0
	CP	FALSE
	JP	Z,CAN35
	LD	A,105
	LD	HL,(INDX)
	SUB	(HL)
	LD	(I2),A
	LD	(HL),A
CAN35:	LD	HL,I1
	DEC	(HL)
	LD	HL,IT
	INC	(HL)
	LD	A,(IT)		;TOO MANY DIGITS
	CP	29
	JP	Z,CANOF
	LD	A,(I1)		;IT'S AN INTEGER
	OR	A
	JP	Z,CANOT
	CALL	GTOKN
	LD	A,(TOKEN)	;CHECK FOR '.'
	CP	28
	JP	Z,CANO4
	CP	3		;CHECK FOR DIGITS
	JP	NZ,CANOF
	JP	CANO3
CANO4:	LD	HL,I1
	DEC	(HL)
	LD	A,(I1)		;#. AND . NOT ALLOWED
	OR	A
	JP	Z,CANOF
CANO5:	CALL	GTOKN
	LD	A,(TOKEN)	;CHECK FOR DIGITS
	CP	3
	JP	NZ,CANOF
	LD	HL,(INDX)	;SAVE LAST DIGIT
	LD	A,(HL)
	LD	(COUNT),A
	LD	A,(ITX)		;SEE IF < 0
	CP	FALSE
	JP	Z,CAN55
	LD	A,105
	SUB	(HL)
	LD	(I2),A
	LD	(HL),A
CAN55:	LD	HL,I1
	DEC	(HL)
	LD	A,(I1)		;SEE IF DONE
	OR	A
	JP	NZ,CANO5
	LD	A,(COUNT)	;NO TRAILING ZEROS
	CP	'0'
	JP	Z,CANOF
CANOT:	LD	A,(ITX)
	CP	FALSE
	JP	Z,CANO7
	LD	A,30
	LD	HL,IT
	SUB	(HL)
	LD	(I2),A
	LD	(IT),A
	LD	HL,(INDX)
	INC	(HL)
CANO7:	LD	A,TRUE
	LD	(RESUL),A
CANOF:	LD	HL,INDX		;PUT INDX BACK
	LD	B,2
	CALL	POPIT
	LD	HL,(INDX)
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	LD	A,(RESUL)
	CP	TRUE
	JP	Z,CANO8
	LD	A,(ITX)
	CP	FALSE
	JP	Z,CANO8
	LD	HL,SLENG
	INC	(HL)
	LD	HL,(PTR3)
	DEC	HL
	LD	(PTR3),HL
CANO8:	RET
;*
;*
COMPA:	;COMPARE 2 STRINGS
	XOR	A
	LD	(CASE),A
COMP1:	LD	HL,(PTR4)
	LD	A,(HL)
	CP	DELIM
	JP	NZ,COMP2
	LD	HL,(PTR5)
	LD	A,(HL)
	CP	DELIM
	JP	Z,COMP5
	JP	COMP6
COMP2:	LD	HL,(PTR5)
	LD	A,(HL)
	CP	DELIM
	JP	Z,COMP4
	LD	HL,(PTR4)
	EX	DE,HL
	LD	HL,(PTR5)
	LD	A,(DE)
	CP	(HL)
	JP	Z,COMP3
	LD	HL,(PTR4)	;PTR4 < PTR5
	EX	DE,HL
	LD	HL,(PTR5)
	LD	A,(DE)
	CP	(HL)
	JP	C,COMP6
	JP	COMP4		;PTR4 > PTR5
COMP3:	LD	HL,(PTR4)
	INC	HL
	LD	(PTR4),HL
	LD	HL,(PTR5)
	INC	HL
	LD	(PTR5),HL
	JP	COMP1
COMP4:	LD	HL,CASE		;PTR4 > PTR5 : CASE = 3
	INC	(HL)
COMP5:	LD	HL,CASE		;PTR4 = PTR5 : CASE = 2
	INC	(HL)
COMP6:	LD	HL,CASE		;PTR4 < PTR5 : CASE = 1
	INC	(HL)
	RET
;*
;*
GTSIZ:	;GET SIZE OF T-O-S ITEM
	CALL	SSCHK
	LD	HL,NULL
	LD	(TPP),HL
	LD	A,(I3)
	CP	8
	JP	Z,GT2
	CALL	PAST		;CHECK T-O-S ITEM
	LD	HL,TPP
	LD	B,2
	CALL	POPIT
	LD	HL,TPP		;GET SIZE + A LITTLE
	LD	B,2
	CALL	POPIT
	LD	HL,(TPP)
	DEC	HL
	LD	(TPP),HL
	LD	HL,TYPE
	LD	B,1
	CALL	POPIT
GT0:	LD	A,(TYPE)
	CP	4
	JP	NZ,GT1
	LD	HL,PTR
	LD	B,2
	CALL	POPIT
	LD	HL,PTR
	LD	B,2
	CALL	PUSHT
	LD	HL,(PTR)
	LD	A,(HL)
	LD	(SLENG),A
	LD	HL,NULL
	LD	C,A
	LD	B,0
	ADD	HL,BC
	INC	HL
	LD	(TPP),HL
GT1:	LD	HL,TYPE
	LD	B,1
	CALL	PUSHT
GT2:	RET
;*
;*
PAST:
	CALL	SSCHK
	LD	HL,(TOS)
	LD	(PTR),HL
	LD	HL,(PTR)	;INITIALIZE PTR AT TYPE OF T-O-S
	DEC	HL
	LD	(PTR),HL
	LD	A,(HL)		;GET TYPE OF T-O-S
	LD	(TYPE),A
PAS2:	LD	A,(TYPE)
	CP	3
	JP	NZ,PAS3
	LD	HL,(PTR)	;STRING T-O-S
	DEC	HL
	LD	(PTR),HL
	LD	A,(HL)		;GET LENGTH
	LD	(COUNT),A
	JP	PAS4
PAS3:	LD	A,PTRLN		;STRING PTR T-O-S
	LD	(COUNT),A
PAS4:	LD	HL,(PTR)
	LD	A,(COUNT)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR),HL
	LD	HL,(TOS)
	LD	(TPP),HL
	LD	HL,(PTR)	;GET SIZE TO T-O-S
	EX	DE,HL
	LD	HL,(TPP)
	CALL	PSUB
	LD	(TPP),HL
	LD	HL,(PTR)	;PTR IS NOW BELOW T-O-S
	DEC	HL
	LD	(PTR),HL
	LD	HL,TPP		;SAVE SIZE
	LD	B,2
	CALL	PUSHT
	LD	HL,PTR		;SAVE BASE OF T-O-S
	LD	B,2
	CALL	PUSHT
	RET
;*
;*
SUBCH:	;CHECK IF SUBSCRIPT IS INTEGER
	CALL	SSCHK
	LD	A,FALSE
	LD	(RESUL),A
	CALL	SUBSI		;GET SIZE OF SUBSCRIPT
	LD	A,(I1)
	OR	A
	JP	Z,SUBC1
	LD	HL,(PTR3)
	LD	A,(HL)
	CP	31
	JP	C,$+6
	JP	NZ,SUBC1
	LD	A,TRUE
	LD	(RESUL),A
SUBC1:	RET
;*
;*
SUBSI:	;GET SIZE OF SUB INTO I1--STARTS AT PTR3
	XOR	A
	LD	(I1),A
	LD	HL,(PTR3)
	LD	(TPP),HL
SUBS1:	LD	HL,(TPP)
	LD	A,(HL)
	CP	DELIM
	JP	Z,SUBS2
	INC	HL
	LD	(TPP),HL
	LD	HL,I1
	INC	(HL)
	JP	SUBS1
SUBS2:	RET
;*
;*
GETCH:	;GET CHAR FROM DEVICE
	CALL	SSCHK
	LD	HL,(DVBSU)
	EX	DE,HL
	LD	HL,(DVBSZ)
	LD	A,(DE)
	CP	(HL)
	JP	NZ,GETC3
	LD	A,(IODVC)
	OR	A
	JP	NZ,GETC1
	CALL	TRMIN		;READ BUFFER FULL FROM TERMINAL
	LD	HL,(DVBST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	A,(RLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR),HL
	LD	(HL),CR
	JP	GETC2
GETC1:	LD	A,(XTDRV)
	LD	(DRIVE),A
	LD	HL,(DEVPM)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(FCB),HL
	LD	HL,(DVBST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BUFFR),HL
	CALL	FREAD
GETC2:	LD	HL,(DVBSU)	;ZERO SIZE USED
	LD	(HL),0
	LD	HL,(DVBST)	;INITIALIZE BUFFER PTR
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(DVPTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
GETC3:	LD	HL,(DVPTR)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	A,(HL)
	LD	(CHR),A
	CP	EOF
	JP	Z,GETC4
	INC	HL
	LD	(PTR),HL
	EX	DE,HL
	LD	HL,(DVPTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(DVBSU)	;INCREMENT SIZE USED
	INC	(HL)
GETC4:	RET
;*
;*
PUTCH:	;SEND CHAR TO DEVICE
	CALL	SSCHK
	LD	A,(IODVC)
	OR	A
	JP	NZ,PUTC1
	LD	A,(CHR)
	CALL	TRMOT
	RET
PUTC1:	LD	A,(IODVC)
	CP	1
	JP	NZ,PUTC2
	LD	A,(CHR)
	CALL	LIST
	RET
PUTC2:	LD	HL,(DEVOP)
	LD	A,(HL)
	CP	3
	JP	Z,PUTC0
	LD	HL,(DVBST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(DVPTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(DVBSU)
	LD	(HL),0
PUTC0:	LD	HL,(DVPTR)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	A,(CHR)
	LD	(HL),A
	LD	HL,(DVBSU)
	INC	(HL)
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	EX	DE,HL
	LD	HL,(DVPTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(DVBSU)
	EX	DE,HL
	LD	HL,(DVBSZ)
	LD	A,(DE)
	CP	(HL)
	JP	NZ,PUTC3
	LD	A,(XTDRV)
	LD	(DRIVE),A
	LD	HL,(DEVPM)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(FCB),HL
	LD	HL,(DVBST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BUFFR),HL
	CALL	FWRIT
	LD	HL,(DVBSU)
	LD	(HL),0
	LD	HL,(DVBST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(DVPTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
PUTC3:	LD	HL,(DEVOP)
	LD	(HL),3
	RET
;*
;*
SETDE:	;SET UP DEVICE POINTERS
	LD	HL,DEVTA	;POINTER TO START OF DEVICE TABLE
	LD	(PTR),HL
SETD1:	LD	A,(IT)
	OR	A
	JP	Z,SETD2
	LD	HL,(PTR)	;MOVE PTR TO NEXT DEVICE
	LD	DE,DEVSZ
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,IT
	DEC	(HL)
	JP	SETD1
SETD2:	LD	HL,(PTR)	;SET OPEN/CLOSE PTR
	LD	(DEVOP),HL
	INC	HL
	LD	(PTR),HL
	LD	(DEVRD),HL	;SET READ/WRITE PTR
	INC	HL
	LD	(PTR),HL
	LD	(DEVX),HL	;SET $X PTR
	LD	DE,INTLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	(DEVY),HL	;SET $Y PTR
	LD	DE,INTLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	(DVBSZ),HL	;SET BUFFER SIZE PTR
	INC	HL
	LD	(PTR),HL
	LD	(DEVPM),HL	;SET PARAMETER PTR
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	(DVBST),HL	;SET BUFFER START PTR
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	(DVPTR),HL	;SET BUFFER PTR
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	(DVBSU),HL	;SET BUFFER SIZE USED PTR
	RET
;*
;*
MKSTR:	;CONVERT T-O-S TO STRING ON STACK
	CALL	SSCHK
	LD	HL,TYPE
	LD	B,1
	CALL	POPIT
	LD	A,(TYPE)
	CP	3
	JP	NZ,A0344
	LD	HL,SLENG	;GET STRING LENGTH
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(SPTR),HL
A0343:	LD	HL,(SPTR)
	LD	(TOS),HL
	JP	A3455
A0344:	LD	HL,PTR
	LD	B,2
	CALL	POPIT
	LD	HL,(PTR)	;GET STRING LENGTH IN SYM TABLE
	LD	A,(HL)
	LD	(SLENG),A
	INC	HL		;MOVE PTR TO START OF STRING
	LD	(PTR),HL
A0345:	LD	HL,(PTR)
	EX	DE,HL
	LD	HL,(TOS)
	LD	A,(SLENG)
	LD	B,A
	CALL	MOVE
	LD	HL,(TOS)
	LD	(SPTR),HL
A3455:	LD	HL,(TOS)
	LD	A,(SLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(TOS),HL
	XOR	A		;I4 KEEPS TRACK OF SIGN
	LD	(I4),A
	LD	HL,(INDX)	;SAVE INDX
	LD	(TPP),HL
	LD	HL,(SPTR)
	DEC	HL
	LD	(INDX),HL
A0346:	LD	A,(SLENG)
	OR	A
	JP	Z,A0349
	CALL	GTOKN
	LD	A,(TOKEN)	;IT'S A DIGIT
	CP	3
	JP	Z,A0348
	CP	28		;IT'S A .
	JP	Z,A0348
	CP	5		;IT'S A +
	JP	Z,A0347
	CP	6
	JP	NZ,A0349
	LD	A,(I4)		;CHANGE SIGN
	XOR	1
	LD	(I4),A
A0347:	LD	HL,SLENG
	DEC	(HL)
	JP	A0346
A0348:	LD	A,(FLG1)	;SET STRING FLAG FOR AC10
	OR	STRNG
	LD	(FLG1),A
	LD	HL,(TOS)	;SAVE START OF NUMBER
	LD	(PTR),HL
	LD	A,(IT)		;JUMP IF WANT INTEGER
	OR	A
	JP	Z,A3483
	CALL	AC10		;CONVERT TO NUMBER
	JP	A3485
A3483:	LD	A,(SLENG)
	LD	(I1),A
	CALL	AC11		;CONVERT TO INTEGER
A3485:	LD	A,(FLG1)
	LD	B,A
	LD	A,STRNG
	CPL
	AND	B
	LD	(FLG1),A
	LD	A,(RESUL)
	CP	TRUE
	JP	NZ,A0349
	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,I1		;GET SIZE OF NUMBER
	LD	B,1
	CALL	POPIT
	LD	A,(I4)
	OR	A
	JP	Z,A034A
	LD	HL,(PTR)
	INC	HL
	LD	(PTR1),HL
	EX	DE,HL
	LD	HL,(PTR)
	LD	A,(I1)
	CALL	SHFU
	LD	(HL),'-'	;SET MINUS SIGN
	LD	HL,I1
	INC	(HL)
A034A:	LD	HL,(SPTR)
	EX	DE,HL
	LD	HL,(PTR)
	LD	A,(I1)
	CALL	SHFD
	JP	A034B
A0349:	LD	HL,(SPTR)
	LD	(TOS),HL
	LD	A,'0'
	CALL	CPUSH
	LD	A,1
	LD	(I1),A
A034B:	LD	HL,I1		;SET SIZE
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	LD	HL,(TPP)	;PUT INDX BACK
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	RET
;*
;*
CKLS:	;CHECK FOR LS
	LD	A,(RLENG)
	LD	(IT),A
	XOR	A
	LD	(NLENG),A
	LD	HL,(PTR)
	LD	(TPP),HL
CK01:	LD	HL,(TPP)
	LD	A,(HL)
	CP	LS
	JP	Z,CK02
	INC	HL
	LD	(TPP),HL
	LD	HL,NLENG
	INC	(HL)
	LD	HL,IT
	DEC	(HL)
	LD	A,(IT)
	OR	A
	JP	NZ,CK01
	XOR	A		;NO LS
	LD	(RESUL),A
	RET
CK02:	LD	A,1		;A LS
	LD	(RESUL),A
	RET
;*
;*
FNDLB:	;SEARCH ROUTINE FOR LABEL
	CALL	SSCHK
	LD	HL,I1		;GET LABEL LENGTH
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)	;TOS TO LABEL START
	LD	A,(I1)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	A,(INF)
	CP	1
	JP	Z,FND3
	LD	(PTR),HL
	LD	HL,(PRGAD)	;PTR1 TO ROUTINE START
	LD	(PTR1),HL
FND1:	LD	HL,(PTR1)	;NO MATCH
	LD	A,(HL)
	CP	EOR
	JP	Z,FND3
	LD	(PTR2),HL	;SAVE START OF LINE
	LD	A,(HL)		;GET COMMAND LENGTH
	LD	(I2),A
	INC	HL
	LD	A,(HL)		;GET LABEL LENGTH
	LD	(IT),A
	INC	HL
	LD	(PTR1),HL
	OR	A
	JP	Z,FND2
	CP	NAMLN
	JP	C,FND15
	LD	A,NAMLN
	LD	(IT),A
FND15:	LD	A,(IT)		;LABELS SAME LENGTH ?
	LD	HL,I1
	CP	(HL)
	JP	NZ,FND2
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(PTR)
	LD	A,(I1)
	LD	C,A
	CALL	JSE
	JP	NZ,$+13
	LD	(PTR),HL
	EX	DE,HL
	LD	(PTR1),HL
	JP	FND4
FND2:	LD	HL,(PTR1)	;MOVE TO NEXT LINE
	LD	A,(I2)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR1),HL
	JP	FND1
FND3:	XOR	A		;NO MATCH
	LD	(RESUL),A
	RET
FND4:	LD	HL,(PTR2)
	LD	(PTR1),HL
	LD	A,1		;A MATCH
	LD	(RESUL),A
	RET
;*
;*
GTTRN:	;GET TRANSPT AND LOAD ROUTINE
	CALL	SSCHK
	LD	HL,TYPE		;GET TYPEOF TRANSPT
	LD	B,1
	CALL	POPIT
	LD	A,(TYPE)
	OR	A
	JP	Z,GTT01
	CALL	LOADI		;LOAD ROUTINE
GTT01:	LD	A,(TYPE)
	CP	1
	JP	Z,GTT02
	OR	A
	JP	NZ,GTT15
	CALL	NAMCK
GTT15:	CALL	MV2LN		;MOVE TO LINE
	LD	A,(RESUL)
	OR	A
	JP	Z,E34
	LD	HL,(PTR1)
	LD	(PRGPT),HL
	RET
GTT02:	LD	HL,(PRGAD)
	LD	(PRGPT),HL
	RET
;*
;*
LINDE:	;DELETE FROM PTR1 TO PTR3
	CALL	SSCHK
	LD	HL,(PTR1)
	LD	(PRGPT),HL
LIN60:	LD	HL,(PTR3)
	EX	DE,HL
	LD	HL,(PRGEN)
	CALL	JPEN
	JP	Z,LIN61
	LD	HL,(PTR3)
	LD	A,(HL)
	LD	HL,(PTR1)
	LD	(HL),A
	INC	HL
	LD	(PTR1),HL
	LD	HL,(PTR3)
	INC	HL
	LD	(PTR3),HL
	JP	LIN60
LIN61:	LD	HL,(PTR1)
	LD	(PRGEN),HL
	LD	(HL),EOR
	LD	A,(FLG1)
	OR	DIRTY
	LD	(FLG1),A
	RET
;*
;*
LININ:	;PUT LINE IN STARTING AT PRGPT
	CALL	SSCHK
	LD	A,(FLG1)
	AND	BRAKE
	JP	NZ,E44
	LD	HL,(PTR)
	LD	(PTR3),HL
	LD	A,(NLENG)
	LD	(COUNT),A
	OR	A
	JP	Z,LIN02
	LD	HL,(INDX)
	LD	(PTR5),HL
	LD	HL,(PTR)
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	CALL	AC15		;TRY NAME LABEL
	LD	A,(RESUL)
	OR	A
	JP	NZ,LIN01
	CALL	AC17		;TRY NUMERIC LABEL
	LD	A,(RESUL)
	OR	A
	JP	Z,E28
LIN01:	CALL	AC123
	LD	HL,(PTR)
	LD	A,(COUNT)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(TPP),HL
	LD	HL,(INDX)	;INVALID LABEL
	EX	DE,HL
	LD	HL,(TPP)
	CALL	JPEN
	JP	NZ,E28
	LD	HL,(PTR5)
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	CALL	FNDLB
	LD	A,(RESUL)	;DUPLICATE LABEL
	CP	1
	JP	Z,E33
LIN02:	LD	HL,(PRGEN)	;SEE IF ROOM
	LD	A,(RLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	DE,2
	ADD	HL,DE
	LD	(TPP),HL
	XOR	A
	LD	(N),A
LIN03:	LD	HL,(SYMEN)
	EX	DE,HL
	LD	HL,(TPP)
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,LIN04
	LD	A,(N)
	CP	1
	JP	Z,E10
	CALL	GARBG
	LD	A,1
	LD	(N),A
	JP	LIN03
LIN04:	LD	HL,(PRGEN)
	LD	(PTR1),HL
	LD	HL,(TPP)	;ADJUST PRGEN
	LD	(PRGEN),HL
LIN0A:	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(PRGPT)
	CALL	JPEN
	JP	Z,LIN05
	LD	HL,(PTR1)	;SHIFT ROUTINE SO LINE WILL FIT
	DEC	HL
	LD	(PTR1),HL
	LD	HL,(TPP)
	DEC	HL
	LD	(TPP),HL
	LD	HL,(PTR1)
	LD	A,(HL)
	LD	HL,(TPP)
	LD	(HL),A
	JP	LIN0A
LIN05:	LD	HL,(PRGPT)	;PUT IN NEW LINE
	LD	A,(RLENG)
	LD	(HL),A
	INC	HL
	LD	A,(COUNT)
	LD	(HL),A
	INC	HL
	LD	(PRGPT),HL
	LD	HL,(PTR3)
	EX	DE,HL
	LD	HL,(PRGPT)
	LD	A,(RLENG)
	LD	B,A
	CALL	MOVE
	LD	HL,(PRGPT)
	LD	A,(RLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PRGPT),HL
	LD	HL,(PRGEN)
	LD	(HL),EOR
	LD	A,(FLG1)
	OR	DIRTY
	LD	(FLG1),A
	RET
;*
;*
LINSE:	;SET PTR1 AND PTR3 AROUND LINES
	CALL	SSCHK
	CALL	MV2LN
	LD	A,(RESUL)
	OR	A
	JP	Z,E34
	LD	HL,(PTR1)	;PTR3 AT START OF LINE
	LD	(PTR3),HL
	LD	A,(CASE)
	CP	1
	JP	NZ,LIN21
	LD	C,(HL)		;ONE LINE
	LD	HL,(PTR3)
	LD	B,0
	ADD	HL,BC
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR3),HL
	RET
LIN21:	LD	A,(CASE)
	CP	2
	JP	NZ,LIN22
	CALL	MV2LN		;LINE TO LINE
	LD	A,(RESUL)
	OR	A
	JP	Z,E34
	LD	HL,(PTR3)
	LD	C,(HL)
	LD	B,0
	ADD	HL,BC
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR3),HL
	RET
LIN22:	LD	HL,(PRGEN)
	LD	(PTR3),HL
	RET
;*
;*
LINWR:	;WRITE OUT A LINE AT PTR
	CALL	SSCHK
	LD	HL,(PTR)	;LINE LENGTH
	LD	A,(HL)
	LD	(SLENG),A
	INC	HL
	LD	A,(HL)		;LABEL LENGTH
	LD	(NLENG),A
	INC	HL
	LD	(PTR),HL
	LD	A,(SLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR2),HL
	LD	A,12
	LD	(IT),A
	LD	HL,NLENG
	CP	(HL)
	JP	C,$+6
	JP	NZ,LIN40
	LD	A,5
	LD	(IT),A
	JP	LIN41
LIN40:	LD	A,(IT)		;GET # OF BLANKS AFTER LBBEL
	LD	HL,NLENG
	SUB	(HL)
	LD	(IT),A
	LD	HL,(DEVOP)
	LD	A,(HL)
	CP	3
	JP	Z,LIN41
	LD	HL,(DVBST)	;INITIALIZE DEVICE PTR
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(DVPTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(DVBSU)
	LD	(HL),0
LIN41:	LD	A,(NLENG)
	OR	A
	JP	Z,LIN42
	LD	HL,(PTR)
	LD	A,(HL)
	LD	(CHR),A
	CALL	PUTCH		;WRITE OUT A CHAR
	LD	HL,NLENG
	DEC	(HL)
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	JP	LIN41
LIN42:	LD	A,BLANK		;WRITE OUT BLANKS AFTER LABEL
	LD	(CHR),A
	CALL	PUTCH
	LD	HL,IT
	DEC	(HL)
	LD	A,(IT)
	OR	A
	JP	NZ,LIN42
	LD	HL,(PTR)	;SKIP OVER LS
	INC	HL
	LD	(PTR),HL
LIN43:	LD	HL,(PTR)	;WRITE OUT REST OF LINE
	EX	DE,HL
	LD	HL,(PTR2)
	CALL	JPEN
	JP	Z,LIN44
	LD	HL,(PTR)
	LD	A,(HL)
	LD	(CHR),A
	CALL	PUTCH
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	JP	LIN43
LIN44:	LD	A,CR
	LD	(CHR),A
	CALL	PUTCH
	LD	A,LF
	LD	(CHR),A
	CALL	PUTCH
	LD	HL,(DEVOP)
	LD	(HL),3
	LD	HL,(DEVY)
	LD	C,INTLN
	CALL	ADD1
	LD	HL,(DEVX)
	LD	DE,IZERO
	CALL	SETI
	RET
;*
;*
LOADI:	;LOAD ROUTINE
	CALL	SSCHK
	CALL	NAMCK
	LD	A,(RESUL)
	CP	1
	JP	Z,LD4
	LD	A,(SLENG)
	OR	A
	JP	Z,LD4
	LD	A,(FLG1)
	AND	DIRTY
	JP	NZ,E42
	CALL	NAMLD
	LD	A,(RTDRV)
	LD	(DRIVE),A
	LD	A,1
	LD	(FCBTY),A
	CALL	FOPEN
	LD	HL,RTBUF
	LD	(BUFFR),HL
	CALL	FREAD
	LD	HL,RTBUF
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PRGEN),HL
	LD	(PTR2),HL
	LD	HL,(PRGAD)
	EX	DE,HL
	LD	HL,(PRGEN)
	ADD	HL,DE
	LD	(PRGEN),HL
	XOR	A
	LD	(N),A
LD01:	LD	HL,(SYMEN)	;SEE IF ROOM
	EX	DE,HL
	LD	HL,(PRGEN)
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,LD02
	LD	A,(N)		;NOT ENOUGH ROOM
	CP	1
	JP	Z,E10
	CALL	GARBG
	LD	A,1
	LD	(N),A
	JP	LD01
LD02:	LD	HL,(PRGAD)
	LD	(PTR1),HL
	LD	HL,(PTR)	;SKIP OVER SIZE
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,PTRLN
	LD	(PTR3),HL
LD1:	LD	HL,(PTR2)	;ALL FINISHED
	LD	DE,NULL
	CALL	JPEN
	JP	Z,LD2
	LD	HL,(PTR)
	LD	A,(HL)
	LD	HL,(PTR1)
	LD	(HL),A
	INC	HL
	LD	(PTR1),HL
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,(PTR2)
	DEC	HL
	LD	(PTR2),HL
	LD	HL,(PTR3)
	INC	HL
	LD	(PTR3),HL
	LD	DE,BUFSZ
	CALL	JPEN
	JP	NZ,LD1
	CALL	FREAD		;REFILL BUFFER
	LD	HL,RTBUF
	LD	(PTR),HL
	LD	HL,NULL
	LD	(PTR3),HL
	JP	LD1
LD2:	LD	HL,(PRGEN)
	LD	(HL),EOR
	RET
LD4:	LD	HL,(TOS)
	DEC	HL
	LD	(TOS),HL
	LD	HL,(TOS)
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	RET
;*
;*
MV2LN:	;MOVE PTR1 TO LINEREF
	CALL	SSCHK
	LD	HL,IT
	LD	B,1
	CALL	POPIT
	LD	A,(IT)
	OR	A
	JP	NZ,MT1
	LD	HL,INT1
	LD	DE,IZERO
	CALL	SETI
	JP	MT2
MT1:	LD	HL,IT
	LD	B,1
	CALL	PUSHT
	LD	HL,INT1		;GET OFFSET
	CALL	STI
MT2:	LD	A,(DT)
	CP	1
	JP	Z,MT3
	CALL	FNDLB		;GET PTR1 TO LABEL LINE
	LD	A,(RESUL)	;NO LABEL
	OR	A
	JP	Z,MT5
MT3:	LD	HL,(PTR1)	;OFFSET TOO LARGE
	EX	DE,HL
	LD	HL,(PRGEN)
	CALL	JPEN
	JP	Z,MT5
	LD	HL,INT1
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,MT4
	LD	HL,(PTR1)
	LD	C,(HL)
	LD	B,0
	ADD	HL,BC
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR1),HL
	LD	HL,INT1
	LD	C,INTLN
	CALL	SUB1
	JP	MT3
MT4:	LD	A,1
	LD	(RESUL),A
	RET
MT5:	XOR	A
	LD	(RESUL),A
	RET
;*
;*
NAMCK:	;COMPARE NAME T-O-S WITH PRG
	CALL	SSCHK
	LD	HL,(TOS)
	DEC	HL
	LD	A,(HL)		;GET NAME LENGTH
	LD	(SLENG),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR),HL
	LD	HL,PRG
	LD	(PTR1),HL
	LD	HL,(TOS)
	LD	(PTR3),HL
	XOR	A
	LD	(NLENG),A
NAM01:	LD	HL,(PTR1)
	LD	A,(HL)
	CP	BLANK
	JP	Z,NAM02
	LD	B,1		;SAVE CURRENT NAME5 ON STACK
	CALL	PUSHT
	LD	HL,NLENG	;AND GET LENGTH
	INC	(HL)
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	A,(NLENG)
	CP	NAMLN
	JP	NZ,NAM01
NAM02:	LD	HL,(PTR3)
	LD	(TOS),HL
	LD	(PTR4),HL
	LD	A,(NLENG)	;NAMES SAME LENGTH?
	LD	HL,SLENG
	CP	(HL)
	JP	NZ,NAM03
	LD	HL,(PTR)
	EX	DE,HL
	LD	HL,(PTR3)
	LD	C,A
	CALL	JSE
	JP	NZ,$+13
	LD	(PTR3),HL
	EX	DE,HL
	LD	(PTR),HL
	JP	NAM04
NAM03:	XOR	A
	LD	(RESUL),A
	RET
NAM04:	LD	A,1		;SAME NAMES
	LD	(RESUL),A
	RET
;*
;*
NAMLD:	;LOAD NAME INTO PRG
	CALL	SSCHK
	LD	HL,(TOS)
	DEC	HL
	LD	A,(HL)
	LD	(IT),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR),HL
	EX	DE,HL
	LD	HL,PRG
	LD	A,(IT)
	LD	B,A
	CALL	MOVE
	LD	A,NAMLN
	LD	HL,IT
	SUB	(HL)
	LD	(I1),A
	LD	HL,PRG
	LD	A,(IT)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR),HL
NAM10:	LD	A,(I1)
	OR	A
	JP	Z,NAM11
	LD	HL,(PTR)
	LD	(HL),BLANK
	LD	HL,I1
	DEC	(HL)
	JP	NAM10
NAM11:	RET
;*
;*
SAVEI:	;SAVE ROUTINE
	CALL	SSCHK
	CALL	MAKE		;ENTER NAME INTO DIRECTORY
	LD	HL,(PRGEN)	;GET SIZE
	LD	(PTR),HL
	LD	HL,(PRGAD)
	EX	DE,HL
	LD	HL,(PTR)
	CALL	PSUB
	LD	(PTR),HL
	LD	HL,(PRGAD)	;PUT SIZE BEFORE ROUTINE
	LD	BC,-(PTRLN)
	ADD	HL,BC
	LD	(PTR1),HL
	LD	HL,(PTR)
	EX	DE,HL
	LD	HL,(PTR1)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,RTBUF
	LD	(BUFFR),HL
SAV01:	LD	HL,RTBUF
	LD	(PTR2),HL
	LD	HL,BUFSZ
	LD	(PTR3),HL
SAV02:	LD	HL,(PTR)
	LD	DE,NULL
	CALL	JPEN
	JP	Z,SAV03
	LD	HL,(PTR1)	;MOVE DATA TO BUFFER
	LD	A,(HL)
	LD	HL,(PTR2)
	LD	(HL),A
	INC	HL
	LD	(PTR2),HL
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	HL,(PTR)
	DEC	HL
	LD	(PTR),HL
	LD	HL,(PTR3)
	DEC	HL
	LD	(PTR3),HL
	LD	DE,NULL
	CALL	JPEN
	JP	NZ,SAV02
	CALL	FWRIT		;WRITE BUFFER OUT
	JP	SAV01
SAV03:	CALL	FWRIT
	CALL	FCLOS
	RET
;*
;*
LN2ST:	;PUT PTR1'S LINE ON STACK
	CALL	SSCHK
	XOR	A
	LD	(IT),A
	LD	A,(RESUL)	;NO LINE MATCH
	OR	A
	JP	Z,STK4
	LD	HL,(PTR1)	;GET LINE LENGTH
	LD	A,(HL)
	LD	(I1),A
	LD	(IT),A
	INC	HL
	LD	(PTR1),HL
	LD	A,(HL)		;GET LABEL LENGTH
	LD	(I2),A
	INC	HL		;PTR1 TO LINE
	LD	(PTR1),HL
STK1:	LD	A,(I2)
	OR	A
	JP	Z,STK2
	LD	HL,(PTR1)	;PUSH LABEL
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	HL,I2
	DEC	(HL)
	LD	HL,I1
	DEC	(HL)
	JP	STK1
STK2:	LD	A,BLANK		;LS
	CALL	CPUSH
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	HL,I1
	DEC	(HL)
STK3:	LD	A,(I1)
	OR	A
	JP	Z,STK4
	LD	HL,(PTR1)	;PUSH REST OF LINE
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	HL,I1
	DEC	(HL)
	JP	STK3
STK4:	LD	HL,IT		;SAVE LENGTH
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	RET
;*
;*
DORET:	;RETURN FROM DO
	CALL	SSCHK
	LD	HL,MODE
	LD	B,1
	CALL	POPIT
	LD	HL,INDFL	;RESTORE THINGS FROM STACK
	LD	B,1
	CALL	POPIT
	LD	HL,INDSW
	LD	B,1
	CALL	POPIT
	LD	HL,FORSW
	LD	B,1
	CALL	POPIT
	LD	HL,SPTR
	LD	B,2
	CALL	POPIT
	LD	HL,PRGPT
	LD	B,2
	CALL	POPIT
	CALL	LOADI		;LOAD ROUTINE
	LD	HL,DOSW
	DEC	(HL)
	LD	HL,LEVEL
	DEC	(HL)
	LD	A,(MODE)
	CP	1
	JP	Z,DOR1
	CALL	INPUT
	JP	DOR2
DOR1:	LD	HL,(DRBUF)
	EX	DE,HL
	LD	HL,(LBUFF)
	LD	A,(DRLNG)
	LD	B,A
	CALL	MOVE
	LD	HL,(LBUFF)
	LD	A,(DRLNG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR),HL
	LD	(HL),EOL
DOR2:	LD	HL,(SPTR)
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	XOR	A
	LD	(FLAG),A
	RET
;*
;*
FORSE:	;GET FOR INFO OFF STACK
	CALL	SSCHK
	LD	HL,INDX
	LD	B,2
	CALL	POPIT
	LD	HL,(TOS)
	LD	(PTR),HL
	LD	(TOPTR),HL
	LD	BC,-(SHTLN+SHTLN+SHTLN)
	ADD	HL,BC
	LD	A,(HL)
	LD	(FSZ),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR),HL
	LD	(FPTR),HL
	LD	BC,-(SHTLN+SHTLN)
	ADD	HL,BC
	LD	A,(HL)
	LD	(ISZ),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR),HL
	LD	(IPTR),HL
	LD	BC,-(PTRLN)
	ADD	HL,BC
	LD	(PTR),HL
	LD	(VPTR),HL
	RET
;*
;*
INDRE:	;RETURN FROM INDIRECTION
	CALL	SSCHK
	LD	HL,LEVEL
	DEC	(HL)
	LD	HL,(INDX)
	LD	(PTR),HL
	LD	(PTR2),HL
	LD	(PTR1),HL
IND0:	LD	HL,(PTR1)
	LD	A,(HL)
	CP	EOI
	JP	Z,IND1
	INC	HL
	LD	(PTR1),HL
	JP	IND0
IND1:	LD	HL,(PTR1)
	LD	DE,SHTLN+SHTLN+PTRLN+SHTLN
	ADD	HL,DE
	LD	(PTR1),HL
	LD	HL,(TOS)
	EX	DE,HL
	LD	HL,(PTR1)
	CALL	JPEN
	JP	Z,IND3
	LD	HL,(PTR)
	INC	HL
	LD	A,(HL)
	LD	(IT),A
	INC	HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(INDX),HL
	LD	HL,(PTR)
	LD	DE,2
	ADD	HL,DE
	LD	A,(HL)
	LD	(INDFL),A
	INC	HL
	LD	(PTR),HL
	LD	HL,(TOS)
	LD	(PTR1),HL
	LD	HL,(PTR2)
	LD	(TOS),HL
	LD	HL,IT
	DEC	(HL)
	LD	HL,(TOS)
	LD	A,(IT)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
IND2:	LD	HL,(PTR)
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	EX	DE,HL
	LD	HL,(PTR1)
	CALL	JPEN
	JP	NZ,IND2
	JP	IND5
IND3:	LD	HL,INDFL
	LD	B,1
	CALL	POPIT
	LD	HL,INDX
	LD	B,2
	CALL	POPIT
	LD	HL,SLENG
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(SLENG)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
IND5:	LD	HL,(INDX)
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	RET
;*
;*
LSUBS:	;LIST SUBSCRIPTS AND VALUES
	CALL	SSCHK
	XOR	A
	LD	(I6),A
	LD	HL,I6
	LD	B,1
	CALL	PUSHT
LSB1:	LD	HL,(DP)
	LD	(PTR),HL
	LD	DE,NULL
	CALL	JPEN
	JP	Z,LSB13
	LD	HL,(DP)		;GET NEXT LEVEL DOWN IN DP
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(DP),HL
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	A,(HL)
	LD	(STYPE),A
	LD	DE,5		;TO ACROSS PTR
	ADD	HL,DE
	LD	(PTR1),HL
	LD	HL,I6
	INC	(HL)
	LD	HL,(PTR1)	;SAVE IT
	LD	B,2
	CALL	PUSHT
	LD	HL,I6
	LD	B,1
	CALL	PUSHT
	LD	A,5		;INDENT
	LD	(IT),A
	LD	(SLENG),A
LSB2:	LD	A,BLANK		;LEADING BLANKS
	CALL	CPUSH
	LD	HL,IT
	DEC	(HL)
	LD	A,(IT)
	OR	A
	JP	NZ,LSB2
	LD	A,(I6)
	LD	(IT),A
	DEC	(HL)		;PERIODS
LSB3:	LD	A,(IT)
	OR	A
	JP	Z,LSB4
	LD	A,'.'
	CALL	CPUSH
	LD	A,BLANK
	CALL	CPUSH
	LD	A,(SLENG)
	ADD	A,2
	LD	(SLENG),A
	LD	HL,IT
	DEC	(HL)
	JP	LSB3
LSB4:	LD	HL,SLENG
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	CALL	AC54
	LD	HL,(PTR1)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR1),HL
	XOR	A
	LD	(SLENG),A
	LD	A,FALSE
	LD	(ITX),A
	LD	A,(HL)
	CP	31
	JP	C,$+6
	JP	NZ,LSB5
	LD	A,(HL)
	CP	14
	JP	C,$+6
	JP	NZ,LSB45
	LD	A,'-'
	CALL	CPUSH
	LD	HL,SLENG
	INC	(HL)
	LD	A,TRUE
	LD	(ITX),A
LSB45:	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
LSB5:	LD	HL,(PTR1)
	LD	A,(HL)
	CP	DELIM
	JP	Z,LSB55
	LD	A,(HL)
	CP	'.'
	JP	Z,LSB53
	LD	A,(ITX)
	CP	FALSE
	JP	Z,LSB53
	LD	A,105
	SUB	(HL)
	LD	(IT),A
	LD	HL,IT
	LD	B,1
	CALL	PUSHT
	JP	LSB54
LSB53:	LD	HL,(PTR1)
	LD	B,1
	CALL	PUSHT
LSB54:	LD	HL,SLENG
	INC	(HL)
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	JP	LSB5
LSB55:	LD	A,(ITX)
	CP	FALSE
	JP	Z,LSB56
	LD	HL,IT
	LD	B,1
	CALL	POPIT
	LD	HL,IT
	INC	(HL)
	LD	B,1
	CALL	PUSHT
LSB56:	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	A,'='
	CALL	CPUSH
	LD	HL,SLENG
	INC	(HL)
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	CALL	AC54
	LD	A,(STYPE)
	CP	8
	JP	Z,LSB12
LSB7:	LD	HL,(PTR1)
	LD	A,(HL)
	LD	(IT),A
	LD	(I1),A
	LD	HL,I1
	INC	(HL)
	INC	(HL)
	LD	A,'"'
	CALL	CPUSH
LSB8:	LD	A,(IT)
	OR	A
	JP	Z,LSB9
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	B,1
	CALL	PUSHT
	LD	HL,IT
	DEC	(HL)
	JP	LSB8
LSB9:	LD	A,'"'
	CALL	CPUSH
	LD	HL,I1
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
LSB11:	CALL	AC54
LSB12:	CALL	AC24
	JP	LSB1
LSB13:	LD	HL,I6
	LD	B,1
	CALL	POPIT
	LD	A,(I6)
	OR	A
	JP	Z,LSB14
	LD	HL,I6
	DEC	(HL)
	LD	HL,DP
	LD	B,2
	CALL	POPIT
	JP	LSB1
LSB14:	RET
;*
;*
MATCH:	;CHECK PATTERN AGAINST STRING
	CALL	SSCHK
	LD	HL,(PTR1)	;SAVE PATTERN POINTER
	LD	(PTR),HL
MAT1:	LD	DE,INT1		;GET PATTERN SIZE
	LD	HL,(PTR1)
	EX	DE,HL
	CALL	SETI
	LD	HL,(PTR1)
	LD	DE,INTLN
	ADD	HL,DE
	LD	(PTR1),HL
	LD	HL,INT1
	LD	A,(HL)
	AND	0F0H
	JP	NZ,MAT2A
	CALL	ITC
	LD	(PLENG),A
	OR	A
	JP	NZ,MAT2
	LD	HL,(INDX)
	EX	DE,HL
	LD	HL,(PTR2)
	CALL	JPEN
	JP	NZ,MAT16
	JP	MAT12
MAT2:	LD	A,(PLENG)	;STRING ALL MATCHED UP
	OR	A
	JP	Z,MAT1A
	LD	HL,(INDX)
	EX	DE,HL
	LD	HL,(PTR2)
	CALL	JPEN
	JP	Z,MAT16
	LD	HL,(INDX)	;CHARS THE SAME?
	EX	DE,HL
	LD	HL,(PTR1)
	LD	A,(DE)
	CP	(HL)
	JP	NZ,MAT14
	INC	HL		;LOOK AT NEXT ONES
	LD	(PTR1),HL
	LD	HL,(INDX)
	INC	HL
	LD	(INDX),HL
	LD	HL,PLENG
	DEC	(HL)
	JP	MAT2
MAT2A:	LD	HL,INT1
	LD	A,(HL)
	XOR	0F0H
	LD	(HL),A
	CALL	ITC
	LD	(PLENG),A
MAT3:	LD	HL,(INDX)
	EX	DE,HL
	LD	HL,(PTR2)
	CALL	JPEN
	JP	Z,MAT16
	LD	HL,(PTR1)	;GET PATTERN SYMBOL
	LD	A,(HL)
	LD	(CHR),A
	CP	'U'
	JP	NZ,MAT4
	LD	A,(TOKEN)	;UPPER CASE
	CP	2
	JP	Z,MAT11
	JP	MAT10
MAT4:	LD	A,(CHR)
	CP	'L'
	JP	NZ,MAT5
	LD	A,(TOKEN)	;LOWER CASE
	CP	1
	JP	Z,MAT11
	JP	MAT10
MAT5:	LD	A,(CHR)
	CP	'A'
	JP	NZ,MAT6
	LD	A,(TOKEN)	;ALPHABETIC
	CP	1
	JP	Z,MAT11
	CP	2
	JP	Z,MAT11
	JP	MAT10
MAT6:	LD	A,(CHR)
	CP	'N'
	JP	NZ,MAT7
	LD	A,(TOKEN)	;NUMERIC
	CP	3
	JP	Z,MAT11
	JP	MAT10
MAT7:	LD	A,(CHR)
	CP	'P'
	JP	NZ,MAT8
	LD	A,(TOKEN)	;PUNCUATION
	CP	4
	JP	C,MAT10
	CP	36
	JP	C,$+6
	JP	NZ,MAT10
	JP	MAT11
MAT8:	LD	A,(CHR)
	CP	'C'
	JP	NZ,MAT9
	LD	A,(TOKEN)
	CP	36
	JP	C,$+6
	JP	NZ,MAT11
	JP	MAT10
MAT9:	LD	A,(TOKEN)
	OR	A
	JP	NZ,MAT11
MAT10:	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	HL,PLENG
	DEC	(HL)
	LD	A,(PLENG)
	OR	A
	JP	NZ,MAT3
	JP	MAT16
MAT1A:	LD	HL,(INDX)
	DEC	HL
	LD	(INDX),HL
MAT11:	CALL	GTOKN
MAT12:	LD	HL,INT2
	LD	C,INTLN
	CALL	SUB1
	LD	A,(HL)
	AND	0F0H
	JP	NZ,MAT13
	LD	C,INTLN
	CALL	ZTEST
	JP	Z,MAT14
	LD	HL,(PTR)
	LD	(PTR1),HL
	JP	MAT1
MAT13:	LD	HL,(PTR)
	LD	(PTR1),HL
	LD	HL,INT2
	LD	DE,IZERO
	CALL	SETI
	JP	MAT16
MAT14:	LD	HL,(PTR1)
	LD	A,(PLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR1),HL
MAT16:	RET
;*
;*
XECRE:	;RETURN FROM XECUTE
	CALL	SSCHK
	LD	HL,MODE
	LD	B,1
	CALL	POPIT
	LD	HL,INDFL	;RESTORE THINGS FROM STACK
	LD	B,1
	CALL	POPIT
	LD	HL,FORSW
	LD	B,1
	CALL	POPIT
	LD	HL,SPTR
	LD	B,2
	CALL	POPIT
	LD	A,(INDSW)
	CP	1
	JP	C,$+6
	JP	NZ,XEC0
	LD	HL,PRGPT
	LD	B,2
	CALL	POPIT
XEC0:	CALL	LOADI		;LOAD ROUTINE
	LD	HL,N
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	A,(N)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
	LD	HL,INDSW
	DEC	(HL)
	LD	HL,LEVEL
	DEC	(HL)
	XOR	A
	LD	(FLAG),A
	LD	A,(MODE)
	CP	1
	JP	Z,XEC1
	LD	A,(INDSW)
	OR	A
	JP	NZ,XEC1
	CALL	INPUT
	JP	XEC2
XEC1:	LD	HL,(DRBUF)
	EX	DE,HL
	LD	HL,(LBUFF)
	LD	A,(DRLNG)
	LD	B,A
	CALL	MOVE
	LD	HL,(LBUFF)
	LD	A,(DRLNG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR),HL
	LD	(HL),EOL
XEC2:	LD	HL,(SPTR)
	DEC	HL
	LD	(INDX),HL
	CALL	GTOKN
	LD	A,FALSE
	LD	(GOTOF),A
	RET
;*
;*
GARBG:	;GARBAGE COLLECTOR AND TRASH MASHER
	CALL	SSCHK
	LD	HL,(SYMPT)
	EX	DE,HL
	LD	HL,(PTEND)
	CALL	JPEN
	JP	Z,GAR18
	LD	HL,(SYMEN)	;SEQUENTIAL SCAN TO FIND GARBAGE
	LD	(TOP),HL
	LD	(LOC),HL
GAR1:	LD	HL,(LOC)	;AT END OF SYM TABLE?
	EX	DE,HL
	LD	HL,(PTEND)
	CALL	JPEN
	JP	Z,GAR3
	LD	HL,(LOC)
	LD	(TGP),HL
	LD	DE,PTRLN	;MOVE TO TYPE
	ADD	HL,DE
	LD	A,(HL)
	LD	(GTYPE),A
	INC	HL
	LD	(LOC),HL
	LD	E,(HL)		;GET ENTRY SIZE
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	LD	HL,(LOC)	;MOVE TO GARBAGE POINTER
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(LOC),HL
	AND	128
	JP	NZ,GAR2
	LD	HL,(TOP)	;SET COMPACTION PTR
	EX	DE,HL
	LD	HL,(LOC)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(BSIZE)
	EX	DE,HL
	ADD	HL,DE
	LD	(TOP),HL
GAR2:	LD	HL,(TGP)
	LD	(LOC),HL
	LD	HL,(BSIZE)	;ADVANCE LOC
	EX	DE,HL
	LD	HL,(LOC)
	ADD	HL,DE
	LD	(LOC),HL
	JP	GAR1
GAR3:	LD	HL,(TOP)	;GET ADJUSTMENT FACTOR
	EX	DE,HL
	LD	HL,(LOC)
	CALL	PSUB
	LD	(LOC),HL
	LD	(ADJ),HL
	LD	HL,(SYMEN)
	LD	(LOC),HL
GAR4:	LD	HL,(LOC)
	EX	DE,HL
	LD	HL,(PTEND)
	CALL	JPEN
	JP	Z,GAR6
	LD	HL,(LOC)	;ADJUST THE COMPACTION POINTERS
	LD	(TGP),HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	A,(HL)
	LD	(GTYPE),A
	INC	HL
	LD	(LOC),HL
	LD	E,(HL)		;GET ENTRY SIZE
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	LD	HL,(LOC)	;MOVE TO GARBAGE PTR
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(LOC),HL
	AND	128
	JP	NZ,GAR5
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(GPTR),HL
	LD	HL,(ADJ)	;ADJUST PTR
	EX	DE,HL
	LD	HL,(GPTR)
	ADD	HL,DE
	LD	(GPTR),HL
	EX	DE,HL
	LD	HL,(LOC)
	LD	(HL),E
	INC	HL
	LD	(HL),D
GAR5:	LD	HL,(TGP)
	LD	(LOC),HL
	LD	HL,(BSIZE)	;MOVE TO NEXT ENTRY
	EX	DE,HL
	LD	HL,(LOC)
	ADD	HL,DE
	LD	(LOC),HL
	JP	GAR4
GAR6:	LD	A,2
	LD	(GARL),A
	LD	HL,(LAST)
	LD	DE,SYMPT
	CALL	JPEN
	JP	Z,GAR65
	XOR	A
	LD	(GARL),A
	LD	HL,(LPTR)
	EX	DE,HL
	LD	HL,(LAST)
	CALL	JPEN
	JP	NZ,GAR64
	LD	A,1
	LD	(GARL),A
GAR64:	LD	HL,(LPTR)
	LD	DE,5
	ADD	HL,DE
	LD	(LOC),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(LPTR),HL
GAR65:	LD	HL,(SYMPT)	;ADJUST SYMPT
	LD	DE,5
	ADD	HL,DE
	LD	(LOC),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(SYMPT),HL
	LD	HL,(SYMEN)	;REDEFINE ALL POINTERS
	LD	(LOC),HL
GAR7:	LD	HL,(LOC)
	EX	DE,HL
	LD	HL,(PTEND)
	CALL	JPEN
	JP	Z,GAR11
	LD	HL,(LOC)
	LD	(TOP),HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	A,(HL)
	LD	(GTYPE),A
	INC	HL
	LD	(LOC),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	AND	128
	JP	NZ,GAR9
	LD	HL,(TOP)	;ADJUST FIRST PTR
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(TGP),HL
	LD	DE,NULL
	CALL	JPEN
	JP	Z,GAR75
	LD	HL,(TGP)
	EX	DE,HL
	LD	HL,(PTEND)
	CALL	JPEN
	JP	Z,GAR75
	LD	HL,(TGP)
	LD	DE,5
	ADD	HL,DE
	LD	(TGP),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(TOP)
	LD	(HL),E
	INC	HL
	LD	(HL),D
GAR75:	LD	A,(GTYPE)
	CP	4
	JP	C,GAR9
	CP	7
	JP	C,$+6
	JP	NZ,GAR8
	LD	HL,(LOC)	;TYPE 4-7
	LD	DE,4
	ADD	HL,DE
	LD	C,(HL)
	LD	B,0
	ADD	HL,BC
	INC	HL
	LD	(LOC),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(TGP),HL
	LD	DE,NULL
	CALL	JPEN
	JP	Z,GAR9
	LD	HL,(TGP)
	LD	DE,5
	ADD	HL,DE
	LD	(TGP),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(LOC)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	JP	GAR9
GAR8:	LD	HL,(LOC)	;TYPE 8-11
	LD	DE,4
	ADD	HL,DE
	LD	(LOC),HL
	LD	E,(HL)		;ADJUST ACROSS PTR
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(TGP),HL
	LD	DE,NULL
	CALL	JPEN
	JP	Z,GAR9
	LD	HL,(TGP)
	LD	DE,5
	ADD	HL,DE
	LD	(TGP),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(LOC)
	LD	(HL),E
	INC	HL
	LD	(HL),D
GAR9:	LD	HL,(TOP)
	LD	(LOC),HL
	LD	HL,(BSIZE)
	EX	DE,HL
	LD	HL,(LOC)
	ADD	HL,DE
	LD	(LOC),HL
	JP	GAR7
GAR11:	LD	HL,(SYMEN)	;COMPACT SYM TABLE
	LD	(TOP),HL
	LD	(LOC),HL
GAR12:	LD	HL,(LOC)	;AT END?
	EX	DE,HL
	LD	HL,(PTEND)
	CALL	JPEN
	JP	Z,GAR15
	LD	HL,(LOC)
	LD	(TGP),HL
	LD	DE,PTRLN	;MOVE TO TYPE
	ADD	HL,DE
	LD	A,(HL)
	LD	(GTYPE),A
	INC	HL
	LD	(LOC),HL
	LD	E,(HL)		;GET ENTRY SIZE
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	LD	HL,(TGP)
	LD	(LOC),HL
	AND	128
	JP	NZ,GAR14
GAR13:	LD	HL,(LOC)	;MOVE ENTRY DOWN
	LD	A,(HL)
	LD	HL,(TOP)
	LD	(HL),A
	INC	HL
	LD	(TOP),HL
	LD	HL,(LOC)
	INC	HL
	LD	(LOC),HL
	LD	HL,(BSIZE)
	DEC	HL
	LD	(BSIZE),HL
	LD	DE,NULL
	CALL	JPEN
	JP	NZ,GAR13
	JP	GAR12
GAR14:	LD	HL,(BSIZE)	;GET NEXT ENTRY
	EX	DE,HL
	LD	HL,(LOC)
	ADD	HL,DE
	LD	(LOC),HL
	JP	GAR12
GAR15:	LD	HL,(PTEND)
	DEC	HL
	LD	(LOC),HL
	LD	HL,(TOP)
	DEC	HL
	LD	(TOP),HL
GAR16:	LD	HL,(TOP)	;SHIFT ENTIRE TABLE UP
	EX	DE,HL
	LD	HL,(SYMEN)
	CALL	JPEN
	JP	Z,GAR17
	LD	HL,(TOP)
	LD	A,(HL)
	LD	HL,(LOC)
	LD	(HL),A
	DEC	HL
	LD	(LOC),HL
	LD	HL,(TOP)
	DEC	HL
	LD	(TOP),HL
	JP	GAR16
GAR17:	LD	HL,(TOP)
	LD	A,(HL)
	LD	HL,(LOC)
	LD	(HL),A
	LD	(SYMEN),HL	;ADJUST SYMEN
	LD	A,(GARL)
	CP	2
	JP	Z,GAR18
	OR	A
	JP	NZ,GAR1A
	LD	HL,(LPTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	A,(HL)
	LD	(GTYPE),A
	LD	DE,PTRLN+PTRLN+SHTLN
	ADD	HL,DE
	LD	(LPTR),HL
	CP	7
	JP	C,$+6
	JP	NZ,GAR1A
	LD	C,(HL)
	LD	B,0
	ADD	HL,BC
	INC	HL
	LD	(LPTR),HL
GAR1A:	LD	HL,(LPTR)
	LD	(LAST),HL
GAR18:	RET
;*
;*
INSER:	;PUTS NAME PART OF SYMBOL TABLE IN
	CALL	SSCHK
	CALL	GTSIZ		;GET SIZE OF T-O-S ITEM
	LD	A,(I3)
	CP	4
	JP	C,INS1
	CP	4		;ADJUST TPP IF AN ARRAY HEAD
	JP	NZ,INS05
	LD	HL,NULL
	LD	(TPP),HL
INS05:	LD	HL,(TPP)
	LD	DE,10
	ADD	HL,DE
	LD	(TPP),HL
	JP	INS2
INS1:	LD	HL,(TPP)	;ADJUST TPP IF NOT ARRAY
	LD	DE,8
	ADD	HL,DE
	LD	(TPP),HL
INS2:	LD	HL,(TPP)	;ADD IN NAME LENGTH
	LD	A,(NLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(TPP),HL
	LD	HL,(PTR3)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	INC	HL
	LD	(PTR3),HL
INS25:	XOR	A		;GARBAGE COLLECTION FLAG
	LD	(N),A
	LD	A,1
	LD	(I1),A
INS26:	LD	HL,(SYMEN)	;SEE IF ROOM FOR ENTRY
	LD	(PTR),HL
	LD	HL,(TPP)
	EX	DE,HL
	LD	HL,(PTR)
	CALL	PSUB
	LD	(PTR),HL
INS3:	LD	HL,(PTR)
	EX	DE,HL
	LD	HL,(PRGEN)
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,INS4
	LD	A,(N)		;ALREADY COLLECTED
	CP	1
	JP	Z,E31
	CALL	GARBG
	LD	A,1		;SET GARBAGE FLAG
	LD	(N),A
	JP	INS26
INS4:	LD	HL,(PTR)	;SAVE START
	LD	(PTR1),HL
	LD	(SYMEN),HL
	LD	DE,2
	ADD	HL,DE
	LD	A,(I3)		;SET TYPE
	LD	(HL),A
	LD	(STYPE),A
	INC	HL
	LD	(PTR),HL
	LD	HL,(TPP)	;SET SIZE
	EX	DE,HL
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,4
	ADD	HL,DE
	LD	A,(NLENG)	;SET NAME LENGTH
	LD	(HL),A
	INC	HL
	LD	(PTR),HL
	LD	HL,(NAME)	;SET NAME
	EX	DE,HL
	LD	HL,(PTR)
	LD	B,A
	CALL	MOVE
	LD	HL,(PTR)	;MOVE PTR PAST NAME
	LD	A,(NLENG)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(PTR),HL
	LD	A,(I3)
	CP	5
	JP	C,INS5
	CP	7
	JP	C,$+6
	JP	NZ,INS5
	LD	DE,2
	ADD	HL,DE
	LD	(PTR),HL
INS5:	RET
;*
;*
MARKS:	;MARK ALL DESCENDENTS OF A NODE
	CALL	SSCHK
	LD	HL,NULL
	LD	(PTR3),HL
MRK1:	LD	HL,(PTR2)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(IT)
	CP	1
	JP	Z,MRK11
	LD	A,(HL)		;GARBAGE ALREADY?
	AND	128
	JP	NZ,MRK3
	LD	A,(HL)
	OR	128
	LD	(HL),A
	JP	MRK15
MRK11:	LD	HL,(PTR)
	LD	A,(HL)
	AND	128
	JP	Z,MRK3
	LD	B,(HL)
	LD	A,128
	CPL
	AND	B
	LD	(HL),A
MRK15:	LD	HL,(PTR)
	INC	HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	(HL),0
MRK2:	LD	HL,(PTR2)
	LD	DE,PTRLN
	ADD	HL,DE
	INC	HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(HL)		;TRY ACROSS THEN DOWN PTRS
	OR	A
	JP	Z,MRK20
	LD	A,(HL)		;TRY DOWN PTR
	CP	1
	JP	Z,MRK21
	JP	MRK3		;BACK UP
MRK20:	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(TPP),HL
	LD	A,1
	LD	(TYPE),A
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,NULL
	CALL	JPEN
	JP	NZ,MRK25
MRK21:	LD	A,2
	LD	(TYPE),A
	LD	HL,(PTR2)	;GET DOWN PTR
	LD	(TPP),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,NULL
	CALL	JPEN
	JP	NZ,MRK25
	JP	MRK3		;BACK UP
MRK25:	LD	HL,(PTR)	;SAVE BRANCH TYPE
	LD	A,(TYPE)
	LD	(HL),A
	LD	HL,(TPP)	;ROTATE LINKS
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	HL,(PTR3)
	EX	DE,HL
	LD	HL,(TPP)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR2)
	LD	(PTR3),HL
	LD	HL,(PTR)
	LD	(PTR2),HL
	JP	MRK1
MRK3:	LD	HL,(PTR3)	;DONE
	LD	DE,NULL
	CALL	JPEN
	JP	Z,MRK4
	LD	HL,(PTR3)	;RETRACE CHAIN 1 PLACE
	LD	DE,PTRLN
	ADD	HL,DE
	INC	HL
	LD	DE,PTRLN	;MOVE TO GARBAGE FIELD
	ADD	HL,DE
	LD	A,(HL)
	LD	(TYPE),A
	LD	DE,PTRLN	;MOVE TO ACROSS PTR
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(PTR3)	;GRAB DOWN PTR (JUST IN CASE)
	LD	(TPP),HL
	CP	1
	JP	NZ,MRK35
	LD	HL,(PTR)	;NEEDED ACROSS
	LD	(TPP),HL
MRK35:	LD	HL,(TPP)	;ROTATE LINKS
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	HL,(PTR2)
	EX	DE,HL
	LD	HL,(TPP)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR3)
	LD	(PTR2),HL
	LD	HL,(PTR)
	LD	(PTR3),HL
	JP	MRK2
MRK4:	RET
;*
;*
SEARC:	;SEARCH SYMBOL TABLE FOR ENTRY
	CALL	SSCHK
	XOR	A
	LD	(CASE),A
	LD	HL,SYMPT	;LAST POINTS TO PREVIOUS ENTRY
	LD	(LAST),HL
	LD	HL,(SYMPT)	;PTR TO START OF SYMBOL TABLE
	LD	(PTR),HL
SEA1:	LD	HL,(PTR)	;TPP TO NEXT ENTRY
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(TPP),HL
	LD	DE,NULL
	CALL	JPEN
	JP	Z,SEA14
	LD	HL,(PTR)	;PTR TO TYPE
	LD	DE,2
	ADD	HL,DE
	LD	A,(HL)
	LD	(STYPE),A
	LD	DE,5		;PTR TO NAME LENGTH
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(HL)
	LD	(COUNT),A
	INC	HL		;PTR TO NAME
	LD	(PTR),HL
	LD	HL,NLENG
	CP	(HL)
	JP	NZ,SEA2
	LD	HL,(PTR)
	EX	DE,HL
	LD	HL,(NAME)
	LD	A,(NLENG)
	LD	C,A
	CALL	JSE
	JP	NZ,$+13
	LD	(NAME),HL
	EX	DE,HL
	LD	(PTR),HL
	JP	SEA3
SEA2:	LD	HL,(TPP)	;TRY NEXT ONE
	LD	(PTR),HL
	LD	HL,(LAST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(LAST),HL
	JP	SEA1
SEA3:	LD	HL,(LAST)
	LD	(LPTR),HL
	LD	A,(SCNT)	;NAME MATCH--NO SUBS
	OR	A
	JP	Z,SEA1B
;*  HERE IF SUBSCRIPTS TO MATCH
	LD	HL,(NAME)
	INC	HL
	LD	(NAME),HL
SEA4:	LD	A,(STYPE)	;NO SUBS IN SYMBOL TABLE
	CP	4
	JP	C,SEA13
	LD	HL,(LAST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(LPTR),HL
	LD	HL,(PTR)
	LD	(LAST),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	(SDP),HL
	LD	DE,NULL
	CALL	JPEN
	JP	Z,SEA8
SEA5:	LD	HL,(PTR)	;SET DOWN PTR
	LD	(DP),HL
	LD	DE,2
	ADD	HL,DE
	LD	A,(HL)		;SET TYPE
	LD	(STYPE),A
	LD	DE,5
	ADD	HL,DE
	LD	(PTR),HL
	LD	(AP),HL		;SET ACROSS PTR
	LD	DE,2
	ADD	HL,DE
	LD	(PTR),HL
;*  NOW CHECK IF SUBSCRIPTS EQUAL
	LD	(PTR5),HL
	LD	HL,(NAME)
	LD	(PTR4),HL
	CALL	COMPA
	LD	A,(CASE)
	CP	2
	JP	Z,SEA11
SEA7:	LD	HL,(AP)		;NO MATCH--MOVE ACROSS
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	HL,(AP)
	LD	(LAST),HL
	LD	HL,(DP)
	LD	(LPTR),HL
	LD	HL,(PTR)
	LD	DE,NULL
	CALL	JPEN
	JP	NZ,SEA5
SEA8:	LD	A,1		;NOT ALL SUBS MATCH
	LD	(CASE),A
	JP	SEA13
SEA11:	LD	HL,(PTR5)
	INC	HL
	LD	(PTR),HL
	LD	HL,(PTR4)
	INC	HL
	LD	(NAME),HL
	LD	HL,SCNT
	DEC	(HL)
	LD	A,(SCNT)
	OR	A
	JP	Z,SEA12
	LD	HL,(DP)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	(SDP),HL
	LD	HL,(DP)
	LD	(LAST),HL
	LD	(LPTR),HL
	LD	HL,(PTR)
	LD	DE,NULL
	CALL	JPEN
	JP	NZ,SEA5
	LD	A,1		;NOT ALL SUBS MATCH
	LD	(CASE),A
	JP	SEA13
SEA1B:	LD	HL,(NAME)
	INC	HL
	LD	(NAME),HL
SEA12:	LD	A,2		;COMPLETE MATCH
	LD	(CASE),A
	LD	A,(STYPE)
	CP	4
	JP	C,SEA13
	CP	7
	JP	C,$+6
	JP	NZ,SEA13
	LD	HL,(PTR)	;MOVE PTR TO VALUE
	LD	DE,2
	ADD	HL,DE
	LD	(PTR),HL
SEA13:	LD	A,1
	LD	(RESUL),A
	RET
SEA14:	XOR	A
	LD	(RESUL),A
	RET
;*
;*
SETVA:	;SETS VALUE IN SYMBOL TABLE
	CALL	SSCHK
SET0:	LD	HL,I4
	LD	B,1
	CALL	POPIT
	LD	A,(I1)
	CP	1
	JP	Z,SET9
	LD	HL,(TOS)
	INC	HL
	LD	(TOS),HL
	LD	A,(I4)
	LD	(I3),A
SET5:	LD	A,(STYPE)
	CP	7
	JP	C,$+6
	JP	NZ,SET7
	CP	4
	JP	C,SET55
	LD	A,(I3)
	ADD	A,4
	LD	(I3),A
SET55:	LD	HL,(PTR3)
	LD	(SPTR),HL
	CALL	INSER		;PUT IN NEW ENTRY
	LD	HL,(SPTR)
	LD	(PTR3),HL
	LD	HL,(LAST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR2),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR1)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(LAST)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR1)
	LD	(PTR),HL
	LD	HL,(PTR2)
	LD	DE,2
	ADD	HL,DE
	LD	(PTR2),HL
	LD	A,(HL)		;MARK OLD AS GARBAGE
	OR	128
	LD	(HL),A
	LD	HL,(PTR)
	LD	DE,7
	ADD	HL,DE
	LD	A,(HL)
	LD	(COUNT),A
	LD	C,A
	LD	B,0
	ADD	HL,BC
	INC	HL
	LD	(PTR),HL
	LD	A,(STYPE)
	CP	4
	JP	C,SET0
	LD	HL,(PTR2)
	LD	DE,5
	ADD	HL,DE
	LD	A,(COUNT)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	INC	HL
	LD	(PTR2),HL
	LD	E,(HL)		;COPY DOWN PTR
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,2
	ADD	HL,DE
	LD	(PTR),HL
	JP	SET0
SET7:	LD	A,(I3)
	ADD	A,8
	LD	(I3),A
	LD	HL,(PTR3)
	LD	(SPTR),HL
	LD	HL,(LAST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,9
	ADD	HL,DE
	LD	(PTR3),HL
	LD	A,1
	LD	(I9),A
	CALL	SINSR		;PUT IN SUBSCRIPT WITH VALUE
	LD	HL,(SPTR)
	LD	(PTR3),HL
	LD	HL,(LAST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR2),HL
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(LAST)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR2)	;PUT IN DOWN PTR
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR1)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR1)
	LD	DE,7
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(PTR2)
	LD	DE,2
	ADD	HL,DE
	LD	A,(HL)		;SET GARBAGE BIT
	OR	128
	LD	(HL),A
	LD	DE,5
	ADD	HL,DE
	LD	(PTR2),HL
	LD	E,(HL)		;SET ACROSS PTR
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,2
	ADD	HL,DE
	LD	(PTR),HL
SET8:	LD	HL,(PTR)	;SKIP PAST SUBSCRIPT
	LD	A,(HL)
	CP	DELIM
	JP	Z,SET85
	INC	HL
	LD	(PTR),HL
	JP	SET8
SET85:	LD	HL,(PTR)	;SKIP DELIMITER
	INC	HL
	LD	(PTR),HL
	JP	SET0
SET9:	LD	HL,(TOS)
	DEC	HL
	LD	A,(HL)
	LD	(SLENG),A
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(PTR2),HL
SET10:	LD	HL,(PTR)
	LD	A,(SLENG)
	LD	(HL),A
	INC	HL
	LD	(PTR),HL
	LD	HL,(PTR2)
	EX	DE,HL
	LD	HL,(PTR)
	LD	B,A
	CALL	MOVE
	RET
;*
;*
SINSR:	;INSERT DUMMY NODES IN SYMBOL TABLE
	CALL	SSCHK
	XOR	A		;GARBAGE COLLECTION FLAG
	LD	(N),A
	LD	A,1
	LD	(I1),A
	CALL	GTSIZ
SIN0:	LD	HL,(TPP)	;BASIC SIZE (NO SUBSCRIPT)
	LD	DE,9
	ADD	HL,DE
	LD	(TPP),HL
	LD	HL,(PTR3)
	LD	(PTR8),HL
SIN1:	LD	HL,(PTR3)
	LD	A,(HL)
	CP	DELIM
	JP	Z,SIN15
	INC	HL
	LD	(PTR3),HL
	LD	HL,(TPP)
	INC	HL
	LD	(TPP),HL
	JP	SIN1
SIN15:	LD	HL,(TPP)
	INC	HL
	LD	(TPP),HL
	LD	HL,(PTR8)
	LD	(PTR3),HL
SIN2:	LD	HL,(SYMEN)	;SEE IF IT'LL FIT
	LD	(PTR),HL
	LD	HL,(TPP)
	EX	DE,HL
	LD	HL,(PTR)
	CALL	PSUB
	LD	(PTR),HL
	EX	DE,HL
	LD	HL,(PRGEN)
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,SIN3
	LD	A,(N)		;NO ROOM, ALREADY COLLECTED
	CP	1
	JP	Z,E31
	CALL	GARBG
	LD	A,1		;SET FLAG
	LD	(N),A
	LD	A,(I9)
	OR	A
	JP	Z,SIN2
	LD	HL,(LAST)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,9
	ADD	HL,DE
	LD	(PTR3),HL
	JP	SIN2
SIN3:	LD	HL,(PTR)
	LD	(PTR1),HL
	LD	(SYMEN),HL
	LD	HL,(PTR)	;NULL DOWN PTR
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,2
	ADD	HL,DE
	LD	A,(I3)		;SET TYPE
	LD	(HL),A
	LD	(STYPE),A
	INC	HL
	LD	(PTR),HL
	LD	HL,(TPP)	;SET SIZE
	EX	DE,HL
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,4
	ADD	HL,DE
	LD	(PTR),HL
	LD	DE,NULL		;NULL ACROSS PTR
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,2
	ADD	HL,DE
	LD	(PTR),HL
SIN4:	LD	HL,(PTR3)
	LD	A,(HL)
	CP	DELIM
	JP	Z,SIN5
	LD	A,(HL)
	LD	HL,(PTR)
	LD	(HL),A
	INC	HL
	LD	(PTR),HL
	LD	HL,(PTR3)
	INC	HL
	LD	(PTR3),HL
	JP	SIN4
SIN5:	LD	HL,(PTR)
	LD	(HL),DELIM
	INC	HL
	LD	(PTR),HL
	LD	HL,(PTR3)
	INC	HL
	LD	(PTR3),HL
	RET
;*
;*
DEL:	;KILL GLOBAL NOT ON LEAF
	CALL	SSCHK
	LD	A,FALSE
	LD	(SPLT),A
	LD	HL,SGREC
	LD	DE,GREC
	CALL	SETD
	LD	A,(N)
	LD	(SN),A
	LD	HL,N
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC
	LD	B,3
	CALL	PUSHT
	LD	HL,(PTR)
	LD	DE,-(GVLEN)
	ADD	HL,DE
	LD	(PTR),HL
	LD	DE,GREC
	EX	DE,HL
	CALL	SETD
	LD	HL,GRCXX
	LD	DE,GREC
	CALL	SETD
DEL1:	CALL	GREAD
	CALL	G2END
	LD	HL,N
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC
	LD	B,3
	CALL	PUSHT
	LD	HL,GRCC3
	LD	DE,NIL
	CALL	JDEN
	JP	Z,DELA
	LD	HL,GREC
	LD	DE,GRCC3
	CALL	SETD
	JP	DEL1
DELA:	LD	HL,(PTR)
	LD	(SPTR),HL
	LD	HL,(TOS)
	LD	(TRAIL),HL
	LD	HL,SN
	LD	B,1
	CALL	PUSHT
	LD	HL,SGREC
	LD	B,3
	CALL	PUSHT
	CALL	SAVKE
	LD	HL,(SPTR)
	LD	(PTR),HL
	CALL	SETSE
	CALL	SQUAS		;DELETE ENTRY IN LEAF
	LD	HL,GREC
	LD	B,3
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC
	LD	B,3
	CALL	PUSHT
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(UBSZ),HL
	CALL	GREAD		;READ IN HIGH UP NODE
	CALL	SETPT		;MOVE PTR TO START OF ENTRY
	LD	HL,GREC
	LD	DE,GRCXX
	CALL	SETD
	LD	A,TRUE
	LD	(FRMDE),A
	CALL	GLST0		;SET THE LEAF VALUE UP HIGH
	LD	A,FALSE
	LD	(UF),A
	LD	HL,(UBSZ)
	LD	DE,BLKS2
	LD	A,E
	SUB	L
	LD	A,D
	SBC	A,H
	JP	C,DEL2
	LD	A,TRUE
	LD	(UF),A
	CALL	FIXTR
DEL2:	RET
;*
;*
ENTSI:	;GET SIZE OF ENTRY TO TPP
	CALL	SSCHK
	LD	HL,(PTR)
	LD	(PTR2),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR3),HL
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	CALL	VALSZ
	LD	HL,(PTR3)
	EX	DE,HL
	LD	HL,(TPP)
	ADD	HL,DE
	LD	DE,PTRLN+GVLEN
	ADD	HL,DE
	LD	(TPP),HL
	LD	HL,(PTR2)
	LD	(PTR),HL
	RET
;*
;*
FDDSC:	;IS NEXT ENTRY A DESCENDENT
	CALL	SSCHK
	LD	HL,PTR3
	LD	B,2
	CALL	PUSHT
	LD	HL,NLEN
	LD	B,2
	CALL	PUSHT
	LD	HL,(PTR)
	LD	(TPP),HL
	XOR	A
	LD	(RESUL),A
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PLEN),HL
	LD	HL,(TPP)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(TPP),HL
	LD	HL,(PLEN)
	EX	DE,HL
	LD	HL,(NLEN)
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,FDD0
	JP	FDD4		;DONE--NO DESCENDENTS
FDD0:	LD	A,(SCNT)
	LD	(I5),A
	LD	HL,(TPP)
	LD	(PTR5),HL
	LD	HL,(PTR3)
	LD	(PTR4),HL
	CALL	COMPA
	LD	A,(CASE)
	CP	2
	JP	NZ,FDD4
	LD	HL,(PTR4)
	INC	HL
	INC	HL
	LD	(PTR4),HL
	LD	HL,(PTR5)
	INC	HL
	INC	HL
	LD	(PTR5),HL
FDD1:	LD	HL,(NLEN)
	LD	DE,NULL
	CALL	JPEN
	JP	Z,FDD3
	LD	HL,(PTR4)
	LD	A,(HL)
	CP	DELIM
	JP	NZ,FDD12
	LD	HL,(PTR5)
	LD	A,(HL)
	CP	DELIM
	JP	Z,FDD13
	JP	FDD4
FDD12:	LD	HL,(PTR5)
	LD	A,(HL)
	CP	DELIM
	JP	Z,FDD4
	LD	HL,(PTR4)
	EX	DE,HL
	LD	HL,(PTR5)
	LD	A,(DE)
	CP	(HL)
	JP	NZ,FDD4
FDD13:	LD	HL,(PTR4)
	INC	HL
	LD	(PTR4),HL
	LD	HL,(PTR5)
	INC	HL
	LD	(PTR5),HL
	LD	HL,(NLEN)
	DEC	HL
	LD	(NLEN),HL
	JP	FDD1
FDD3:	LD	A,1
	LD	(RESUL),A
FDD4:	LD	HL,NLEN		;RESTORE VALUES
	LD	B,2
	CALL	POPIT
	LD	HL,PTR3
	LD	B,2
	CALL	POPIT
	RET
;*
;*
FINDK:	;FIND PLACE FOR A KEY
	CALL	SSCHK
	LD	A,TRUE
	LD	(PASSU),A
	LD	A,FALSE
	LD	(RESUL),A
	LD	A,(GLBDR)
	LD	(DRIVE),A
	XOR	A
	LD	(FCBTY),A
	LD	A,(GLOPN)
	CP	1
	JP	Z,FDKA
	CALL	FOPEN
	LD	A,1
	LD	(GLOPN),A
	CALL	RDROO
FDKA:	LD	HL,GREC
	LD	DE,ROOT
	CALL	SETD
FDK0:	LD	HL,GREC
	LD	DE,NIL
	CALL	JDEN
	JP	Z,FDK4
	LD	A,(PASSU)
	CP	TRUE
	JP	NZ,FDK4
	CALL	GREAD
	LD	HL,(GLBUF)	;PTR TO START OF BUFFER
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	E,(HL)		;GET MIDDLE OFFSET
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(TPP),HL
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	A,(HL)
	LD	(N),A
	INC	HL
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	LD	(PTR7),HL	;SAVE STARTING PLACE
	LD	HL,(TPP)	;MOVE PTR TO MIDDLE
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	(PTR),HL
	LD	E,(HL)		;GET KEY SIZE
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR1),HL
	LD	DE,NULL
	CALL	JPEN
	JP	Z,FDK05
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(SCNT)
	LD	(I5),A
	CALL	KEYCM		;COMPARE KEYS
	LD	A,(CASE)
	CP	2
	JP	Z,FDK2
	LD	A,FALSE
	LD	(RESUL),A
	LD	A,(CASE)
	CP	3
	JP	Z,FDK15
FDK05:	LD	HL,(PTR7)	;PUT PTR BACK TO START
	LD	(PTR),HL
	XOR	A
	LD	(N),A
FDK1:	LD	HL,(PTR)	;GET KEY SIZE
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR1),HL
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(PTR1)
	LD	DE,NULL
	CALL	JPEN
	JP	Z,FDK3
	LD	A,(SCNT)
	LD	(I5),A
	CALL	KEYCM		;COMPARE KEYS
	LD	A,(CASE)	;FOUND IT?
	CP	2
	JP	Z,FDK2
	LD	A,FALSE
	LD	(RESUL),A
	LD	A,(CASE)
	CP	1
	JP	Z,FDK3
FDK15:	LD	HL,(PTR1)	;PTR PAST KEY TO TYPE
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	(PTR),HL
	CALL	VALSZ
	LD	HL,(TPP)	;PTR PAST VALUE TO DOWN PTR
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,N
	INC	(HL)
	JP	FDK1
FDK2:	LD	A,FALSE		;IT'S FOUND
	LD	(PASSU),A
	LD	A,TRUE
	LD	(RESUL),A
FDK3:	LD	HL,N		;SAVE LOCATION IN BLOCK
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC		;SAVE BLOCK NUMBER
	LD	B,3
	CALL	PUSHT
	LD	HL,(PTR)
	LD	BC,-(GVLEN+PTRLN)
	ADD	HL,BC
	LD	(PTR),HL
	LD	DE,GREC		;GET NEXT BLOCK BELOW
	EX	DE,HL
	CALL	SETD
	JP	FDK0
FDK4:	LD	HL,(PTR)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	RET
;*
;*
FINDM:	;SCAN TO MIDDLE ENTRY OF NODE
	CALL	SSCHK
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	OR	A
	LD	HL,(BSIZE)	;DIVIDE BSIZE BY TWO
	LD	A,H
	RRA
	LD	H,A
	LD	A,L
	RRA
	LD	L,A
	LD	(BSIZE),HL
	LD	HL,(PTR)	;PTR TO START OF FIRST KEY
	LD	DE,PTRLN+PTRLN+GVLEN
	ADD	HL,DE
	INC	HL
	LD	(PTR),HL
	XOR	A
	LD	(N),A
	LD	HL,NULL
	LD	(PTR1),HL
FNDM1:	LD	HL,PTR1
	LD	B,2
	CALL	PUSHT
	LD	HL,(PTR)	;GET NAME AND SUB SIZE
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(TPP),HL
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(TPP)	;PTR TO VAR TYPE
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(TPP)
	EX	DE,HL
	LD	HL,(PTR1)
	ADD	HL,DE
	LD	DE,PTRLN+GVLEN
	ADD	HL,DE
	LD	(PTR1),HL
	CALL	VALSZ		;GET VALUE SIZE TO TPP
	LD	HL,(TPP)	;PTR TO DOWN PTR
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,GVLEN	;PTR TO NEXT ENTRY
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(TPP)
	EX	DE,HL
	LD	HL,(PTR1)
	ADD	HL,DE
	LD	(PTR1),HL
	LD	HL,N
	INC	(HL)
	LD	HL,TPP
	LD	B,2
	CALL	POPIT
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(BSIZE)
	CALL	JPEN
	JP	Z,FNDM2
	LD	HL,(BSIZE)
	EX	DE,HL
	LD	HL,(PTR1)
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,FNDM1
	LD	HL,(TPP)
	LD	(PTR1),HL
	LD	HL,N
	DEC	(HL)
FNDM2:	RET
;*
;*
FIXTR:	;FIX UP TRAIL FOR UNDERFLOW
	CALL	SSCHK
	LD	A,(SPLT)	;SEE IF DID A SPLIT
	CP	TRUE
	JP	Z,FIXT1
	LD	HL,(TRAIL)	;MOVE TOS BACK TO TRAIL
	LD	(TOS),HL
FIXT0:	LD	HL,GREC		;GET UNDERFLOW NODE
	LD	B,3
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	POPIT
	CALL	GREAD		;MAKE UNERFLOW NODE CURRENT
	RET
FIXT1:	LD	HL,(TOP)	;PTR1 TO BEGINNING OF OLD TRAIL
	LD	(PTR1),HL
	LD	(PTR),HL
	LD	HL,(USTAK)	;GET TOP ENTRY OFF SPLIT TRAIL
	LD	DE,-(GVLEN)
	ADD	HL,DE
	LD	(USTAK),HL
	EX	DE,HL
	LD	HL,TGREC
	CALL	SETD
	LD	HL,(USTAK)
	DEC	HL
	LD	(USTAK),HL
	LD	A,(HL)
	LD	(TN),A
	LD	HL,TGREC	;FOUND START OF SPLIT TRAIL YET?
	LD	DE,ROOT
	CALL	JDEN
	JP	Z,FIXT3
FIXT2:	LD	HL,(PTR1)	;SAVE START OF ENTRY
	LD	(PTR),HL
	LD	A,(HL)		;GET OFFSET
	LD	(N),A
	INC	HL
	LD	(PTR1),HL
	EX	DE,HL		;GET BLOCK NUMBER
	LD	HL,TGREC
	CALL	SETD
	LD	HL,(PTR1)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR1),HL
	LD	HL,GREC
	LD	DE,TGREC
	CALL	JDEN
	JP	NZ,FIXT2
FIXT3:	LD	HL,(PTR)	;MOVE TOS TO WHERE STACK GOES BAD
	LD	(TOS),HL
	LD	A,(TN)
	LD	(N),A
	LD	HL,GREC
	LD	DE,TGREC
	CALL	SETD
FIXT4:	LD	HL,N		;SAVE OFFSET ON STACK
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC		;SAVE BLOCK NUMBER ON STACK
	LD	B,3
	CALL	PUSHT
	LD	HL,(USTAK)	;USED UP SPLIT STACK?
	LD	DE,TSTAK
	CALL	JPEN
	JP	Z,FIXT5
	LD	HL,(USTAK)
	LD	DE,-(GVLEN)
	ADD	HL,DE
	LD	(USTAK),HL
	EX	DE,HL
	LD	HL,GREC
	CALL	SETD
	LD	HL,(USTAK)
	DEC	HL
	LD	(USTAK),HL
	LD	A,(HL)
	LD	(N),A
	JP	FIXT4
FIXT5:	CALL	GREAD		;READ IN NODE THAT SPLIT
	CALL	SETPT		;MOVE PTR TO BEFORE INSERTED ENTRY
	LD	HL,(PTR)	;BACK PTR UP TO DOWN PTR
	LD	DE,-(GVLEN)
	ADD	HL,DE
	LD	(PTR),HL
	EX	DE,HL
	LD	HL,GREC
	CALL	SETD
FIXT6:	CALL	GREAD		;GET NODE BELOW ONE FROM SPLIT
	CALL	G2END
	LD	HL,N		;SAVE LAST ENTRY PLACE
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC		;AND BLOCK NUMBER
	LD	B,3
	CALL	PUSHT
	LD	HL,GRCC3	;JUMP IF AT LEAF
	LD	DE,NIL
	CALL	JDEN
	JP	Z,FIXT7
	LD	HL,GREC		;GET NEXT LEVEL DOWN
	LD	DE,GRCC3
	CALL	SETD
	JP	FIXT6
FIXT7:	LD	HL,(TOS)	;NOW HAVE NEW TRAIL
	LD	(TRAIL),HL
	JP	FIXT0
;*
;*
FNAKD:	;FIX UP NAKED REFERENCE
	CALL	SSCHK
	LD	A,(NLENG)
	OR	A
	JP	NZ,NAK3
	LD	A,(NSUBS)
	OR	A
	JP	Z,E36
	LD	A,(SCNT)
	OR	A
	JP	Z,E36
	LD	A,1
	LD	(NR),A
	LD	HL,(NAME)
	LD	(TPP),HL
	LD	A,(SCNT)	;# OF SUBS ON STACK
	LD	(I5),A
	LD	HL,NSUBS	;BACK UP NAKED 1 SUB
	DEC	(HL)
	LD	HL,(NLAST)
	LD	(NPTR),HL
	LD	HL,(TPP)
	INC	HL
	LD	(TPP),HL
	CALL	MOVSU		;MOVE SUBS TO NAKED PLACE
	LD	A,(NSUBS)
	LD	(SCNT),A
	LD	(SSUB),A
	LD	HL,(NSIZE)
	LD	A,(NMSZ)
	CPL
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	DEC	HL
	LD	(NLEN),HL
	LD	A,(NMSZ)	;SET SIZE OF NAME
	LD	(NLENG),A
	LD	HL,NREF
	LD	(NAME),HL
	LD	(PTR3),HL
	RET
NAK3:	LD	A,(SCNT)
	OR	A
	JP	Z,NAK4
	CALL	SNAKD
	LD	HL,(PTR)
	LD	(TPP),HL
	LD	A,(SCNT)
	LD	(I5),A
	CALL	MOVSU
NAK4:	RET
;*
;*
FNDOL:	;FIND OLDEST ENTRY (AGE IS 0)
	CALL	SSCHK
	LD	HL,(GLBTA)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(TPP),HL
	XOR	A
	LD	(IT),A
FNDO1:	LD	HL,(TPP)	;FIND OLD ONE
	LD	A,(HL)
	OR	A
	JP	Z,FNDO2
	LD	DE,GBTSZ	;TPP TO NEXT ENTRY
	ADD	HL,DE
	LD	(TPP),HL
	LD	HL,IT
	INC	(HL)
	JP	FNDO1
FNDO2:	LD	A,(IT)		;SAVE BUFFER NUMBER
	LD	(BUFNO),A
	CALL	SETGL		;SET GLOBAL PTRS
	LD	HL,(GLDRT)
	LD	A,(HL)
	OR	A
	JP	Z,FNDO3
	LD	HL,GRCC4	;DIRTY, SO WRITE IT
	LD	DE,GREC
	CALL	SETD
	LD	DE,GREC
	LD	HL,(GLBNO)
	EX	DE,HL
	CALL	SETD
	CALL	GWRIT
	LD	HL,GREC
	LD	DE,GRCC4
	CALL	SETD
FNDO3:	LD	HL,(GLBNO)	;SET RECORD NUMBER
	LD	DE,GREC
	CALL	SETD
	CALL	UPDRE		;UPDATE AGES
	RET
;*
;*
FNDRE:	;LOOK FOR BLOCK 'GREC'
	CALL	SSCHK
	XOR	A
	LD	(RESUL),A
	LD	HL,(GLBTA)	;TPP TO START OF TABLE
	LD	(TPP),HL
	LD	(IT),A
FNDR1:	LD	HL,(TPP)
	LD	DE,GREC
	CALL	JDEN
	JP	Z,FNDR2
	LD	HL,(TPP)	;TPP TO NEXT ENTRY
	LD	DE,GBTSZ
	ADD	HL,DE
	LD	(TPP),HL
	LD	HL,IT
	INC	(HL)
	LD	A,(IT)
	LD	HL,NGBUF
	CP	(HL)
	JP	NZ,FNDR1
	RET
FNDR2:	LD	A,1
	LD	(RESUL),A
	RET
;*
;*
G2END:	;MOVE PTR TO LAST ENTRY--SET PTR4
	CALL	SSCHK
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	E,(HL)		;GET MIDDLE OFFSET
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(TPP),HL
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	A,(HL)
	LD	(N),A
	INC	HL
	LD	(PTR),HL
	EX	DE,HL
	LD	HL,GRCC3
	CALL	SETD
	LD	HL,(PTR)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(TPP)	;MOVE TO MIDDLE ENTRY
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	(PTR),HL
G2E1:	LD	HL,(PTR)	;SAVE ENTRY NAME SIZE
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR2),HL
	LD	DE,NULL
	CALL	JPEN
	JP	Z,G2E2
	LD	HL,(PTR)	;SAVE ENTRY START
	LD	(PTR3),HL
	LD	HL,(PTR2)
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	CALL	VALSZ
	LD	HL,(TPP)
	LD	(PTR4),HL
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	(PTR),HL
	LD	DE,GRCC3
	EX	DE,HL
	CALL	SETD
	LD	HL,(PTR)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,N
	INC	(HL)
	JP	G2E1
G2E2:	LD	HL,(PTR3)
	LD	(PTR),HL
	RET
;*
;*
GETFI:	;GET FIRST ENTRY IN TREE
	CALL	SSCHK
	LD	A,FALSE
	LD	(RESUL),A
	LD	HL,GREC
	LD	DE,ROOT
	CALL	SETD
GTFS1:	LD	HL,GREC
	LD	DE,NIL
	CALL	JDEN
	JP	Z,GTFS2
	XOR	A
	LD	(N),A
	LD	HL,N		;LEAVE A TRAIL
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC
	LD	B,3
	CALL	PUSHT
	CALL	GREAD		;READ IN NODE
	CALL	SETPT		;SET PTR AT FIRST ENTRY
	LD	HL,(PTR)
	LD	BC,-(GVLEN)
	ADD	HL,BC
	LD	(PTR),HL
	LD	DE,GREC		;GET FIRST DOWN PTR
	EX	DE,HL
	CALL	SETD
	LD	A,TRUE
	LD	(RESUL),A
	JP	GTFS1
GTFS2:	LD	A,(RESUL)
	CP	FALSE
	JP	Z,GTFS3
	LD	HL,(PTR)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
GTFS3:	RET
;*
;*
GETNE:	;GET NEXT ENTRY AFTER PTR (CALL FINDKEY FIRST)
	CALL	SSCHK
	LD	HL,ROOT
	LD	DE,NIL
	CALL	JDEN
	JP	Z,GTNX4
	LD	HL,GREC
	LD	B,3
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	POPIT
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,GTNX1
	LD	HL,(PTR)	;SKIP OVER PREFECT MATCH
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	CALL	VALSZ		;SKIP OVER VALUE
	LD	HL,(TPP)
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,N
	INC	(HL)
GTNX1:	LD	HL,(PTR)	;PTR AT START OF NEXT ONE
	LD	BC,-(GVLEN)
	ADD	HL,BC
	LD	(PTR),HL
	LD	DE,GRCC1
	EX	DE,HL
	CALL	SETD
	LD	HL,GRCC1	;CHECK IF ROOM TO GO DOWN
	LD	DE,NIL
	CALL	JDEN
	JP	NZ,GTNX3
	LD	HL,(PTR)	;CAN'T GO DOWN
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
GTNX2:	LD	HL,(PTR)	;NOT AT END SO DONE
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,NULL
	CALL	JPEN
	JP	NZ,GTNX5
	LD	HL,GREC		;AT ROOT?
	LD	DE,ROOT
	CALL	JDEN
	JP	Z,GTNX4
	LD	HL,GREC		;GO UP A LEVEL
	LD	B,3
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	POPIT
	CALL	GREAD
	CALL	SETPT
	JP	GTNX2
GTNX3:	LD	HL,N		;LEAVE A TRAIL
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC
	LD	B,3
	CALL	PUSHT
	LD	HL,GREC
	LD	DE,GRCC1
	CALL	SETD
	CALL	GREAD
	XOR	A
	LD	(N),A
	CALL	SETPT		;SET PTR AT FIRST ENTRY
	JP	GTNX1
GTNX4:	LD	A,FALSE		;NO MORE
	LD	(RESUL),A
	RET
GTNX5:	LD	A,TRUE
	LD	(RESUL),A
	LD	HL,N
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC
	LD	B,3
	CALL	PUSHT
	RET
;*
;*
GINSE:	;INSERT A GLOBAL VALUE
	CALL	SSCHK
	LD	HL,(PTR2)
	LD	(PTR1),HL
	LD	HL,(PTR4)
	EX	DE,HL
	LD	HL,(PTR1)
	ADD	HL,DE
	LD	(PTR1),HL
	LD	DE,BLKSH
	LD	A,E
	SUB	L
	LD	A,D
	SBC	A,H
	JP	C,E8
	LD	HL,GREC		;RETRIEVE LOCATION
	LD	B,3
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	POPIT
	CALL	GREAD
	CALL	SETPT		;MOVE PTR TO INSERT PLACE
	LD	HL,(BSIZE)	;PTR1 IS SIZE USED IN BLOCK
	LD	(PTR1),HL
	LD	HL,(PTR2)	;ADD ON NEW ENTRY SIZE -- NAME + SUBS
	EX	DE,HL
	LD	HL,(PTR1)
	ADD	HL,DE
	LD	(PTR1),HL
	LD	HL,(PTR4)
	EX	DE,HL
	LD	HL,(PTR1)
	ADD	HL,DE
	LD	DE,OVRHD	;ADD ON OVERHEAD -- SIZE + PTRS
	ADD	HL,DE
	LD	(PTR1),HL
	LD	DE,BLKSZ	;WILL IT FIT?
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,GINS1
	CALL	SPLIT		;NO, SO SPLIT NODE
	RET
GINS1:	CALL	SETGV		;SET GLOBAL VALUE
	LD	A,FALSE
	LD	(PASSU),A
	RET
;*
;*
GLBCL:	;CLOSE GLOBAL FILE
	CALL	SSCHK
	LD	A,(GLOPN)
	CP	1
	JP	NZ,GLB2
	XOR	A
	LD	(BUFNO),A
GLB0:	LD	A,(BUFNO)
	LD	(IT),A
	CALL	SETGL
	LD	HL,(GLDRT)
	LD	A,(HL)
	OR	A
	JP	Z,GLB1
	LD	DE,GREC
	LD	HL,(GLBNO)
	EX	DE,HL
	CALL	SETD
	CALL	GWRIT
GLB1:	LD	HL,(GLDRT)
	LD	(HL),0
	LD	HL,(GLBNO)
	LD	DE,NIL
	CALL	SETD
	LD	HL,BUFNO
	INC	(HL)
	LD	A,(BUFNO)
	LD	HL,NGBUF
	CP	(HL)
	JP	NZ,GLB0
GLB2:	RET
;*
;*
GLKIL:	;KILL A GLOBAL VARIABLE
	CALL	SSCHK
	LD	A,TRUE
	LD	(FRMKL),A
	LD	HL,GRCY
	LD	DE,NIL
	CALL	SETD
	LD	HL,GREC
	LD	B,3
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	POPIT
	LD	HL,(PTR)	;SAVE ENTRY START
	LD	BC,-(GVLEN)
	ADD	HL,BC
	LD	(TPP),HL
	LD	DE,NIL		;SEE IF AT LEAF
	CALL	JDEN
	JP	Z,GLKL1
	CALL	DEL		;NOT ON LEAF
	JP	GLKL3
GLKL1:	CALL	SQUAS
	LD	A,TRUE
	LD	(UF),A
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,BLKS2
	LD	A,E
	SUB	L
	LD	A,D
	SBC	A,H
	JP	C,GLKL3
	LD	A,FALSE
	LD	(UF),A
GLKL3:	LD	HL,ROOT
	LD	DE,GREC
	CALL	JDEN
	JP	Z,GLKL4
	LD	A,(UF)
	CP	TRUE
	JP	NZ,GLKL4
	CALL	UNDER
	JP	GLKL3
GLKL4:	LD	A,(UF)
	CP	TRUE
	JP	NZ,GLKL5
	CALL	GREAD
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	LD	DE,NULL
	CALL	JPEN
	JP	NZ,GLKL5
	LD	HL,(PTR)	;DEALLOCATE ROOT
	LD	DE,PTRLN+PTRLN
	ADD	HL,DE
	INC	HL
	LD	(PTR),HL
	LD	DE,GRCX
	EX	DE,HL
	CALL	SETD
	CALL	DEALL
	LD	HL,ROOT
	LD	DE,GRCX
	CALL	SETD
	LD	HL,GREC		;NOW GET FIRST BLOCK (MAP)
	LD	DE,GZERO
	CALL	SETD
	CALL	GREAD
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	DE,ROOT
	CALL	SETD
	LD	HL,(GLDRT)
	LD	(HL),1
GLKL5:	LD	HL,(TOP)
	LD	(TOS),HL
	RET
;*
;*
GLSET:	;SET GLOBAL VARIABLE
	CALL	SSCHK
	LD	A,FALSE
	LD	(FRMKL),A
	LD	HL,(TOS)
	LD	(TRAIL),HL
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,GLST1
GLST0:	CALL	SQUAS		;DELETE ENTRY IF SAME
	LD	A,TRUE
	LD	(PASSU),A
	JP	GLST2
GLST1:	LD	HL,GRCX
	LD	DE,NIL
	CALL	SETD
GLST2:	LD	HL,TSTAK
	LD	(USTAK),HL
GLSTA:	LD	A,(PASSU)
	CP	FALSE
	JP	Z,GLST3
	LD	HL,GREC
	LD	DE,ROOT
	CALL	JDEN
	JP	Z,GLST3
	CALL	GINSE
	JP	GLSTA
GLST3:	LD	A,(PASSU)
	CP	FALSE
	JP	Z,GLST4
	XOR	A		;ASSUME CAME FROM FIRST HALF
	LD	(I9),A
	LD	HL,GRCC1
	LD	DE,ROOT
	CALL	JDEN
	JP	Z,GLST5
	LD	A,1
	LD	(I9),A
GLST5:	LD	HL,GRCC1
	LD	DE,ROOT
	CALL	SETD
	CALL	ALLOC
	CALL	FNDOL
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	HL,ROOT
	LD	DE,GREC
	CALL	SETD
	LD	HL,(USTAK)
	LD	A,(I9)
	LD	(HL),A
	INC	HL
	LD	(USTAK),HL
	LD	DE,ROOT
	CALL	SETD
	LD	HL,(USTAK)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(USTAK),HL
	LD	HL,(PTR)
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(HL),0
	INC	HL
	LD	(PTR),HL
	LD	DE,GRCC1
	CALL	SETD
	LD	HL,(PTR)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	CALL	SETGV
	LD	HL,GREC		;NOW GET FIRST BLOCK (MAP)
	LD	DE,GZERO
	CALL	SETD
	CALL	GREAD
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	DE,ROOT
	CALL	SETD
	LD	HL,(GLDRT)
	LD	(HL),1
GLST4:	RET
;*
;*
GREAD:	;READ IN GREC'TH BLOCK
	CALL	SSCHK
	CALL	FNDRE		;SEE IF ALREADY AROUND
	LD	A,(RESUL)
	CP	1
	JP	Z,GRE1
	CALL	FNDOL		;FIND PLACE TO READ TO
	CALL	GREED		;READ IT
	LD	HL,(GLDRT)
	LD	(HL),0
	RET
GRE1:	CALL	SETGL		;SET GLOBAL POINTERS
	CALL	UPDRE
	RET
;*
;*
KEYCM:	;KEY COMPARISON
	CALL	SSCHK
	LD	HL,PTR3		;SAVE STARTING POINTS
	LD	B,2
	CALL	PUSHT
	LD	HL,PTR
	LD	B,2
	CALL	PUSHT
	LD	HL,PTR4
	LD	B,2
	CALL	PUSHT
	LD	HL,(PTR)	;SET PTR5 FOR COMPARE ROUTINE
	LD	(PTR5),HL
	LD	HL,(PTR3)	;SET PTR4 FOR COMPARE ROUTINE
	LD	(PTR4),HL
	CALL	COMPA		;COMPARE NAMES
	LD	A,FALSE
	LD	(RESUL),A
	LD	A,(CASE)
	CP	2
	JP	NZ,KEY9
	LD	A,TRUE
	LD	(RESUL),A
	LD	HL,(PTR5)	;PAST DELIMITER
	INC	HL
	LD	A,(HL)		;GET NUMBER OF SUBS
	LD	(I6),A
	INC	HL		;PAST SUB COUNT
	LD	(PTR5),HL
	LD	HL,(PTR4)	;SAME FOR PTR4
	INC	HL
	LD	(PTR4),HL
	INC	HL
	LD	(PTR4),HL
KEY1:	LD	A,(I5)
	OR	A
	JP	Z,KEY7
	LD	A,(I6)
	OR	A
	JP	Z,KEY8
	LD	HL,(PTR5)
	LD	(LAST),HL
	CALL	COMPA		;COMPARE SUBS
	LD	A,(CASE)
	CP	2
	JP	NZ,KEY9
	LD	HL,(PTR4)	;MOVE PAST DELIMITERS
	INC	HL
	LD	(PTR4),HL
	LD	HL,(PTR5)
	INC	HL
	LD	(PTR5),HL
	LD	HL,I5
	DEC	(HL)
	LD	HL,I6
	DEC	(HL)
	JP	KEY1
KEY7:	LD	A,(I6)
	OR	A
	JP	Z,KEY9
	LD	A,1
	LD	(CASE),A
	JP	KEY9
KEY8:	LD	A,3
	LD	(CASE),A
KEY9:	LD	HL,PTR4		;RESTORE POINTERS
	LD	B,2
	CALL	POPIT
	LD	HL,PTR
	LD	B,2
	CALL	POPIT
	LD	HL,PTR3
	LD	B,2
	CALL	POPIT
	RET
;*
;*
LGLOB:	;LIST GLOBAL NAMES
	CALL	SSCHK
	LD	A,(GLBDR)
	LD	(DRIVE),A
	XOR	A
	LD	(FCBTY),A
	LD	A,(GLOPN)
	CP	1
	JP	Z,LGL0
	CALL	FOPEN		;OPEN GLOBAL FILE
	LD	A,1
	LD	(GLOPN),A
	CALL	RDROO		;READ IN GLOBAL MAP
LGL0:	CALL	GETFI
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,LGL5
LGL1:	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN+PTRLN+GVLEN
	ADD	HL,DE
	INC	HL
	LD	(PTR),HL
LGL2:	LD	HL,(PTR)
	LD	(SPTR),HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,BLANK
	CALL	CPUSH
	LD	A,BLANK
	CALL	CPUSH
	LD	HL,(TOS)
	LD	(NMPTR),HL
	XOR	A
	LD	(SLENG),A
	LD	HL,VAR
	LD	(PTR1),HL
LGL3:	LD	HL,(PTR)
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR)
	LD	A,(HL)
	LD	HL,(PTR1)
	LD	(HL),A
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,SLENG
	INC	(HL)
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	LD	HL,(PTR)
	LD	A,(HL)
	CP	DELIM
	JP	NZ,LGL3
	LD	HL,(PTR1)
	LD	(HL),DELIM
LGL4:	LD	A,(SLENG)
	ADD	A,2
	LD	(IT),A
	LD	HL,IT
	LD	B,1
	CALL	PUSHT
	LD	A,3
	CALL	CPUSH
	CALL	AC54
	CALL	AC24
	LD	HL,(SPTR)
	LD	(PTR),HL
LGL45:	LD	A,TRUE
	LD	(RESUL),A
	CALL	GETNE
	LD	A,(RESUL)
	CP	FALSE
	JP	Z,LGL5
	LD	HL,VAR
	LD	(PTR4),HL
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR5),HL
	CALL	COMPA
	LD	A,(CASE)
	CP	2
	JP	Z,LGL45
	JP	LGL2
LGL5:	RET
;*
;*
MERGL:	;MERGE WITH PAGE TO LEFT
	CALL	SSCHK
	LD	HL,GREC
	LD	DE,GRECA
	CALL	SETD
	CALL	GREAD		;MAKE UNDERFLOW CURRENT NODE
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN+PTRLN
	ADD	HL,DE
	LD	(PTR3),HL
	INC	HL		;PTR TO DOWN PTR
	LD	(PTR3),HL
	LD	DE,GRCX
	EX	DE,HL
	CALL	SETD
	LD	HL,GREC
	LD	DE,GRECB
	CALL	SETD
	CALL	GREAD		;MAKE LEFT PAGE CURRENT
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,PTRLN+PTRLN+GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	INC	HL		;PTR IS AT END
	LD	(PTR),HL
	CALL	SETGV		;SET ANCESTOR GUY IN B
	LD	HL,(PTR3)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(GLBUF)	;MOVE PTR1 TO END OF B
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR1),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	EX	DE,HL
	LD	HL,(PTR1)
	ADD	HL,DE
	LD	DE,PTRLN+PTRLN+GVLEN
	ADD	HL,DE
	LD	(PTR1),HL
	INC	HL		;PTR1 AT END
	LD	(PTR1),HL
	CALL	MOVAL		;MOVE A TO END OF B
	LD	HL,(PTR1)
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(GLDRT)
	LD	(HL),1
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	HL,(BSIZE)	;SET NEW SIZE
	EX	DE,HL
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	CALL	FINDM		;GET MIDDLE PTRS FOR B
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(PTR1)	;SET MIDDLE OFFSET
	EX	DE,HL
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(N)
	LD	(HL),A
	LD	HL,GREC
	LD	DE,GRECA
	CALL	SETD
	CALL	GREAD
	CALL	DEALL		;RETURN NODE A TO SYSTEM
	LD	HL,GREC
	LD	DE,GRECC
	CALL	SETD
	CALL	GREAD
	LD	A,(CN)
	LD	(N),A
	CALL	SETPT
	CALL	SQUAS
	RET
;*
;*
MERGR:	;MERGE WITH PAGE ON RIGHT
	CALL	SSCHK
	LD	HL,GREC
	LD	DE,GRECB
	CALL	SETD
	CALL	GREAD		;GET PAGE ON RIGHT
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN+PTRLN+GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	INC	HL		;PTR TO START OF "B"
	LD	(PTR),HL
	LD	HL,GREC
	LD	DE,GRECA
	CALL	SETD
	CALL	GREAD
	LD	HL,(GLBUF)	;GET PAGE "A"
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR1),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	LD	HL,(PTR1)
	LD	DE,PTRLN+PTRLN+GVLEN
	ADD	HL,DE
	INC	HL
	LD	(PTR1),HL
	LD	HL,(BSIZE)	;PTR1 TO END OF "A"
	EX	DE,HL
	LD	HL,(PTR1)
	ADD	HL,DE
	LD	(PTR1),HL
	CALL	MOVAL		;MOVE "B" TO "A"
	LD	HL,(PTR1)
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(GLDRT)
	LD	(HL),1
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	HL,(BSIZE)	;SET NEW SIZE FOR A
	EX	DE,HL
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	CALL	FINDM
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(N)
	LD	(HL),A
	LD	HL,GREC
	LD	DE,GRECB
	CALL	SETD
	CALL	GREAD
	CALL	DEALL		;RETURN B TO SYSTEM
	LD	HL,GREC
	LD	DE,GRECC
	CALL	SETD
	CALL	GREAD
	LD	A,(CN)
	LD	(N),A
	CALL	SETPT
	CALL	SQUAS
	RET
;*
;*
MOVAL:	;MOVE ALL OF NODE FROM PTR TO PTR1
	CALL	SSCHK
MOVA1:	LD	HL,(PTR)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(TPP),HL
	LD	DE,NULL
	CALL	JPEN
	JP	Z,MOVA2
	LD	HL,(TPP)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(TPP),HL
	CALL	MOVEN
	JP	MOVA1
MOVA2:	RET
;*
;*
MOVEN:	;MOVE ENTRY FROM PTR TO PTR1
	CALL	SSCHK
MOVE1:	LD	HL,(PTR)	;SET NAME AND SUBS
	LD	A,(HL)
	LD	HL,(PTR1)
	LD	(HL),A
	INC	HL
	LD	(PTR1),HL
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,(BSIZE)
	INC	HL
	LD	(BSIZE),HL
	LD	HL,(TPP)
	DEC	HL
	LD	(TPP),HL
	LD	DE,NULL
	CALL	JPEN
	JP	NZ,MOVE1
	CALL	VALSZ
	LD	HL,(TPP)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(TPP),HL
MOVE2:	LD	HL,(PTR)	;SET VALUE AND TYPE
	LD	A,(HL)
	LD	HL,(PTR1)
	LD	(HL),A
	INC	HL
	LD	(PTR1),HL
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,(BSIZE)
	INC	HL
	LD	(BSIZE),HL
	LD	HL,(TPP)
	DEC	HL
	LD	(TPP),HL
	LD	DE,NULL
	CALL	JPEN
	JP	NZ,MOVE2
	RET
;*
;*
MOVSU:	;MOVE SUBS FROM STACK TO NAKED PLACE
	CALL	SSCHK
MOVS0:	LD	HL,(NPTR)
	LD	(NLAST),HL
MOVS1:	LD	HL,(TPP)	;MOVE SUBS TO NAKED PLACE
	LD	A,(HL)
	LD	(IT),A
	LD	HL,(NPTR)
	LD	(HL),A
	INC	HL
	LD	(NPTR),HL
	LD	DE,VAR
	CALL	JPEN
	JP	Z,E15
	LD	HL,(TPP)
	INC	HL
	LD	(TPP),HL
	LD	A,(IT)
	CP	DELIM
	JP	NZ,MOVS1
MOVS2:	LD	HL,NSUBS
	INC	(HL)
	LD	HL,I5
	DEC	(HL)
	LD	A,(I5)
	OR	A
	JP	NZ,MOVS0
	LD	HL,(NPTR)
	LD	(NSIZE),HL
	LD	DE,NREF		;GET SIZE OF NAKED ENTRYE
	CALL	PSUB
	LD	(NSIZE),HL
	LD	HL,NREF
	LD	A,(NMSZ)
	LD	C,A
	LD	B,0
	ADD	HL,BC
	LD	(TPP),HL
	LD	A,(NSUBS)	;SET # OF SUBS
	LD	(HL),A
	RET
;*
;*
RDROO:	;READ IN FIRST MAP BLOCK AND GET ROOT
	CALL	SSCHK
	LD	HL,GREC
	LD	DE,GZERO
	CALL	SETD
	CALL	GREAD		;READ IN FIRST BLOCK
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	DE,ROOT		;GET VALUE OF ROOT
	EX	DE,HL
	CALL	SETD
	LD	HL,(PTR)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(HL)		;GET SIZE OF MAP
	LD	(MAPSZ),A
	RET
;*
;*
SAVKE:	;SAVE KEY AND VALUE ON STACK
	CALL	SSCHK
	LD	HL,GRCY
	LD	DE,ROOT
	CALL	JDEN
	JP	Z,SAVK0
	LD	HL,GRCC3
	LD	B,3
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	POPIT
	LD	A,(A47)
	OR	A
	JP	Z,SAVK0
	LD	HL,(TOS)
	LD	(TRAIL),HL
SAVK0:	LD	HL,(PTR)	;SET SIZE OF NAME AND SUBS
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PPTR2),HL
	LD	(TPP),HL
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(TOS)	;SAVE NAME START
	LD	(SNMPT),HL
SAVK1:	LD	HL,(PTR)	;SAVE NAME AND SUBS ON STACK
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,(TPP)
	DEC	HL
	LD	(TPP),HL
	LD	DE,NULL
	CALL	JPEN
	JP	NZ,SAVK1
	LD	HL,(PTR)
	LD	A,(HL)
	LD	(SST),A
	CP	3
	JP	NZ,SAVK2
	INC	HL
	LD	(TPP),HL
	LD	A,(HL)		;GET STRING LENGTH
	LD	(SSLEN),A
SAVK2:	CALL	VALSZ		;GET SIZE OF VALUE
	LD	HL,(TPP)	;SAVE VALUE SIZE
	LD	(PPTR4),HL
	LD	HL,(TOS)	;SAVE VALUE START
	LD	(SVLPT),HL
SAVK3:	LD	HL,(PTR)	;SAVE VALUE AND TYPE
	LD	B,1
	CALL	PUSHT
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,(TPP)
	DEC	HL
	LD	(TPP),HL
	LD	DE,NULL
	CALL	JPEN
	JP	NZ,SAVK3
	LD	DE,GRCZ		;SAVE DOWN PTR
	LD	HL,(PTR)
	EX	DE,HL
	CALL	SETD
	LD	HL,(PTR)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(SVLPT)
	INC	HL
	LD	(SVLPT),HL
	LD	HL,GRCY
	LD	DE,ROOT
	CALL	JDEN
	JP	Z,SAVK4
	LD	HL,N
	LD	B,1
	CALL	PUSHT
	LD	HL,GRCC3
	LD	B,3
	CALL	PUSHT
SAVK4:	RET
;*
;*
;*
;*
SETGL:	;SET GLOBAL BUFFER POINTERS
	LD	HL,(GLBTA)	;TPP TO START OF GLOBAL TABLE
	LD	(TPP),HL
SETG1:	LD	A,(IT)
	OR	A
	JP	Z,SETG2
	LD	HL,(TPP)	;PTR TO NEXT ENTRY
	LD	DE,GBTSZ
	ADD	HL,DE
	LD	(TPP),HL
	LD	HL,IT
	DEC	(HL)
	JP	SETG1
SETG2:	LD	HL,(TPP)	;SET BLOCK NUMBER PTR
	LD	(GLBNO),HL
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(TPP),HL
	LD	(GLAGE),HL	;SET BUFFER AGE PTR
	INC	HL
	LD	(TPP),HL
	LD	(GLDRT),HL	;SET BUFFER DIRTY PTR
	INC	HL
	LD	(TPP),HL
	LD	(GLBUF),HL	;SET BUFFER START PTR
	RET
;*
;*
SETGV:	;SET GLOBAL VARIABLE
	CALL	SSCHK
	LD	HL,(PTR)
	LD	(PTR1),HL
STGV1:	LD	HL,(PTR)	;AT END?
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,NULL
	CALL	JPEN
	JP	Z,STGV2
	LD	HL,(PTR)	;SKIP NAME AND SUBS
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	CALL	VALSZ
	LD	HL,(TPP)	;PTR PAST VALUE
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,GVLEN	;PTR PAST DOWN PTR
	ADD	HL,DE
	LD	(PTR),HL
	JP	STGV1
STGV2:	LD	HL,(PTR)
	LD	(TPP),HL
	LD	HL,(PTR2)	;MOVE OVER NAME AND SUBS
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(PTR4)	;MOVE OVER VALUE SIZE
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,PTRLN+GVLEN	;PTR AT NEW END
	ADD	HL,DE
	LD	(PTR),HL
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	DEC	HL
	LD	(PTR),HL
STGV3:	LD	HL,(TPP)	;MOVE EVERYTHING AFTER PTR
	EX	DE,HL
	LD	HL,(PTR1)
	CALL	JPEN
	JP	Z,STGV4
	LD	HL,(TPP)
	DEC	HL
	LD	(TPP),HL
	LD	A,(HL)
	LD	HL,(PTR)
	LD	(HL),A
	DEC	HL
	LD	(PTR),HL
	JP	STGV3
STGV4:	LD	HL,(PTR2)	;SET SIZE OF NAME AND SUBS
	EX	DE,HL
	LD	HL,(PTR1)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR1)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR1),HL
	LD	HL,(PTR2)
	LD	(TPP),HL
	LD	HL,(NMPTR)
	LD	(BASE),HL
STGV5:	LD	HL,(NMPTR)	;SET NAME AND SUBS
	LD	A,(HL)
	LD	HL,(PTR1)
	LD	(HL),A
	INC	HL
	LD	(PTR1),HL
	LD	HL,(NMPTR)
	INC	HL
	LD	(NMPTR),HL
	LD	HL,(TPP)
	DEC	HL
	LD	(TPP),HL
	LD	DE,NULL
	CALL	JPEN
	JP	NZ,STGV5
	LD	HL,(PTR1)	;SET TYPE
	LD	A,(ST)
	LD	(HL),A
	INC	HL
	LD	(PTR1),HL
	LD	HL,(PTR4)
	LD	(TPP),HL
	CP	3
	JP	NZ,STGV6
	LD	A,(A47)
	OR	A
	JP	Z,STGV6
	LD	HL,(PTR1)	;SET STRING LENGTH
	LD	A,(SLENG)
	LD	(HL),A
	INC	HL
	LD	(PTR1),HL
	LD	HL,(TPP)
	DEC	HL
	LD	(TPP),HL
STGV6:	LD	HL,(TPP)
	DEC	HL
	LD	(TPP),HL
STGV7:	LD	HL,(TPP)
	LD	DE,NULL
	CALL	JPEN
	JP	Z,STGV8
	LD	HL,(VLPTR)	;SET VALUE
	LD	A,(HL)
	LD	HL,(PTR1)
	LD	(HL),A
	INC	HL
	LD	(PTR1),HL
	LD	HL,(VLPTR)
	INC	HL
	LD	(VLPTR),HL
	LD	HL,(TPP)
	DEC	HL
	LD	(TPP),HL
	JP	STGV7
STGV8:	LD	HL,(PTR1)	;SET DOWN PTR
	LD	DE,GRCX
	CALL	SETD
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	LD	HL,(PTR2)	;ADD ON NAME AND SUBS
	EX	DE,HL
	LD	HL,(BSIZE)
	ADD	HL,DE
	LD	(BSIZE),HL
	LD	HL,(PTR4)	;ADD ON VALUE SIZE
	EX	DE,HL
	LD	HL,(BSIZE)
	ADD	HL,DE
	LD	DE,PTRLN+GVLEN
	ADD	HL,DE
	LD	(BSIZE),HL
	EX	DE,HL
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	CALL	FINDM		;FIND MIDDLE ENTRY
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(PTR1)	;SET OFFSET TO MIDDLE
	EX	DE,HL
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(N)
	LD	(HL),A
	LD	HL,(GLDRT)
	LD	(HL),1
	RET
;*
;*
SETPT:	;MOVE PTR TO I'TH PLACE
	CALL	SSCHK
	LD	A,(N)
	LD	(I4),A
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	LD	HL,(PTR)
	LD	DE,PTRLN+PTRLN+GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	INC	HL		;PTR TO FIRST ITEM
	LD	(PTR),HL
SETP1:	LD	A,(I4)
	OR	A
	JP	Z,SETP2
	LD	HL,(PTR)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	CALL	VALSZ
	LD	HL,(TPP)	;PTR PAST VALUE
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,GVLEN	;PTR PAST DOWN PTR
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,I4
	DEC	(HL)
	JP	SETP1
SETP2:	RET
;*
;*
SETSE:	;SET PTRS FROM TEMP PTRS IN SAVKEY
	LD	HL,(PPTR2)
	LD	(PTR2),HL
	LD	HL,(PPTR4)
	LD	(PTR4),HL
	LD	HL,(SNMPT)
	LD	(NMPTR),HL
	LD	HL,(SVLPT)
	LD	(VLPTR),HL
	LD	A,(SST)
	LD	(ST),A
	LD	A,(SSLEN)
	LD	(SLENG),A
	RET
;*
;*
SHIFL:	;SHIFT ITEMS FROM LEFT PAGE TO UNDERFLOW
	CALL	SSCHK
	LD	HL,GREC
	LD	DE,GRECC
	CALL	SETD
	CALL	GREAD
	LD	A,(CN)
	LD	(N),A
	CALL	SETPT
	CALL	SQUAS
	LD	HL,GREC
	LD	DE,GRECA
	CALL	SETD
	CALL	GREAD
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN+PTRLN+SHTLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	DE,GRCX
	EX	DE,HL
	CALL	SETD
SHL0:	LD	HL,GREC
	LD	DE,GRECA
	CALL	SETD
	CALL	GREAD
	XOR	A
	LD	(N),A
	CALL	SETPT		;PTR TO START IN "A" NODE
	CALL	SETGV		;SET NEW ENTRY IN "A" NODE
	LD	HL,(TRAIL)
	LD	(TOS),HL
SHL1:	LD	HL,GREC
	LD	DE,GRECB
	CALL	SETD
	CALL	GREAD
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	CALL	G2END		;MOVE PTR TO END OF NODE "B"
	CALL	ENTSI
	LD	HL,(TPP)
	EX	DE,HL
	LD	HL,(BSIZE)
	CALL	PSUB
	LD	DE,PTRLN+PTRLN+SHTLN+GVLEN
	ADD	HL,DE
	LD	(BSIZE),HL
	LD	DE,BLKS2
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,SHL2
	LD	HL,(PTR)
	LD	(SPTR),HL
	LD	HL,N
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC
	LD	B,3
	CALL	PUSHT
	CALL	SAVKE
	LD	HL,GREC
	LD	B,3
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	POPIT
	LD	HL,GREC
	LD	DE,GRECA
	CALL	SETD
	CALL	GREAD		;MAKE UNDERFLOW PAGE CURRENT
	LD	HL,(GLBUF)	;PTR2 TO START OF BUFFER
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR2),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR2),HL
	LD	HL,(PPTR2)	;ADD IN NAME AND SUB SIZE
	EX	DE,HL
	LD	HL,(PTR2)
	ADD	HL,DE
	LD	(PTR2),HL
	LD	HL,(PPTR4)	;ADD IN VALUE SIZE
	EX	DE,HL
	LD	HL,(PTR2)
	ADD	HL,DE
	LD	DE,OVRHD
	ADD	HL,DE
	LD	(PTR2),HL
	LD	DE,BLKSZ	;SEE IF NEW ENTRY WILL FIT
	LD	A,E
	SUB	L
	LD	A,D
	SBC	A,H
	JP	C,SHL2
	LD	HL,GREC
	LD	DE,GRECB
	CALL	SETD
	CALL	GREAD		;MAKE PAGE TO LEFT CURRENT
	LD	HL,(SPTR)
	LD	(PTR),HL
	CALL	SQUAS
	CALL	SETSE
	JP	SHL0
SHL2:	LD	HL,GREC
	LD	DE,GRECB
	CALL	SETD
	CALL	GREAD
	CALL	G2END
	LD	HL,N
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC
	LD	B,3
	CALL	PUSHT
	LD	HL,(PTR)
	LD	(SPTR),HL
	CALL	SAVKE
	LD	HL,GREC
	LD	B,3
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	POPIT
	LD	HL,(SPTR)
	LD	(PTR),HL
	CALL	SQUAS
	LD	HL,GREC
	LD	DE,GRECA
	CALL	SETD
	CALL	GREAD
	XOR	A
	LD	(N),A
	CALL	SETPT
	LD	HL,(PTR)
	LD	BC,-(GVLEN)
	ADD	HL,BC
	LD	(PTR),HL
	LD	DE,GRCX		;SET IN SAVKEY
	CALL	SETD
	LD	HL,GRCX
	LD	DE,GRECA
	CALL	SETD
	LD	A,TRUE
	LD	(PASSU),A
	LD	HL,CN
	LD	B,1
	CALL	PUSHT
	LD	HL,GRECC
	LD	B,3
	CALL	PUSHT
	CALL	SETSE
	CALL	GLST2
	RET
;*
;*
SHIFR:	;SHIFT ITEMS FROM RIGHT PAGE TO UNDERFLOW
	CALL	SSCHK
	LD	HL,GREC
	LD	DE,GRECC
	CALL	SETD
	CALL	GREAD
	LD	A,(CN)
	LD	(N),A
	CALL	SETPT
	CALL	SQUAS
	LD	HL,GREC
	LD	DE,GRECA
	CALL	SETD
	CALL	GREAD
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR1),HL
	LD	(PTRX),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	LD	HL,(PTR1)
	LD	DE,PTRLN+PTRLN+GVLEN
	ADD	HL,DE
	LD	(PTR1),HL
	INC	HL		;PTR1 AT FIRST ENTRY
	LD	(PTR1),HL
	LD	HL,(BSIZE)	;PTR1 AFTER LAST ENTRY
	EX	DE,HL
	LD	HL,(PTR1)
	ADD	HL,DE
	LD	(PTR1),HL
	LD	HL,GREC
	LD	DE,GRECB
	CALL	SETD
	CALL	GREAD
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(SBSIZ),HL
	LD	HL,(PTR)
	LD	DE,PTRLN+PTRLN+GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	INC	HL		;PTR AT FIRST ENTRY
	LD	(PTR),HL
SHRT1:	CALL	ENTSI		;SET TPP TO ENTRY SIZE
	LD	HL,(BSIZE)
	LD	(PTR2),HL
	LD	HL,(TPP)	;GET PROPOSED NEW SIZE
	EX	DE,HL
	LD	HL,(PTR2)
	ADD	HL,DE
	LD	DE,OVRHD
	ADD	HL,DE
	LD	(PTR2),HL
	LD	DE,BLKSZ	;SEE IF IT FITS
	LD	A,E
	SUB	L
	LD	A,D
	SBC	A,H
	JP	C,SHRT2
	LD	HL,(TPP)
	EX	DE,HL
	LD	HL,(SBSIZ)
	CALL	PSUB
	LD	DE,PTRLN+PTRLN+SHTLN+GVLEN
	ADD	HL,DE
	LD	(SBSIZ),HL
	LD	DE,BLKS2
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,SHRT2
	LD	HL,(PTR)
	LD	(SPTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(TPP),HL
	CALL	MOVEN		;MOVE ENTRY FROM B TO A
	LD	HL,(PTR1)
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(SPTR)
	LD	(PTR),HL
	LD	HL,PTR1
	LD	B,2
	CALL	PUSHT
	LD	HL,BSIZE
	LD	B,2
	CALL	PUSHT
	CALL	SQUAS
	LD	HL,BSIZE
	LD	B,2
	CALL	POPIT
	LD	HL,PTR1
	LD	B,2
	CALL	POPIT
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(SPTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(SBSIZ),HL
	JP	SHRT1
SHRT2:	LD	HL,(BSIZE)
	EX	DE,HL
	LD	HL,(PTRX)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,N
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC
	LD	B,3
	CALL	PUSHT
	LD	HL,(PTR)
	LD	(SPTR),HL
	CALL	SAVKE
	LD	HL,(SPTR)
	LD	(PTR),HL
	LD	HL,GREC
	LD	B,3
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	POPIT
	CALL	SQUAS
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN+PTRLN+SHTLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	DE,GRCX
	CALL	SETD
	LD	HL,GRCX
	LD	DE,GRECB
	CALL	SETD
	LD	A,TRUE
	LD	(PASSU),A
	LD	HL,CN
	LD	B,1
	CALL	PUSHT
	LD	HL,GRECC
	LD	B,3
	CALL	PUSHT
	CALL	SETSE
	CALL	GLST2
	RET
;*
;*
SNAKD:	;SET NAKED REF NAME
	CALL	SSCHK
	LD	A,(NLENG)
	LD	(COUNT),A
	LD	(NMSZ),A
	LD	HL,COUNT
	INC	(HL)
	LD	HL,(NAME)
	EX	DE,HL
	LD	HL,NREF
	LD	A,(COUNT)
	LD	B,A
	CALL	MOVE
	XOR	A
	LD	(NSUBS),A
	LD	HL,NREF
	LD	(NLAST),HL
	LD	A,(COUNT)
	LD	L,A
	LD	H,0
	LD	(NSIZE),HL
	EX	DE,HL
	LD	HL,(NLAST)
	ADD	HL,DE
	LD	(NLAST),HL
	LD	(NPTR),HL
	XOR	A
	LD	(NR),A
	RET
;*
;*
SPLIT:	;SPLIT BUFFER AND PASS UP MIDDLE ENTRY
	CALL	SSCHK
	LD	A,TRUE
	LD	(SPLT),A
	LD	HL,GRCY
	LD	DE,GREC
	CALL	SETD
	LD	HL,(PTR)	;SAVE ENTRY POINT
	LD	(PTR7),HL
	LD	A,(N)
	LD	(INN),A
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR8),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(SBSIZ),HL
	LD	HL,(PTR8)	;PTR TO MIDDLE POINTER
	LD	DE,PTRLN+PTRLN+SHTLN+GVLEN
	ADD	HL,DE
	LD	(PTR8),HL
	LD	HL,(SBSIZ)	;PTR8 TO END OF USED SPACE
	EX	DE,HL
	LD	HL,(PTR8)
	ADD	HL,DE
	LD	(PTR8),HL
	LD	HL,GRCC1	;GRCC1 WILL BE NODE INSERTING INTO
	LD	DE,GREC
	CALL	SETD
	LD	HL,GRCC2	;GRCC2 IS THE OLD NODE
	LD	DE,GREC
	CALL	SETD
	CALL	ALLOC		;GREC IS THE NEW NODE
	CALL	FNDOL		;GET BUFFER SPACE
	LD	HL,GRECA
	LD	DE,GREC
	CALL	SETD
	LD	A,(A47)
	CP	1
	JP	Z,SPTC
	LD	HL,GRCY		;IF AT ROOT, IT'S OK
	LD	DE,ROOT
	CALL	JDEN
	JP	Z,SPTC
SPTE:	LD	HL,(TRAIL)	;GET START OF ENTRY
	LD	(PTRA),HL
	LD	(PTRB),HL
	LD	HL,(PTRA)	;PTRA TO ANCESTOR BLOCK
	LD	BC,-(GVLEN)
	ADD	HL,BC
	LD	(PTRA),HL
	LD	DE,TGREC	;SAVE IT
	EX	DE,HL
	CALL	SETD
	LD	HL,(PTRA)	;PTRA TO LOCATION IN BLOCK
	DEC	HL
	LD	(PTRA),HL
	LD	A,(HL)		;SAVE IT
	LD	(TN),A
SPTA:	LD	HL,(PTRB)
	EX	DE,HL
	LD	HL,(TOS)
	CALL	JPEN
	JP	Z,SPTB
	LD	HL,(PTRB)	;MOVE TO  ITEM DOWN
	LD	A,(HL)
	LD	HL,(PTRA)
	LD	(HL),A
	INC	HL
	LD	(PTRA),HL
	LD	HL,(PTRB)
	INC	HL
	LD	(PTRB),HL
	JP	SPTA
SPTB:	LD	HL,(PTRA)	;SHIFT LOCATION IN BLOCK AND
	LD	A,(TN)
	LD	(HL),A
	INC	HL
	LD	(PTRA),HL
	LD	DE,TGREC	;ANCESTOR BLOCK TO TOS
	CALL	SETD
	LD	HL,(NMPTR)	;ADJUST NMPTR AND
	LD	BC,-(GVLEN+SHTLN)
	ADD	HL,BC
	LD	(NMPTR),HL
	LD	HL,(VLPTR)	;VLPTR
	LD	BC,-(GVLEN+SHTLN)
	ADD	HL,BC
	LD	(VLPTR),HL
	LD	HL,(TRAIL)
	LD	BC,-(GVLEN+SHTLN)
	ADD	HL,BC
	LD	(TRAIL),HL
	LD	HL,TGREC
	LD	DE,ROOT
	CALL	JDEN
	JP	Z,SPTC
	LD	A,(FRMDE)
	CP	FALSE
	JP	Z,SPTC
	LD	HL,TGREC
	LD	B,3
	CALL	POPIT
	LD	HL,TN
	LD	B,1
	CALL	POPIT
	LD	HL,TGREC
	LD	DE,GRCY
	CALL	JDEN
	JP	NZ,SPTE
	LD	A,FALSE
	LD	(FRMKL),A
	JP	SPTE
SPTC:	LD	A,FALSE
	LD	(FRMKL),A
	LD	(FRMDE),A
	LD	HL,GREC
	LD	DE,GRCC2
	CALL	SETD
	CALL	GREAD		;MAKE SPLITTING NODE CURRENT
	LD	HL,PTR2
	LD	B,2
	CALL	PUSHT
	LD	HL,PTR4
	LD	B,2
	CALL	PUSHT
	CALL	G2END
	LD	HL,PTR4
	LD	B,2
	CALL	POPIT
	LD	HL,PTR2
	LD	B,2
	CALL	POPIT
	LD	A,(N)		;WILL MAKE MALFORMED TREE
	CP	1
	JP	Z,E8
	LD	A,(N)
	OR	A
	RRA			;N/2
	LD	(N),A
	CALL	SETPT		;PUT PTR AT "MIDDLE"
	LD	HL,(PTR)
	LD	(PTR9),HL
	XOR	A
	LD	(I9),A
	LD	HL,(PTR7)
	EX	DE,HL
	LD	HL,(PTR)
	CALL	JPEN
	JP	NZ,SPT0
	LD	A,1		;PASSING NEW ENTRY UP
	LD	(I9),A
	LD	HL,GRCZ		;FIRST DOWN PTR OF NEW BLOCK
	LD	DE,GRCX
	CALL	SETD
	JP	SPT2
SPT0:	LD	HL,(PTR)
	EX	DE,HL
	LD	HL,(PTR7)
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,SPTZ
	LD	HL,GRCC1	;SET NODE INSERTING INTO
	LD	DE,GRECA
	CALL	SETD
	LD	A,(INN)
	LD	HL,N
	SUB	(HL)
	LD	(INN),A
	LD	HL,INN
	DEC	(HL)
	JP	SPT1
SPTZ:	LD	HL,N		;BACK UP ONE ENTRY
	DEC	(HL)
	CALL	SETPT
	LD	HL,(PTR)	;PUT PTR9 THERE TOO
	LD	(PTR9),HL
SPT1:	CALL	SAVKE		;SAVE KEY ON STACK AND SET PTRS AND SIZES
	LD	HL,(PPTR2)
	EX	DE,HL
	LD	HL,(SBSIZ)
	CALL	PSUB
	LD	(SBSIZ),HL
	LD	HL,(PPTR4)
	EX	DE,HL
	LD	HL,(SBSIZ)
	CALL	PSUB
	LD	BC,-(GVLEN+PTRLN)
	ADD	HL,BC
	LD	(SBSIZ),HL
SPT2:	LD	HL,(USTAK)	;SAVE OFFSET ON SPLIT STACK
	LD	A,(INN)
	LD	(HL),A
	INC	HL
	LD	(USTAK),HL
	LD	DE,GRCC1
	CALL	SETD
	LD	HL,(USTAK)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(USTAK),HL
	LD	HL,(PTR8)	;CALCULATE BUFFER SIZES USED
	LD	(LAST),HL
	LD	HL,(PTR)
	EX	DE,HL
	LD	HL,(LAST)
	CALL	PSUB
	LD	(LAST),HL
	EX	DE,HL
	LD	HL,(SBSIZ)
	CALL	PSUB
	LD	(SBSIZ),HL
	LD	HL,GREC
	LD	DE,GRECA
	CALL	SETD
	CALL	GREAD
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR1),HL
	LD	HL,(LAST)	;SET NEW NODE SIZE USED
	EX	DE,HL
	LD	HL,(PTR1)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR1)
	LD	DE,PTRLN+PTRLN
	ADD	HL,DE
	INC	HL
	LD	(PTR1),HL
	LD	DE,GRCZ		;SET FIRST PTR
	CALL	SETD
	LD	HL,(PTR1)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR1),HL
SPT3:	LD	HL,(PTR)
	EX	DE,HL
	LD	HL,(PTR7)
	CALL	JPEN
	JP	NZ,SPT4
	LD	HL,(PTR1)	;MOVE INSERT PLACE TO NEW NODE
	LD	(PTR7),HL
SPT4:	LD	HL,(PTR)	;MOVE REST OF BLOCK TO NEW NODE
	EX	DE,HL
	LD	HL,(PTR8)
	CALL	JPEN
	JP	Z,SPT5
	LD	HL,(PTR)
	LD	A,(HL)
	LD	HL,(PTR1)
	LD	(HL),A
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	LD	HL,(PTR1)
	INC	HL
	LD	(PTR1),HL
	JP	SPT3
SPT5:	LD	HL,(PTR1)
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR9)
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,GRCC3
	LD	DE,GREC
	CALL	SETD
	CALL	FINDM		;GET MIDDLE OF NEW NODE
	LD	HL,(GLDRT)
	LD	(HL),1
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(PTR1)	;SET MIDDLE OFFSET
	EX	DE,HL
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(N)
	LD	(HL),A
	LD	HL,GREC
	LD	DE,GRCC2
	CALL	SETD
	CALL	GREAD		;MAKE OLD NODE CURRENT
	LD	HL,(GLDRT)
	LD	(HL),1
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	HL,(SBSIZ)	;SET SIZE
	EX	DE,HL
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	CALL	FINDM
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(PTR1)	;SET MIDDLE OFFSET
	EX	DE,HL
	LD	HL,(PTR)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(PTR)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	LD	A,(N)
	LD	(HL),A
	LD	A,(I9)
	CP	1
	JP	Z,SPT6
	LD	HL,GREC		;GET NODE INSERTING IN
	LD	DE,GRCC1
	CALL	SETD
	CALL	GREAD
	LD	HL,(PTR7)	;PUT PTR IN RIGHT PLACE
	LD	(PTR),HL
	CALL	SETGV		;SET NEW VALUE
	LD	A,(A47)
	CP	1
	JP	Z,SPT60
	LD	HL,(BASE)	;GET BASE OF JUST SET VARIABLE
	LD	(PTR1),HL
	LD	HL,(VLPTR)
	LD	(PTR),HL
	LD	(TPP),HL
	LD	HL,(BASE)	;GET SIZE OF JUST SET VARIABLE
	EX	DE,HL
	LD	HL,(TPP)
	CALL	PSUB
	LD	(TPP),HL
SPT55:	LD	HL,(PTR)	;SEE IF IT'S ALL MOVED
	EX	DE,HL
	LD	HL,(TOS)
	CALL	JPEN
	JP	Z,SPT57
	LD	HL,(PTR)	;MOVE A CHARACTER
	LD	A,(HL)
	LD	HL,(PTR1)
	LD	(HL),A
	INC	HL
	LD	(PTR1),HL
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	JP	SPT55
SPT57:	LD	A,(A47)
	OR	A
	JP	Z,SPT59
	LD	HL,(TPP)	;ADJUST TRAIL PTR DOWN
	EX	DE,HL
	LD	HL,(TRAIL)
	CALL	PSUB
	LD	(TRAIL),HL
SPT59:	LD	HL,(TPP)	;ADJUST SNMPT PTR DOWN
	EX	DE,HL
	LD	HL,(SNMPT)
	CALL	PSUB
	LD	(SNMPT),HL
	LD	HL,(TPP)	;ADJUST SVLPT PTR DOWN
	EX	DE,HL
	LD	HL,(SVLPT)
	CALL	PSUB
	LD	(SVLPT),HL
	LD	HL,(PTR1)	;SHIFT TOS DOWN
	LD	(TOS),HL
SPT60:	LD	A,TRUE
	LD	(PASSU),A
	CALL	SETSE
	XOR	A
	LD	(A47),A
SPT6:	LD	HL,GRCX
	LD	DE,GRCC3
	CALL	SETD
	LD	HL,GREC
	LD	DE,GRCY
	CALL	SETD
	RET
;*
;*
SQUAS:	;DELETE ENTRY POINTED TO BY PTR
	CALL	SSCHK
	LD	HL,PTR2
	LD	B,2
	CALL	PUSHT
	LD	HL,PTR4
	LD	B,2
	CALL	PUSHT
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR5),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(BSIZE),HL
	LD	HL,(PTR5)
	LD	DE,PTRLN+PTRLN+GVLEN
	ADD	HL,DE
	INC	HL
	LD	(PTR5),HL
	LD	HL,(BSIZE)	;PTR AT END
	EX	DE,HL
	LD	HL,(PTR5)
	ADD	HL,DE
	LD	(PTR5),HL
	LD	HL,(PTR)
	LD	(LAST),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR2),HL
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,PTRLN	;PTR AT TYPE
	ADD	HL,DE
	LD	(PTR),HL
	CALL	VALSZ
	LD	HL,(TPP)
	LD	(PTR4),HL
	EX	DE,HL		;TO DOWN PTR
	LD	HL,(PTR)
	ADD	HL,DE
	LD	(PTR),HL
	LD	DE,GRCX		;SAVE DOWN PTR
	EX	DE,HL
	CALL	SETD
	LD	HL,(PTR)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(PTR),HL
	LD	HL,(LAST)
	LD	(TPP),HL
	LD	HL,(PTR2)	;GET SIZE OF ENTRY DELETED
	EX	DE,HL
	LD	HL,(PTR4)
	ADD	HL,DE
	LD	DE,GVLEN+PTRLN
	ADD	HL,DE
	LD	(PTR4),HL
	LD	HL,(TPP)
	LD	(PTR2),HL
SQ4:	LD	HL,(PTR5)
	EX	DE,HL
	LD	HL,(PTR)
	CALL	JPEN
	JP	Z,SQ5
	LD	HL,(PTR)	;SHIFT EVERYTHING DOWN
	LD	A,(HL)
	LD	HL,(LAST)
	LD	(HL),A
	INC	HL
	LD	(LAST),HL
	LD	HL,(PTR)
	INC	HL
	LD	(PTR),HL
	JP	SQ4
SQ5:	LD	HL,(LAST)
	LD	DE,NULL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(TPP),HL
	LD	HL,(PTR4)
	EX	DE,HL
	LD	HL,(BSIZE)
	CALL	PSUB
	LD	(BSIZE),HL
	EX	DE,HL
	LD	HL,(TPP)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	CALL	FINDM
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(TPP),HL
	LD	HL,(PTR1)
	EX	DE,HL
	LD	HL,(TPP)
	LD	(HL),E
	INC	HL
	LD	(HL),D
	LD	HL,(TPP)
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(TPP),HL
	LD	A,(N)
	LD	(HL),A
	LD	HL,(PTR2)
	LD	(PTR),HL
	LD	HL,(GLDRT)
	LD	(HL),1
	LD	HL,PTR4
	LD	B,2
	CALL	POPIT
	LD	HL,PTR2
	LD	B,2
	CALL	POPIT
	RET
;*
;*
UNDER:	;FIX UP NODE THAT'S TOO SMALL
	CALL	SSCHK
	LD	A,FALSE
	LD	(SPLT),A
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(SBSIZ),HL
	LD	HL,GRECA	;SAVE UNDERFLOW PAGE
	LD	DE,GREC
	CALL	SETD
	XOR	A
	LD	(I2),A
	LD	HL,GREC		;GET PARENT
	LD	B,3
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	POPIT
	LD	HL,(TOS)
	LD	(TRAIL),HL
	LD	HL,GRECC	;SAVE PARENT PAGE
	LD	DE,GREC
	CALL	SETD
	LD	A,(N)
	LD	(CN),A
	CALL	GREAD
	CALL	SETPT		;MOVE TO PLACE
	LD	HL,(PTR)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,NULL
	CALL	JPEN
	JP	NZ,UNDF0
	LD	A,1
	LD	(I2),A
	LD	HL,N
	DEC	(HL)
	LD	HL,CN
	DEC	(HL)
	CALL	SETPT
UNDF0:	LD	HL,(PTR)
	LD	(SPTR),HL
	LD	BC,-(GVLEN)
	ADD	HL,BC
	LD	(PTR2),HL
	LD	HL,N
	LD	B,1
	CALL	PUSHT
	LD	HL,GREC
	LD	B,3
	CALL	PUSHT
	CALL	SAVKE
	LD	HL,GREC
	LD	B,3
	CALL	POPIT
	LD	HL,N
	LD	B,1
	CALL	POPIT
	LD	HL,(SPTR)
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,PTRLN
	ADD	HL,DE
	LD	(PTR),HL
	CALL	VALSZ
	LD	HL,(TPP)
	EX	DE,HL
	LD	HL,(PTR)
	ADD	HL,DE
	LD	(PTR),HL
	LD	(PTR1),HL	;SAVE PLACE
	LD	DE,GVLEN	;SKIP PAST ENTRY
	ADD	HL,DE
	LD	(PTR),HL
	XOR	A
	LD	(I3),A
	LD	A,(I2)
	OR	A
	JP	NZ,UNDF1
	LD	DE,GRECB	;GET NODE TO RIGHT OF UNDERFLOW
	LD	HL,(PTR1)
	EX	DE,HL
	CALL	SETD
	JP	UNDF2
UNDF1:	LD	DE,GRECB	;GET NODE TO LEFT OF UNDERFLOW
	LD	HL,(PTR2)
	EX	DE,HL
	CALL	SETD
	LD	A,1		;IT'S THE LEFT NODE
	LD	(I3),A
UNDF2:	LD	HL,GREC
	LD	DE,GRECB
	CALL	SETD
	CALL	GREAD		;READ SIBLING (RIGHT OR LEFT)
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(TPP),HL
	LD	(PTR1),HL
	LD	HL,(SBSIZ)
	EX	DE,HL
	LD	HL,(TPP)
	ADD	HL,DE
	LD	DE,OVRHD
	ADD	HL,DE
	LD	(TPP),HL
	CALL	SETSE
	LD	HL,(PTR2)
	EX	DE,HL
	LD	HL,(TPP)
	ADD	HL,DE
	LD	(TPP),HL
	LD	HL,(PTR4)
	EX	DE,HL
	LD	HL,(TPP)
	ADD	HL,DE
	LD	(TPP),HL
	XOR	A		;DO A MERGE
	LD	(I2),A
	LD	DE,BLKSZ
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,UNDF3
	LD	A,1		;DO A MOVE
	LD	(I2),A
	LD	HL,(PTR1)
	LD	DE,BLKS2
	EX	DE,HL
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,UNDF3
	LD	A,FALSE
	LD	(UF),A
	JP	UNDF8
UNDF3:	LD	A,(I3)		;DO LEFT
	CP	1
	JP	Z,UNDF5
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	DE,PTRLN+PTRLN
	ADD	HL,DE
	INC	HL
	LD	(PTR),HL
	LD	DE,GRCX
	EX	DE,HL
	CALL	SETD
	LD	HL,GREC
	LD	DE,GRECA
	CALL	SETD
	CALL	GREAD
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,(PTR)
	ADD	HL,DE
	LD	DE,PTRLN+PTRLN+GVLEN+SHTLN
	ADD	HL,DE
	LD	(PTR),HL
	CALL	SETGV
	LD	HL,(TRAIL)
	LD	(TOS),HL
	LD	A,(I2)
	OR	A
	JP	Z,UNDF4
	CALL	SHIFR
	JP	UNDF7
UNDF4:	CALL	MERGR
	JP	UNDF7
UNDF5:	LD	A,(I2)
	OR	A
	JP	Z,UNDF6
	CALL	SHIFL
	JP	UNDF7
UNDF6:	CALL	MERGL
UNDF7:	LD	HL,GREC
	LD	DE,GRECC
	CALL	SETD
	CALL	GREAD
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
	LD	(PTR),HL
	LD	A,FALSE
	LD	(UF),A
	LD	A,(SPLT)
	CP	TRUE
	JP	Z,UNDF8
	LD	HL,(PTR)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,BLKS2
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,UNDF8
	LD	A,TRUE
	LD	(UF),A
	LD	HL,(TRAIL)
	LD	(TOS),HL
	LD	HL,CN
	LD	B,1
	CALL	PUSHT
	LD	HL,GRECC
	LD	B,3
	CALL	PUSHT
	LD	HL,(TOS)
	LD	(TRAIL),HL
	CALL	FIXTR
UNDF8:	RET
;*
;*
UPDRE:	;UPDATE BUFFER AGES
	LD	HL,(GLAGE)
	LD	A,(HL)
	LD	(IT),A
	LD	HL,(GLBTA)
	LD	DE,GVLEN
	ADD	HL,DE
	LD	(TPP),HL
	XOR	A
	LD	(I1),A
UPDR1:	LD	HL,(TPP)	;LEAVE ALONE
	LD	A,(IT)
	CP	(HL)
	JP	C,$+6
	JP	NZ,UPDR3
	CP	(HL)		;UPDATE
	JP	NZ,UPDR2
	LD	A,(NGBUF)
	LD	(HL),A
UPDR2:	LD	HL,(TPP)
	DEC	(HL)
UPDR3:	LD	HL,I1
	INC	(HL)
	LD	HL,(TPP)	;MOVE TO NEXT ENTRY
	LD	DE,GBTSZ
	ADD	HL,DE
	LD	(TPP),HL
	LD	A,(I1)
	LD	HL,NGBUF
	CP	(HL)
	JP	NZ,UPDR1
	RET
;*
;*
VALSZ:	;GET SIZE OF VALUE
	LD	HL,(PTR)
	LD	(TPP),HL
	LD	A,(HL)
	LD	(I1),A
VAL2:	LD	A,(I1)		;STRING
	CP	3
	JP	NZ,VALA
VAL25:	LD	HL,(TPP)
	INC	HL
	LD	(TPP),HL
	LD	A,(HL)
	LD	(I1),A
	LD	L,A
	LD	H,0
	INC	HL
	LD	(TPP),HL
	JP	VAL4
VALA:	LD	A,(I1)
	CP	7
	JP	Z,VAL25
	XOR	A
	LD	(I1),A
VAL3:	LD	A,(I1)
	LD	L,A
	LD	H,0
	LD	(TPP),HL
VAL4:	LD	HL,(TPP)
	INC	HL
	LD	(TPP),HL
	RET
;*
;*        END OF TDL UTILITY ROUTINES
GTCOM:	LD	A,(TOKEN)	;GET TOKEN VALUE
	CP	2
	JP	NZ,E5
	LD	D,1		;INITIALIZE CHARACTER COUNT
	LD	HL,(INDX)
	CALL	SSCHK
	PUSH	HL		;SAVE COMMAND START
GET2:	CALL	GTOKN		;GET NEXT TOKEN
	LD	A,(TOKEN)
	CP	2
	JP	NZ,GET3
	INC	D		;INCREMENT COUNT
	JP	GET2
GET3:	XOR	A		;RESET FLAG FOR Z COMMANDS
	LD	(I0),A
	POP	HL
	LD	A,(HL)
	CP	'Z'		;SEE IF Z COMMAND
	JP	NZ,GET31
	INC	HL		;MOVE PAST 'Z'
	DEC	D
	LD	A,1
	LD	(I0),A		;SET Z FLAG
GET31:	LD	C,D
	LD	A,(I0)
	OR	A
	LD	A,(FNC)
	JP	Z,GET34	;CHECK Z FLAG
	CP	0		;CHECK FUNCTION FLAG
	JP	NZ,GET32
	LD	DE,ZCOMM	;Z COMMANDS--NO $
	JP	GET37
GET32:	CP	1
	JP	NZ,GET33
	LD	DE,ZFUNC	;Z COMMAND--$ FUNCTION
	JP	GET37
GET33:	LD	DE,ZSPEC	;Z COMMAND--$ SPECIAL VARIABLE
	JP	GET37
GET34:	CP	0		;CHECK FUNCTION FLAG
	JP	NZ,GET35
	LD	DE,COMMS	;REGULAR COMMANDS
	JP	GET37
GET35:	CP	1
	JP	NZ,GET36
	LD	DE,FUNCS	;$ FUNCTIONS
	JP	GET37
GET36:	LD	DE,SPECS	;$ SPECIAL VARIABLES
GET37:	LD	A,C
	CP	1
	JP	Z,GET9		;IT'S A 1 CHARACTER COMMAND
GET4:	PUSH	HL
	LD	A,(DE)
	CP	CR		;CHECK FOR END OF COMMAND TABLE
	JP	Z,E5
	LD	B,A
	CP	C		;COMPARE LENGTHS
	JP	NZ,GET75
	INC	DE
	LD	B,C
GET6:	LD	A,(DE)
	CP	(HL)		;COMPARE LETTERS
	JP	NZ,GET8
	INC	HL
	INC	DE
	DEC	B
	JP	NZ,GET6
	POP	HL		;IT'S A MATCH
GET7:	LD	A,(FNC)		;CHECK FUNCTION FLAG
	CP	1
	JP	NZ,GET73
	CALL	GTOKN
GET73:	LD	A,(DE)
	LD	L,A
	INC	DE
	LD	A,(DE)
	LD	H,A
	XOR	A
	LD	(LOCKS),A
	JP	(HL)
GET75:	INC	DE
GET8:	INC	DE		;NO MATCH--TRY NEXT ENTRY
	DEC	B
	JP	NZ,GET8
	INC	DE
	INC	DE
	POP	HL
	JP	GET4
GET9:	LD	A,(DE)		;TRY FIRST CHARACTER MATCHES
	LD	B,A
	CP	CR
	JP	Z,E5
	LD	B,A
	INC	DE
	LD	A,(DE)
	CP	(HL)
	JP	NZ,GET12
GET11:	INC	DE		;GET LOCATION
	DEC	B
	JP	NZ,GET11
	JP	GET7
GET12:	INC	DE		;MOVE TO NEXT COMMAND
	DEC	B
	JP	NZ,GET12
	INC	DE
	INC	DE
	JP	GET9
;
;
COMMS:	DEFB	3,'SET'
	DEFW	TES
	DEFB	2,'IF'
	DEFW	FI
	DEFB	4,'ELSE'
	DEFW	ELSE
	DEFB	3,'FOR'
	DEFW	FOR
	DEFB	2,'DO'
	DEFW	DO
	DEFB	4,'GOTO'
	DEFW	GOTO
	DEFB	5,'WRITE'
	DEFW	WRITE
	DEFB	4,'READ'
	DEFW	READ
	DEFB	4,'KILL'
	DEFW	KILL
	DEFB	4,'LOCK'
	DEFW	LOCK
	DEFB	3,'USE'
	DEFW	USE
	DEFB	6,'XECUTE'
	DEFW	XECUT
	DEFB	5,'CLOSE'
	DEFW	CLOSE
	DEFB	4,'OPEN'
	DEFW	OPEN
	DEFB	4,'QUIT'
	DEFW	QUIT
	DEFB	1,'H'
	DEFW	HS
	DEFB	4,'HANG'
	DEFW	HANG
	DEFB	5,'BREAK'
	DEFW	BREAK
	DEFB	4,'HALT'
	DEFW	HALT
	DEFB	4,'VIEW'
	DEFW	VIEWS
	DEFB	CR
;
;
FUNCS:	DEFB	5,'ASCII'
	DEFW	ASCII
	DEFB	4,'CHAR'
	DEFW	CHAR
	DEFB	4,'DATA'
	DEFW	DATA
	DEFB	7,'EXTRACT'
	DEFW	EXTRA
	DEFB	4,'FIND'
	DEFW	FIND
	DEFB	7,'JUSTIFY'
	DEFW	JUSTI
	DEFB	6,'LENGTH'
	DEFW	LENGT
	DEFB	4,'NEXT'
	DEFW	NEXT
	DEFB	5,'ORDER'
	DEFW	ORDER
	DEFB	5,'PIECE'
	DEFW	PIECE
	DEFB	6,'RANDOM'
	DEFW	RANDO
	DEFB	6,'SELECT'
	DEFW	SELEC
	DEFB	4,'TEXT'
	DEFW	TEXT
	DEFB	4,'VIEW'
	DEFW	VIEW
	DEFB	CR
;
;
SPECS:	DEFB	7,'HOROLOG'
	DEFW	HOROL
	DEFB	2,'IO'
	DEFW	IO
	DEFB	3,'JOB'
	DEFW	JOB
	DEFB	7,'STORAGE'
	DEFW	STORA
	DEFB	4,'TEST'
	DEFW	TEST
	DEFB	1,'X'
	DEFW	X
	DEFB	1,'Y'
	DEFW	Y
	DEFB	CR
;
;
ZCOMM:	DEFB	4,'SAVE'
	DEFW	ZSAVE
	DEFB	4,'LOAD'
	DEFW	ZLOAD
	DEFB	5,'PRINT'
	DEFW	ZPRIN
	DEFB	6,'DELETE'
	DEFW	ZDELE
	DEFB	6,'REMOVE'
	DEFW	ZREMO
	DEFB	4,'MOVE'
	DEFW	ZMOVE
	DEFB	2,'GO'
	DEFW	ZGO
	DEFB	6,'INSERT'
	DEFW	ZINSE
	DEFB	6,'OPTION'
	DEFW	ZOPTI
	DEFB	4,'CALL'
	DEFW	ZCALL
	DEFB	3,'ARG'
	DEFW	ZARG
	DEFB	CR
;
;
ZSPEC:	DEFB	4,'NAME'
	DEFW	ZNAME
	DEFB	CR
;
;
ZFUNC:	DEFB	3,'ARG'
	DEFW	ZGRA
	DEFB	CR
;
;
;
GTOKN:	CALL	SSCHK
	PUSH	HL		;SAVE REGISTERS
	PUSH	DE
	PUSH	BC
	CALL	INCHK		;SEE IF A CHARACTER
	LD	HL,(INDX)	;GET ACTUAL CHARACTER
	INC	HL
	LD	(INDX),HL
	LD	A,127		;SEE IF LEGAL CHAR
	CP	(HL)
	JP	NC,GTOK0
	XOR	A
	JP	GTOK1
GTOK0:	LD	C,(HL)
	LD	B,0
	LD	HL,TKTBL	;FIND IT IN THE TABLE
	ADD	HL,BC
	LD	A,(HL)
GTOK1:	LD	(TOKEN),A
	POP	BC		;RESTORE REGISTERS
	POP	DE
	POP	HL
	RET
;
;
TKTBL:	DEFB	40,50,50,50,50,50,50,50,50,37
	DEFB	38,50,39,50,50,50,50,50,50,50
	DEFB	50,50,50,50,50,50,50,50,50,50
	DEFB	50,50,31,12,23,09,27,19,11,04
	DEFB	25,26,07,05,21,06,28,08,03,03
	DEFB	03,03,03,03,03,03,03,03,22,29
	DEFB	13,17,14,30,24,02,02,02,02,02
	DEFB	02,02,02,02,02,02,02,02,02,02
	DEFB	02,02,02,02,02,02,02,02,02,02
	DEFB	02,15,10,16,20,18,32,01,01,01
	DEFB	01,01,01,01,01,01,01,01,01,01
	DEFB	01,01,01,01,01,01,01,01,01,01
	DEFB	01,01,01,35,33,36,34,50
;
;
CKCHR:	LD	A,FALSE
	LD	(RESUL),A
	LD	L,3		;SEE IF A CHARACTER
	CALL	BIOS
	OR	A
	RET	Z
;
	LD	L,6
	CALL	BIOS
	LD	(CHR),A
	LD	A,TRUE
	LD	(RESUL),A
	RET
;
;
INCHK:	LD	L,3		;SEE IF A CHARACTER
	CALL	BIOS
	OR	A
	RET	Z		;RETURN IF NOTHING
;
	LD	L,6		;GET CHARACTER
	CALL	BIOS
;
	CP	CTRLC
	JP	Z,ERR25	;RESTART IF CONTROL-C
;
	CP	CTRLP
	JP	NZ,INCK1
	LD	A,(PTOGL)	;FLIP PRINT TOGGLE
	XOR	1
	LD	(PTOGL),A
	RET
;
INCK1:	CP	CTRLS
	RET	NZ		;IGNORE ALL OTHERS
	LD	A,1		;SET STOP TOGGLE
	LD	(STOGL),A
	RET
;
;
ERROR:	LD	HL,(SSTK)
	LD	SP,HL
	PUSH	AF
	CALL	CRLF
	LD	A,(MODE)	;SEE IF DIRECT MODE
	OR	A
	JP	NZ,ERR2		;IF DIRECT, DON'T WRITE OUT LBUFF
	LD	HL,(LBUFF)
ERR0:	LD	A,(HL)		;GET CHAR FROM LINE EXECUTION BUFFER
	CP	EOL		;SEE IF AT END
	JP	Z,ERR1
	PUSH	HL
	CALL	TRMOT		;WRITE OUT CHAR
	POP	HL
	INC	HL
	JP	ERR0
ERR1:	CALL	CRLF
ERR2:	POP	AF
	LD	(I1),A
	LD	DE,ERFCB
	LD	C,15
	CALL	BDOS		;OPEN ERROR MSG FILE
;
	CP	255		;SEE IF ERROR MSG FILE PRESENT
	LD	A,(I1)		;RELOAD ERROR NUMBER
	JP	NZ,ERR22	;JUMP IF FILE PRESENT
;
	LD	HL,ERRMS+5	;JUST WRITE OUT ERROR NUMBER
	LD	(HL),'0'-1
ERR21:	INC	(HL)
	SUB	10
	JP	NC,ERR21
	ADD	A,10+'0'
	INC	HL
	LD	(HL),A
	LD	HL,ERRMS	;GET READY TO WRITE IT
	JP	ERR23
ERR22:	RLCA
	LD	E,A		;SAVE ERROR NUMBER
	LD	D,0
	LD	HL,ERRS
	ADD	HL,DE		;GET OFFSET TO ERROR MESSAGE
	LD	E,(HL)		;MSG START WITHIN SECTOR TO E
	INC	HL
	LD	D,(HL)		;SECTOR NUMBER TO D
	PUSH	DE		;AND SAVE IT
	LD	DE,80H		;DEFAULT BUFFER
	LD	C,DMAF
	CALL	BDOS
	POP	DE
	PUSH	DE
	LD	HL,ERFCB+32
	LD	(HL),D		;SET SECTOR NUMBER TO READ
	LD	DE,ERFCB
	LD	C,20
	CALL	BDOS		;READ ERROR MSG SECTOR
;
	POP	DE		;RESTORE START OF MSG
	LD	D,0		;NOW OFFSET IN D,E
	LD	HL,80H		;H,L TO START OF DEFAULT BUFFER
	ADD	HL,DE		;H,L TO START OF MSG
;
ERR23:	LD	A,(HL)		;GET A CHAR TO PRINT
	CP	CR		;SEE IF DONE
	JP	Z,ERR24	;GET OUT IF DONE
;
	PUSH	HL		;SAVE WHERE WE GOT THE CHAR FROM
	CALL	TRMOT		;PRINT CHAR
	POP	HL		;RESTORE CHAR
	INC	HL
	JP	ERR23
;
ERR25:	CALL	CRLF		;ENTRY POINT FROM CONTROL-C
	LD	A,(FLG1)
	AND	4
	LD	(FLG1),A
	JP	ERR3
;
ERR24:	CALL	CRLF
ERR3:	LD	A,(FLG1)
	AND	8
	JP	Z,ERR35
	LD	HL,(BKPTR)
	LD	(TOS),HL
	JP	ERR4
ERR35:	LD	HL,(XSTK)
	LD	(TOS),HL
ERR4:	XOR	A
	LD	(IT),A
	CALL	SETDE
	LD	A,(FLG1)
	AND	0CH
	LD	(FLG1),A
	LD	A,(I1)
	CP	38
	JP	Z,MMP0
	JP	MMP1A
;
ERRS:	DEFW	0000H,001DH,002DH,0042H,005CH
	DEFW	0100H,0116H,012EH,0145H,015CH
	DEFW	0200H,021FH,0230H,0247H,0264H
	DEFW	0300H,031BH,0337H,0349H,035CH
	DEFW	0400H,0414H,0425H,0434H,044BH
	DEFW	0500H,051FH,0538H,054CH,056BH
	DEFW	0600H,0619H,0630H,064CH,065DH
	DEFW	0700H,071AH,073AH,0753H,0768H
	DEFW	0800H,0815H,0831H,0849H
	DEFW	0900H,091FH,093FH,0952H,0965H
	DEFW	0A00H,0A12H,0A21H,0A48H
;
; SCMP COMPARES TWO STRINGS WITH:
;      H,L AT START OF STRING #1
;      D,E AT START OF STRING #2
;      B   HAS LENGTH OF STRING #1
;      C   HAS LENGTH OF STRING #2
; ON EXIT:
;      IF #1 = #2, Z IS SET
;      IF #1 <= #2, NC IS SET
;      IF #1 > #2, C IS SET
;      IF #1 <> #2, NZ IS SET
;
SCMP:	PUSH	HL		;SAVE REGISTERS
	PUSH	DE
	PUSH	BC
;
SCMP1:	LD	A,B		;GET LENGTH OF STRING #1
	OR	A		;SEE IF FINISHED
	JP	NZ,SCMP2	;JUMP IF MORE LEFT
	OR	C		;SEE IF ALL DONE
	JP	Z,SCMP5	;JUMP IF BOTH STRINGS EQUAL
	JP	SCMP4		;#1 DONE, #2 HAS SOME LEFT (H,L < D,E)
SCMP2:	LD	A,C		;GET LENGTH OF STRING #2
	OR	A		;SEE IF FINISHED
	JP	Z,SCMP4	;#2 DONE, #1 HAS SOME LEFT (H,L > D,E)
	LD	A,(DE)		;GET STRING #2 CHARACTER
	CP	(HL)		;COMPARE TO STRING #1 CHARACTER
	JP	NZ,SCMP5	;JUMP IF DIFFERENT CHARACTER
	INC	HL		;MOVE TO NEXT IN STRING #1
	INC	DE		;MOVE TO NEXT IN STRING #2
	DEC	B		;DECREMENT STRING #1 COUNT
	DEC	C		;DECREMENT STRING #2 COUNT
	JP	SCMP1		;AND LOOP
SCMP4:	CP	B		;AND COMPARE TO B (ONE IS ZERO THE OTHER +)
SCMP5:	POP	BC		;RESTORE REGISTERS
	POP	DE
	POP	HL
	RET
;
;
; ARITHMETIC FUNCTIONS
;
;	ON ENTRY:
;	  PTR1 POINTS TO OP #1
;	  PTR2 POINTS TO OP #2
;	  I1   LENGTH OF OP #1
;	  I2   LENGTH OF OP #2
;	  I6   OPERATION TOKEN
;
;	ON EXIT:
;	  RESULT IS ON STACK
;
;
NUMOP:	LD	A,(I6)		;GET OPERATION
	PUSH	AF		;SAVE OPERATION
	LD	A,(I1)		;GET #1 OPERAND LENGTH
	LD	C,A
	LD	B,BCDLN		;LENGTH OF BCD NUMBER IN BYTES
	LD	HL,(PTR1)	;POINTER TO OP #1
	LD	DE,OP1		;DESTINATION
	CALL	BCDPK		;PACK STRING INTO BCD IN OP1
	LD	(SGN1),A	;SAVE SIGN
	LD	A,(COUNT)
	LD	(DP1),A		;SAVE COUNT OF DECIMAL PLACES
;
	LD	A,(I2)		;GET OPERAND #2 LENGTH
	LD	C,A
	LD	HL,(PTR2)	;GET POINTER TO OP #2
	LD	DE,OP2		;DESTINATION
	CALL	BCDPK		;PACK OPERAND #2 IN OP2 IN BCD
	LD	(SGN2),A	;SAVE OPERAND #2 SIGN
	LD	A,(COUNT)	;SAVE COUNT OF DECCIMAL PLACES
	LD	(DP2),A
;
FOPS3B:	LD	C,A		;SAVE OP2 DECIMAL PLACES IN C
	LD	A,(DP1)
	LD	B,A
	POP	AF		;RESTORE OPERATION
;
	CP	13
	JP	NC,FOPS2
;
	CP	7
	JP	NC,FOPS9	;JUMP IF NOT + OR -
;
	CP	5		;SEE IF +
	JP	Z,FOPS3A
;
FOPS2:	LD	A,(SGN2)	;CHANGE SIGN OF OP2
	XOR	1
	LD	(SGN2),A
;
FOPS3A:	LD	A,B
	SUB	C		;COMPARE DP1 WITH DP2
	JP	Z,FOPS6	;JUMP IF BOTH THE SAME
;
	JP	C,FOPS4	;JUMP IF DP1 < DP2
;
	LD	C,B		;DP2 > DP1 SO SHIFT OP2
	LD	B,A		;SAVE RESULT DP IN B
	LD	HL,I2
	LD	A,BCDLN*2
	SUB	(HL)		;SEE IF ROOM TO SHIFT
	CP	B
	LD	HL,OP2		;GET READY TO SHIFT OP2
	JP	NC,FOPS5
;
	LD	DE,OP1
	EX	DE,HL
	CALL	BCDST		;SET OP1 TO OP2
	LD	A,(DP2)
	LD	(DP1),A		;SET DECIMAL PLACES
	LD	A,(S2)
	LD	(S1),A
	JP	FOPS45
;
FOPS4:	CPL
	INC	A		;MAKE # > 0
	LD	B,A
	LD	HL,I1
	LD	A,BCDLN*2
	SUB	(HL)
	CP	B
	JP	C,FOPS45	;ALL DONE
	JP	FOPS46
;
FOPS45:	LD	A,(I6)
	CP	13
	JP	NC,FOPSD3
	JP	FOPSE
;
FOPS46:	LD	HL,OP1		;GET READY TO SHIFT OP1
FOPS5:	PUSH	BC		;SAVE B,C DURING SHIFT
	LD	C,BCDLN
FOPS5A:	CALL	TIM10		;SHIFT IT
	DEC	B
	JP	NZ,FOPS5A
	POP	BC		;RESTORE B,C
;
FOPS6:	LD	A,C		;GET NUMBER OF DECIMAL PLACES IN RESULT
	LD	(DP1),A
;
	LD	HL,SGN1
	LD	A,(SGN2)
	CP	(HL)		;COMPARE SIGNS
	LD	HL,OP1
	LD	DE,OP2
	LD	C,BCDLN
	JP	NZ,FOPS7
	LD	A,(I6)
	CP	13
	JP	NC,FOPSD3
;
	CALL	BCDAD		;DO ADDITION
	JP	FOPSE
FOPS7:	LD	B,BCDLN
	CALL	SCMP		;COMPARE OPERANDS
	JP	C,FOPS8
	EX	DE,HL		;IF HERE, OP1 <= OP2
	LD	A,(SGN2)
	LD	(SGN1),A
FOPS8:	PUSH	AF		;SAVE Z AND C FOR < & >
	LD	A,(I6)
	CP	13
	JP	NC,FOPSE3
	POP	AF		;GET RID OF Z AND C
;
	CALL	BCDSB		;SUBTRACT
	JP	FOPSE
;
FOPS9:	CP	9		;SEE IF MOD
	JP	Z,FOPSA	;IF SO, DON'T DO SIGN STUFF
	CP	11
	JP	NC,FOPSD1
;
	PUSH	AF		;SAVE OPERATION
;
	LD	HL,SGN1
	LD	A,(SGN2)	;COMPARE SIGNS
	XOR	(HL)		;SET RESULT SIGN
	LD	(SGN1),A	;SAVE RESULT SIGN
;
	POP	AF		;RESTORE OPERATION
	CP	7		;SEE IF *
	JP	NZ,FOPSA	;JUMP IF NOT MULTIPLICATION
;
	LD	A,B
	ADD	A,C		;GET DP IN RESULT
	LD	(DP1),A
;
	LD	HL,OP1
	LD	DE,OP2
	LD	C,BCDLN
	CALL	BCDML
	LD	HL,TNUMB	;POINT TO ANSWER
	JP	FOPSE
;
FOPSA:	PUSH	AF		;SAVE OPERATION
;
	CP	9		;SEE IF MOD
	JP	NZ,FOPSA3	;JUMP IF NOT
;
	LD	HL,SOP1
	LD	DE,OP1
	PUSH	BC
	LD	C,BCDLN
	CALL	BCDST		;SAVE OP1 FOR END OF MOD
	POP	BC
;
FOPSA3:	LD	A,B		;GET DECIMAL PLACES IN DIVIDEND
	SUB	C		;GET DIFFERENCE TO DIVISOR
	JP	C,FOPSA0	;JUMP IF MORE IN DIVISOR
;
	LD	B,A		;SET D.P. FOR QUOTIENT
	JP	FOPSA2
;
;
FOPSA0:	LD	HL,OP1		;SET UP FOR SHIFT
	LD	C,BCDLN
	CPL			;GET NUMBER TO SHIFT POSITIVE
	INC	A
	LD	B,A
FOPSA1:	CALL	TIM10		;SHIFT DIVIDEND
	DEC	B
	JP	NZ,FOPSA1
;
FOPSA2:	POP	AF
	CP	8		;SEE IF REAL DIVIDE
	JP	NZ,FOPSC
;
FOPSB:	LD	HL,OP1
	LD	DE,OP2
	LD	C,BCDLN
	CALL	BCDRD
	LD	HL,RTNUM	;POINT TO ANSWER
	LD	A,B
	LD	(DP1),A		;SET DECIMAL PLACES
	JP	FOPSE
;
FOPSC:	CP	9		;SEE IF MOD
	JP	NZ,FOPSD
;
	LD	HL,OP1
	LD	DE,OP2
	LD	C,BCDLN
	CALL	BCDRD		;GET OP1 / OP2
;
	LD	DE,RTNUM
	CALL	ISET		;GET INTEGER ( OP1 / OP2 )
;
	LD	A,B		;GET # OF DECIMAL PLACES IN RESULT
	OR	A
	JP	Z,FOPSC1	;JUMP IF NONE
;
	LD	A,(SGN1)
	LD	HL,SGN2
	CP	(HL)		;CHECK RESULT SIGN
	LD	HL,OP1
	JP	Z,FOPSC1	;JUMP IF RESULT POSITIVE
;
	CALL	ADD1
;
FOPSC1:	LD	DE,OP2
	CALL	BCDML		;GET OP1 * FLOOR (OP1 / OP2)
;
	LD	HL,OP1		;PUT OP1 BACK
	LD	DE,SOP1
	CALL	BCDST
;
	LD	HL,OP2
	LD	DE,TNUMB
	CALL	BCDST		;SET OP2 TO OP1 * FLOOR (OP1 / OP2)
;
	LD	A,(SGN1)	;SET SIGN FOR  ABOVE OPERATIONS
	LD	(SGN2),A
	LD	A,2		;PUT SUBTRACT OPERATOR ON STACK
	PUSH	AF
	LD	A,(DP2)		;SET UP OP2 DECIMAL PLACE
	JP	FOPS3B		;NOW GO SUBTRACT
;
FOPSD:	CP	10		;SEE IF INTEGER DIVISION
	JP	NZ,FOPSD1
;
	LD	HL,OP1
	LD	DE,OP2
	LD	C,BCDLN
	CALL	BCDDV
;
	LD	HL,OP1
	LD	DE,TNUMB	;POINT TO ANSWER
	CALL	ISET		;GRAB INTEGER PART
	XOR	A
	LD	(DP1),A		;SET DECIMAL PLACES IN ANSWER
	JP	FOPSE
;
FOPSD1:	CP	11		;SEE IF AND
	JP	NZ,FOPSD2
;
	LD	HL,OP1
	LD	C,BCDLN
	CALL	ZTEST		;SEE IF OP #1 IS ZERO
	JP	Z,ZANS		;IF YES, RESULT IF 0
;
	LD	HL,OP2
	CALL	ZTEST		;CHECK OP #2
	JP	Z,ZANS		;IF ZERO, RESULT IS 0
	JP	OANS		;BOTH ARE NON-ZERO
;
FOPSD2:	CP	12		;SEE IF OR
	JP	NZ,FOPSD3
;
	LD	HL,OP1
	LD	C,BCDLN
	CALL	ZTEST		;SEE IF OP #1 IS ZERO
	JP	NZ,OANS		;IF NOT, RESULT IS ONE
;
	LD	HL,OP2
	CALL	ZTEST		;CHECK OP #2
	JP	Z,ZANS		;BOTH ARE ZERO
	JP	OANS
;
FOPSE3:	POP	AF		;GET Z AND C
	JP	Z,ZANS		;BOTH WERE THE SAME SO ZERO RESULT
	LD	A,(I6)
FOPSD3:	CP	13		;SEE IF LESS THAN
	JP	NZ,FOPSD4
;
	LD	A,(SGN1)
	OR	A
	JP	Z,ZANS
	JP	OANS
;
FOPSD4:	LD	A,(SGN1)	;IT'S A GREATER THAN
	OR	A
	JP	Z,OANS
;
ZANS:	LD	A,(FLG1)	;CHECK NOT FLAG
	AND	NOTFL
	JP	NZ,OANS1
ZANS1:	LD	A,'0'		;RESULT IS NUMBER 0
	JP	ENDIT
OANS:	LD	A,(FLG1)	;CHECK NOT FLAG
	AND	NOTFL
	JP	NZ,ZANS1
OANS1:	LD	A,'1'
;
ENDIT:	CALL	SPUSH
	LD	A,1
	CALL	SPUSH
	LD	A,3
	CALL	SPUSH
	RET
;
FOPSE:	LD	C,MAXDG
	CALL	BCDRN		;ROUND OFF NUMBER IN OP1 TO MAXDG PLACES
	CALL	BCDPS		;PUSH RESULT ON STACK
	RET
;
;
;BCDPK PACKS A STRING INTO BCD FORM
;	ON ENTRY:
;	   H,L AT MOST SIGNIFICANT BYTE OF STRING
;	   D,E AT MOST SIGNIFICANT BYTE OF OF BCD PLACE
;	   B   MAX NUMBER OF BYTES ALLOWED (14 FOR REAL, 5 FOR INTEGER)
;	   C   NUMBER OF BYTES IN STRING
;
;	ON EXIT:
;	  A  SIGN OF BCD NUMBER--0 IF POSITIVE, 1 IF NEGATIVE
;	  COUNT  NUMBER OF DECIMAL PLACES
;
;
BCDPK:	PUSH	HL		;SAVE REGISTERS
	PUSH	DE
;
	LD	A,'-'		;CHECK FOR NEGATIVE
	CP	(HL)
	LD	A,0		;ASSUME >= 0
	JP	NZ,BCDP0
	INC	HL		;SKIP MINUS SIGN
	DEC	C
	LD	A,1		;SET < 0
BCDP0:	PUSH	BC
	PUSH	AF		;SAVE SIGN INDICATOR
;
	CALL	SKPST		;MOVE H,L OVER (H,L TO LEAST SIGNIF DIGIT)
	EX	DE,HL		;H,L AT DESTINATION & D,E AT SOURCE
;
	LD	A,B		;GET MAX DIGITS
	ADD	A,A
	DEC	A		;CONVERT TO DIGITS
	CP	C		;COMPARE TO ACTUAL DIGITS
	JP	C,E2		;ARITHMETIC OVERFLOW
;
;
	PUSH	BC
	LD	C,B		;SET C TO MAX NUMBER
	CALL	SKPST		;MOVE H,L TO DEST LEAST SIGNIF. DIGIT
	POP	BC		;RESTORE OLD B,C
;
	XOR	A
	LD	(COUNT),A	;SET DECIMAL PLACES COUNT
	LD	(DFLAG),A	;RESET DECIMAL PLACE FLAG
;
BCDP1:	CALL	CHKDP		;CHECK FOR DECIMAL PLACE AND COUNT DIGITS
	JP	Z,BCDP2B
;
	AND	0FH		;STRIP ASCII BIAS
	LD	(HL),A		;SAVE
	DEC	C
	JP	Z,BCDP2A	;SEE IF DONE
;
	DEC	DE		;MOVE TO NEXT (PREVIOUS) DIGIT
	CALL	CHKDP		;CHECK FOR DECIMAL PLACE AND COUNT DIGITS
	JP	Z,BCDP2A
;
	AND	0FH		;STRIP ASCII BIAS
	RLCA
	RLCA
	RLCA
	RLCA			;SHIFT DIGIT TO HIGH ORDER NIBBLE
;
	OR	(HL)		;INCLUDE LOW ORDER NIBBLE
BCDP2:	LD	(HL),A		;SAVE IN DESTINATION
	DEC	DE
	DEC	HL
	DEC	B
	DEC	C
	JP	NZ,BCDP1	;LOOP UNTIL DONE
	JP	BCDP2B
;
BCDP2A:	DEC	HL
	DEC	B
;
BCDP2B:	LD	A,B		;GET NUMBER OF  DIGITS LEFT
	OR	A
	JP	Z,BCDP4	;JUMP IF DONE
BCDP3:	LD	(HL),0		;ZERO OUT BYTE
	DEC	B
	DEC	HL
	JP	NZ,BCDP3
BCDP4:	POP	AF		;GET SIGN
	POP	BC
	PUSH	AF		;SAVE SIGN
	LD	A,(DFLAG)
	OR	A		;CHECK IF HAD A DECIMAL PLACE
	JP	Z,BCDP5	;JUMP IF NO
;
	LD	HL,COUNT
	LD	A,C
	SUB	(HL)		;ADJUST COUNT
	LD	(COUNT),A
;
BCDP5:	POP	AF		;GET SIGN BACK
	POP	DE
	POP	HL
	RET
;
;
; CHKDP CHECKS FOR DECIMAL PLACE AND COUNTS THE DECIMAL DIGITS
;
;	ON ENTRY:
;	  D,E IS AT BYTE TO CHECK
;	  C   NUMBER OF DIGITS LEFT IN STRING
;
;	ON EXIT:
;	  D,E IS MOVED IF BYTE WAS DECIMAL PLACE
;	  Z    SET IF DECIMAL PLACE WAS LAST CHARACTER IN STRING
;	  COUNT IS INCREMENTED IF A DECIMAL PLACE FOUND PREVIOUSLY
;	  DFLAG IS SET IF DECIMAL PLACE ENCOUNTERED
;
CHKDP:	PUSH	HL		;SAVE H,L
	LD	A,(DE)		;GET THE CHARACTER
	CP	'.'		;SEE IF A DECIMAL PLACE
	JP	NZ,CHKD1
	LD	A,1		;D.P. FOUND SO SET DFLAG
	LD	(DFLAG),A
;
	DEC	DE		;SKIP D.P.
	LD	HL,COUNT
	INC	(HL)
	DEC	C		;DECREMENT STRING COUNT
	JP	Z,CHKD3
;
CHKD1:	LD	A,(DFLAG)	;CHECK DECIMAL PLACE FLAG
	OR	A
	JP	Z,CHKD2
;
	LD	HL,COUNT
	INC	(HL)
;
CHKD2:	LD	A,(DE)		;GET CHARACTER BACK
	OR	A		;RESET Z FLAG
CHKD3:	POP	HL		;RESTORE H,L
	RET
;
;
; SKPST SKIPS OVER PARTS OF A STRING
;	ON ENTRY:
;	  H,L IS IN THE STRING
;	  C   IS THE NUMBER OF CHARACTERS TO SKIP
;
;	ON EXIT:
;	  H,L IS MOVED OVER
;	  B,C IS THE SAME AS ON ENTRY
;
SKPST:	PUSH	BC		;SAVE B,C
	LD	B,0
	ADD	HL,BC		;MOVE H,L OVER
	DEC	HL
	POP	BC
	RET
;
;
;
; BCDT2  MULTIPLIES A BCD NUMBER BY 2
;	ON ENTRY:
;	  H,L IS AT MOST SIGNIFICANT DIGIT OF NUMBER
;	  C   IS NUMBER OF BYTES IN BCD NUMBER
;
;	ON EXIT:
;	  RESULT IS IN SAME PLACE
;	  ALL REGISTERS ARE AS AT ENTRY
;
BCDT2:	CALL	SKPST		;MOVE H,L TO LEAST SIGNIFICANT DIGIT
	PUSH	AF		;SAVE ACCUM
	PUSH	BC		;SAVE B,C
	XOR	A
BCDX1:	LD	A,(HL)		;GET BYTE
	ADC	A,A		;TIMES 2 PLUS CARRY FROM PREVIOUS BYTE
	DAA			;CONVERT TO BCD
	LD	(HL),A		;SAVE IT
	DEC	HL
	DEC	C
	JP	NZ,BCDX1
	INC	HL		;BACK UP H,L
	POP	BC
	POP	AF
	RET
;
;
;
; BCDD2 DIVIDES A BCD NUMBER BY 2
;
;	ON ENTRY:
;	  H,L AT MOST SIGNIFICANT BYTE OF BCD NUMBER
;	  C   # OF BYTES IN BCD NUMBER
;
;	ON EXIT:
;	  NUMBER DIVIDED BY TWO AT H,L
;	  ALL REGISTERS SAME AS ON ENTRY (EXCEPT PSW)
;	  IF CARRY SET, THERE WAS A REMAINDER
;
BCDD2:	PUSH	BC		;SAVE THE REGISTERS
	PUSH	DE
	PUSH	HL
	XOR	A		;CLEAR CARRY
	PUSH	AF		;SAVE CARRY
	LD	D,A		;ZERO D
BDD1:	POP	AF		;GET CARRY
	LD	A,(HL)		;GET NEXT BYTE
	RRA			;DIVIDE BY TWO GRABBING PREVIOUS CARRY
	PUSH	AF		;SAVE CARRY
	SUB	D		;ADJUST FOR PRIOR CARRY IN
	LD	E,A		;SAVE SHIFTED BYTE
	POP	AF
	PUSH	AF
	JP	C,BDD2
	LD	D,0		;NO CARRY ADJUST
	JP	BDD3
BDD2:	LD	D,30H		;A CARRY ADJUST
BDD3:	AND	08H		;CHECK AUX CARRY
	LD	A,E
	JP	Z,BDD4		;JUMP IF NO AUX CARRY
	SUB	3		;ADJUST FOR AUX CARRY
BDD4:	LD	(HL),A		;SAVE BYTE
	INC	HL		;MOVE TO NEXT BYTE
	DEC	C
	JP	NZ,BDD1
	POP	AF
	POP	HL		;RESTORE REGISTERS
	POP	DE
	POP	BC
	RET
;
;
;
; BCDAD ADDS THE TWO STRINGS AT H,L AND D,E AND PUTS THE
;	RESULT IN D,E
;
;	ON ENTRY:
;	  H,L IS AT ONE OPERAND
;	  D,E IS AT OTHER OPERAND
;	  C   IS NUMBER OF BYTES IN BCD NUMBER
;
;	ON EXIT:
;	  RESULT IS AT H,L
;	  REGISTERS ARE SAVED
;
BCDAD:	PUSH	BC		;SAVE REGISTERS
	PUSH	AF
	CALL	SKPST		;MOVE H,L TO LEAST SIGNIFICANT BYTE
	EX	DE,HL
	CALL	SKPST		;MOVE H,L TO LEAST SIGNIFICANT BYTE
	XOR	A		;CLEAR CARRY
BCDA1:	LD	A,(DE)		;GET A BYTE
	ADC	A,(HL)		;ADD H,L BYTE + CARRY FROM PREVIOUS
	DAA			;CONVERT BACK TO BCD
	LD	(DE),A		;SAVE SUM
	DEC	HL		;MOVE TO NEXT BYTE
	DEC	DE
	DEC	C
	JP	NZ,BCDA1
	JP	C,E2		;OVERFLOW
	EX	DE,HL		;PUT H,L AND D,E BACK WHERE THEY BELONG
	INC	HL
	INC	DE
	POP	AF
	POP	BC
	RET
;
;
; BCDSB SUBTRACTS BCD NUMBER AT D,E FROM BCD NUMBER AT H,L
;
;	ON ENTRY:
;	  H,L AT MINUEND
;	  D,E AT SUBTRAHEND
;	  C   NUMBER OF BYTES IN BCD NUMBER
;
;	ON EXIT:
;	  H,L AT RESULT
;	  REGISTERS ARE SAVED
;
BCDSB:	PUSH	BC		;SAVE REGISTERS
	PUSH	AF
	CALL	SKPST		;H,L TO LEAST SIGNIFICANT BYTE
	EX	DE,HL		;SWAP D,E AND H,L (SO DO D,E - H,L)
	CALL	SKPST		;H,L TO LEAST SIGNIFICANT BYTE
	SCF			;INITIAL VALUE FOR CARRY
	PUSH	AF		;SAVE CARRY
BCDS1:	LD	A,99H
	SUB	(HL)		;FORM 99 - (H,L)
	LD	B,A		;SAVE FOR A  MOMENT
	POP	AF
	LD	A,(DE)
	ADC	A,B		;FORM 99 - (H,L) + (D,E) + CARRY
	DAA			;CONVERT TO BCD
	LD	(DE),A		;SAVE RESULT
	PUSH	AF		;SAVE CARRY
	DEC	HL
	DEC	DE
	DEC	C
	JP	NZ,BCDS1	;LOOP UNTIL DONE
	POP	AF		;GET RID OF CARRY
	JP	NC,E2		;OVERFLOW
	EX	DE,HL		;PUT D,E AND H,L BACK
	INC	HL
	INC	DE
	POP	AF
	POP	BC
	RET
;
;
;
; ADD1 ADDS 1 TO A BCD NUMBER
;
;	ON ENTRY:
;	  H,L IS AT MOST SIGNIFICANT DIGIT OF NUMBER
;	  C   IS NUMBER OF BYTES IN NUMBER
;
;	ON EXIT:
;	  H,L IS AT RESULT
;	  ALL REGISTERS ARE SAVED
;
ADD1:	PUSH	BC		;SAVE REGISTERS
	PUSH	AF
	CALL	SKPST		;H,L TO LEAST SIGNIFICANT BYTE
	XOR	A		;CLEAR CARRY
	LD	B,A		;ZERO OUT B
	LD	A,01H
ADD11:	ADC	A,(HL)
	DAA			;CONVERT TO BCD
	LD	(HL),A		;SAVE RESULT
	DEC	HL
	DEC	C
	LD	A,B		;PUT ZERO IN A FOR REST OF SUM
	JP	NZ,ADD11	;LOOP UNTIL DONE
	JP	C,E2		;OVERFLOW
	INC	HL
	POP	AF		;RESTORE REGISTERS
	POP	BC
	RET
;
;
; SUB1 SUBTRACTS 1 FROM A BCD NUMBER
;
;	ON ENTRY:
;	  H,L IS AT MOST SIGNIFICANT DIGIT OF NUMBER
;	  C   IS NUMBER OF BYTES IN NUMBER
;
;	ON EXIT:
;	  H,L IS AT RESULT
;	  ALL REGISTERS ARE SAVED
;
SUB1:	PUSH	DE		;SAVE REGISTERS
	PUSH	BC
	PUSH	AF
;
	CALL	SKPST		;H,L TO LEAST SIGNIFICANT BYTE
	SCF			;SET CARRY FOR SUBTRACT
	PUSH	AF		;SAVE CARRY
	LD	E,1		;NUMBER SUBTRACTING
;
SUB11:	LD	A,99H
	SUB	E		;GET 99 - #
	LD	B,A		;SAVE 99 - #
	POP	AF		;RESTORE CARRY FROM PREVIOUS DIGIT
	LD	A,(HL)
	ADC	A,B		;GET H,L + 99 - # + CARRY
	DAA
	LD	(HL),A		;SAVE DIGITS
;
	PUSH	AF		;SAVE CARRY FOR NEXT DIGITS
	DEC	HL
	DEC	C
	LD	E,0		;SET SUBTRACT NUMBER FOR THE REST
	JP	NZ,SUB11
;
	POP	AF		;THROW CARRY AWAY
	INC	HL		;H,L BACK TO START
	POP	AF		;RESTORE REGISTERS
	POP	BC
	POP	DE
	RET
;
;
; ZTEST TESTS A BCD NUMBER FOR ZERO
;
;	ON ENTRY:
;	  H,L AT MOST SIGNIFICANT BYTE
;	  C   NUMBER OF BYTES IN BCD NUMBER
;
;	ON EXIT:
;	  Z IS SET IF ZERO, ELSE NZ
;	  ALL REGISTERS EXCEPT PSW AS ON ENTRY
;
ZTEST:	PUSH	HL		;SAVE REGISTERS
	PUSH	BC
ZTST1:	LD	A,(HL)		;GET A BYTE
	OR	A
	JP	NZ,ZTST2	;IF NOT ZERO, GET OUT
	INC	HL
	DEC	C
	JP	NZ,ZTST1
ZTST2:	POP	BC		;RESTORE REGISTERS
	POP	HL
	RET
;
;
; ISET SETS THE INTEGER PART OF A BCD NUMBER
;
;	ON ENTRY:
;	  H,L POINTES TO DESTINATION
;	  D,E POINTS TO SOURCE
;	  C   # OF BYTES IN BCD NUMBER
;	  B   # OF DECIMAL PLACES IN SOURCE
;
;	ON EXIT:
;	  ALL REGISTERS SAVED
;
ISET:	PUSH	AF		;SAVE REGISTERS
	PUSH	DE
	PUSH	HL
	PUSH	BC
;
	CALL	SKPST		;MOVE DESTINATION TO LEAST SIGNIFICANT DIGIT
	EX	DE,HL		;H,L HAS SOURCE D,E HAS DESTINATION
	CALL	SKPST		;MOVE SOURCE TO LEAST SIGNIFICANT BYTE
;
	OR	A		;CLEAR  CARRY
	LD	A,B		;GET DECIMAL PLACES
	RRA			;DIVIDE BY TWO TO GET BYTES
	PUSH	AF		;SAVE CARRY
	PUSH	DE		;SAVE LEAST SIG BYTE OF DESTINATION
	LD	B,A
	CPL
	LD	E,A
	LD	D,0FFH
	INC	DE
	ADD	HL,DE		;SHIFT SOURCE OVER
;
	LD	A,C
	SUB	B
	LD	C,A		;GET NUMBER OF BYTES TO MOVE
;
	POP	DE		;GET DESTINATION BACK
	PUSH	DE
ISET1:	LD	A,(HL)
	LD	(DE),A
	DEC	DE
	DEC	HL
	DEC	C
	JP	NZ,ISET1
;
	LD	A,B
	OR	A
	JP	Z,ISET1B
;
	XOR	A
ISET1A:	LD	(DE),A		;ZERO OUT REST OF NUMBER
	DEC	DE
	DEC	B
	JP	NZ,ISET1A
;
ISET1B:	POP	HL		;RESTORE LEAST SIGNIFICANT BYTE OF DEST
	POP	AF		;CHECK CARRY
	JP	NC,ISET4	;JUMP IF EVEN # OF DECIMAL PLACES
;
	LD	A,(HL)		;NOW HAVE TO SHIFT WHOLE NUMBER DOWN ONE DIGIT
	POP	BC		;GET NUMBER OF BYTES IN NUMBER
	PUSH	BC
	JP	ISET3
;
ISET2:	LD	A,(HL)		;GET TWO DIGITS
	LD	B,A		;SAVE IN B
	AND	0FH		;LOOK AT LOW NIBBLE
;
	RLCA
	RLCA
	RLCA
	RLCA			;MOVE LOW NIBBLE TO HIGH NIBBLE
	INC	HL		;BACK UP H,L ONE
	OR	(HL)		;SITCK DIGIT IN LOWER BYTE
	LD	(HL),A
	DEC	HL		;PUT H,L BACK
;
	LD	A,B		;GET BYTE BACK
ISET3:	AND	0F0H		;GET HIGH NIBBLE
;
	RRCA
	RRCA
	RRCA
	RRCA			;MOVE HIGH NIBBLE TO LOW NIBBLE
	LD	(HL),A		;AND STORE IT
;
	DEC	HL		;MOVE TO NEXT BYTE
	DEC	C
	JP	NZ,ISET2
;
ISET4:	POP	BC		;RESTORE REGISTERS
	POP	HL
	POP	DE
	POP	AF
	RET
;
;
; BCDML MULTIPLIES TWO BCD NUMBERS
;
;	ON ENTRY:
;	  H,L POINTS TO THE MULTIPLICAND
;	  D,E POINTS TO THE MULTIPLIER
;	  C   IS NUMBER OF BYTES IN BCD NUMBER
;
;	ON EXIT:
;	  RESULT IS IN TNUMB
;	  ALL REGISTERS (EXCEPT PSW) ARE SAME
;
BCDML:	PUSH	HL		;SAVE REGISTERS
	PUSH	DE
	PUSH	BC
;
	PUSH	HL		;SAVE H,L
	LD	HL,TNUMB
	CALL	BCDZR		;ZERO OUT TNUMB
	POP	HL
;
	EX	DE,HL		;H,L GETS MULTIPLIER
;
BCDM0:	CALL	ZTEST		;SEE IF MULTIPLIER IS ZERO
	JP	Z,BCDM2	;IF YES, GET OUT
;
	PUSH	HL		;SAVE MULTIPLIER START
	CALL	SKPST		;MOVE H,L TO LEAST SIGNIFICANT DIGIT
	LD	A,(HL)
	AND	1		;SEE IF MULTIPLIER IS ODD OR EVEN
	JP	Z,BCDM1	;JUMP IF EVEN
;
	LD	HL,TNUMB	;H,L TO TEMP. NUMBER
	CALL	BCDAD		;ADD MULTIPLICAND AND TEMP NUMBER
BCDM1:	EX	DE,HL		;H,L NOW HAS MULTIPLICAND
	CALL	BCDT2		;MULTIPLICAND TIMES TWO
;
	POP	DE		;RESTORE MULTIPLIER
	EX	DE,HL
	CALL	BCDD2		;MULTIPLIER DIVIDED BY TWO
;
	JP	BCDM0
;
BCDM2:	POP	BC		;RESTORE REGISTERS
	POP	DE
	POP	HL
	RET
;
;
; BCDDV DIVIDES TWO BCD NUMBERS
;
;	ON ENTRY:
;	  H,L POINTS AT DIVIDEND
;	  D,E POINTS AT DIVISOR
;	  C   IS COUNT OF # OF BYTES IN BCD NUMBER
;
;	ON EXIT:
;	  QUOTIENT IS IN TNUMB
;	  REMAINDER IS IN H,L
;	  ALL REGISTERS ARE SAVED (EXCEPT PSW)
;
BCDDV:	PUSH	BC		;SAVE REGISTERS
	PUSH	HL
	PUSH	DE
;
	LD	(REM),HL	;SAVE DIVIDEND (WILL END UP AS REMAINDER)
;
	EX	DE,HL
	CALL	ZTEST		;SEE IF DIVISOR IS ZERO
	JP	Z,E17		;DIVIDE BY ZERO
	EX	DE,HL
;
	LD	HL,W
	CALL	BCDST		;SET W FROM D,E
;
	LD	HL,TNUMB
	CALL	BCDZR		;ZERO OUT TNUMB
	LD	B,C		;SAME NUMBER OF CHARACTERS FOR COMPARE
BCDO1:	LD	DE,W
	LD	HL,(REM)
	EX	DE,HL
	CALL	SCMP
	JP	C,BCDO2	;JUMP IF W > REM
;
	CALL	BCDT2		;MULTIPLY W  BY TWO
	JP	BCDO1
;
BCDO2:	POP	DE		;GET Y ADDRESS
	PUSH	DE		;AND SAVE FOR NEXT TIME AROUND
;
	LD	HL,W
	CALL	SCMP
	JP	Z,BCDO3	;JUMP IF W = Y OR
	JP	NC,BCDO3	;     IF W < Y
;
	LD	HL,TNUMB
	CALL	BCDT2		;TNUMB TIMES TWO
;
	LD	HL,W
	CALL	BCDD2		;W DIVIDED BY TWO
;
	EX	DE,HL
	LD	HL,(REM)
	CALL	SCMP
	JP	Z,BCDO2A	;JUMP IF W = REM
	JP	NC,BCDO2	;JUMP IF W > REM
;
BCDO2A:	CALL	BCDSB		;REM := REM - W
;
	LD	HL,TNUMB
	CALL	ADD1
	JP	BCDO2
;
BCDO3:	POP	DE
	POP	HL
	POP	BC
	RET
;
;
; TIME10 MULTIPLIES A BCD NUMBER BY 10
;
;	ON ENTRY:
;	  H,L POINTS TO MOST SIGNIFICANT BYTE OF BCD NUMBER
;	  C   HAS SIZE IN BYTES OF BCD NUMBER
;
;	ON EXIT:
;	  H,L POINTS TO ANSWER
;	  ALL REGISTERS UNCHANGED
;
TIM10:	PUSH	AF		;SAVE REGISTERS
	PUSH	BC
	PUSH	DE
;
	CALL	SKPST		;H,L TO LEAST SIGNIFICANT BYTE
	LD	D,0		;ZERO CARRY FROM PREVIOUS DIGIT
;
TIMS1:	LD	A,(HL)		;GET TWO DIGITS
	RLCA
	RLCA
	RLCA
	RLCA			;MULTIPLY BY 10
	LD	E,A		;SAVE IN E
;
	AND	0F0H		;OLD LOW NIBBLE IS NOW HIGH NIBBLE
	OR	D		;PUT IN PREVIOUS BYTE'S HIGH NIBBLE
	LD	(HL),A		;AND PUT IT BACK
;
	LD	A,E		;GET SHIFTED BYTE
	AND	0FH		;NOW GET OLD HIGH NIBBLE
	LD	D,A		;PUT IN D FOR NEXT TIME
;
	DEC	HL
	DEC	C
	JP	NZ,TIMS1
;
	LD	A,D		;CHECK FOR OVERFLOW
	OR	A
	JP	NZ,E2
;
	INC	HL		;ADJUST H,L
	POP	DE		;RESTORE REGISTERS
	POP	BC
	POP	AF
	RET
;
;
; GETNM GETS THE NUMBER OF DIGITS IN A BCD NUMBER
;       TRAILING ZEROS ARE INCLUDED
;
;	ON ENTRY:
;	  H,L POINTS TO START OF BCD NUMBER
;	  C   HAS NUMBER OF BYTES IN NUMBER
;
;	ON EXIT:
;	  ALL REGISTERS ARE SAVED
;	  A HAS NUMBER OF DIGITS
;
GETNM:	PUSH	HL		;SAVE REGISTERS
	PUSH	BC
;
GETN1:	LD	A,(HL)		;GET A BYTE
	OR	A
	JP	NZ,GETN2	;JUMP IF NON-ZERO
;
	INC	HL
	DEC	C
	JP	NZ,GETN1
	JP	GETN3		;ALL DIGITS ARE ZERO
;
GETN2:	LD	B,A		;SAVE FIRST NON-ZERO BYTE
;
	LD	A,C		;GET NUMBER OF BYTES LEFT
	RLCA			;CONVERT TO NUMBER OF DIGITS
	LD	C,A		;AND SAVE FOR LATER
;
	LD	A,B
	AND	0F0H		;SEE IF NON-ZERO WAS IN HIGH ORDER NIBBLE
	JP	NZ,GETN3	;JUMP IF IN HIGH NIBBLE
;
	DEC	C		;LOW ORDER, SO REDUCE DIGIT COUNT
;
GETN3:	LD	A,C		;RETURN COUNT
	POP	BC		;RESTORE REGISTERS
	POP	HL
	RET
;
;
; BCDRD IS A BCD DIVIDE WITH FRACTIONAL REMAINDER
;
;	ON ENTRY:
;	  H,L AT DIVIDEND
;	  D,E AT DIVISOR
;	  C   IS COUNT OF BYTES IN BCD NUMBER
;	  B   # OF DECIMAL PLACES IN DIVIDEND
;
;	ON EXIT:
;	  QUOTIENT IS IN RTNUM
;	  B HAS NUMBER OF DECIMAL PLACES IN RTNUM
;	  OTHER REGISTERS SAVED
;
BCDRD:	PUSH	HL		;SAVE REGISTERS
	PUSH	DE
;
	PUSH	HL		;SAVE DIVIDEND
	LD	HL,RTNUM
	CALL	BCDZR		;ZERO OUT RTNUM
	POP	HL		;RESTORE DIVIDEND
;
BCDR1:	POP	DE		;GET DIVISOR
	PUSH	DE
	CALL	BCDDV		;DIVIDE H,L BY D,E
;
	PUSH	HL		;SAVE REMAINDER POINTER
	LD	HL,RTNUM	;ACCUMULATE ANSWER
	CALL	TIM10
	LD	DE,TNUMB
	CALL	BCDAD		;RTNUM := RTNUM * 10 + TNUMB
;
	CALL	GETNM		;GET # OF DIGITS IN RTNUM
	POP	HL		;RESTORE REMAINDER POINTER
	CP	MAXDG+1		;COMPARE TO MAX # OF SIGNIFICANT DIGITS
	JP	NC,BCDR2
;
	CALL	ZTEST		;SEE IF REMAINDER IS ZERO
	JP	Z,BCDR2	;JUMP IF YES
	CALL	TIM10		;REMAINDER TIMES 10
	INC	B		;INCREMENT # OF DECIMAL PLACES
	JP	BCDR1
;
BCDR2:	POP	DE		;RESTORE REGISTERS
	POP	HL
	RET
;
;
; BCDZR ZEROS OUT A BCD NUMBER
;
;	ON ENTRY:
;	  H,L POINTS TO BCD NUMBER
;	  C   HAS NUMBER OF BYTES IN NUMBER
;
;	ON EXIT:
;	  ALL REGISTERS (EXCEPT PSW) ARE SAVED
;
BCDZR:	PUSH	HL		;SAVE REGISTERS
	PUSH	BC
	XOR	A
;
BCDZ1:	LD	(HL),A		;ZERO OUT BYTE
	INC	HL
	DEC	C
	JP	NZ,BCDZ1
;
	POP	BC		;RESTORE REGISTERS
	POP	HL
	RET
;
;
; BCDST SETS ONE BCD EQUAL TO ANOTHER
;
;	ON ENTRY:
;	  H,L POINTS TO DESTINATION
;	  D,E POINTS TO SOURCE
;	  C   HAS # OF BYTES TO MOVE
;
;	ON EXIT:
;	  ALL REGISTERS SAVED
;
BCDST:	PUSH	HL		;SAVE REGISTERS
	PUSH	DE
	PUSH	BC
	PUSH	AF
;
BCDG1:	LD	A,(DE)		;GRAB A BYTE
	LD	(HL),A		;AND SAVE IT
	INC	HL
	INC	DE
	DEC	C
	JP	NZ,BCDG1
;
	POP	AF		;RESTORE REGISTERS
	POP	BC
	POP	DE
	POP	HL
	RET
;
;
; BCDRN ROUNDS OFF BCD NUMBER IN OP1 TO MAXDG PLACES
;
;	ON ENTRY:
;	   H,L AT BCD NUMBER TO ROUND
;	   C   MAX NUMBER OF DIGITS IN NUMBER
;
;	ON EXIT:
;	   H,L AT MOST SIGNIFICANT DIGIT
;	   B   NUMBER OF INTEGER DIGITS
;	   C   NUMBER OF DECIMAL PLACES
;	   A   1 IF STARTING AT LOW NIBBLE ELSE 0
;
BCDRN:	PUSH	HL		;SAVE START OF NUMBER
	LD	B,BCDLN		;GET SIZE IN BYTES TO B
;
BRND1:	LD	A,(HL)		;FIND FIRST NON-ZERO BYTE
	OR	A
	JP	NZ,BRND2
	INC	HL
	DEC	B
	JP	NZ,BRND1
	LD	BC,0		;ALL DIGITS ARE ZERO
	POP	HL
	JP	BRNDS
;
BRND2:	LD	E,0		;E WILL BE NUMBER OF BYTES IN BCD NUMBER
;
	LD	A,B		;GET NUMBER OF BYTES LEFT
	ADD	A,A		;NOW IT'S DIGITS
	LD	B,A
;
	LD	A,(DJ)
	OR	A
	JP	Z,BRND25
	LD	A,(DP1)
	CP	B
	JP	C,BRND25	;JUMP IF FEWER DIGITS THAN DECIMAL PLACES
;
	POP	HL		;GET START OF NUMBER
	PUSH	HL
	PUSH	BC		;SAVE MAX DIGITS
	LD	C,A		;DECIMAL PLACES TO C
	LD	A,BCDLN*2
	SUB	C		;GET DIGITS BEFORE NUMBER
	RRA			;CONVERT TO BYTES
	PUSH	AF		;SAVE CARRY
;
	LD	C,A
	LD	B,0
	ADD	HL,BC		;H,L TO STARTING PLACE
	POP	AF
	POP	BC
	LD	A,(DP1)
	LD	B,A		;SET DIGITS LEFT
	JP	C,BRND26	;AT LOW NIBBLE
	LD	D,0
	JP	BRND3		;AT HIGH NIBBLE
;
BRND25:	LD	A,(HL)		;GET DIGITS BACK
	AND	0F0H		;CHECK WHICH NIIBBLE
	LD	A,B
	LD	D,0
	JP	NZ,BRND3
;
BRND26:	DEC	C
	DEC	B
	LD	A,B
	DEC	A		;SKIP TOP DIGIT
	LD	D,1
	INC	HL
;
BRND3:	PUSH	BC		;SAVE DIGIT COUNTS
	SUB	C		;SEE IF ROOM FOR ALL SIGNIFICANCE
	LD	B,A		;SAVE DIGITS AFTER SIGNIFICANCE
	JP	C,BRNDT
	JP	Z,BRNDT
;
	LD	A,C
	OR	A		;SEE IF DONE
	LD	A,D
	JP	Z,BRND4
;
BRND3A:	XOR	A		;AT HIGH NIBBLE
	DEC	C
	JP	Z,BRND4
	LD	A,1		;AT LOW NIBBLE
	INC	HL
	INC	E		;ADD  1 TO BYTE COUNT
	DEC	C
	JP	NZ,BRND3A
;
BRND4:	PUSH	HL		;SAVE LOW ORDER BYTE PLACE
	PUSH	AF		;SAVE WHICH NIBBLE
	OR	A
	JP	Z,BRND5	;JUMP IF AT HIGH NIBBLE
	LD	D,50H		;LAST DIGIT WAS LOW ORDER
	JP	BRND6
BRND5:	LD	D,05H		;LAST DIGIT WAS LOW ORDER
BRND6:	INC	E		;ALLOW FOR CARRY OUT OF HIGH DIGIT
	LD	A,(HL)		;GET A BYTE
	ADD	A,D		;ADD 5 TO LAST DIGIT
	DAA
	LD	(HL),A		;PUT IT BACK
;
BRND7:	DEC	HL		;AND CARRY THROUGH REST OF NUMBER
	LD	A,(HL)
	ADC	A,0		;ADD IN PREVIOUS CARRY
	DAA
	LD	(HL),A		;AND STORE IT
;
	DEC	E
	JP	NZ,BRND7
;
	POP	AF		;RESTORE NIBBLE WHERE STARTED
	POP	HL		;AND LOCATION
	OR	A		;CHECK WHICH BYTE
	JP	NZ,BRND8
	LD	A,(HL)		;GET LEAST SIGNIFICANT DDIGIT
	AND	0F0H		;ZERO LOW NIBBLE
	LD	(HL),A
	INC	HL		;MOVE TO NEXT BYTE
	DEC	B		;ONE LESS DIGIT LEFT
;
BRND8:	LD	A,B		;CHECK DIGITS AFTER SIG PART
	OR	A
	JP	Z,BRND9
;
	LD	(HL),0		;ZERO OUT BYTE
	INC	HL		;MOVE TO NEXT BYTE
	DEC	B
	DEC	B		;JUST DID TWO DIGITS
	JP	BRND8
;
BRND9:	POP	BC
	POP	HL
	LD	C,BCDLN
	CALL	GETNM		;SEE IF EXTRA DIGIT ADDED
	LD	B,A
	JP	BRNDV
;
BRNDT:	POP	BC		;GET NUMBER OF DIGITS LEFT
	POP	HL
BRNDV:	LD	DE,BCDLN
	ADD	HL,DE		;H,L TO LEAST SIGNIFICANT BYTE
;
BRNDU:	DEC	HL
	LD	D,1
	LD	A,(DP1)		;SET NUMBER OF DECIMAL PLACES
	LD	C,A
	OR	A
	JP	Z,BRNDY
;
BRNDX:	LD	A,(HL)		;GET 2 DIGITS
	AND	0FH		;SEE IF ANYTHING IN LOW NIBBLE
	JP	NZ,BRNDY
	DEC	B
	DEC	C
	LD	D,0
	JP	Z,BRNDY
;
	LD	A,(HL)
	AND	0F0H		;SEE IF ANYTHING IN HIGH NIBBLE
	JP	NZ,BRNDY
	DEC	B
	DEC	C
	LD	D,1
	JP	Z,BRNDZ
	DEC	HL
	JP	BRNDX
;
BRNDZ:	DEC	HL
BRNDY:	LD	A,B		;GET NUMBER OF DIGITS LEFT
	SUB	C
	JP	NC,BRNDQ
	XOR	A
BRNDQ:	LD	B,A		;SET NUMBER OF INTEGER DIGITS
;
	LD	A,C
	ADD	A,B
	RRA			;CONVERT TO BYTES
	LD	E,1
	JP	NC,BRNDR
	DEC	E
BRNDR:	PUSH	DE
	CPL
	LD	E,A
	LD	D,0FFH
	INC	DE
	ADD	HL,DE		;MOVE H,L OVER
;
	POP	DE
	LD	A,E
	AND	D
	JP	Z,BRNDS
	INC	HL
;
BRNDS:	LD	A,E
	XOR	D
	RET
;
;
; BCDPS  PUSHES BCD NUMBER ON THE STACK
;
;	ON ENTRY:
;	   H,L AT MOST SIGNIFICANT DIGIT TO PUSH
;	   B   COUNT OF INTEGER DIGITS
;	   C   COUNT OF DECIMAL FRACTION DIGITS
;	   A   IF 1 START AT LOW NIBBLE, IF 0 START AT HIGH
;
;	ON EXIT:
;
;
BCDPS:	PUSH	BC		;SAVE COUNTS
	LD	E,A		;SAVE STARTING NIBBLE INDICATOR
	LD	A,C		;GET DECIMAL FRACTION COUNTT
	OR	B
	JP	NZ,BCPSX	;JUMP IF NUMBER IS ZERO
	LD	A,'0'		;ONLY A ZERO
	CALL	SPUSH
	LD	D,1
	JP	BCPS5
;
BCPSX:	LD	D,0		;ZERO OUT COUNT
	LD	A,(SGN1)	;GET SIGN OF RESULT
	OR	A
	JP	Z,BCPSY
;
	LD	A,'-'
	CALL	SPUSH		;PUSH A MINUS SIGN
	INC	D
;
BCPSY:	LD	A,(DJ)		;SEE IF A $J
	OR	A
	JP	Z,BCPS0
	LD	A,B		;SEE IF AN INTEGER PART
	OR	A
	JP	NZ,BCPS1
	LD	A,'0'
	CALL	SPUSH		;START WITH LEADING ZERO
	INC	D
	JP	BCPS4A
;
BCPS0:	LD	A,B		;GET NUMBER OF DIGITS
	OR	A
	JP	Z,BCPS4A
;
BCPS1:	LD	A,E		;GET NIBBLE INDICATOR
	OR	A
	JP	NZ,BCPSA
;
BCPS3:	LD	A,(HL)		;GET 2 DIGITS
	AND	0F0H		;LOOK AT HIGH NIBBLE
	RRA
	RRA
	RRA
	RRA
	OR	30H		;CONVERT TO CHARACTER
	INC	D
	CALL	SPUSH		;PUSH ON STACK
	DEC	B
	JP	Z,BCPS4
;
BCPSA:	LD	A,(HL)
	AND	0FH		;LOOK AT LOW NIBBLE
	OR	30H		;CONVERT TO CHARACTER
	INC	D
	CALL	SPUSH
	INC	HL
	DEC	B
	JP	NZ,BCPS3
	LD	E,0		;NEXT TIME AT HIGH NIBBLE
	JP	BCPS4A
;
BCPS4:	LD	E,1		;NEXT TIME AT LOW NIBBLE
BCPS4A:	LD	A,C		;CHECK FOR  DECIMAL FRACTION
	OR	A
	JP	Z,BCPS5
;
	LD	A,'.'
	CALL	SPUSH		;PUSH ON DECIMAL PLACE
	INC	D
	LD	B,C		;MOVE COUNT TO B
	LD	C,0		;AND FIX SO WE DON'T LOOP FOREVER
	JP	BCPS0
;
BCPS5:	POP	BC		;RESTORE ORIGINAL COUNTS
	LD	A,(DJ)		;CHECK IF $J
	OR	A
	JP	Z,BCPS7
;
	LD	A,(I6)		;GET NUMBER OF DECIMAL PLACES WANTED
	SUB	C
	LD	B,A		;B GETS NUMBER OF TRAILING ZEROS TO ADD
	JP	Z,BCPS7
;
	LD	A,C		;SEE IF DECIMAL PLACE PUSHED YET
	OR	A
	JP	NZ,BCPS6
;
	LD	A,'.'
	CALL	SPUSH
	INC	D
;
BCPS6:	LD	A,'0'
	CALL	SPUSH		;ADD TRAILING ZEROS
	INC	D
	DEC	B
	JP	NZ,BCPS6
;
BCPS7:	LD	A,D		;GET STRING LENGTH
	CALL	SPUSH
	LD	A,3		;IT'S A NUMERIC STRING
	CALL	SPUSH
	RET
;
;
SPUSH:	PUSH	HL
	PUSH	DE
	PUSH	BC
	CALL	CPUSH
	POP	BC
	POP	DE
	POP	HL
	RET
;
;
CRLF:	LD	A,CR		;WRITE OUT CARRIAGE RETURN
	CALL	TRMOT
	LD	A,LF		;AND LINE FEED
	CALL	TRMOT
	RET
;
;
WIPE:	LD	A,BS		;WIPE OUT PREVIOUS CHARACTER
	CALL	TRMOT
	LD	A,' '
	CALL	TRMOT
	LD	A,BS
	CALL	TRMOT
	RET
;
;
PTS:	LD	HL,(TPP)	;CONVERT POINTER VALUE IN TPP TO STACK #
	LD	DE,1000		;DIGIT WEIGHT
	LD	BC,0
;
PTS1:	LD	A,L		;SEE IF DIGIT FITS
	SUB	E
	LD	L,A
	LD	A,H
	SBC	A,D
	LD	H,A
	JP	C,PTS2		;JUMP IF NO ROOM
	INC	B		;ADD 1 TO DIGIT COUNT
	JP	PTS1
;
PTS2:	ADD	HL,DE		;TAKE CARE OF EXTRA SUBTRACT
	LD	A,B
	OR	C		;SEE IF A DIGIT
	JP	Z,PTS3
;
	LD	A,B
	OR	30H		;CONVERT TO CHARACTER
	CALL	SPUSH
	INC	C		;INCREMENT CHARACTER COUNT
PTS3:	LD	A,100
	CP	E		;SEE IF DONE
	JP	Z,PTS4
;
	LD	DE,100		;SET UP FOR NEXT DIGIT
	LD	B,0
	JP	PTS1
;
PTS4:	PUSH	DE		;SET UP FOR CTS
	PUSH	BC
	PUSH	AF
	LD	E,C
	LD	D,L
	JP	CTS3
;
;
DOLJ:	LD	HL,(TOS)	;$JUSTIFY TO # T-O-S
	DEC	HL
	DEC	HL		;TO LENGTH
	LD	A,(HL)
	LD	C,A		;SAVE LENGTH IN C
	CPL
	LD	E,A
	LD	D,0FFH
	INC	DE
	ADD	HL,DE
	LD	(TOS),HL	;TOS BELOW STRING
;
	LD	DE,OP1
	LD	B,BCDLN
	CALL	BCDPK		;PUT STRING # AS BCD IN OP1
;
	LD	(SGN1),A	;SAVE SIGN
	LD	A,(COUNT)
	LD	(DP1),A		;SAVE DECIMAL PLACE COUNT
	LD	B,A
;
	EX	DE,HL		;OP1 TO H,L
	LD	C,BCDLN
	CALL	GETNM		;GET TOTAL DIGITS IN NUMBER
	SUB	B		;GET INTEGER DIGIT COUNT
	JP	NC,DOL0
	XOR	A
DOL0:	LD	D,A		;SAVE IN D
;
	LD	A,(I6)		;GET DECIMAL PLACES TO ROUND TO
	CP	B
	JP	C,DOLJ1	;JUMP IF I6 < DP1
	LD	A,B
;
DOLJ1:	ADD	A,D		;GET TOTAL DIGITS
	CP	MAXDG		;SEE IF TOO MANY
	JP	C,DOLJ2
	LD	A,MAXDG
;
DOLJ2:	LD	C,A
	CALL	BCDRN		;ROUND IT
	CALL	BCDPS
	RET
;
;
NXTRN:	LD	HL,OP1		;GET NEXT RANDOM NUMBER
	LD	DE,RNDM
	LD	C,BCDLN
	CALL	BCDST
;
	LD	HL,OP2
	LD	DE,RNDML
	CALL	BCDST
;
	LD	DE,OP1
	CALL	BCDML		;GET RNDM * RNDML
;
	LD	HL,RNDM+(BCDLN-(RNMOD/2))
	LD	DE,TNUMB+(BCDLN-(RNMOD/2))
	LD	C,RNMOD/2
	CALL	BCDST		;SET RANDOM NUMBER TO INTEGER PART
;
	LD	HL,OP1+(BCDLN-INTLN)
	LD	DE,INT1
	LD	C,INTLN
	CALL	BCDST		;SET INT1 INTO OP1
;
	LD	HL,OP2
	LD	DE,RNDM
	LD	C,BCDLN
	CALL	BCDST		;SET OP2 TO RANDOM NUMBER SEED
;
	LD	DE,OP1
	CALL	BCDML
;
	LD	HL,TNUMB
	CALL	GETNM		;GET NUMBER OF DIGITS
	LD	B,A
	LD	A,BCDLN*2	;GET TOTAL POSSIBLE NUMBER OF DIGITS
	SUB	B
	RRA			;NUMBER OF BYTES TO START
	PUSH	AF		;SAVE CARRY (HIGH OR LOW NIBBLE)
;
	LD	E,A
	LD	D,0
	ADD	HL,DE		;H,L TO START OF NUMBER
;
	LD	A,B		;GET DIGITS IN NUMBER
	SUB	RNMOD
	JP	NC,NXTR0
	XOR	A
NXTR0:	LD	B,A		;SAVE NUMBER OF INTEGER DIGITS
	LD	C,0		;SET NUMBER OF DECIMAL DIGITS
;
	POP	AF		;GET HIGH OR LOW NIBBLE
	LD	A,0
	JP	NC,NXTR1
	INC	A
NXTR1:	CALL	BCDPS		;PUSH NUMBER
;
	RET
;
;
GETTI:	LD	HL,DOLH+10
	IN	A,(CLK+4)	;GET 1 SECOND
	LD	(HL),A
	LD	B,A		;SAVE FOR LATER ALSO
;
	DEC	HL
	IN	A,(CLK+5)	;GET 10 SECONDS
	LD	(HL),A
;
	DEC	HL
	IN	A,(CLK+6)	;GET 1 MINUTE
	LD	(HL),A
;
	DEC	HL
	IN	A,(CLK+7)	;GET 10 MINUTE
	LD	(HL),A
;
	DEC	HL
	IN	A,(CLK+8)	;GET 1 HOUR
	LD	(HL),A
;
	DEC	HL
	IN	A,(CLK+9)	;GET 10 HOUR
	LD	(HL),A
;
	DEC	HL
	IN	A,(CLK+10)	;GET 1 DAY
	LD	(HL),A
;
	DEC	HL
	IN	A,(CLK+11)	;GET 10 DAY
	LD	(HL),A
;
	DEC	HL
	IN	A,(CLK+12)	;GET 100 DAY
	LD	(HL),A
;
	DEC	HL
	IN	A,(CLK+13)	;GET 1000 DAY
	LD	(HL),A
;
	DEC	HL
	IN	A,(CLK+14)	;GET 10000 DAY
	LD	(HL),A
;
	IN	A,(CLK+4)	;GET SECONDS AGAIN
	XOR	B
	AND	0FH
	JP	NZ,GETTI	;TIME CHANGED SO GET IT AGAIN
;
	LD	HL,DOLH
	LD	DE,DAYS
	LD	BC,0505H
	CALL	BCDPK		;PACK DAYS
;
	LD	HL,DOLH+5
	LD	DE,SECS
	LD	BC,0502H
	CALL	BCDPK		;PACK HOURS
;
	LD	HL,RTNUM
	LD	DE,I60
	LD	C,5
	CALL	BCDST		;60 TO RTNUM
;
	LD	DE,SECS
	CALL	BCDML		;HOURS * 60 = MINUTES
;
	LD	HL,DOLH+7
	LD	DE,SECS
	LD	BC,0502H
	CALL	BCDPK		;PACK MINUTES
;
	LD	HL,TNUMB
	EX	DE,HL
	LD	C,5
	CALL	BCDAD		;MINUTES+60*HOURS
;
	LD	HL,RTNUM
	LD	DE,I60
	CALL	BCDST
;
	LD	DE,SECS
	CALL	BCDML		;MINUTES*60=SECONDS
;
	LD	HL,DOLH+9
	LD	DE,SECS
	LD	BC,0502H
	CALL	BCDPK		;PACK SECONDS
;
	LD	HL,TNUMB
	EX	DE,HL
	LD	C,5
	CALL	BCDAD		;ADD ON SECONDS
;
	RET
;
;
TIMTK:	LD	(HANDL),HL
	LD	HL,0
	JP	C,TIMT0
;
	ADD	HL,SP
	JP	TIMT1
TIMT0:	ADD	HL,SP
	SCF
;
TIMT1:	LD	SP,NEWST
	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
;
; CHECK IF TIMEOUT OR HANG
	LD	A,(WAIT)
	OR	A
	JP	Z,TIMT2
;
	LD	HL,DTIME
	LD	C,INTLN
	CALL	SUB1		;A TIMING SO SUBTRACT 1
	CALL	ZTEST		;SEE IF AT ZERO
	JP	NZ,TIMT2
;
	LD	A,TRUE		;TIMED OUT
	LD	(TIME),A
;
TIMT2:	POP	AF
	POP	BC
	POP	DE
	POP	HL
	LD	SP,HL
	LD	HL,(HANDL)
	EI
	RET
;
HANDL:	DEFS	2
	DEFS	30
NEWST	EQU	$
;
SSCHK:	PUSH	HL
	PUSH	DE
	PUSH	AF
	LD	HL,(TOS)	;CHECK IF ROOM ON SYNTAX STACK
	LD	DE,14		;ROOM FOR 7 PUSHES
	ADD	HL,DE
	EX	DE,HL
	LD	HL,0
	ADD	HL,SP		;GET SP
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,E19
	POP	AF
	POP	DE
	POP	HL
	RET
;
RDSEE:	CALL	SSCHK		;SET RANDOM SEED
RDS1:	LD	HL,RNDM		;POINT TO RANDOM NUMBER
	LD	C,BCDLN
	CALL	ADD1		;INCREMENT NUMBER
	LD	L,3		;SEE IF CHARACTER TYPED
	CALL	BIOS
	OR	A
	JP	Z,RDS1
	LD	HL,RNDM+BCDLN-1
	LD	A,(HL)
	AND	0F0H
	OR	1
	LD	(HL),A
	RET
;
;
CPUSH:	LD	HL,(TOS)	;PUSH (A) ONTO STACK
	LD	(HL),A
	INC	HL
	LD	(TOS),HL
	JP	PSH2		;CHECK FOR OVERFLOW
;
;
; CTI CONVERTS A CHARACTER (0-255) TO AN INTEGER
;
CTI:	PUSH	HL		;SAVE REGISTERS
	PUSH	BC
	PUSH	AF
;
	LD	C,INTLN-2
CTI1:	LD	(HL),0		;ZERO OUT START OF INTEGER
	INC	HL
	DEC	C
	JP	NZ,CTI1
;
CTI2:	SUB	100		;GET HUNDREDS DIGIT
	JP	C,CTI3
	INC	C
	JP	CTI2
;
CTI3:	ADD	A,100		;FIX UP EXTRA SUBTRACT
	LD	(HL),C		;SET HUNDREDS DIGIT
	LD	C,0
	INC	HL		;MOVE TO NEXT DIGITS
;
CTI4:	SUB	10		;GET TENS DIGIT
	JP	C,CTI5
	INC	C
	JP	CTI4
;
CTI5:	ADD	A,10		;FIX UP EXTRA SUBTRACT
	LD	B,A		;SAVE NUMBER
	LD	A,C		;GET TENS DIGIT
	RLCA
	RLCA
	RLCA
	RLCA			;TENS DIGIT IN CORRECT PLACE
;
	OR	B		;INCLUDE UNITS DIGIT
	LD	(HL),A		;SET IN INTEGER
;
	POP	AF		;RESTORE REGISTERS
	POP	BC
	POP	HL
	RET
;
;
; CTS CONVERTS A CHARACTER (0-255) TO A STRING ON THE STACK
;
CTS:	PUSH	DE		;SAVE REGISTERS
	PUSH	BC
	PUSH	AF
;
	LD	E,0		;STRING LENGTH
	LD	C,100		;GET HUNDREDS DIGIT
;
CTS0:	LD	B,0		;THE STRING CHARACTER
CTS1:	SUB	C
	JP	C,CTS2		;JUMP IF CONVERTED
	INC	B		;ADD 1 TO DIGIT
	JP	CTS1
;
CTS2:	ADD	A,C		;CORRECT FOR EXTRA SUBTRACTION
	LD	D,A		;SAVE WHAT'S LEFT OF CHARACTER
	LD	A,B		;GET DIGIT JUST DONE
	OR	E
	JP	Z,CTS3		;SKIP LEADING ZEROS
;
	LD	A,B
	OR	30H		;CONVERT TO ASCII DIGIT
	CALL	SPUSH
	INC	E		;COUNT UP LENGTH
;
CTS3:	LD	A,10
	CP	C		;SEE IF DONE
	JP	Z,CTS4
;
	LD	C,A		;DO TENS DIGIT NEXT
	LD	A,D		;PUT CHARACTER BACK
	JP	CTS0
;
CTS4:	LD	A,D		;GET CHARACTER BACK
	OR	30H		;CONVERT TO ASCII DIGIT
	CALL	SPUSH
	INC	E
;
	LD	A,E		;GET LENGTH
	CALL	SPUSH
	LD	A,3
	CALL	SPUSH
;
	POP	AF		;RESTORE REGISTERS
	POP	BC
	POP	DE
	RET
;
;
; ITC CONVERTS AN INTEGER TO A CHARACTER (0-255)
;
ITC:	PUSH	HL		;SAVE REGISTERS
	PUSH	DE
	PUSH	BC
;
	LD	A,FALSE
	LD	(RESUL),A	;SET RESULT JUST IN CASE
;
	LD	DE,I255
	LD	BC,INTLN*257
	CALL	SCMP		;COMPARE INTEGER AND 255
	JP	C,ITC5		;RETURN IF INTEGER > 255
;
	LD	B,0
	ADD	HL,BC
	DEC	HL		;H,L TO LEAST SIGNIFICANT BYTE
	LD	A,(HL)
	LD	B,A		;SAVE BYTE IN B
;
	AND	0FH		;GET UNITS DIGIT
	LD	C,A		;SAVE IN C
	LD	A,B
	AND	0F0H		;GET TENS DIGIT
	RRCA
	RRCA
	RRCA
	RRCA			;SHIFT DIGIT TO LOW NIBBLE
	LD	B,10
;
ITC1:	OR	A		;SEE IF NO DIGIT
	JP	Z,ITC3
	LD	E,A
	LD	A,C		;GET PREVIOUS SUM
;
ITC2:	ADD	A,B		;ADD IN DIGIT WEIGHT
	DEC	E
	JP	NZ,ITC2
;
	LD	C,A		;SAVE NEW SUM
ITC3:	LD	A,100
	CP	B		;SEE IF DONE
	JP	Z,ITC4
;
	LD	B,A		;SET UP FOR HUNDREDS DIGIT
	DEC	HL
	LD	A,(HL)		;GET HUNDREDS DIGIT
	JP	ITC1
;
ITC4:	LD	A,TRUE
	LD	(RESUL),A
;
	LD	A,C		;GET CHARACTER
ITC5:	POP	BC		;RESTORE REGISTERS
	POP	DE
	POP	HL
	RET
;
;
; ITS CONVERTS INTEGER TO STRING ON STACK
;
ITS:	LD	B,INTLN
	XOR	A
	LD	(SGN1),A	;SET SIGN +
	LD	A,(HL)		;GET FIRST BYTE
	AND	0F0H		;CHECK SIGN
	JP	Z,ITS1
	LD	A,1
	LD	(SGN1),A	;SET SIGN
	LD	A,(HL)
	AND	0FH		;CLEAR SIGN
	JP	ITS15
ITS1:	LD	A,(HL)		;FIND FIRST SIGNIFICANT DIGIT
	OR	A
ITS15:	JP	NZ,ITS2
	INC	HL
	DEC	B
	JP	NZ,ITS1
	LD	BC,0		;IT'S A ZERO
	JP	ITS3
;
ITS2:	LD	A,B		;GET BYTES LEFT IN NUMBER
	ADD	A,A		;CONVERT TO DIGITS
	LD	B,A		;AND SAVE
;
	LD	C,0		;NO DECIMAL PLACES
	LD	A,(HL)		;GET BYTE (2 DIGITS)
	AND	0F0H
	LD	A,0
	JP	NZ,ITS3		;JUMP IF SOMETHING IN HIGH NIBBLE
;
	INC	A		;SET LOW NIBBLE FLAG FOR BCDPS
	DEC	B		;REDUCE DIGIT COUNT
;
ITS3:	CALL	BCDPS		;PUSH NUMBER ON STACK
	RET
;
;
JDEN:	LD	C,3
JDEN1:	LD	A,(DE)
	CP	(HL)
	RET	NZ
	INC	HL
	INC	DE
	DEC	C
	JP	NZ,JDEN1
	RET
;
JPEN:	LD	A,L		;COMPARE POINTERS
	SUB	E
	LD	L,A
	LD	A,H
	SBC	A,D
	OR	L
	RET
;
JSE:	LD	A,C		;COMPARE STRINGS
	OR	A
	RET	Z
JSE1:	LD	A,(DE)
	CP	(HL)
	RET	NZ
	INC	HL
	INC	DE
	DEC	C
	JP	NZ,JSE1
	RET
;
LIST:	LD	E,A
	LD	C,LISTF
	CALL	BDOS
	RET
;
MOVE:	LD	A,B
	OR	A		;CHECK IF ZERO
	RET	Z
MV1:	LD	A,(DE)		;MOVE STRINGS
	LD	(HL),A
	INC	DE
	INC	HL
	DEC	B
	JP	NZ,MV1
	RET
;
MSG:	LD	A,(HL)		;PRINT FROM H,L TO 0
	OR	A
	RET	Z
	CALL	TRMOT
	INC	HL
	JP	MSG
;
;
; NTS CONVERTS A NUMBER TO A STRING T-O-S
;
NTS:	DEC	HL		;MOVE TO SIGN
	LD	A,(HL)
	LD	(SGN1),A
	DEC	HL
	LD	C,(HL)		;SET DECIMAL DIGITS
	DEC	HL
	LD	B,(HL)		;SET INTEGER DIGITS
;
	LD	A,C
	ADD	A,B		;GET TOTAL DIGITS
	RRA			;GET TOTAL BYTES
	PUSH	AF		;SAVE CARRY
;
	LD	E,A
	LD	A,BCDLN
	SUB	E		;GET STARTING BYTES
	ADD	A,3		;BECAUSE BACKED UP
	LD	E,A
	LD	D,0
	ADD	HL,DE		;SHIFT H,L OVER
;
	POP	AF
	LD	A,0		;GET READY FOR HI/LO NIBBLE
	JP	NC,NTS1
	DEC	HL		;BACK UP TO LOW NIBBLE
	INC	A
;
NTS1:	CALL	BCDPS		;PUSH #
	RET
;
;
POPIT:	LD	E,B
	LD	D,0
	ADD	HL,DE
	DEC	HL
	EX	DE,HL		;POP OFF B CHARACTERS
	LD	HL,(TOS)	;MOVE POINTER TO LEAST SIGNIFICANT PART
	DEC	HL
POP1:	LD	A,(HL)		;TAKE CHARS--ONE AT A TIME
	LD	(DE),A
	DEC	DE
	DEC	HL
	DEC	B
	JP	NZ,POP1
	INC	HL
	LD	(TOS),HL	;SAVE T-O-S
	RET
;
PSUB:	LD	A,L		;SUBTRACT POINTERS
	SUB	E
	LD	L,A
	LD	A,H
	SBC	A,D
	LD	H,A
	RET
;
PUSHT:	EX	DE,HL		;PUSH B CHARACTERS ON STACK
	LD	HL,(TOS)
PSH1:	LD	A,(DE)
	LD	(HL),A
	INC	HL
	INC	DE
	DEC	B
	JP	NZ,PSH1
	LD	(TOS),HL
PSH2:	EX	DE,HL		;CHECK FOR OVERFLOW
	LD	HL,0
	ADD	HL,SP
	LD	A,L
	SUB	E
	LD	A,H
	SBC	A,D
	JP	C,E1
	RET
;
SETD:	LD	C,3		;SET DISK BLOCK VALUE
	JP	SETI1
;
;
SETI:	LD	C,5		;SET INTEGER VALUE
SETI1:	LD	A,(DE)
	LD	(HL),A
	INC	DE
	INC	HL
	DEC	C
	JP	NZ,SETI1
	RET
;
;
; SHFD SHIFTS THE STACK DOWN TOWARDS ITS BASE
;
SHFD:	PUSH	HL		;SAVE REGISTERS
	PUSH	DE
	PUSH	BC
	PUSH	AF
;
	LD	C,A		;SAVE COUNT
;
SHFD1:	LD	A,C		;GET COUNT
	OR	A
	JP	Z,SHFD2
	LD	A,(HL)		;GET A BYTE
	LD	(DE),A		;AND SAVE IT
	INC	DE
	INC	HL
	DEC	C
	JP	SHFD1
;
SHFD2:	EX	DE,HL
	LD	(TOS),HL	;SAVE NEW TOS
;
	POP	AF		;RESTORE REGISTERS
	POP	BC
	POP	DE
	POP	HL
	RET
;
;
; SHFU SHIFT THE STACK TOWARDS THE TOP
;
SHFU:	PUSH	AF		;SAVE REGISTERS
	PUSH	BC
;
	LD	B,0
	LD	C,A
	ADD	HL,BC
	DEC	HL		;H,L TO FIRST ONE TO GET
	EX	DE,HL
	ADD	HL,BC
;
	LD	(TOS),HL
	OR	A		;SEE IF NO CHARACTERS TO MOVE
	JP	Z,SHFU2
;
	CALL	SSCHK		;SEE IF ROOM
;
	DEC	HL		;H,L TO FIRST PLACE TO PUT
;
SHFU1:	LD	A,(DE)
	LD	(HL),A
	DEC	HL
	DEC	DE
	DEC	C
	JP	NZ,SHFU1
;
	INC	HL
SHFU2:	POP	BC		;RESTORE REGISTERS
	POP	AF
	INC	DE
	EX	DE,HL
	RET
;
;
; STC0 CONVERTS A STRING ON T-O-S TO A CHARACTER (0-255)
;
STC0:	PUSH	HL		;SAVE REGISTERS
	PUSH	DE
	PUSH	BC
;
	LD	HL,(TOS)	;H,L POINTS ABOVE STACK
	DEC	HL		;H,L TO THE 3
	DEC	HL		;H,L TO THE LENGTH
	LD	A,(HL)		;GET LENGTH
;
	PUSH	HL		;SAVE LENGTH
	LD	E,A
	CPL			;FORM 2'S COMPLEMENT
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC		;H,L TO START OF STRING
	LD	(TOS),HL	;SET NEW TOS POINTER
;
	POP	HL		;GET END OF STRING
	LD	A,FALSE
	LD	(RESUL),A
;
	LD	A,E		;GET LENGTH
	OR	A
	JP	Z,STC5		;DONE--NULL STRING
	CP	4
	JP	NC,STC5		;DONE--TOO LONG
;
	DEC	HL		;MOVE H,L TO UNITS DIGIT
	LD	A,(HL)
	AND	0FH		;GET UNITS DIGIT
	LD	D,A
;
	DEC	E		;DECREMENT LENGTH
	JP	Z,STC4		;JUMP IF DONE
	LD	C,10
;
STC1:	DEC	HL		;MOVE TO NEXT DIGIT
	LD	A,(HL)
	AND	0FH		;STRIP ASCII BIAS
	JP	Z,STC3
;
	LD	B,A
	LD	A,D		;GET DIGIT WEIGHT
;
STC2:	ADD	A,C
	JP	C,STC5		;JUMP IF OVERFLOW
	DEC	B
	JP	NZ,STC2
;
	LD	D,A		;SAVE CHARACTER SO FAR
STC3:	DEC	E
	JP	Z,STC4		;JUMP IF DONE
;
	LD	C,100
	JP	STC1
;
STC4:	LD	A,TRUE
	LD	(RESUL),A
	LD	A,D		;GET RESULT
;
STC5:	POP	BC		;RESTORE REGISTERS
	POP	DE
	POP	HL
	RET
;
;
; STI CONVERTS STRING ON T-O-S TO INTEGER
;
STI:	PUSH	AF		;SAVE REGISTERS
	PUSH	DE
	PUSH	BC
	PUSH	HL
;
	LD	HL,(TOS)
	DEC	HL		;H,L TO 3
	DEC	HL		;H,L TO LENGTH
	LD	A,(HL)
	LD	C,A
;
	CPL			;FORM 2'S COMPLEMENT OF LENGTH
	LD	E,A
	LD	D,0FFH
	INC	DE
	ADD	HL,DE
	LD	(TOS),HL	;NEW TOS POINTER
;
	POP	DE		;GET INTEGER START
	LD	B,INTLN
	CALL	BCDPK
;
	OR	A		;CHECK SIGN
	JP	Z,STI1
	LD	A,(DE)
	OR	0F0H		;SET SIGN
	LD	(DE),A
STI1:	EX	DE,HL
	POP	BC		;RESTORE REGISTERS
	POP	DE
	POP	AF
	RET
;
;
; STN CONVERTS STRING T-O-S TO A NUMERIC
;
STN:	PUSH	HL		;SAVE REGISTERS
	PUSH	DE
	PUSH	BC
	PUSH	AF
;
	EX	DE,HL
	LD	HL,(TOS)
	DEC	HL		;TO 3
	DEC	HL		;TO LENGTH
	LD	A,(HL)
	PUSH	AF		;SAVE LENGTH
;
	CPL			;GET 2'S COMPLEMENT
	LD	C,A
	LD	B,0FFH
	INC	BC
	ADD	HL,BC
	LD	(TOS),HL
;
	POP	AF		;GET LENGTH BACK
	LD	C,A
	LD	B,BCDLN
	CALL	BCDPK
;
	DEC	DE
	LD	(DE),A		;SAVE SIGN
	DEC	DE
	LD	A,(COUNT)	;NUMBER OF DECIMAL PLACES
	LD	(DE),A
	DEC	DE
	LD	B,A
	OR	A		;CHECK IF DECIMAL PLACES
	JP	Z,STN1		;JUMP IF NONE
	DEC	C		;DON'T COUNT '.'
STN1:	LD	A,C
	SUB	B		;GET INTEGER DIGITS
	LD	(DE),A
;
	POP	AF		;RESTORE REGISTERS
	POP	BC
	POP	DE
	POP	HL
	RET
;
;
TRMIN:	LD	HL,BDATA	;READ FROM TERMINAL
	LD	BC,0		;B IS RUBOUT FLAG, C IS COUNT
;
TRM1:	PUSH	HL		;SAVE REGISTERS
	PUSH	DE
	PUSH	BC
	LD	L,6
	CALL	BIOS		;READ A CHARACTER
	POP	BC		;RESTORE REGISTERS
	POP	DE
	POP	HL
;
	CP	CR		;SEE IF DONE
	JP	NZ,TRM05
TRM01:	LD	A,C
	LD	(RLENG),A
	RET
;
TRM05:	CP	RUB		;A RUBOUT?
	JP	NZ,TRM0
;
	LD	A,C		;GET COUNT
	OR	A
	JP	Z,TRM1		;IF AT START IGNORE
;
	LD	A,B
	OR	A
	JP	NZ,TRM15	;SEE IF RUBOUT FLAG SET
;
	LD	A,'\'
	CALL	TRMOT		;WRITE A \
TRM15:	DEC	C		;BACK UP
	DEC	HL
	LD	A,(HL)		;GET CHARACTER
	CP	CTRLI
	JP	NZ,TRM16
	LD	A,' '
TRM16:	CALL	TRMOT		;ECHO CHARACTER BACKED OVER
	LD	B,1		;SET RUBOUT FLAG
	JP	TRM1
;
TRM0:	CP	' '		;SEE IF CONTROL CHARACTER
	JP	NC,TRM7
;
	CP	CTRLI
	JP	Z,TRM7
;
	CP	CTRLC
	JP	Z,ERR24	;RE-INITIALIZE MUMPS
;
	CP	CTRLE
	JP	NZ,TRM2
	CALL	CRLF		;WRITE CR-LF
	JP	TRM1
;
TRM2:	CP	CTRLH
	JP	NZ,TRM3
	LD	A,C		;SEE IF ROOM TO BACK UP
	OR	A
	JP	Z,TRM1
;
	CALL	WIPE		;WIPE OUT PREVIOUS CHARACTER
	DEC	HL
	DEC	C
	JP	TRM1
;
TRM3:	CP	CTRLR
	JP	NZ,TRM4
	CALL	CRLF
	LD	(HL),0		;MARK END OF BUFFER
	EX	DE,HL
	LD	HL,BDATA
	CALL	MSG		;WRITE OUT BUFFER
	EX	DE,HL
	JP	TRM1
;
TRM4:	CP	CTRLU
	JP	NZ,TRM5
	CALL	CRLF
	JP	TRMIN		;START OVER
;
TRM5:	CP	CTRLX
	JP	NZ,TRM61	;IGNORE OTHER CONTROL CHARACTERS
	LD	A,C
	OR	A		;SEE IF AT START
	JP	Z,TRM1
TRM6:	CALL	WIPE		;WIPEOUT PREVIOUS CHARACTER
	DEC	C
	JP	NZ,TRM6
	JP	TRMIN
;
TRM61:	CP	CTRLP
	JP	NZ,TRM1
	LD	A,(PTOGL)
	XOR	1
	LD	(PTOGL),A
	JP	TRM1
;
TRM7:	LD	E,A
	LD	A,B		;CHECK RUBOUT FLAG
	OR	A
	JP	Z,TRM8
;
	LD	B,0		;RESET RUBOUT FLAG
	LD	A,'\'
	CALL	TRMOT
TRM8:	LD	A,E
	CP	CTRLI		;SEE IF LS
	JP	NZ,TRM9
;
	LD	A,' '
TRM9:	CALL	TRMOT		;ECHO CHARACTER
	INC	C
	LD	(HL),E
	LD	A,255
	CP	C		;SEE IF BUFFER FULL
	JP	Z,TRM01	;IF SO GET OUT
	INC	HL
	JP	TRM1
;
;
TRMOT:	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	CALL	INCHK
	LD	A,(STOGL)	;SEE IF WANT TO WAIT
	OR	A
	JP	Z,TRMO1
	LD	L,6		;WAIT FOR CHARACTER (ANY)
	CALL	BIOS
	XOR	A
	LD	(STOGL),A	;RESET WAIT TOGGLE
TRMO1:	POP	AF		;GET CHAR BACK
	PUSH	AF
	LD	L,9		;WRITE CHAR OUT
	LD	C,A
	CALL	BIOS
;
	POP	AF
	LD	C,A
	LD	A,(PTOGL)	;CHECK PRINT TOGGLE
	OR	A
	JP	Z,TRMO2
;
	LD	L,12
	CALL	BIOS
;
TRMO2:	POP	BC
	POP	DE
	POP	HL
	RET
;
;
; THE START OF GLOBAL HANDLING ROUTINES
;
;
RECSE:	LD	HL,(GREC+1)
	ADD	HL,HL		;* 2
	ADD	HL,HL		;* 4
	LD	(GLFCB+33),HL	;SET RANDOM RECORD NUMBER
	LD	HL,GLFCB+35
	LD	(HL),0
	RET
;
;
GREED:	CALL	SSCHK
	CALL	RECSE
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	CALL	RDBLK
	RET
;
;
GWRIT:	CALL	SSCHK
	CALL	RECSE
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	CALL	WTBLK
	CALL	RECSE
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	CALL	WTBLK
	LD	HL,GLFCB
	LD	(FCB),HL
	LD	A,(GLBDR)
	LD	(DRIVE),A
	CALL	FCLOS
	RET
;
;
ALLOC:	LD	HL,0		;START AT BLOCK 0
	LD	A,1
	LD	(T1),A		;FIRST TIME THROUGH
	LD	A,(MAPSZ)
	LD	(TMPSZ),A
	LD	DE,0		;HOW FAR INTO THE BIT IS
ALL0:	LD	(GREC+1),HL
	XOR	A
	LD	(GREC),A
	PUSH	HL		;SAVE CURRENT BLOCK
	PUSH	DE		;SAVE HOW FAR IN
	CALL	GREAD		;READ IN A MAP BLOCK
;
	LD	BC,BLKSZ	;LOAD BLOCK SIZE
	LD	HL,(GLBUF)
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL		;H,L HAS START OF BUFFER
	LD	A,(T1)		;SEE IF FIRST BLOCK
	OR	A
	JP	Z,ALL05	;IF NOT THE FIRST TIME IGNORE SKIP
	DEC	BC		;SKIP OVER STARTING STUFF
	DEC	BC
	DEC	BC
	DEC	BC
	LD	DE,GVLEN+SHTLN
	ADD	HL,DE
ALL05:	POP	DE		;RESTORE HOW FAR IN
ALL1:	LD	A,(HL)
	OR	A		;LOOK FOR NON-ZERO
	JP	NZ,ALL2		;(MEANS BLOCK AVAILABLE)
	INC	HL
	INC	DE		;INCREMENT WORD COUNT
	DEC	BC		;DECREMENT SIZE LEFT
	LD	A,C
	OR	B		;SEE IF SIZE LEFT IS ZERO
	JP	Z,ALL15	;NO ROOM IN THIS BLOCK, TRY NEXT
	JP	ALL1
ALL15:	LD	HL,TMPSZ
	DEC	(HL)
	LD	A,(HL)
	OR	A
	JP	Z,E37		;NO DISK ROOM
	XOR	A
	LD	(T1),A		;ALREADY THROUGH ONCE
	POP	HL		;RESTORE CURRENT BLOCK NUMBER
	INC	HL
	JP	ALL0
ALL2:	POP	BC		;GET RID OF CURRENT BLOCK
	LD	BC,0
	EX	DE,HL
ALL3:	RLCA			;GET WHICH BIT WITHIN THE WORD
	JP	C,ALL4
	INC	BC
	JP	ALL3
ALL4:	ADD	HL,HL		;NOW GET WHICH BIT THIS WAS
	ADD	HL,HL		;* 4
	ADD	HL,HL		;* 8
	ADD	HL,BC		;ADD IN THE BITS
	LD	(GREC+1),HL	;SET GREC
	XOR	A
	LD	(GREC),A
	SCF
	EX	DE,HL		;RESTORE LOCATION IN TABLE
	INC	C
ALL5:	RRA			;SET UP MASK
	DEC	C
	JP	NZ,ALL5
	CPL
	AND	(HL)		;RESET BIT IN MAP
	LD	(HL),A
	LD	HL,(GLDRT)	;MARK BUFFER DIRTY
	LD	(HL),1
	RET
;
;
DEALL:	LD	HL,(GREC+1)	;GET BLOCK # TO GIVE BACK
	PUSH	HL		;SAVE CURRENT BLOCK
	LD	BC,32		;ADJUST FOR STUFF IN FIRS BLOCK
	ADD	HL,BC
	LD	A,H		;GET WHICH BLOCK WE NEED TO READ IN
	AND	0F0H
	RRCA
	RRCA
	RRCA
	RRCA
	PUSH	HL		;SAVE H,L FOR A BEFORE PICTURE
	LD	L,A		;THE BLOCK NUMBER
	LD	H,0
	LD	(GREC+1),HL
	XOR	A
	LD	(GREC),A
	CALL	GREAD
	POP	HL		;RESTORE H,L NOW THAT WE HAVE THE BLOCK READ
	LD	A,H
	AND	0FH		;WIPE OUT BLOCK NUMBER
	LD	H,A
	LD	A,L		;GET LOW BYTE
	AND	7		;GET LOW 3 BITSV
	LD	E,A		;SAVE IT (BIT #)
	LD	B,3		;# TO SHIFT
DEA1:	XOR	A		;CLEAR CARRY
	LD	A,H		;ROTATE H,L SO IT HAS THE BYTE
	RRA
	LD	H,A
	LD	A,L
	RRA
	LD	L,A
	DEC	B
	JP	NZ,DEA1
	XOR	A
	SCF
	INC	E
DEA2:	RRA			;NOW SET UP MASK
	DEC	E
	JP	NZ,DEA2
	EX	DE,HL		;MOVE OFFSET TO D,E
	LD	HL,(GLBUF)
	LD	C,(HL)
	INC	HL
	LD	B,(HL)		;B,C HAS THE START OF THE BUFFER
	EX	DE,HL		;H,L AS OFFSET
	ADD	HL,BC
	OR	(HL)		;SET BIT IN MAP
	LD	(HL),A
	LD	HL,(GLDRT)	;BUFFER HAS CHANGED
	LD	(HL),1
	POP	HL		;RESTORE BLOCK # THAT WAS JUST WIPED OUT
	LD	(GREC+1),HL
	XOR	A
	LD	(GREC),A
	CALL	GREAD		;MAKE THAT BLOCK CURRENT
	LD	HL,(GLBNO)
	LD	DE,NIL
	CALL	SETD
	LD	HL,(GLDRT)
	LD	(HL),0
	RET
;
;
RDBLK:	LD	L,READF
	JP	BLKIO
WTBLK:	LD	L,WRITF
BLKIO:	LD	A,(GLBDR)
	INC	A
	LD	(GLFCB),A
	LD	B,4		;NUMBER OF SECTORS IN A BLOCK
BLK1:	LD	C,DMAF
	PUSH	DE
	PUSH	BC
	PUSH	HL
	CALL	BDOS		;SET DMA ADDRESS
	POP	HL
	POP	BC
	PUSH	BC
	PUSH	HL
	LD	A,4
	CP	B		;SEE IF FIRST TIME THROUGH
	LD	A,L		;GET READ/WRITE FUNCTION NUMBER
	JP	NZ,BLK2		;JUMP IF NOT FIRST TIME
	ADD	A,13		;MAKE THE FUNCTION A RANDOM READ/WRITE
BLK2:	LD	C,A		;SET THE FUNCTION IN C
	LD	DE,GLFCB
	CALL	BDOS		;DO THE READ/WRITE
	OR	A
	JP	NZ,E39
	POP	HL
	POP	BC
	POP	DE
	PUSH	HL
	LD	A,4
	CP	B		;SEE IF FIRST TIME THROUGH
	JP	NZ,BLK3		;JUMP IF NOT FIRST TIME
	LD	HL,GLFCB+32
	INC	(HL)		;INCREMENT RECORD COUNT SINCE RANDOMS DON'T
BLK3:	LD	HL,128		;GET NEXT SECTOR ADDRESS
	ADD	HL,DE
	EX	DE,HL
	POP	HL
	DEC	B
	JP	NZ,BLK1
	RET
;
;
SERCH:	CALL	SSCHK		;SEARCH FOR NAMES (VIEW 3)
	LD	A,TRUE
	LD	(RESUL),A
;
	LD	C,DMAF
	LD	DE,80H
	CALL	BDOS
;
	LD	DE,SRFCB
	LD	A,(RTDRV)
	INC	A
	LD	(DE),A		;SELECT DRIVE
;
	LD	C,SERCF
	LD	A,(IT)
	ADD	A,C
	LD	C,A
	CALL	BDOS		;SEARCH FIRST OR NEXT (IT TAKES CARE OF IT)
;
	CP	0FFH
	JP	NZ,SERC1
	LD	A,FALSE
	LD	(RESUL),A
	RET
;
SERC1:	LD	HL,80H
	ADD	A,A		; * 2
	ADD	A,A		; * 4
	ADD	A,A		; * 8
	ADD	A,A		; * 16
	ADD	A,A		; * 32
	LD	E,A
	LD	D,0
	ADD	HL,DE		; H,L TO FCB START
	INC	HL		;H,L TO NAME START
	LD	(PTR),HL
	RET
;
;
FSEAR:	CALL	SSCHK
	CALL	FCBIT
	LD	C,DMAF
	LD	DE,80H
	CALL	BDOS
	LD	HL,(FCB)
	LD	A,(DRIVE)
	INC	A
	LD	(HL),A		;SELECT DRIVE
	EX	DE,HL
	LD	C,SERCF
	CALL	BDOS
	INC	A
	JP	NZ,SEAR1
	LD	(RESUL),A	;NO MATCH
	RET
SEAR1:	LD	A,1		;A MATCH
	LD	(RESUL),A
	RET
;
;
MAKE:	CALL	SSCHK
	LD	HL,(FCB)
	LD	A,(DRIVE)
	INC	A
	LD	(HL),A		;SELECT DRIVE
	EX	DE,HL
	LD	C,MAKEF
	CALL	BDOS
	INC	A
	RET	NZ
	JP	E9		;DIRECTORY FULL
;
;
FWRIT:	CALL	SSCHK
	LD	HL,(BUFFR)
	EX	DE,HL
	LD	C,DMAF
	CALL	BDOS
	LD	HL,(FCB)
	LD	A,(DRIVE)
	INC	A
	LD	(HL),A		;SELECT DRIVE
	LD	B,5		;# OF RETRIES
FWRT1:	LD	HL,(FCB)
	EX	DE,HL
	LD	C,WRITF
	PUSH	BC
	CALL	BDOS
	OR	A
	POP	BC
	RET	Z
	DEC	B
	JP	Z,E37		;WRITE ERROR
	LD	L,15H		;HOME DRIVE
	CALL	BIOS
	JP	FWRT1
	RET
;
;
FCLOS:	CALL	SSCHK
	LD	HL,(FCB)
	LD	A,(DRIVE)
	INC	A
	LD	(HL),A		;SELECT DRIVE
	EX	DE,HL
	LD	C,CLOSF
	CALL	BDOS
	RET
;
;
FOPEN:	CALL	SSCHK
	CALL	FCBIT		;SET UP FCB
FOPPL:	LD	HL,(FCB)
	LD	A,(DRIVE)
	INC	A
	LD	(HL),A		;SELECT DRIVE
	EX	DE,HL
	LD	C,OPENF
	CALL	BDOS
	INC	A
	RET	NZ
	LD	A,(FCBTY)	;SEE IF ROUTINE OR GLOBAL
	OR	A
	JP	NZ,E38		;ROUTINE NOT IN LIBRARY
	JP	E37		;NO GLOBALS
;
;
FREAD:	CALL	SSCHK
	LD	HL,(BUFFR)
	EX	DE,HL
	LD	C,DMAF
	CALL	BDOS
	LD	HL,(FCB)
	LD	A,(DRIVE)
	INC	A
	LD	(HL),A		;SELECT DRIVE
	EX	DE,HL
	LD	C,READF		;READ BUFFER FULL
	CALL	BDOS
	CP	0		;NORMAL READ?
	RET	Z
	CP	1		;EOF?
	RET	Z
	JP	E39		;READ ERROR
;
;
REMOV:	CALL	SSCHK
	LD	HL,(FCB)
	LD	A,(DRIVE)
	INC	A
	LD	(HL),A		;SELECT DRIVE
	EX	DE,HL
	LD	C,REMF
	CALL	BDOS
	RET
;
;
BRK:	XOR	A		;SEE IF A CHARACTER IS THERE
	LD	(I1),A
	CALL	SSCHK
	LD	C,BRAKF
	CALL	BDOS
	RRCA
	RET	NC
	LD	A,1
	LD	(I1),A
	RET
;
;
READC:	CALL	SSCHK		;READ A CHARACTER
	LD	C,RD1F
	CALL	BDOS
	LD	(CHR),A
	RET
;
;
FCBIT:	LD	A,(FCBTY)	;SET UP FCB FROM NAME ON STACK
	OR	A
	JP	NZ,FCBA		;GLOBALS?
	LD	HL,GLFCB
	LD	(FCB),HL
	RET
FCBA:	CP	1
	JP	NZ,FCBB		;ROUTINE?
	LD	HL,RTFCB
	JP	FCB0
FCBB:	LD	HL,(DEVPM)	;EXTERNAL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
FCB0:	LD	(FCB),HL
	LD	HL,(TOS)
	DEC	HL
	LD	C,(HL)		;SIZE TO C
	LD	A,C
	CPL
	LD	E,A
	LD	D,0FFH
	INC	DE
	ADD	HL,DE
	LD	(TOS),HL	;TOS NOW BELOW NAME
	LD	HL,(FCB)
	EX	DE,HL
	LD	HL,(TOS)
	XOR	A
	LD	(DE),A		;ZERO FIRST BYTE
	PUSH	DE		;SAVE FCB PLACE
	INC	DE
	LD	B,11
	LD	A,' '		;BLANK OUT NAME PLACE
FCBC:	LD	(DE),A
	INC	DE
	DEC	B
	JP	NZ,FCBC
	OR	B		;SEE IF DONE
	JP	Z,FCBD
	LD	B,21
	XOR	A
	JP	FCBC
FCBD:	POP	DE		;RESTORE FCB PLACE
	LD	B,NAMLN-1
FCB1:	INC	DE		;NAME TO FCB
	LD	A,(HL)
	CP	'.'		;FILE TYPE?
	JP	Z,FCB2
	INC	HL
	LD	(DE),A
	DEC	C
	JP	Z,FCB3
	DEC	B
	JP	NZ,FCB1
	JP	FCB3
FCB2:	INC	HL		;SKIP .
	DEC	C
	PUSH	BC
	LD	C,B
	LD	B,0
	EX	DE,HL
	ADD	HL,BC
	EX	DE,HL
	DEC	DE
	POP	BC
	LD	B,3
	JP	FCB1
FCB3:	LD	A,(FCBTY)	;CHECK FCB TYPE
	CP	2
	RET	Z
	LD	C,B
	LD	B,0
	EX	DE,HL
	ADD	HL,BC
	LD	(HL),'M'
	INC	HL
	LD	(HL),'M'
	INC	HL
	LD	(HL),'P'
	RET
;
;
ASROU:	RET
;
;*************************************************************
;*
;*  INSERT ASSEMBLY LANGUAGE ROUTINES HERE
;*
;*************************************************************
;
;
PTR:	DEFB	0,0
PTR1:	DEFB	0,0
PTR2:	DEFB	0,0
PTR3:	DEFB	0,0
PTR4:	DEFB	0,0
PTR5:	DEFB	0,0
PTR6:	DEFB	0,0
PTR7:	DEFB	0,0
PTR8:	DEFB	0,0
PTR9:	DEFB	0,0
PTRA:	DEFB	0,0
PTRB:	DEFB	0,0
PTRX:	DEFB	0,0
PTRX1:	DEFB	0,0
PTRX2:	DEFB	0,0
PPTR2:	DEFB	0,0
PPTR4:	DEFB	0,0
SNMPT:	DEFB	0,0
SVLPT:	DEFB	0,0
SBSIZ:	DEFB	0,0
UBSZ:	DEFB	0,0
PT1:	DEFB	0,0
NAME:	DEFB	0,0
TNAME:	DEFB	0,0
TPP:	DEFB	0,0
TP1:	DEFB	0,0
VSZ:	DEFB	0,0
SETBS:	DEFB	0,0
TPTR:	DEFB	0,0
TTPTR:	DEFB	0,0
LAST:	DEFB	0,0
DP:	DEFB	0,0
AP:	DEFB	0,0
LPTR:	DEFB	0,0
SPTR:	DEFB	0,0
TOP:	DEFB	0,0
LOC:	DEFB	0,0
TGP:	DEFB	0,0
BSIZE:	DEFB	0,0
ADJ:	DEFB	0,0
GPTR:	DEFB	0,0
PLEN:	DEFB	0,0
NLEN:	DEFB	0,0
SDP:	DEFB	0,0
SSDP:	DEFB	0,0
SBOS:	DEFB	0,0
NSTOS:	DEFB	0,0
NEXTP:	DEFB	0,0
NLAST:	DEFB	0,0
NSIZE:	DEFB	0,0
NPTR:	DEFB	0,0
FCB:	DEFB	0,0
DEVOP:	DEFB	0,0
DEVRD:	DEFB	0,0
DEVPM:	DEFB	0,0
DEVX:	DEFB	0,0
DEVY:	DEFB	0,0
DVBSZ:	DEFB	0,0
DVBST:	DEFB	0,0
DVPTR:	DEFB	0,0
DVBSU:	DEFB	0,0
BUFFR:	DEFB	0,0
GLBNO:	DEFB	0,0
GLAGE:	DEFB	0,0
GLDRT:	DEFB	0,0
GLBUF:	DEFB	0,0
GLCNT:	DEFB	0,0
NMPTR:	DEFB	0,0
VLPTR:	DEFB	0,0
TRAIL:	DEFB	0,0
FPTR:	DEFB	0,0
TARPT:	DEFB	0,0
BASE:	DEFB	0,0
IPTR:	DEFB	0,0
VPTR:	DEFB	0,0
TOPTR:	DEFB	0,0
REM:	DEFB	0,0
BKPTR:	DEFB	0,0
GLBTA:	DEFB	0,0
DRBUF:	DEFB	0,0
USTAK:	DEFB	0,0
;
GREC:	DEFB	0,0,0
GRCC1:	DEFB	0,0,0
GRCC2:	DEFB	0,0,0
GRCC3:	DEFB	0,0,0
GRCC4:	DEFB	0,0,0
GRCX:	DEFB	0,0,0
GRCY:	DEFB	0,0,0
GRCZ:	DEFB	0,0,0
ROOT:	DEFB	0,0,0
GRECA:	DEFB	0,0,0
GRECB:	DEFB	0,0,0
GRECC:	DEFB	0,0,0
SGREC:	DEFB	0,0,0
TGREC:	DEFB	0,0,0
GRCXX:	DEFB	0,0,0
;
TIMF:	DEFB	0
GLOPN:	DEFB	0
TST:	DEFB	0
TST1:	DEFB	0
STCNT:	DEFB	0
NLENG:	DEFB	0
SLENG:	DEFB	0
CHR:	DEFB	0
STYPE:	DEFB	0
COUNT:	DEFB	0
COLD:	DEFB	0
SETF:	DEFB	0
SETSW:	DEFB	0
DT:	DEFB	0
FORFL:	DEFB	0
DJ:	DEFB	0
DN:	DEFB	0
DOR:	DEFB	0
KILF:	DEFB	0
GOTOF:	DEFB	0
ENDF:	DEFB	0
FNDF:	DEFB	0
GTYPE:	DEFB	0
GARL:	DEFB	0
RDF:	DEFB	0
INF:	DEFB	0
VF:	DEFB	0
PF:	DEFB	0
PATF:	DEFB	0
PLENG:	DEFB	0
GLB:	DEFB	0
TYPE:	DEFB	0
DSF:	DEFB	0
LEVEL:	DEFB	0
I0:	DEFB	0
I1:	DEFB	0
I2:	DEFB	0
I3:	DEFB	0
I4:	DEFB	0
I5:	DEFB	0
I6:	DEFB	0
I7:	DEFB	0
I9:	DEFB	0
II:	DEFB	0
IT:	DEFB	0
ITX:	DEFB	0
N:	DEFB	0
CN:	DEFB	0
SN:	DEFB	0
TN:	DEFB	0
FNC:	DEFB	0
SCNT:	DEFB	0
SSCNT:	DEFB	0
SSUB:	DEFB	0
SDVC:	DEFB	0
NSUBS:	DEFB	0
NMSZ:	DEFB	0
NR:	DEFB	0
FLG1:	DEFB	0
IX:	DEFB	0
DMF:	DEFB	0
ST:	DEFB	0
SST:	DEFB	0
SSLEN:	DEFB	0
SKTR:	DEFB	0
SNAME:	DEFB	0
DRIVE:	DEFB	0
GLBDR:	DEFB	0
RTDRV:	DEFB	0
XTDRV:	DEFB	0
DEVNO:	DEFB	0
FCBTY:	DEFB	0
BUFNO:	DEFB	0
PASSU:	DEFB	0
UF:	DEFB	0
A47:	DEFB	0
DIF:	DEFB	0
SPLT:	DEFB	0
FRMKL:	DEFB	0
IXT:	DEFB	0
NX:	DEFB	0
I1X:	DEFB	0
I2X:	DEFB	0
I4X:	DEFB	0
LVAL:	DEFB	0
FSZ:	DEFB	0
ISZ:	DEFB	0
DP1:	DEFB	0
DP2:	DEFB	0
SGN1:	DEFB	0
SGN2:	DEFB	0
DFLAG:	DEFB	0
FCASE:	DEFB	0
PTOGL:	DEFB	0
STOGL:	DEFB	0
NUMBR:	DEFB	0
DELET:	DEFB	0
T1:	DEFB	0
MAPSZ:	DEFB	0
TMPSZ:	DEFB	0
SVACT:	DEFB	0
DRLNG:	DEFB	0
MODE:	DEFB	0
FRMDE:	DEFB	0
INN:	DEFB	0
;
NIL:	DEFB	0FFH,0FFH,0FFH
GZERO:	DEFB	0,0,0
;
INT1:	DEFB	0,0,0,0,0
INT2:	DEFB	0,0,0,0,0
INT3:	DEFB	0,0,0,0,0
;
IZERO:	DEFB	0,0,0,0,0
IONE:	DEFB	0,0,0,0,1
I127:	DEFB	0,0,0,1,27H
IMIN1:	DEFB	0F0H,0,0,0,1
IMIN2:	DEFB	0F0H,0,0,0,2
I255:	DEFB	0,0,0,2,55H
;
DAYS:	DEFB	0,0,0,0,0
SECS:	DEFB	0,0,0,0,0
;
OP1:	DEFS	14
OP2:	DEFS	14
TNUMB:	DEFS	14
SOP1:	DEFS	14
RTNUM:	DEFS	14
W:	DEFS	14
;
	DEFS	3		;ROOM FOR SIGN, INTEGER , AND DECIMAL
FREAL:	DEFS	14
	DEFS	3
RNDM:	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,1
RNDML:	DEFB	0,0,0,0,0,0,0,0,23H,45H,67H,89H,87H,63H
RNMOD	EQU	12		;10**RNMOD IS RANDOM NUMBER MODULUS
;
TSTAK:	DEFS	60		;TEMPORARY SPLIT STACK
;
BLKSZ	EQU	512		;DISK BLOCK SIZE FOR GLOBALS
BLKSH	EQU	248		;MAX LENGTH OF GLOBAL ENTRY
BLKS2	EQU	256		;HALF OF BLOCK SIZE
OVRHD	EQU	15		;OVERHEAD IN EACH GLOBAL NODE
MAXNK	EQU	200		;MAX SIZE FOR NAKED VARIABLE
GBTSZ	EQU	7		;SIZE OF ENTRY IN GLOBAL BUFFER TABLE
DEVSZ	EQU	20		;SIZE OF DEVICE TABLE ENTRY
MAXAR	EQU	50		;MAX NUMBER OF BYTES IN ARGUMENT FOR ASSEM. ROUTINE
GVLEN	EQU	3		;DISK BLOCK POINTER SIZE
BUFSZ	EQU	128		;DISK BUFFER SIZE
MAXDV	EQU	4		;MAX DEVICE NUMBER
STRLN	EQU	255		;MAX STRING LENGTH
NAMLN	EQU	9		;MAX RECOGNIZABLE NAME LENGTH (+1 FOR DELIM)
MXLVL	EQU	20		;MAX NESTING LEVEL
SHTLN	EQU	1		;BYTE LENGTH OF SHORT NUMBER
PTRLN	EQU	2		;BYTE LENGTH OF POINTER
INTLN	EQU	5		;BYTE LENGTH OF INTEGER
BCDLN	EQU	14		;BYTE LENGTH OF BCD NUMBER
MAXDG	EQU	9		;MAX NUMBER OF SIGNIFICANT DIGITS
SYNLN	EQU	300		;SYNTAX STACK LENGTH (BYTES)
STKLN	EQU	500		;EXECUTION STACK LENGTH (BYTES)
EOL	EQU	0AH		;END OF LINE CHARACTER
EOI	EQU	0		;END OF INDIRECTION CHARACTER
PROMT	EQU	'>'		;PROMPT CHARACTER
LS	EQU	09H		;LINE START CHARACTER
EOR	EQU	0		;END OF ROUTINE CHARACTER
DELIM	EQU	0		;END OF STRING DELIMITER
TRUE	EQU	1
FALSE	EQU	0
CTRLC	EQU	03H		;CONTROL C
CTRLE	EQU	05H		;CONTROL E
CTRLH	EQU	08H		;CONTROL H
BS	EQU	08H		;BACK SPACE
CTRLI	EQU	09H		;TAB
CR	EQU	0DH		;CARRIAGE RETURN
LF	EQU	0AH		;LINE FEED
FF	EQU	0CH		;FORM FEED
CTRLP	EQU	10H		;CONTROL P
CTRLR	EQU	12H		;CONTROL R
CTRLS	EQU	13H		;CONTROL S
CTRLU	EQU	15H		;CONTROL U
CTRLX	EQU	18H		;CONTROL X
RUB	EQU	7FH		;RUBOUT
;
EOF	EQU	1AH		;DISK FILE END OF FILE
ESC	EQU	1BH		;ESCAPE CHARACTER
BOOT	EQU	0000
BDOS	EQU	0005H
RD1F	EQU	1
LISTF	EQU	5
BRAKF	EQU	11
SELCT	EQU	14
OPENF	EQU	15
CLOSF	EQU	16
SERCF	EQU	17
SERCN	EQU	18
REMF	EQU	19
READF	EQU	20
WRITF	EQU	21
MAKEF	EQU	22
DMAF	EQU	26
;
NULL	EQU	0000H
BLANK	EQU	' '
STRNG	EQU	1		;STRING BIT IN FLG1
NOTFL	EQU	2		;NOT FLAG BIT IN FLG1
DIRTY	EQU	4		;DIRTY BIT
BRAKE	EQU	8		;BREAK MODE BIT
;
INDIR	EQU	0
DIREC	EQU	1
;
;
PDATA	EQU	$
TOS:	DEFB	0,0		;TOP OF STACK
RESUL:	DEFB	0
CASE:	DEFB	0
ACTFL:	DEFB	0
TOKEN:	DEFB	0
INDX:	DEFB	0,0
LOCKS:	DEFB	0
INDFL:	DEFB	0
INDSW:	DEFB	0
DOSW:	DEFB	0
FORSW:	DEFB	0
FLAG:	DEFB	0
SSTK:	DEFB	0,0		;POINTER TO BASE OF SYNTAX STACK
XSTK:	DEFB	0,0		;POINTER TO BASE OF EXECUTION STACK
LBUFF:	DEFB	0,0		;POINTER TO START OF LINE EXECUTION BUFFER
IODVC:	DEFB	0
JOBNM:	DEFB	0
SWIF:	DEFB	0
PRG:	DEFS	NAMLN
PRGPT:	DEFB	0,0		;POINTER TO LINE BEING INTERPRETED
PRGAD:	DEFB	0,0		;POINTER TO START OF PROGRAM
PRGLS:	DEFB	0,0		;POINTER TO LINE BEFORE PRGPT
PRGEN:	DEFB	0,0		;POINTER TO END OF PROGRAM
SYMPT:	DEFB	0,0		;POINTER TO START OF SYMBOL TABLE
SYMEN:	DEFB	0,0		;POINTER TO LOWEST MEMORY IN SYMBOL TABLE
PTEND:	DEFB	0,0		;POINTER TO END OF PARTITION
PBIG:	DEFB	0FFH,0
;
BRKM:	DEFB	'B R E A K  ---  ',0
ZOROU:	DEFB	'ROUTINES ON ',0
ZOGLO:	DEFB	'GLOBALS ON ',0
SYSF:	DEFB	'SYSFILE',0
;
NREF:	DEFS	MAXNK
VAR:	DEFB	NAMLN
ARGPL:	DEFS	MAXAR		;ARGUMENT PASSING PLACE
DEVTA:	DEFB	1,2,0,0,0,0,0,0,0,0,0,0,255;TERMINAL
	DEFW	0,BDATA,0
	DEFB	0
;
	DEFB	0,1,0,0,0,0,0,0,0,0,0,0,132;PRINTER
	DEFW	0,PBUFF,0
	DEFB	0
;
	DEFB	0,2,0,0,0,0,0,0,0,0,0,0,128;DISK #1
	DEFW	DFCB1,DBUF1,0
	DEFB	0
;
	DEFB	0,2,0,0,0,0,0,0,0,0,0,0,128;DISK #2
	DEFW	DFCB2,DBUF2,0
	DEFB	0
;
	DEFB	0,2,0,0,0,0,0,0,0,0,0,0,128;DISK #3
	DEFW	DFCB3,DBUF3,0
	DEFB	0
;
RTFCB:	DEFS	36
DFCB1:	DEFS	36
DFCB2:	DEFS	36
DFCB3:	DEFS	36
;
ERRMS:	DEFB	'ERR:   ',CR
;
SRFCB:	DEFB	0,'????????MMP',0,0,0,0
	DEFS	20
;
PBUFF:	DEFS	132
DBUF1:	DEFS	128
DBUF2:	DEFS	128
DBUF3:	DEFS	128
RTBUF:	DEFS	128
;
;
;
; CLOCK VARIABLES HERE
;
WAIT:	DEFB	0
TIME:	DEFB	0
DTIME:	DEFB	0,0,0,0,0
DOLH:	DEFS	11
CLK	EQU	20H
I60:	DEFB	0,0,0,0,60H
;
FREE	EQU	$
;
; THIS IS WHERE THE CLOCK STUFF GOES
;
;
; MOUNTAIN HARDWARE VERSION
;	LD	A,0C3H		;SET UP ADDRESS FOR HANDLER
;	LD	(INTRPT),A
;	LD	HL,TIMTK
;	LD	(INTRPT+1),HL
;
;	MVI	A,14H
;	OUT	CLK+15		;INTERRUPT ON SECONDS
;	EI
;
; END MOUNTAIN HARDWARE VERSION
;
	JP	MUMPS
;
INTRPT	EQU	8H		;INTERRUPT HANDLER
;
	END	100H
