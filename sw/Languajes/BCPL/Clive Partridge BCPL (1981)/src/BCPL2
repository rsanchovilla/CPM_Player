	NAME BCPL2
 
* This module contains the interpreter routines
* for the 2-byte BCPL system. It is important
* to remember that there are two stacks, one is the
* main stack whose top is STACKP, and the hardware
* stack which is used as the working stack. This means
* that on routine calls parameters must be transfered
* from one to the other.
* HL is used as top-of-stack, BC as program counter,
* IY points to 'registers'.
* Alternative registers used so beware!
* Because the hardware stack is used as the main
* working stack one must be careful about it.
* Bear in mind that interrupts use it too.
 
* This is designed for speed, not beauty or size.
 
* External global.
 
	GLOBAL FINISH
 
* Globals exported
 
	GLOBAL XRET
	GLOBAL INIT
	GLOBAL NEXT
	GLOBAL PROG
 
* Offsets from IY.
 
DYNP	EQU 0
GLOB	EQU 2
STACKP	EQU 4
 
BXTABLE:
 
YUSER	EQU ($-BXTABL)/3
	PUSH BC
	RET
	DEFB 0
YFINISH	EQU ($-BXTABL)/3
	JP FINISH
YPERCNT	EQU ($-BXTABL)/3
	JP XPRCNT
YSHL	EQU ($-BXTABL)/3
	JP XSHL
YSHR	EQU ($-BXTABL)/3
	JP XSHR
YEQUALS	EQU ($-BXTABL)/3
	JP XEQUALS
YNEQ	EQU ($-BXTABL)/3
	JP XNEQ
YLEQ	EQU ($-BXTABL)/3
	JP XLEQ
YGEQ	EQU ($-BXTABL)/3
	JP XGEQ
YGR	EQU ($-BXTABL)/3
	JP XGR
YLE	EQU ($-BXTABL)/3
	JP XLE
YTIMES	EQU ($-BXTABL)/3
	JP XTIMES
YDIV	EQU ($-BXTABL)/3
	JP XDIV
YREM	EQU ($-BXTABL)/3
	JP XREM
YAND	EQU ($-BXTABL)/3
	JP XAND
YOR	EQU ($-BXTABL)/3
	JP XOR
YEQV	EQU ($-BXTABL)/3
	JP XEQV
YNEQV	EQU ($-BXTABL)/3
	JP XNEQV
YPLUS	EQU ($-BXTABL)/3
	JP XPLUS
YMINUS	EQU ($-BXTABL)/3
	JP XMINUS
YPLING	EQU ($-BXTABL)/3
	JP XPLUS
YMNPLUS	EQU ($-BXTABL)/3
	JP NEXT
YMONMIN	EQU ($-BXTABL)/3
	JP XMNMIN
YMNPLNG	EQU ($-BXTABL)/3
	JP NEXT
YNOT	EQU ($-BXTABL)/3
	JP XNOT
YABS	EQU ($-BXTABL)/3
	JP XABS
YAT	EQU ($-BXTABL)/3
	JP NEXT
YLNGLEQ	EQU ($-BXTABL)/3
	JP XLNLEQ
YLNGGEQ	EQU ($-BXTABL)/3
	JP XLNGEQ
YLONGGR	EQU ($-BXTABL)/3
	JP XLNGGR
YLONGLE	EQU ($-BXTABL)/3
	JP XLNGLE
YDEREF	EQU ($-BXTABL)/3
	JP XDEREF
YPUSH2	EQU ($-BXTABL)/3
	JP XPUSH2
YPUSH1	EQU ($-BXTABL)/3
	JP XPUSH1
YPSHZRO	EQU ($-BXTABL)/3
	JP XFALSE
YPSHONE	EQU ($-BXTABL)/3
	JP XPSONE
YPSHTWO	EQU ($-BXTABL)/3
	JP XPSTWO
YPSHTHE	EQU ($-BXTABL)/3
	JP XPSTHE
YPSHFOR	EQU ($-BXTABL)/3
	JP XPSFOR
YFALSE	EQU ($-BXTABL)/3
	JP XFALSE
YTRUE	EQU ($-BXTABL)/3
	JP XTRUE
YASSIGN	EQU ($-BXTABL)/3
	JP XASSIG
YASSTIM	EQU ($-BXTABL)/3
	JP XASSTIM
YASSDIV	EQU ($-BXTABL)/3
	JP XASSDIV
YASSREM	EQU ($-BXTABL)/3
	JP XASSREM
YASSAND	EQU ($-BXTABL)/3
	JP XASSAND
YASSOR	EQU ($-BXTABL)/3
	JP XASSOR
YASSEQV	EQU ($-BXTABL)/3
	JP XASSEQV
YASSNQV	EQU ($-BXTABL)/3
	JP XASSNQV
YASSPLS	EQU ($-BXTABL)/3
	JP XASSPLS
YASSMNS	EQU ($-BXTABL)/3
	JP XASSMNS
YPSHD2	EQU ($-BXTABL)/3
	JP XPSHD2
YPSHD1	EQU ($-BXTABL)/3
	JP XPSHD1
YPSHG2	EQU ($-BXTABL)/3
	JP XPSHG2
YPSHG1	EQU ($-BXTABL)/3
	JP XPSHG1
YDPSD2	EQU ($-BXTABL)/3
	JP XDPSD2
YDPSD1	EQU ($-BXTABL)/3
	JP XDPSD1
YDPSG2	EQU ($-BXTABL)/3
	JP XDPSG2
YDPSG1	EQU ($-BXTABL)/3
	JP XDPSG1
YFCALL	EQU ($-BXTABL)/3
	JP XCALL
YFCAL0	EQU ($-BXTABL)/3
	JP XCAL0
YFCAL1	EQU ($-BXTABL)/3
	JP XCAL1
YFCAL2	EQU ($-BXTABL)/3
	JP XCAL2
YFCAL3	EQU ($-BXTABL)/3
	JP XCAL3
YPCALL	EQU ($-BXTABL)/3
	JP XCALL
YPCAL0	EQU ($-BXTABL)/3
	JP XCAL0
YPCAL1	EQU ($-BXTABL)/3
	JP XCAL1
YPCAL2	EQU ($-BXTABL)/3
	JP XCAL2
YPCAL3	EQU ($-BXTABL)/3
	JP XCAL3
YJUMP	EQU ($-BXTABL)/3
	JP XJUMP
YRJUMP	EQU ($-BXTABL)/3
	JP XRJUMP
YJFALSE	EQU ($-BXTABL)/3
	JP XJFALS
YRJFALS	EQU ($-BXTABL)/3
	JP XRJFAL
YJTRUE	EQU ($-BXTABL)/3
	JP XJTRUE
YRJTRUE	EQU ($-BXTABL)/3
	JP XRJTRU
YRET	EQU ($-BXTABL)/3
	JP XRET
YDEPER	EQU ($-BXTABL)/3
	JP XDEPER
YPERASS	EQU ($-BXTABL)/3
	JP XPERAS
YPASTIM	EQU ($-BXTABL)/3
	JP XPASTIM
YPASDIV	EQU ($-BXTABL)/3
	JP XPASDIV
YPASREM	EQU ($-BXTABL)/3
	JP XPASREM
YPASAND	EQU ($-BXTABL)/3
	JP XPASAND
YPASOR	EQU ($-BXTABL)/3
	JP XPASOR
YPASEQV	EQU ($-BXTABL)/3
	JP XPASEQV
YPASNQV	EQU ($-BXTABL)/3
	JP XPASNQV
YPASPLS	EQU ($-BXTABL)/3
	JP XPASPLS
YPASMNS	EQU ($-BXTABL)/3
	JP XPASMNS
YTABLE	EQU ($-BXTABL)/3
	JP XTABLE
YSTRIN	EQU ($-BXTABL)/3
	JP XSTRIN
YDYNDE	EQU ($-BXTABL)/3
	JP XDYNDE
YSWITC	EQU ($-BXTABL)/3
	JP XSWITC
YGOTO	EQU ($-BXTABL)/3
	JP XGOTO
 
XPSHG2:	PUSH HL
	LD A,(BC)
	LD H,A
	INC BC
	JR LPSHG1
 
XPSHD2:	PUSH HL
	LD A,(BC)
	LD H,A
	INC BC
	JR LPSHD1
 
XPSHG1:	PUSH HL
	LD H,0
LPSHG1:	LD E,(IY+GLOB)
	LD D,(IY+GLOB+1)
	JR LPSHD2
 
XPSHD1:	PUSH HL
	LD H,0
LPSHD1:	LD E,(IY+DYNP)
	LD D,(IY+DYNP+1)
LPSHD2:	LD A,(BC)
	LD L,A
	INC BC
	ADD HL,DE
	JP NEXT
 
XDPSG2:	PUSH HL
	LD A,(BC)
	LD H,A
	INC BC
	JR GLOB1
 
XDPSD2:	PUSH HL
	LD A,(BC)
	LD H,A
	INC BC
	JR DYNP1
 
INIT:	EXX
	LD DE,BXTABLE	;initialise alt regs
	LD B,0
	EXX
	JR NEXT
 
XTRUE:	PUSH HL
TRUE:	LD HL,-1
	JR NEXT
 
XEQUAL:	POP DE
	SBC HL,DE
	JR Z TRUE
	LD HL,0
	JR NEXT
 
XGR:	POP DE
	CALL COMP
	JP M TRUE
	LD HL,0
	JR NEXT
 
XLE:	POP DE
	EX DE,HL
	CALL COMP
	JP M TRUE
	LD HL,0
	JR NEXT
 
XNEQ:	POP DE
	SBC HL,DE
	JR NZ TRUE
	LD HL,0
	JR NEXT
 
XGEQ:	POP DE
	EX DE,HL
	CALL COMP
	JP P TRUE
	LD HL,0
	JR NEXT
 
XLEQ:	POP DE
	CALL COMP
	JP P TRUE
	LD HL,0
	JR NEXT
 
XDPSG1:	PUSH HL
	LD H,0
GLOB1:	LD E,(IY+GLOB)
	LD D,(IY+GLOB+1)
	JR DYNP2
 
XDPSD1:	PUSH HL
	LD H,0
DYNP1:	LD E,(IY+DYNP)
	LD D,(IY+DYNP+1)
DYNP2:	LD A,(BC)
	LD L,A
	INC BC
	ADD HL,DE
XDEREF:	ADD HL,HL
	LD A,(HL)
	INC HL
	LD L,(HL)
	LD H,A
NEXT:	LD A,(BC)
	EXX
	LD L,A
	LD C,A
	LD H,B
	ADD HL,HL
	ADD HL,BC
	ADD HL,DE
	PUSH HL
	EXX
	INC BC
	RET
 
XNOT:	LD A,H
	CPL
	LD H,A
	LD A,L
	CPL
	LD L,A
	JR NEXT
 
XPLUS:	POP DE
	ADD HL,DE
	JR NEXT
 
XMINUS:	EX DE,HL
	POP HL
	SBC HL,DE
	JR NEXT
 
XOR:	POP DE
	LD A,D
	OR H
	LD H,A
	LD A,E
	OR L
	LD L,A
	JR NEXT
 
XAND:	POP DE
	LD A,D
	AND H
	LD H,A
	LD A,E
	AND L
	LD L,A
	JR NEXT
 
XNEQV:	POP DE
	LD A,D
	XOR H
	LD H,A
	LD A,E
	XOR L
	LD L,A
	JR NEXT
 
XEQV:	POP DE
	LD A,D
	XOR H
	CPL
	LD H,A
	LD A,E
	XOR L
	CPL
	LD L,A
	JR NEXT
 
XTIMES:	POP DE
	PUSH BC
	LD B,D
	LD C,E
	LD DE,0
XMULT1:	EX DE,HL
	SRL B
	RR C
	JR NC XMULT2
	ADD HL,DE
XMULT2:	LD A,B
	OR C
	JR Z XMULT3
	EX DE,HL
	ADD HL,HL
	JR XMULT1
 
XMULT3:	POP BC
	JP NEXT
 
XDIV:	POP DE
	PUSH BC
	CALL DIVIDE
	LD H,B
	LD L,C
	POP BC
	JP P NEXT
	JR XMNMIN
	
XREM:	POP DE
	PUSH BC
	CALL DIVIDE
	POP BC
	JP P NEXT
	JR XMNMIN
 
XABS:	BIT 7,H
	JR Z NEXT
XMNMIN:	EX DE,HL
	LD HL,0
	SBC HL,DE
	JP NEXT
 
XFALSE:	PUSH HL
	LD HL,0
	JP NEXT
 
XPSONE:	PUSH HL
	LD HL,1
	JP NEXT
 
XPSTWO:	PUSH HL
	LD HL,2
	JP NEXT
 
XPSTHE:	PUSH HL
	LD HL,3
	JP NEXT
 
XPSFOR:	PUSH HL
	LD HL,4
	JP NEXT
 
XPUSH2:	PUSH HL
	LD A,(BC)
	LD H,A
	INC BC
	JR PUSH
 
XPUSH1:	PUSH HL
	LD H,0
PUSH:	LD A,(BC)
	LD L,A
	INC BC
	JP NEXT
 
XDEPER:	LD L,(HL)
	LD H,0
	JP NEXT
 
XLNLEQ:	POP DE
	CALL COMP
	JP M LNGF
	EX DE,HL
	POP DE
	CALL COMP
	JP M FAL
TRU:	LD HL,-1
	JP NEXT
 
XLNGGR:	POP DE
	CALL COMP
	JP P LNGF
	EX DE,HL
	POP DE
	CALL COMP
	JP P FAL
	JR TRU
 
LNGF:	POP AF
FAL:	LD HL,0
	JP NEXT
 
XLNGLE:	POP DE
	CALL COMP
	JR Z LNGF
	JP M LNGF
	POP HL
	CALL COMP
	JP P FAL
	JR TRU
 
XLNGEQ:	POP DE
	CALL COMP
	JR Z XLGEQ1
	JP P LNGF
XLGEQ1:	POP HL
	CALL COMP
	JP P TRU
	JR FAL
 
COMP:	LD A,D
	XOR H
	JP M COMP1
	SBC HL,DE
	RET
 
COMP1:	XOR D
	OR 1		;Ensure NZ
	RET
 
XPRCNT:	POP DE
	ADD HL,DE
	ADD HL,DE
	JP NEXT
 
XASS:	PUSH IX
	POP BC
XASSIG:	EX DE,HL
	POP HL
	ADD HL,HL
	LD (HL),D
	INC HL
	LD (HL),E
	POP HL
	JP NEXT
 
XPASS:	PUSH IX
	POP BC
XPERAS:	POP DE
	EX DE,HL
	LD (HL),E
	POP HL
	JP NEXT
 
XGOTO:	LD C,H
	LD B,L
	POP HL
	JP NEXT
 
XSTRIN:	PUSH HL
	LD A,(BC)
	LD D,B
	LD E,C
	LD L,A
	LD H,0
	ADD HL,BC
	LD B,H
	LD C,L
	EX DE,HL
	SRL H
	RR L
	INC BC
	JP NEXT
 
XSWITC:	EX DE,HL
	LD H,B
	LD L,C
	LD A,(HL)
	INC HL
	LD H,(HL)
	LD L,A
	ADD HL,BC
	PUSH HL
	POP IX
	LD A,(HL)
	INC HL
	LD H,(HL)
	LD L,A
	LD BC,0
SWITC1:	PUSH HL
	OR A
	SBC HL,BC
	JR Z NOTFOU
	ADD HL,BC
	ADD HL,BC
	SRL H
	RR L
	INC HL
	PUSH HL
	ADD HL,HL
	ADD HL,HL
	EX DE,HL
	PUSH IX
	EX (SP),HL
	SBC HL,DE
	LD D,(HL)
	INC HL
	LD E,(HL)
	EX (SP),HL
	EX DE,HL
	CALL COMP
	JR Z FOUND
	JP P TOOLOW
	POP AF
	POP HL
	POP AF
	DEC HL
	JR SWITC1
 
TOOLOW:	POP AF
	POP BC
	POP HL
	JR SWITC1
 
FOUND:	POP BC
	POP AF
	POP AF
	POP HL
	INC BC
	JR XJUMP
 
NOTFOU:	PUSH IX
	POP BC
	INC BC
	INC BC
	POP HL
	POP HL
	JR XJUMP
 
XTABLE:	PUSH HL
	LD H,B
	LD L,C
	SRL H
	RR L
	INC HL
	JR XJUMP
 
XJTRUE:	BIT 7,H
	POP HL
	JR Z NOJUMP
	JR XJUMP
 
XJFALS:	BIT 7,H
	POP HL
	JR NZ NOJUMP
XJUMP:	LD A,(BC)
	LD E,A
	INC BC
	LD A,(BC)
	DEC BC
	LD D,A
	EX DE,HL
	ADD HL,BC
	LD B,H
	LD C,L
	EX DE,HL
	JP NEXT
 
NOJUMP:	INC BC
NORJUM:	INC BC
	JP NEXT
 
XRJTRU:	BIT 7,H
	POP HL
	JR Z NORJUM
	JR XRJUMP
 
XRJFAL:	BIT 7,H
	POP HL
	JR NZ NORJUM
XRJUMP:	LD A,(BC)
	CPL
	INC A
	LD D,255
	LD E,A
	EX DE,HL
	ADD HL,BC
	LD B,H
	LD C,L
	EX DE,HL
	JP NEXT
 
XSHL:	LD A,L
	AND 0F0H
	LD A,L
	POP HL
	JP NZ FAL
	BIT 3,A
	JR Z XSHL1
	LD H,L
	LD L,0
XSHL1:	AND 7
	JP Z NEXT
	SLA L
	RL H
	DEC A
	JR XSHL1
 
XSHR:	LD A,L
	AND 0F0H
	LD A,L
	POP HL
	JP NZ FAL
	BIT 3,A
	JR Z XSHR1
	LD L,H 
	LD H,0
XSHR1:	AND 7
	JP Z NEXT
	SRL H
	RR L
	DEC A
	JR XSHR1
 
* DIVIDE divides DE by HL, leaving answer in BC,
* and remainder in HL, with M set if answer needs
* to be negated.
 
DIVIDE:	LD A,D
	XOR H
	PUSH AF
	BIT 7,D
	JR Z LDIV9
	LD A,D
	CPL
	LD D,A
	LD A,E
	CPL
	LD E,A
	INC DE
LDIV9:	BIT 7,H
	JR Z LDIV8
	LD A,L
	CPL
	LD L,A
	LD A,H
	CPL
	LD H,A
	INC HL
LDIV8:	LD BC,0
	LD A,H
	OR L
	JR Z LDIV4
	XOR A
LDIV1:	ADD HL,HL
	INC A
	JR NC LDIV1
	EX DE,HL
LDIV2:	RR D
	RR E
	SLA C
	RL B
	INC BC
	SBC HL,DE
	JR NC LDIV3
	ADD HL,DE
	OR A
	DEC BC
LDIV3:	DEC A
	JR NZ LDIV2	;Carry clear
LDIV4:	POP AF
	RET
 
XCAL4:	LD A,4
	JR XCALL7
 
XCAL3:	LD A,3
	JR XCALL7
 
XCAL2:	LD A,2
	JR XCALL7
 
XCAL1:	LD A,1
	JR XCALL7
 
XCAL0:	XOR A
	JR XCALL7
 
XCALL:	LD A,(BC)
XCALL7:	DEC BC
	PUSH HL
	LD L,(IY+STACKP)
	LD H,(IY+STACKP+1)
	LD E,(IY+DYNP+1)
	LD (HL),E
	LD E,(IY+DYNP)
	SRL H
	RR L
	LD (IY+DYNP),L
	LD (IY+DYNP+1),H
	ADD HL,HL
	INC HL
	LD (HL),E
	INC HL
	LD (HL),C
	INC HL
	LD (HL),B
	INC HL
	LD C,A
	LD B,0
	ADD HL,BC
	ADD HL,BC
	OR A
	JR Z XCALL1
XCALL2:	POP BC
	DEC HL
	LD (HL),C
	DEC HL
	LD (HL),B
	DEC A
	JR NZ XCALL2
	POP BC
XCALL1:	POP BC
	EX DE,HL
	LD L,B
	LD H,C
	LD C,(HL)
	INC HL
	LD B,(HL)
	INC HL
	EX DE,HL
	DEC BC
	DEC BC
	ADD HL,BC
	ADD HL,BC
	LD B,D
	LD C,E
	EX DE,HL
	LD HL,0
	ADD HL,SP
	EX DE,HL
	LD (HL),E
	INC HL
	LD (HL),D
	INC HL
	LD (IY+STACKP),L
	LD (IY+STACKP+1),H
XCALL9:	POP HL
	JP NEXT
	
XRET:	EX DE,HL
	PUSH DE
	LD H,(IY+STACKP+1)
	LD L,(IY+STACKP)
	DEC HL
	LD A,(HL)
	DEC HL
	LD L,(HL)
	LD H,A
	LD SP,HL
	LD H,(IY+DYNP+1)
	LD L,(IY+DYNP)
	ADD HL,HL
	LD (IY+STACKP),L
	LD (IY+STACKP+1),H
	LD A,(HL)
	LD (IY+DYNP+1),A
	INC HL
	LD A,(HL)
	LD (IY+DYNP),A
	INC HL
	LD C,(HL)
	INC HL
	LD B,(HL)
	EX DE,HL
	LD A,(BC)
	INC BC
	CP YFCALL
	JR Z XRL1
	CP YPCALL
	JR NZ XRL2
XRL1:	INC BC
XRL2:	CP YPCALL	;This depends on order of codes
	JR NC XCALL9
	JP NEXT
 
XDYNDE:	PUSH HL
	LD A,(BC)
	INC BC
	LD L,A
	LD H,0
	ADD HL,HL
	ADD HL,SP
	PUSH BC
	LD B,A
	LD E,L
	LD D,H
	LD A,(HL)
	INC HL
	PUSH HL
	LD H,(HL)
	LD L,A
	INC HL
	ADD HL,HL
LDYN1:	DEC DE
	LD A,(DE)
	LD (HL),A
	DEC DE
	INC HL
	LD A,(DE)
	LD (HL),A
	INC HL
	DJNZ LDYN1
	POP HL
	POP BC
	INC HL
	LD SP,HL
	POP HL
	JP NEXT
 
XASSTI:	PUSH BC
	LD BC,TASSTI
	JR XASSTN
 
XASSDI:	PUSH BC
	LD BC,TASSDI
	JR XASSTN
 
XASSRE:	PUSH BC
	LD BC,TASSRE
	JR XASSTN
 
XASSAN:	PUSH BC
	LD BC,TASSAN
	JR XASSTN
 
XASSOR:	PUSH BC
	LD BC,TASSOR
	JR XASSTN
 
XASSEQ:	PUSH BC
	LD BC,TASSEQ
	JR XASSTN
 
XASSNQ:	PUSH BC
	LD BC,TASSNQ
	JR XASSTN
 
XASSPL:	PUSH BC
	LD BC,TASSPL
	JR XASSTN
 
XASSMN:	PUSH BC
	LD BC,TASSMN
XASSTN:	POP IX
	POP DE
	PUSH DE
	PUSH HL
	EX DE,HL
	ADD HL,HL
	LD D,(HL)
	INC HL
	LD E,(HL)
	POP HL
	PUSH DE
	JP NEXT
 
TASSTI:	DEFB YTIMES,0
	JP XASS
 
TASSDI:	DEFB YDIV,0
	JP XASS
 
TASSRE:	DEFB YREM,0
	JP XASS
 
TASSAN:	DEFB YAND,0
	JP XASS
 
TASSOR:	DEFB YOR,0
	JP XASS
 
TASSEQ:	DEFB YEQV,0
	JP XASS
 
TASSNQ:	DEFB YNEQV,0
	JP XASS
 
TASSPL:	DEFB YPLUS,0
	JP XASS
 
TASSMN:	DEFB YMINUS,0
	JP XASS
 
XPASTI:	PUSH BC
	LD BC,TPASTI
	JR XPASTN
 
XPASDI:	PUSH BC
	LD BC,TPASDI
	JR XPASTN
 
XPASRE:	PUSH BC
	LD BC,TPASRE
	JR XPASTN
 
XPASAN:	PUSH BC
	LD BC,TPASAN
	JR XPASTN
 
XPASOR:	PUSH BC
	LD BC,TPASOR
	JR XPASTN
 
XPASEQ:	PUSH BC
	LD BC,TPASEQ
	JR XPASTN
 
XPASNQ:	PUSH BC
	LD BC,TPASNQ
	JR XPASTN
 
XPASPL:	PUSH BC
	LD BC,TPASPL
	JR XPASTN
 
XPASMN:	PUSH BC
	LD BC,TPASMN
XPASTN:	POP IX
	POP DE
	PUSH DE
	LD A,(DE)
	LD E,A
	LD D,0
	PUSH DE
	JP NEXT
 
TPASTI:	DEFB YTIMES,0
	JP XPASS
 
TPASDI:	DEFB YDIV,0
	JP XPASS
 
TPASRE:	DEFB YREM,0
	JP XPASS
 
TPASAN:	DEFB YAND,0
	JP XPASS
 
TPASOR:	DEFB YOR,0
	JP XPASS
 
TPASEQ:	DEFB YEQV,0
	JP XPASS
 
TPASNQ:	DEFB YNEQV,0
	JP XPASS
 
TPASPL:	DEFB YPLUS,0
	JP XPASS
 
TPASMN:	DEFB YMINUS,0
	JP XPASS
 
* Align on two byte boundary.
 
	IF ($.AND.1)=1
	DEFB 0
	ENDIF
 
* Conventionally this is the module that precedes
* the first BCPL module proper so PROG is here.
 
PROG	EQU $
 
	END
ÿÿ                 ÿÿÿï