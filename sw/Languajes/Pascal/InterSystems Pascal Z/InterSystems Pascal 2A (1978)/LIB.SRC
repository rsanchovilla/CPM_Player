; PASCAL RUN-TIME SUPPORT LIBRARY	
;
; COPYRIGHT 1978 BY JEFF MOSKOW
;	11/12/79
;
; INITIALIZE SOME RUN-TIME PARAMETERS TO THEIR CORRECT DEFAULT VALUES
;
R:	SET	0FFFFH		;DEFAULT FOR RANGE  CHECKING IS YES
C:	SET	0FFFFH		;   "     "  CTRL-C     "     "  "
M:	SET	0FFFFH		;   "     "  MATH       "     "  "
S:	SET	0FFFFH		;   "     "  STACK      "     "  "
E:	SET	00000H		;   "     "  EXTENDED ERROR MESSAGES IS OFF
F:	SET	0FFFFH		;DEFAULT FOR FLOATING POINT CHECKING IS ON.
T:	SET	00000H		;   "     "  DEFAULT FOR TRACE OPTION IS OFF
VALID:	SET	00000H		;STATEMENT NUMBER ISN'T VALID
;
;
; PASCAL DEFAULTS
;
MAXOUT	EQU	3		;NUMBER OF ALLOWABLE OUTPUT FILES
CR	EQU	13		;CARRIAGE RETURN
LF	EQU	10		;LINE FEED
EOFMRK	EQU	1AH		; Enf of file marker.
BUFLEN	EQU	80		;SIZE OF PASCAL'S CONSOLE BUFFER.
OUTLST	EQU	4		;OUTPUT LIST LOCATION
TOPFRM	EQU	OUTLST+MAXOUT+MAXOUT+BUFLEN+3	;SPACE FOR STACK FRAME #1
MARGIN	EQU	50		;STACK OVERFLOW MARGIN

COMPILER EQU	0		;TRUE IF ASSEMBLING THE COMPILER.

MAXDRV	EQU	16		;MAXIMUM # OF DRIVES (USED BY FILNAM).


	ORG	100H

;GET DEFAULT DRIVE NUMBER.
START:	MVI	C,25		; CP/M CODE TO GET CURRENT DRIVE NUMBER.
	CALL	CPM
	LHLD	6		;GET POINTER TO TOP OF MEMORY.
	DCX	H
	MOV	M,A		;STORE DEFAULT DRIVE NUMBER.

	LXI	B,0		;CLEAR STATEMENT NUMBER
	LXI	H,LAST		;Start of heap.
	EXX
	LHLD	6		; 1 PAST LAST BYTE IN RAM.
	LXI	D,0-TOPFRM-1	; AMOUNT OF SPACE TO RESERVE + 1.
	DAD	D
	PUSH	H
	PUSH	H
	POP	X
	POP	Y
	SPHL			;MAKE SP DO THE SAME
	MVI	B,MAXOUT*2+OUTLST
	XRA	A		;CLEAR FILE AREA ABOVE THE STACK
CLRSTK:	MOV	M,A		
	INX	H	
	DJNZ	CLRSTK	
	INX	H
	MOV	M,A		; PUT_CHAR_POINTER := 0 (BUFFER EMPTY).
;STICK STRING RESIDING AT COMMAND TAIL BUFFER (80H) IN TEXT BUFFER FOR
;CONSUMPTION BY PASCAL PROGRAM (THE COMPILER USES THIS).
	LXI	H,80H		; ADDRESS OF TEXT BUFFER WITH REST OF COM LINE.
	CMP	M		; 0 - number of characters in command tail
	JRZ	NOCOM
	MOV	B,M		; B := NUMBER OF CHARACTERS.
	DCR	B
	INX	H		; POINT TO FIRST CHARACTER.
INITLP	INX	H
	MOV	C,M
	CALL	TOUT		; STUFF CHARACTER INTO OUR BUFFER.
	DJNZ	INITLP
NOCOM	MVI	C,CR
	CALL	TOUT		; Mark the end of buffer line.
; L9999 is the label on the first line of code of the program translated
; by the Pascal/z compiler.
	JMP	L9999


	IF COMPILER
	DB	'Copyright 1978 by Jeff Moscow. 2a   '
	ENDIF

	NLIST
;THIS SET OF ROUTINES SIMULATES A K2 OPERATING SYSTEM IN A CP/M
;ENVIRONMENT.
;WRITTEN BY ROBERT BEDICHEK SUMMER 1979

RESTRT	EQU	0		;SYSTEM RESTART ADDRESS.
CPM	EQU	5		; CP/M ENTRY ADDRESS.


CSTS	PUSH	B
	PUSH	D
	PUSH	H
	MVI	C,11		; CP/M CODE FOR CONSOLE STATUS.
	CALL	CPM
	ORA	A		;TEST A FOR RETURN CODE.
	JRZ	POPHDB
	MVI	A,0FFH
	JMPR	POPHDB

;CONSOLE IN READS AND ECHOS A CHARACTER FROM THE CONSOLE.
CI	PUSH	B
	PUSH	D
	PUSH	H
	MVI	C,1		;CP/M CODE FOR CONSOLE READ.
	CALL	CPM
	JMPR	POPHDB		;RESTORE REGISTERS AND RETURN.

;CONSOLE OUT PROCEDURE PRINTS A CHARACTER PASSED IN REGISTER C ON THE CONSOLE.
CO	PUSH	B
	PUSH	D
	PUSH	H
	MOV	E,C		;CP/M WANTS THE CHARACTER IN E.
	MVI	C,2
	CALL	CPM
	JMPR	POPHDB		;RESTORE REGISTERS AND RETURN.


FCB	EQU	0
DEVNUM	EQU	33		; OFFSET OF DEVICE NUMBER ENTRY.
BYTPT	EQU	34		; OFFSET OF BYTE POINTER/COUNTER ENTRY.
LSBYT	EQU	35		; OFFSET OF LAST BLOCK BYTE COUNT.
DATAB	EQU	36		; OFFSET OF DATA BUFFER ENTRY.



;SELECT DISK TELLS CP/M TO USE THE DEVICE SPECIFIED BY THE DEVICE NAME
;ENTRY IN THE FILE DESCRIPTOR POINTED TO BY HL.  REGISTERS A AND F ARE TRASHED.
SELDSK	PUSH	B
	PUSH	D
	PUSH	H
;SET DMA ADDRESS TO 80H FOR CP/M'S INTERNAL OPERATIONS.
	PUSH	H
	LXI	D,80H		; SYSTEM'S DMA AREA.
	MVI	C,26		; CP/M CODE TO SET DMA ADDRESS.
	CALL	CPM
	POP	H
	LXI	D,DEVNUM
	DAD	D		; ADDRESS OF DEVICE NUMBER NOW IN HL
	MOV	E,M
	MVI	C,14		; CP/M CODE FOR SELECT DISK.
	CALL	CPM
	JMPR	POPHDB

;DELETE REMOVES THE FILE (FROM THE DIRECTORY) WHICH IS SPECIFIED BY THE
;FILE DESCRIPTOR POINTED TO BY HL.
DELETE	PUSH	B
	PUSH	D
	PUSH	H
	PUSH	PSW
	CALL	SELDSK		; SELECT THE PROPER DRIVE.
	XCHG
	MVI	C,19		; CP/M CODE FOR DELETE FILE ENTRY
	CALL	CPM
	POP	PSW

POPHDB	POP	H
	POP	D
	POP	B
	RET


;OPNOT OPENS A FILE FOR OUTPUT.  THE POINTER TO THE FILE DESCRIPTOR IS
;PASSED IN HL.  ANY FILE WITH THE SAME NAME ALREADY IN THE DIRECTORY IS 
;DELETED.
OPNOT	PUSH	B
	PUSH	D
	PUSH	H
	PUSH	PSW
	CALL	SELDSK
	XCHG
	MVI	C,22		; CP/M CODE TO CREATE A FILE ENTRY.
	CALL	CPM
	CPI	255		; CHECK FOR DIRECTORY FULL ERROR.
	JZ	DERR
	POP	PSW
	POP	H
	POP	D
	POP	B
	; FALL THROUGH AND DO CODE FOR OPENING AN INPUT FILE.

OPNIN	PUSH	B
	PUSH	D
	PUSH	H
	PUSH	PSW

	PUSH	H
	LXI	D,BYTPT		; OFFSET INTO FILE DESCRIPTOR OF BYTE POINTER.
	DAD	D
	MVI	M,0FFH		; SET BYTE POINTER TO EMPTY.
	INX	H		; HL NOW POINTS TO LSBYT
	MVI	M,0FFH
	POP	H		; RESTORE HL (IT NOW POINTS TO START OF FCB).
	CALL	SELDSK		; SELECT PROPER DRIVE.
	XCHG
	MVI	C,15		; CP/M CODE FOR OPEN FILE.
	CALL	CPM
	ADI	1		; CARRY NOW SET IF ERROR OCCURRED.
	POP	B
	MOV	A,B		; RESTORE A WITHOUT AFFECTING THE FLAGS.
	JMPR	POPHDB

BYTIN	PUSH	B
	PUSH	D
	PUSH	H
	LXI	D,BYTPT
	DAD	D
	MOV	A,M
	INX	H
	CMP	M
	CMC			; MAKE CARRY 0 UNLESS END OF BLOCK.
	JRNZ	NTEMPT		; BRANCH AROUND BLOCK READ IF NOT EMPTY.

;THIS READS A 256 BYTE BLOCK INTO THE DATA AREA OF THE FILE DESCRIPTOR
;POINTED TO HL - LSBYT. IT MODIFIES BYTPT, LSBYT, ALL REGISTERS EXCEPT HL AND A.
	PUSH	PSW
	PUSH	H
	MOV	A,M
	ADI	1		; TEST LSBYT FOR FFH
	JNC	BEOF		; END OF FILE HAS BEEN REACHED.
	LXI	D,FCB-LSBYT
	DAD	D		; HL NOW POINTS TO FCB.
	CALL	SELDSK		; SELECT PROPER DRIVE.

	POP	D
	PUSH	D
	INX	D		; DE NOW POINTS TO START OF DATA BUFFER.
	MVI	C,26		; CP/M CODE FOR SETTING DMA ADDRESS.
	CALL	CPM
	POP	H
	PUSH	H
	LXI	D,FCB-LSBYT
	DAD	D
	XCHG
	MVI	C,20		; CP/M CODE FOR READ SECTOR.
	CALL	CPM
	ORA	A
	JRNZ	EOF99

;READ SECOND SECTOR TO FILL 256 BYTE BLOCK.
	POP	H
	PUSH	H
	LXI	D,128+DATAB-LSBYT
	DAD	D		; HL NOW POINTS TO SECOND HALF OF DATA BUFFER.
	XCHG
	MVI	C,26		; CP/M CODE FOR SETTING S_DMA ADDRESS.
	CALL	CPM
	POP	H
	PUSH	H
	LXI	D,FCB-LSBYT
	DAD	D		; HL NOW POINTS TO FCB.
	XCHG
	MVI	C,20		; CP/M CODE FOR READ SECTOR.
	CALL	CPM
	ORA	A
	JRNZ	EOF360
	POP	H
	POP	PSW
	ORA	A		; CLEAR CARRY FOR NOT EOF INDICATION.
	JMPR	NTEMPT

EOF99
BEOF	POP	H
	POP	PSW
	STC			; SET CARRY FOR EOF INDICATION.
	JMPR	NTEMPT

EOF360	POP	H
	MVI	M,7FH		; CODE FOR HALF FULL BUFFER.
	POP	PSW
	ORA	A		; NOT EOF QUITE YET.

NTEMPT	PUSH	PSW		; SAVE CARRY (CARRY = 1 ===> EOF).
	INR	A		; INCREMENT BYTE POINTER/COUNTER.
	DCX	H
	MOV	M,A		; STORE UPDATED BYTE POINTER.COUNTER.
	MOV	E,A
	MVI	D,0		; MAKE HIGH BYTE OF OFFSET INTO DATA BLOCK ZERO.
	INX	H
	INX	H
	DAD	D		; HL NOW POINTS TO DATA BYTE.
	POP	PSW		; RESTORE CARRY.
	MOV	A,M
	JMP	POPHDB

;BYTE OUT PUTS THE BYTE PASSED IN A IN THE FILE DESCRIPTOR
;POINTED TO BY HL.  REGISTER F IS DESTOYED.
BYTOT	PUSH	B
	PUSH	D
	PUSH	H
	MOV	A,C		; BYTE TO WRITE ===> A
	LXI	D,BYTPT		; OFFSET INTO DESCRIPTOR OF BYTE POINTER.
	DAD	D
	INR	M		; INCREMENT BYTE COUNTER/POINTER.
	JRNZ	NTFULL		; FALL THROUGH IF BUFFER IS FULL.

;BLKOT WRITES A 256 BYTE BLOCK WHOSE FILE DESCRIPTOR IS POINTED
;TO BY HL - BYTPT.  IT DESTROYS  DE, BC, F.
;IF LSBYT IS FF THE BLOCK IS NOT WRITTEN.  IN ANY EVENT, LSBYT IS SET TO
;ZERO.  LSBYT SERVES AS A FLAG FOR THE VERY FIRST BYTOT DONE TO A FILE.
BLKOT	PUSH	PSW
	PUSH	H
	INX	H
	MOV	A,M
	MVI	M,0		; SET LSBYT TO ZERO.
	INR	A		; TEST LSBYT FOR FF
	JRZ	FIRSTC		; BRANCH IF THIS IS FROM THE FIRST CALL OF BYTOT.
	LXI	D,FCB-LSBYT
	DAD	D		; HL NOW POINTS TO FCB.
	CALL	SELDSK		; SELECT PROPER DRIVE.
	PUSH	H
	LXI	D,DATAB
	DAD	D		; HL NOW POINTS TO START OF DATA BUFFER.
	XCHG
	MVI	C,26		; CP/M CODE TO SET DMA ADDRESS.
	CALL	CPM
	POP	H
	PUSH	H
	XCHG
	MVI	C,21		; CP/M CODE TO WRITE A SECTOR.
	CALL	CPM
	ORA	A		; TEST FOR ERROR CODE.
	JRNZ	DERR
	POP	H
	PUSH	H
	LXI	D,128+DATAB
	DAD	D		; HL NOW POINTS TO SECOND HALF OF DATA BUFFER.
	XCHG
	MVI	C,26		; CP/M CODE TO SET DMA ADDRESS.
	CALL	CPM
	POP	H
	XCHG
	MVI	C,21		; CP/M CODE TO WRITE A SECTOR.
	CALL	CPM
	ORA	A
	JRNZ	DERR
FIRSTC	POP	H
	POP	PSW

NTFULL	MOV	E,M
	MVI	D,0
	DAD	D
	INX	H
	INX	H		; HL NOW POINTS TO LOCATION FOR NEW BYTE.
	MOV	M,A		; STORE BYTE IN FILE DESCRIPTOR.
	JMP	POPHDB

;THIS DIAGONOSES THE TYPE OF DISK WRITE ERROR.
DERR	LXI	H,UNKERR	;DEFAULT ERROR MESSAGE.
	CPI	1		;TEST FOR ERROR IN EXTENDING FILE.
	JRNZ	NTEXTR
	LXI	H,EXTERR
NTEXTR	CPI	2		; TEST FOR DISK FULL
	JRNZ	NTDFUL
	LXI	H,FULERR
NTDFUL	CPI	255		; TEST FOR DIRECTORY FULL
	JRNZ	NTDIRF
	LXI	H,DIRERR
NTDIRF	JMP	PERROR

UNKERR	DB	'Disk erro','r'+80H	; FOR UNDEFINED ERROR CODES.
EXTERR	DB	'Error in extending fil','e'+80H
FULERR	DB	'Disk ful','l'+80H
DIRERR	DB	'Directory ful','l'+80H
NAMERR	DB	'Bad filename',CR,LF+80H

;CLOSE OUT CLOSES THE OUTPUT FILE WHOSE DESCRIPTOR IS POINTED TO BY HL.

FILCHR	EQU	EOFMRK		; BYTE TO PAD END OF FILE WITH.

CLSOT	PUSH	B
	PUSH	D
	PUSH	H
	PUSH	PSW
	PUSH	H
	LXI	D,BYTPT		; OFFSET INTO FILE OF BYTE POINTER/COUNTER.
	DAD	D
	XCHG
	POP	H		; DE NOW POINTS TO START OF FILE DESCRIPTOR.
EOFILL	MVI	C,FILCHR
	CALL	BYTOT
	LDAX	D
	ORA	A
	JZ	FILLED
	JMP	EOFILL

FILLED	XCHG
	MVI	C,16		; CP/M CODE FOR CLOSE FILE.
	CALL	CPM
	POP	PSW
	JMP	POPHDB


	LIST

;FILE NAME DECODES A STRING FROM THE TEXT BUFFER AS A FILE SPECIFICATION.
;IT STORES THE CORRESPONDING CP/M FILE CONTROL BLOCK (FCB) IN A 34 BYTE
;BLOCK STARTING AT HL.  THE 34TH BYTE IS THE DRIVE NUMBER AND IS NOT
;LOOKED AT BY CP/M (IT IS LOOKED AT BY SELDSK).
FILNAM	PUSH	B
	PUSH	D
	PUSH	H
	PUSH	PSW
	MVI	M,0		; MAKE FIRST BYTE OF FCB ZERO.
	INX	H
	PUSH	H		; HL POINTS TO START OF FCB NAME FIELD.
;FILL THE NAME FIELD WITH SPACES (THE DEFAULT CHARACTER).
	MVI	B,11		; 8 CHARACTERS FOR FILE NAME + 3 FOR FILE TYPE.
DEFSP	MVI	M,' '		; STUFF A SPACE.
	INX	H
	DJNZ	DEFSP

;MAKE THE REST OF THE FCB ZERO.
	MVI	B,33-11-1	;NUMBER OF BYTES TO ZERO.
ZEROLP	MVI	M,0
	INX	H
	DJNZ	ZEROLP

SKIPSP	CALL	TIN		; GET A CHARACTER FROM THE TEXT BUFFER.
	JRZ	SKIPSP		; IGNORE SPACES.
	JRC	FILNER		; Error if no characters in buffer.
	SUI	'A'		; A..P ===> 0..15
	MOV	B,A
	CALL	TIN
	JRC	FILNER		; There has to be at least 2 chars in fn.
	CPI	':'		; IS A DRIVE SPECIFIED?
	JRZ	DRVSP

	PUSH	H
	LHLD	6		; HL POINTS TO TOP OF MEMORY.
	LXI	D,-GETP
	DAD	D		; HL POINTS TO TEXT IN POINTER.
	DCR	M
	DCR	M		; PUSH IT BACK 2 CHARACTERS.

	LHLD	6
	DCX	H		; HL POINTS TO DEFAULT DRIVE #.
	MOV	B,M
	POP	H

;CHARACTER IN A SHOULD BE THE DRIVE LETTER.
DRVSP	MOV	A,B		; DRIVE LETTER ===> A
	CPI	MAXDRV		; IS IT A VALID DRIVE NUMBER?
	JRC	DRVOK
;RETURN AN ERROR CODE.
FILNER	POP	H		; CLEAN UP THE STACK.
NAMER	LXI	H,NAMERR
	CALL	TXTYP		; 'Bad filename'
	POP	PSW
	STC
	JMP	POPHDB

DRVOK	MOV	M,A		; STORE DRIVE NUMBER.

	POP	H
	MVI	B,9		; LIMIT + 1 TO # OF CHARS IN FILE NAME.
SKSP	CALL	TIN
	JRC	NOMORE		; Branch if the text in buffer is empty.
	JRZ	SKSP		; Skip spaces.
	CPI	'.'
	JRZ	NXTPT		; Branch if we have reached the type field.
	MOV	M,A		; STORE THE CHARACTER IN THE FCB.
	INX	H		; INCREMENT THE FCB POINTER.
	DJNZ	SKSP
	JMPR	NAMER		;TOO MANY CHARACTERS IN A FIELD.

NXTPT	MOV	C,B
	MVI	B,4		; LIMIT +1 OF # OF CHARS IN FILE TYPE.
NOIMAG	DCR	C
	JRZ	SKSP
	INX	H
	JMPR	NOIMAG

NOMORE	POP	PSW
	ORA	A
	JMP	POPHDB

TXTBUF	EQU	BUFLEN+2+1+1
GETP	EQU	TXTBUF		; POINTS TO NEXT CHARACTER TO READ FROM BUFFER.
PUTP	EQU	TXTBUF-1	; Points to last character in buffer.

;THE TIN, TXTIN, AND TOUT ROUTINES MANIPULATE A TEXT BUFFER AND
;THEIR ASSOCIATED POINTERS.  THE BUFFER RESIDES IN THE TOP OF THE
;TPA.

;EACH CALL TO TIN RETURNS THE NEXT CHARACTER IN THE TEXT BUFFER.
;A CARRAIGE RETURN IS PASSED TO INDICATE END OF LINE.  A CPI 20H
;IS DONE BEFORE CONTROL IS RETURNED TO THE CALLING PROGRAM.  THUS,
;Z IS TRUE IF THE CHARACTER IS A SPACE AND M AND C ARE TRUE IF
;THE RETURNED CHARACTER IS A CONTROL CHARACTER.  THE CHARACTER IS
;RETURNED IN A.

TIN	PUSH	B
	PUSH	D
	PUSH	H
	LHLD	6		; HL POINTS TO TOP OF TPA + 1.
	LXI	D,-GETP
	DAD	D
	PUSH	H		; Save pointer to text_in_pointer.
	MOV	E,M
	MVI	D,0
	DAD	D		; HL points to next character to read - 1.
	INX	H
	MOV	A,M
	POP	H
	CPI	' '		; Test for end of line.
	JRC	ENDL
	INR	M
	CPI	' '
EN:	JMP	POPHDB

ENDL	INX	H		; HL POINTS TO LAST CHARACTER POINTER.
	MVI	M,0		; MAKE IT 1 FOR FUTURE TOUT CALLS.
	JMPR	EN

;TXTIN READS A LINE INTO THE TEXT BUFFER AND SETS THE TEXT IN
;POINTER TO THE FIRST CHARACTER (TEXT IN POINTER := 1).

TXTIN	PUSH	B
	PUSH	D
	PUSH	H
	LHLD	6
	LXI	D,-GETP
	DAD	D		; HL POINTS TO START OF TEXT BUFFER.
	MVI	M,BUFLEN-1	; TELL CP/M THE MAXIMUM # OF CHARS TO READ.
	XCHG
	MVI	C,10		; CP/M CODE TO READ A LINE.
	CALL	CPM
	MVI	C,CR
	CALL	TOUT
	MVI	C,LF
	CALL	CO
	JMP	POPHDB


;TOUT STUFFS THE CHARACTER PASSED IN C INTO THE TEXT BUFFER.  THE CARRY IS
;SET IFF THE BUFFER IS FULL.  THE TEXT_IN_POINT IS RESET TO THE FIRST
;CHARACTER ON EVERY CALL.

TOUT	PUSH	B
	PUSH	D
	PUSH	H
	PUSH	PSW
	LHLD	6
	LXI	D,-GETP
	DAD	D		; HL POINTS TO THE TEXT_IN_POINTER.
	MVI	M,1		; TEXT_IN_POINTER := 1
	INX	H
	MOV	A,M		; A := TEXT_FILL_POINTER
	CPI	BUFLEN
	JRZ	BFULL		; BRANCH IF BUFFER IS FULL.
	INR	M		; TEXT_FILL_POINTER := TEXT_FILL_POINTER + 1
	MOV	E,M
	MVI	D,0
	DAD	D		; HL POINTS TO SLOT FOR CHARACTER IN C.
	MOV	M,C		; STUFF IT.
	POP	PSW
	ORA	A
	JMP	POPHDB

BFULL	DCR	M		; Make it work.
	MVI	C,CR		; Put CR at end of text buffer.
	CALL	TOUT		; Watch out, here's Recursive Robert.
	POP	PSW
	STC
	JMP	POPHDB

;TXTYP WRITES THE STRING OF CHARACTERS POINTED TO BY HL TO THE CONSOLE.
;A NULL OR A CHARACTER WITH ITS MSB SET MARKS THE END OF THE STRING.

TXTYP	MOV	A,M
	ORA	A
	RZ
	PUSH	PSW
	ANI	7FH
	MOV	C,A
	CALL	CO
	POP	PSW
	RM
	INX	H
	JMPR	TXTYP

;
; CHAIN TO ANOTHER PASCAL PROGRAM WITH THE SAME GLOBAL STACK
;
CHAIN:	LXI	H,5CH		;CP/M default file control block.
	CALL	FILNAM		;PROCESS FILENAME STORED BY FTXTIN
	CALL	OPNIN		;OPEN IT
	JRC	CHERR		;NOT THERE, CHAIN ERROR

	LXI	D,100H		;Start of overlay.
KEEPRD:	PUSH	D		;Save overlay pointer.
	MVI	C,26		; CP/M code to set DMA address.
	CALL	CPM
	LXI	D,5CH
	MVI	C,20
	CALL	CPM		;Read 128 bytes of overlay.
	POP	D
	LXI	H,128
	DAD	D		;Make DMA pointer point to next 128 byte chunk.
	XCHG
	ORA	A		;Test code returned by CP/M.
	JRZ	KEEPRD		;Branch if not EOF.
;
; JUMP INTO CALLED PROGRAM

	XRA	A		; The compiled code likes A=0.
	JMP	L9999+14	; Start program without reinitializing stack.

CHERR:	LXI	H,CHMSG		;POINT TO THE MESSAGE
	JMP	PERROR
CHMSG:	DB	'Unable to chai','n'+80H


;		End of CP/M section
	NLIST

;
;
ILOD:	MACRO	Q,SIZE,OFST	;;INDIRECT LOAD (FOR CALL BY REF VARS
	IF	SIZE&8000H	;;NEGATIVE SIZE
	IF	OFST		;;IF OFFSET IS NON-ZERO
	LXI	B,OFST-2	;;LOAD NON-ZERO OFFSET
	CALL	ILVNZ		;;SKIP THE LOAD ZERO
	ELSE			;;DO ZERO OFFSET
	CALL	ILOADV		;;GOTO LOAD ZERO INSTR
	ENDIF			;;DONE WITH OFFSETS
	ELSE			;;VARIABLE SIZE IS KNOWN
	IF	SIZE-1		;;IF VARIABLE SIZE IS NOT 1
	IF	OFST		;;IF OFFSET IS NON-ZERO
	LXI	B,OFST		;;LOAD NON-ZERO OFFSET
	CALL	IL2NZ		;;SKIP THE LOAD ZERO
	ELSE
	CALL	ILOAD2		;;GOTO LOAD ZERO INSTR
	ENDIF			;;DONE WITH OFFSETS
	ELSE			;;DO VARS WITH A SIZE OF 1
	IF	OFST		;;IF OFFSET IS NON-ZERO
	LXI	B,OFST		;;LOAD NON-ZERO OFFSET
	CALL	IL1NZ		;;SKIP THE LOAD ZERO
	ELSE			;;DO ZERO OFFSET
	CALL	ILOAD1		;;GOTO LOAD ZERO INSTR
	ENDIF			;;DONE WITH OFFSETS
	ENDIF
	ENDIF
	ENDMAC			;;END OF ILOD
;
;
ILOAD1:	LXI	B,0		;LOAD A ZERO
IL1NZ:	PUSH	B		;SAVE THE OFFSET
	PUSH	X		;INDIRECT ALWAYS OF X REG
	POP	B		;ADD OFFSET REG TO VADDR FIELD
	DAD	B		;WHICH IS IN HL
	MOV	B,M		;GET VARIABLE BASE ADDRESS
	DCX	H
	MOV	C,M
IL1V:	POP	H		;GET OFFSET
	DAD	B		;ADD TO BASE ADDRESS
	MOV	L,M		;GET VALUE
	MOV	H,A		;CLEAR HIGH BYTE
	RET			;DONE!!!
;
;
ILOAD2:	LXI	B,0		;LOAD A ZERO
IL2NZ:	PUSH	B		;SAVE THE OFFSET
	PUSH	X		;INDIRECT ALWAYS OF X REG
	POP	B		;ADD OFFSET REG TO VADDR FIELD
	DAD	B		;WHICH IS IN HL
	MOV	B,M		;GET VARIABLE BASE ADDRESS
	DCX	H
	MOV	C,M
IL2V:	POP	H		;GET OFFSET
	DAD	B		;ADD TO BASE ADDRESS
	MOV	B,M		;GET HIGH BYTE
	DCX	H
	MOV	L,M		;GET LOW BYTE
	MOV	H,B		;RESTORE HIGH BYTE
	RET			;DONE!!!
;
;
ILOADV:	LXI	B,0		;ZERO OFFSET
ILVNZ:	PUSH	B		;SAVE THE OFFSET
	PUSH	X		;ALWAYS USE X-REG FOR INDIRECT
	POP	B		;ADD OFFSET REG TO VADDR FIELD
	DAD	B		;WHICH IS IN HL
	MOV	B,M		;GET HIGH ORDER ADDRESS BYTE
	DCX	H
	MOV	C,M		;GET LOW  ORDER ADDRESS BYTE
	DCX	H
	MOV	A,M		;GET VARIABLE SIZE
	DCR	A		;CHECK SIZE
	JRZ	IL1V		;LOAD VAR OF SIZE 1
	XRA	A		;LOAD VAR OF SIZE 2
	JR	IL2V		;DONE!!!
;
;
ISTR:	MACRO	Q,SIZE,OFST	;;INDIRECT STORE A VARIABLE LENGTH INTEGER
	IF	OFST		;;NON ZERO OFFSET
	LXI	B,OFST		;;LOAD OFFSET
	CALL	ISTRNZ
	ELSE
	CALL	ISTORE		;;ZERO OFFSET
	IF	R		;;RANGE CHECKING
	JC	REFERR		;;CALL BY REF ERROR
	ENDIF
	ENDIF
	ENDMAC
;
;
ISTORE:	LXI	B,0		;SET A ZERO OFFSET
ISTRNZ:	PUSH	B		;SAVE THE OFFSET
	PUSH	X		;ALWAYS USE X-REG FOR INDIRECT
	POP	B		;ADD OFFSET REG TO VADDR FIELD
	DAD	B		;WHICH IS IN HL
	MOV	B,M		;HIGH PART
	DCX	H
	MOV	C,M		;LOW PART
	DCX	H
	MOV	A,M		;GET VARIABLE SIZE
	POP	H		;RESTORE OFFSET
	DAD	B		;ADD OFFSET TO THE VARIABLE ADDRESS
	DCR	A
	JRZ	ISTR1		;STORE A ONE BYTE VARIABLE
	XRA	A		;CLEAR ACCUMULATOR
	MOV	M,D		;STORE HIGH BYTE
	MOV	D,A		;CLEAR HIGH BYTE
	DCX	H
ISTR1:	MOV	M,E		;STORE LOW  BYTE
	CMP	D		;CHECK HIGH BYTE FOR OVERFLOW
	RET
;
; LPOP -- POP A VALUE FROM THE MIDDLE OF THE STACK
; USED ONLY FOR SET ASSIGNMENTS
;
LPOP:	MACRO	REG,DISTANCE	;;LONG POP
	IF	DISTANCE	;;LONG POP
	PUSH	H		;;SAVE HL
	LXI	H,DISTANCE+2	;;POINT TO ITEM TO POP
	DAD	S
	MOV	E,M		;;GET LOW BYTE
	INX	H
	MOV	D,M		;;GET HIGH BYTE
	PUSH	D		;;SAVE THIS VALUE
	MOV	D,H		;;COPY POINTER
	MOV	E,L
	DCX	H		;;POINT TO INTERMEDIATE BLOCK
	DCX	H
	LXI	B,DISTANCE	;;LENGTH OF INTERMEDIATE BLOCK
	LDDR			;;MOVE BLOCK UP 2 BYTES
	POP	D		;;GET NEW DE VALUE
	POP	H		;;RESTORE HL
	POP	B		;;FIX STACK POINTER
	ELSE			;;SHORT POP
	POP	D
	ENDIF
	ENDMAC
;
;
ADDR:	MACRO	Q		;;CALCULATE ADDRESS USING SPECIFIED REG
TEMP	SET	'Q'-'IY'
	IF	'Q'-'Y'*TEMP	;;DEFAULT IS X-REG
	CALL	XADDR		;;CALL ROUTINE TO DO IT
	ELSE
	CALL	YADDR		;;OTHERWISE USE Y-REG
	ENDIF
	ENDMAC
;
;
MIDL:	MACRO	REG,LEVEL	;;SET IX TO POINT TO A DIFFERENT LEVEL
	PUSH	X		;;SAVE PRESENT IX
	MVI	A,LEVEL
MIDL1:	SET	$		;;LOOP INDICATOR
	MOV	C,6(X)		;;GET OLD IX
	MOV	B,7(X)
	PUSH	B		;;MOVE POINTER TO IX
	POP	X
	CMP	1(X)		;;CHECK FOR RIGHT LEVEL
	JRNZ	MIDL1		;;NO...TRY AGAIN
	XRA	A		;;CLEAR ACCUMULATOR
	ENDMAC			;;YES, KEEP ON GOING
;
;
DSUB:	MACRO	Q,SIZE
	IF	0!SIZE&8000H	;;CHECK FOR FLOATING POINT SUBTRACTION
	CALL	FSUB
	IF	F		;;CHECK FOR ERROR IF REQUIRED
	JC	FLTERR
	ENDIF
	ELSE			;;SUBTRACT Q OR DE FROM HL
	XRA	A		;;CLEAR CARRY
	DSBC	Q D		;;SUBTRACT IT
	ENDIF
	ENDMAC			;;DONE
;
;
DADD	MACRO	Q,SIZE
	IF	0!SIZE&8000H	;;CHECK FOR FLOATING POINT ADD
	CALL	FADD
	IF	F		;;CHECK FOR ERROR IF REQUIRED
	JC	FLTERR
	ENDIF
	ELSE
	DAD	Q D		;;ADD Q OR DE TO HL
	ENDIF
	ENDMAC
;
;
XADDR:	DSUB			;SUBTRACT VARPART
	PUSH	X		;GET X-REG
	POP	D		;X-REG -> B-REG
	DAD	D		;ADD OFFSET TO REGISTER
	RET			;DONE!!!
;
;
YADDR:	DSUB			;SUBTRACT VARPART
	PUSH	Y		;GET Y-REG
	POP	D		;Y-REG -> B-REG
	DAD	D		;ADD OFFSET TO REGISTER
	RET			;DONE!!!
;
;
ENTR:	MACRO	Q,LVL,VSIZ	;;ENTER A PROC/FCT ON LVL WITH VSIZ VARS
	IF	LVL-1		;;CHECK FOR INNER LEVELS
	MVI	B,LVL		;;SAVE LEVEL NUMBER
	LXI	D,-VSIZ		;;SAVE VSIZ BYTES OF STACK
	IF	S		;;DO STACK CHECKING
	CALL	ENTRSC		;;ENTER WITH STACK CHEKING
	ELSE
	CALL	ENTER		;;A SUBROUTNE WILL FINISH
	ENDIF
	ELSE			;;LEVEL 1
	LXI	H,1-VSIZ	;;SET UP STACK POINTER
	DAD	S
	SPHL
	LXI	D,LAST+MARGIN	;;DO STACK CHECKING FOR LEVEL 1
	DSUB	D		;SUBTRACT DE FROM HL
	JC	STKERR		;OVERFLOW!!
; LABEL TO JUMP TO FOR A CHAINED PROGRAM
CHAIN$:
	ENDIF
	ENDMAC			;;ALL ENTERED
;
;
ENTRSC:	INR	A		;INDICATE STACK CHECKING
ENTER:	XTIX			;SAVE OLD DA POINTER
	LXI	H,0		;CLEAR OUT NEW DA
	PUSH	H
	PUSH	H
	PUSH	B		;SAVE LEVEL NUMBER
	DAD	S		;SP -> HL
	INX	S		;LEVEL IS ONE BYTE
	PUSH	H		;THIS VALUE IS NEW DA POINTER AND
	XTIX	
	DAD	D		;SUBTRACT ROOM FOR VARIABLES
	POP	D		;GET RETURN ADDRESS
	SPHL			;NEW SP
	PUSH	D		;RETURN ADDR -> TOP OF STACK
	ORA	A		;DO STACK CHECKING?
	RZ			;NO, JUST RETURN
	XRA	A		;CLEAR ACCUMULATOR
	EXX
	MOV	B,A		;CLEAR STATEMENT REGISTER
	MOV	C,A
	PUSH	H		;MOVE TOP OF THE HEAP
	EXX
	LXI	D,MARGIN	;GET SAFETY MARGIN
	DSUB	D		;SUBTRACT SAFETY MARGIN
	POP	D		;GET TOP OF HEAP
	DSUB	D		;CHECK FOR SP >= TOH+MARGIN
	JC	STKERR		;...STACK OVERFLOW ERROR
	RET			;ALL DONE
;
;
EXIT:	MACRO	Q,SSIZ		;;EXIT FROM A PROC/FCT
	LXI	H,SSIZ+6	;;GET NUMBER OF STACK BYTES
	JMP	EXITF		;;FINISH UP IN A SUBROUTINE
	ENDMAC
;

	LIST
;
EXITF:	SPIX			;CHANGE SP -> DA
	POP	B		;SKIP LEVEL NUMBER
	POP	B		;SKIP DWITH VALUE
	DAD	S		;GET NEW STACK POINTER
;
; IN ORDER TO CLOSE OUTPUT FILES CORRECTLY JUST
; CLOSE ALL FILES WHOSE BUFFER ADDRESS IS LESS THAN
; THE ADDRESS IN THE HL REGISTER PAIR
; B, C, D, E, H, L MAY BE CHANGED PLEASE LEAVE THE
; OTHER REGISTERS INTACT ( THE ACCUMULATOR HAS A ZERO )
;
	PUSH	Y		;SAVE Y
	LXI	B,OUTLST
	DADY	B
	MVI	B,MAXOUT
	XCHG			;NEW STACK POINTER IN DE
SFLT:	MOV	H,1(Y)		;GET POSSIBLE BUFFER ADDRESS
	MOV	L,0(Y)
	MOV	A,H
	ORA	L		;CHECK FOR A ZERO
	JRZ	FGT		;YES, DON'T TRY TO CLOSE IT
	PUSH	H
	DSBC	D		;SEE IF FILE IS BELOW THE STACK
	POP	H
	JRNC	FGT		;NO, DON'T CLOSE IT
	INX	H		;POINT TO FDOS BUFFER
	INX	H
	INX	H
	CALL	CLSOT		;CLOSE THE FILE
	XRA	A
	MOV	0(Y),A		;INDICATE THAT THIS SLOT IS EMPTY
	MOV	1(Y),A
FGT:	INX	Y
	INX	Y
	DJNZ	SFLT
	XRA	A		;ZERO A
	POP	Y		;RESTORE Y
	XCHG			;RESTORE HL (NEW STACK POINTER)
	POP	D		;GET RETURN VALUE
	POP	X		;OLD DA POINTER
	POP	B		;GET RETURN ADDRESS
	SPHL			;SET NEW STACK POINTER
	MOV	H,B		;RETURN ADDRESS -> HL
	MOV	L,C
	CMP	E		;SET CARRY IF NECESSARY
	EXX			;CLEAR BC AS STATEMENT TRACE
	MOV	B,A
	MOV	C,A
	EXX
	PCHL			;RETURN
;
;
ERROR:	EXX			;CHECK STATEMENT NUMBER
	MOV	A,B
	ORA	C
	CNZ	PSTAT		;PRINT NON-ZERO STATEMENT NUMBER
ERR1:	CALL	TIN		;ERROR EXIT ROUTINES ARE THE SAME
	JRNC	ERR1		;AS NORMAL EXIT BUT EMPTY TXTIN FIRST
;
;
L0:	LXI	B,OUTLST	;CLOSE ALL REMAINING OPEN OUTPUT FILES
	DADY	B		;POINT TO OPEN OUTPUT FILE POINTERS
	MVI	B,MAXOUT	;LAST PART OF OUTPUT FILE TABLE
L0A:	MOV	H,1(Y)		;GET NEXT ADDRESS
	MOV	L,0(Y)		;AND CHECK FOR NON-ZERO
	INX	Y		;BUMP POINTER
	INX	Y
	MOV	A,H
	ORA	L
	INX	H		;ADD 3 TO POINTER IN CASE
	INX	H		;IT'S A FILE POINTER
	INX	H
	CNZ	CLSOT		;CLOSE FILE FOR NON-ZERO POINTER
	DJNZ	L0A		;GO CHECK NEXT POINTER IF THERE IS ONE
	JMP	RESTRT		;ALL DONE
;
	NLIST
;
EQUL:	MACRO	Q,SIZE		;;EQUALITY TEST
	IF	SIZE		;;TEST FOR STRUCTURED RELOP
	IF	SIZE&8000H	;;CHECK FOR FP OPERATION
	CALL	FPEQ		;;YES, DO FP OP
	ELSE
	LXI	B,SIZE		;;SAVE VAR SIZE
	CALL	SEQUL
	ENDIF
	ELSE
	CALL	IEQUL		;;INTEGER TEST
	ENDIF
	ENDMAC
;
;
NEQL:	MACRO	Q,SIZE		;;NON-EQUALITY TEST
	IF	SIZE		;;TEST FOR STRUCTURED RELOP
	IF	SIZE&8000H	;;CHECK FOR FP OPERATION
	CALL	FPNEQ		;;YES, DO FP OP
	ELSE
	LXI	B,SIZE		;;SAVE VAR SIZE
	CALL	SNE
	ENDIF
	ELSE
	CALL	INE		;;INTEGER TEST
	ENDIF
	ENDMAC
;
;
LE:	MACRO	Q,SIZE		;;LESS THAN OR EQUAL TEST
	IF	SIZE		;;TEST FOR STRUCTURED RELOP
	IF	SIZE&8000H	;;CHECK FOR FP OPERATION
	CALL	FPLTE		;;YES, DO FP OP
	ELSE
	LXI	B,SIZE		;;SAVE VAR SIZE
	CALL	SLE	
	ENDIF
	ELSE
	CALL	ILE		;;INTEGER TEST
	ENDIF
	ENDMAC
;
;
LESS:	MACRO	Q,SIZE		;;LESS THAN TEST
	IF	SIZE		;;TEST FOR STRUCTURED RELOP
	IF	SIZE&8000H	;;CHECK FOR FP OPERATION
	CALL	FPLT		;;YES, DO FP OP
	ELSE
	LXI	B,SIZE		;;SAVE VAR SIZE
	CALL	SLT	
	ENDIF
	ELSE
	CALL	ILT		;;INTEGER TEST
	ENDIF
	ENDMAC
;
;
GE:	MACRO	Q,SIZE		;;GREATER THAN OR EQUAL TO TEST
	IF	SIZE		;;TEST FOR STRUCTURED RELOP
	IF	SIZE&8000H	;;CHECK FOR FP OPERATION
	CALL	FPGTE		;;YES, DO FP OP
	ELSE
	LXI	B,SIZE		;;SAVE VAR SIZE
	CALL	SGE	
	ENDIF
	ELSE
	CALL	IGE		;;INTEGER TEST
	ENDIF
	ENDMAC
;
;
GRET:	MACRO	Q,SIZE		;;GREATER THAN TEST
	IF	SIZE		;;TEST FOR STRUCTURED RELOP
	IF	SIZE&8000H	;;CHECK FOR FP OPERATION
	CALL	FPGT		;;YES, DO FP OP
	ELSE
	LXI	B,SIZE		;;SAVE VAR SIZE
	CALL	SGT	
	ENDIF
	ELSE
	CALL	IGT		;;INTEGER TEST
	ENDIF
	ENDMAC
;
;
FDVD:	MACRO	Q,SIZE		;;FLOATING POINT DIVISION
	CALL	FDIVD
	IF	F		;;CHECK FOR ERROR IF REQUIRED
	JC	DIVERR
	ENDIF
	ENDMAC
;
;
MULT:	MACRO	Q,SIZE		;;CALL MULTIPLY ROUTINE
	IF	0!SIZE&8000H	;;CHECK FOR FLOATING POINT OPERATION
	CALL	FMULT
	IF	F		;;CHECK FOR ERROR IF REQUIRED
	JC	MLTERR
	ENDIF
	ELSE
	IF	M		;;CHECK FOR OVERFLOW
	CALL	IMULT
	ELSE			;;USE FAST ROUTINE
	CALL	QMULT
	ENDIF
	ENDIF
	ENDMAC
;
;
DIVD:	MACRO			;;CALL DIVIDE ROUTINE
	CALL	IDIVD
	IF	M		;;CHECK FOR OVERFLOW
	JC	DIVERR
	ENDIF
	ENDMAC

;
;
MMOD:	MACRO			;;CALL MOD ROUTINE
	CALL	IMOD
	IF	M		;;CHECK FOR OVERFLOW
	JC	DIVERR
	ENDIF
	ENDMAC
;
;
NEGT:	MACRO	REG		;;NEGATE SPECIFIED REGISTER PAIR
	IF	'REG'-'H'	;;DO DE PAIR OR FLOAT
	IF	'REG'-'D'	;;DO FLOAT NUMBER
	POP	H		;;GET LOW WORD
	POP	D		;;GET HIGH WORD
	MVI	A,80H		;;SET HIGH BIT
	XRA	E		;;TOGGLE HIGH BIT OF E
	MOV	E,A		;;REPLACE HIGH WORD OF MANTISSA
	PUSH	D		;;RESTORE HIGH WORD
	PUSH	H		;;RESTORE LOW  WORD
	ELSE			;;DO DE PAIR
	MOV	A,E
	CMA			;;COMPLEMENT LOW BYTE
	MOV	E,A
	MOV	A,REG
	CMA			;;COMPLEMENT HIGH BYTE
	MOV	REG,A
	INX	REG		;;AND INCREMENT
	ENDIF
	ELSE
	MOV	A,L
	CMA			;;COMPLEMENT LOW BYTE
	MOV	L,A
	MOV	A,REG
	CMA			;;COMPLEMENT HIGH BYTE
	MOV	REG,A
	INX	REG		;;AND INCREMENT
	ENDIF
	XRA	A		;;CLEAR ACCUMULATOR
	ENDMAC
;
; RUN-TIME CONTROL MACROS
;
CTRL:	MACRO			;;CHECK FOR A CTRL-C
	IF	C		;;IF CTRL-C CHECKING IS ENABLED
	CALL	CSTS		;;CHECK FOR A CHARACTER TYPED
	JRZ	$+16		;;NO CHARACTER....CONTINUE
	CALL	CI		;;GET THE CHARACTER
	CPI	'C'&3FH		;;IS IT A CTRL-C
	JZ	ERROR		;;YES....ABORT!!!
	MVI	C,7		;;RING BELL
	CALL	CO
	XRA	A		;;CLEAR THE ACCUMULATOR BEFORE
	ENDIF			;;RETURNING
	ENDMAC
;
;
RCHK:	MACRO	REG,LBND,HBND	;;RANGE CHECK MACRO
	IF	R		;;ONLY CHECK IF CHECKING IS ENABLED
	LXI	B,LBND		;;SAVE LOWER BOUND
	IF	'REG'-'H'	;;DO DE REGISTER PAIR
	PUSH	H		;;SAVE POSSIBLE ADDRESS
	LXI	H,HBND		;;SAVE UPPER BOUND
	CALL	CHKDE		;;CHECK IT
	POP	H		;;RESTORE POSSIBLE ADDRESS
	ELSE
	PUSH	D		;;SAVE DE REGISTER PAIR
	LXI	D,HBND		;;SAVE UPPER BOUND
	CALL	CHKHL		;;CHECK THE VALUE
	POP	D		;;RESTORE DE
	ENDIF
	ENDIF
	ENDMAC
;
;
CHKDE:	CALL	IGE		;MAKE SURE THAT THE UPPER BOUND IS
	JRNC	RNGERR		;GREATER THAN/ EQUAL TO DE
	MOV	H,B
	MOV	L,C
	CALL	ILE		;MAKE SURE THAT THE LOWER BOUND IS
	RC			;LESS THAN/ EQUAL TO DE
	JR	RNGERR		;OOOPS!!
;
;
CHKHL:	CALL	ILE		;MAKE SURE HL IS LESS THAN/ EQUAL TO
	JRNC	RNGERR		;THE UPPER BOUND
	MOV	D,B
	MOV	E,C
	CALL	IGE		;MAKE SURE THAT HL IS GREATER THAN/EQUAL TO
	RC			;THE LOWER BOUND
	JR	RNGERR		;ERROR
;
;
STMT:	MACRO	Q,NUMBER	;;MACRO FOR TRACES AND....
	IF	T+E		;;....EXTENDED ERROR MESSAGES
VALID	SET	0FFFFH		;;STATEMENT NUMBER IS VALID
	EXX			;;SWITCH REGISTER SETS TO SINCE
	LXI	B,NUMBER	;;STATEMENT NUMBER IS STORED IN OTHER BC
	IF	T		;;PRINT NUMBER IF TRACE
	IF	'M'-'Q'
	CALL	PSTAT		;;IS ON
	ENDIF
	ENDIF
	EXX			;;RESTORE PROGRAM REGISTERS
	ELSE			;;NO OPTIONS ENABLED
	IF	VALID		;;IF OPTION WAS JUST TURNED OFF
	EXX			;;THEN SET ALTERNATE BC TO ZERO
	MOV	B,A		;;CLEAR BC
	MOV	C,A
	EXX
VALID	SET	00000H		;;SET INVALID FLAG
	ENDIF
	ENDIF
	ENDMAC			;;END OF MACRO
;
;
PSTAT:	PUSH	H		;SAVE HEAP POINTER
	LXI	H,STMTMSG	;PRINT STATEMENT MESSAGE
	PUSH	B		;STATEMENT NUMBER -> HL
	CALL	TXTYP
	POP	H
	PUSH	H
	LXI	D,1000		;DO THOUSANDS DIGIT
	CALL	DIGIT
	LXI	D,100		;DO HUNDREDS  DIGIT
	CALL	DIGIT
	LXI	D,10		;DO TENS DIGIT
	CALL	DIGIT
	LXI	D,1		;DO ONES DIGIT
	CALL	DIGIT
	LXI	H,CRLF		;POINT TO CRLF
	CALL	TXTYP		;PRINT IT
	POP	B		;RESTORE STATEMENT NUMBER
	POP	H		;RESTORE HEAP POINTER
	XRA	A		;CLEAR ACC
	RET
;
DIGIT:	MVI	C,'0'-1		;INITIALIZE ASCII COUNTER
	XRA	A		;CLEAR CARRY
DIG1:	INR	C		;BUMP COUNTER
	DSBC	D		;TRY ANOTHER SUBTRACTION
	JRNC	DIG1		;KEEP IT UP WHILE POSITIVE RESULT
	DAD	D		;ELSE MAKE RESULT +IVE
	JMP	CO		;PRINT CHAR AND RETURN TO CALLER
;
; ERROR MESSAGES
;
FLTERR:	LXI	H,FLTMSG	;FLOATING POINT ERROR
	JR	PERROR
HPERR:	LXI	H,HPMSG		;HEAP OVERFLOW
	JR	PERROR
REFERR:	LXI	H,REFMSG	;BY-REF PRECISION ERROR
	JR	PERROR
STKERR:	LXI	H,STKMSG	;POINT TO STACK ERROR MESSAGE
	JR	PERROR
RNGERR:	LXI	H,RNGMSG	;POINT TO THE OUT OF RANGE MESSAGE
	JR	PERROR		;PRINT THE ERROR MESSAGE
DIVERR:	LXI	H,OUMSG		;DIVIDE ERROR
	JR	PERROR
MLTERR	LXI	H,MLTMSG	;MULTIPLY ERROR
PERROR:	CALL	TXTYP		;PRINT IT
	JMP	ERROR		;AND ABORT
;
REFMSG	DB	'Call by reference precision erro','r'+80H
RNGMSG	DB	'Index or value out of rang','e'+80H
OUMSG	DB	'Attempted divide by zer','o'+80H
MLTMSG	DB	'Multiply overflo','w'+80H
STKMSG	DB	'Stack overflo','w'+80H
STMTMSG	DB	' -- statement',' '+80H
HPMSG	DB	'Heap overflo','w'+80H
FLTMSG	DB	'Floating point overflow/underflo','w'+80H
CRLF	DB	CR,LF+80H
;
;
; MULTIPLY ROUTINES
;
;
;MULTIPLY REQUIRES THE A REGISTER TO BE 0
;THE MULTIPLIER MUST BE IN DE AND THE MULTIPLICAND MUST BE IN HL
QMULT:	MVI	B,17	;FAST MULTIPLY -- NO ERROR CHECKING
	CMP	D	;OPTIMIZATION SECTION...
	JRZ	OPT	;...CHECK FOR A ZERO HIGH BYTE
	CMP	H
	JRNZ	NOOPT	;CAN'T FIND ONE
	XCHG
OPT:	MVI	B,9	;ONLY DO NINE SHIFTS
	MOV	D,E
NOOPT:	MOV	A,B	;NUMBER OF SHIFTS
	MOV	B,H	;COPY HL -> BC
	MOV	C,L
	LXI	H,0	;CLEAR RESULT
MLOOP:	DCR	A	;CHECK SHIFT COUNTER
	RZ
	DAD	H	;SHIFT PARTIAL RESULT
	XCHG
	DAD	H	;SHIFT MULTIPLIER
	XCHG
	JRNC	MLOOP	;NEXT SHIFT
	DAD	B	;ADD IN MULTIPLICAND
	JR	MLOOP
;
;
IMULT:	PUSH	D	;SAVE A COPY OF THE MULTIPLICAND
	PUSH	H	;SAVE A COPY OF THE MULTIPLIER
;MAKE BOTH OPERANDS POSITIVE
	BIT	7,D
	JRZ	CANDP	;MULTIPLICAND POSITIVE
	PUSH	H	;SAVE MULTIPLIER
	MOV	H,A	;0 HL
	MOV	L,A
	XRA	A
	DSBC	D	;CHANGE SIGNS OF MULTIPLICAND
	XCHG		;MOVE MULTIPLICAND
	POP	H	;POP ABS OF MULTIPLIER
CANDP:	BIT	7,H
	JRZ	CAND0	;MULTIPLIER POSITIVE
	PUSH	D
	XCHG
	XRA	A
	MOV	H,A
	MOV	L,A
	DSBC	D
	POP	D

;IS THE MULTIPLICAND 0?
CAND0:	CMP	H
	JRNZ	SETUP
	CMP	L
	JRNZ	OP2ONE

;MULTIPLICAND IS ZERO
	POP	H	;MULTIPLICAND
	POP	D	;MULTIPLIER
	XRA	A
	RET

;IS MULTIPLICAND 1 OR -1
OP2ONE:	DCR	L
	INX	H
	JRNZ	SETUP

;IT'S A ONE, WHAT'S THE SIGN?
	XRA	A
	POP	D	;MULTIPLICAND
	POP	H	;MULTIPLIER
	BIT	7,D
	RZ		;SIGN STAYS THE SAME

;CHANGE THE SIGN
	JR	CSIGN

SETUP:	MOV	B,D
	MOV	C,E
	XCHG
	MOV	H,A
	MOV	L,A
;MULTIPLY LOOP
MCONT:	SRAR	B	;SHIFT MULTIPLICAND
	RRAR	C
	JRNC	MTEST
	DAD	D
	BIT	7,H
	JNZ	MLTERR	;JUMP TO OVERFLOW ERROR ROUTINE

MTEST:	SLAR	E	;SHIFT MULTIPLIER
	RLAR	D
	MOV	A,B
	ORA	C
	JRNZ	MCONT

;DONE MULTIPLY
	POP	B	;ORIGINAL MULTIPLICAND
	POP	D	;ORIGINAL MULTIPLIER
	MOV	A,D
	XRA	B	;LIKE SIGNS IS POSITIVE
	BIT	7,A	;OTHERWISE NEGATIVE
	JRZ	POS
CSIGN:	XCHG
	XRA	A   
	MOV	H,A
	MOV	L,A
	DSBC	D

POS:	XRA	A
	RET

;ABSOLUTE VALUE RETURNS THE ABSOLUTE VALUE OF THE SIXTEEN BIT
;NUMBER IT IS PASSED IN HL IN HL.
ABS:	BIT	7,H
	RZ		;POSITIVE NUMBER
	XCHG		;COMPLEMENT NUMBER
	MOV	H,A
	MOV	L,A
	XRA	A
	DSBC	D
	RET
;
; RETURN THE ABSOLUTE VALUE OF A FLOATING POINT NUMBER
;
FPABS:	POP	H	;GET RETURN ADDRESS
	POP	D	;GET LOW WORD OF NUMBER
	POP	B	;GET HIGH WORD
	RES	SIGN,C	;CLEAR SIGN BIT
	PUSH	B	;RESTORE NUMBER
	PUSH	D	;....AND....
	PCHL		;RETURN
;
; SQUARE AN INTEGER
;
SQR:	MOV	D,H	;SET DE = HL
	MOV	E,L
	JMP	IMULT	;MULTIPLY HL BY HL
;
; SQUARE A FLOATING POINT NUMBER
;
FPSQR:	POP	H	;GET RETURN ADDRESS
	POP	D	;GET FLOATING POINT NUMBER
	POP	B
	PUSH	B	;RESTORE FLOATING POINT NUMBER
	PUSH	D
	PUSH	B	;MAKE A COPY OF IT
	PUSH	D
	PUSH	H	;RESTORE RETURN ADDRESS
	JMP	FMULT	;AND MULTIPLY
;
;
; DIVIDE ROUTINES
;
;DIVIDE HL BY DE

;SAVE A COPY OF THE DIVISOR AND
;THE DIVIDEND FOR THE SIGNS
IDIVD:	PUSH	D
	PUSH	H
	XRA	A
;MAKE BOTH THE DIVISOR AND DIVIDEND POSITIVE
	BIT	7,D
	JRZ	DIVSPO
	MOV	H,A
	MOV	L,A
	DSBC	D	;CHANGE SIGN
	XCHG
	POP	H
	PUSH	H
DIVSPO:	BIT	7,H
	JRZ	DIVDPO
	PUSH	D
	XCHG
	XRA	A
	MOV	H,A
	MOV	L,A
	DSBC	D	;CHANGE SIGN
	POP	D

;NOW BOTH ARE POSITIVE, CHECK FOR DIVISION BY ZERO
DIVDPO:	CMP	D
	JRNZ	CKNM
	ORA	E
	JRZ	ZERO	;DIVISION BY ZERO
;CHECK FOR DIVISION BY ONE
	DCR	A
	JRNZ	NOTONE
;DIVISION BY ONE OR MINUS ONE
	POP	H
	POP	D
	BIT	7,D
	JRZ	ONEDON
	XCHG		;DIVISOR NEGATIVE CHANGE SIGN
	XRA	A
	MOV	H,A	;OF THE ANSWER
	MOV	L,A
	DSBC	D
ONEDON:	MOV	D,A	;REMAINDER:=0
	MOV	E,A
	XRA	A	;CLEAR CARRY
	RET

NOTONE:	DCR	A
	JRNZ	NOTTWO

;DIVISION BY TWO
	MOV	B,H	;ANSWER INTO BC
	MOV	C,L
	SRAR	B
	RRAR	C
	MOV	H,A	;REMAINDER:=0
	MOV	L,A
	RLAR	L	;REMAINDER = CARRY
	JR	SIGNS

;DIVISION BY  ZERO
ZERO:	POP	H
	POP	D
	STC		;SET CARRY INDICATES OVFL ERROR
	RET

NOTTWO:	XRA	A	;CLEAR A

;NORMALIZE THE DIVISOR, KEEPING COUNT OF THE NUMBER
;OF SHIFTS REQUIRED TO ACCOMPLISH THIS
CKNM:	BIT	6,D
	JRNZ	NORM
	INR	A
	SLAR	E	;SHIFT DIVISOR LEFT ONE BIT
	RLAR	D
	JMPR	CKNM

NORM:	LXI	B,0H
	INR	A
;DIVIDE LOOP
DIVLOP:	ORA	A	;CLEAR CARRY
	DSBC	D	;ATTEMPT SUBTRACTION
	JRC	FAIL
	STC
	RLAR	C	;SHIFT ONE INTO ANSWER
	RLAR	B
	JMPR	TEST

;SUBTRACTION FAILED
FAIL:	DAD	D
	SLAR	C	;SHIFT ZERO INTO NUMBER
	RLAR	B

;END LOOP TEST
TEST:	SRAR	D	;SHIFT DIVISOR
	RRAR	E
	DCR	A
	JRNZ	DIVLOP

;DONE DIVISION IS COMPLETE
;THE MAGNITUDE OF THE REMAINDER IS IN HL
;THE MAGNITUDE OF THE ANSWER IS IN BE
SIGNS:	POP	PSW	;ORIGINAL DIVIDEND, HIGH BYTE -> ACC
	POP	D	;DIVISOR
	XCHG		;REMAINDER INTO DE
	XRA	H	;LIKE OR UNLIKE SIGNS
	LXI	H,0H
	JP	LIKE
	DSBC	B	;CARRY IS ALREADY CLEAR FROM XRA H
	XRA	A	;RESET CARRY
	RET

LIKE:	DAD	B
	XRA	A	;CLEAR A AND RESET CARRY
	RET

;MOD RETURNS HL - ( ( HL DIV DE ) * DE )
IMOD:	BIT	7,H	;CHECK SIGN OF RESULT
	JRZ	POSRSLT
	CALL	IDIVD
	RC		;DONE IF AN ERROR OCCURRED
	MOV	H,A
	MOV	L,A	;CHANGE SIGN OF RESULT
	DSBC	D
	XRA	A	;CLEAR CARRY
	RET

;RESULT IS POSTIVE
POSRSLT	CALL	IDIVD
	XCHG
	RET

	LIST
;FILE ROUTINES
;SYSTEM FILE BUFFER STRUCTURE
;FIRST BYTE IS END OF FILE FLAG
;SECOND IS THE READ AHEAD BYTE FOR INPUT FILES
;AND THE WRITEN TO FLAG FOR OUTPUT FILES
;THE THIRD IN THE END OF LINE FLAG
;FOLLOWING THESE ARE THE K2 BUFFER

;RESET REOPENS AN INPUT FILE, SO A USER CAN
;READ IT FROM THE BEGINNING

;GET BUFFER ADDRESS FROM STACK
RESET:	PUSH	B		;SAVE <FNAM> LENGTH
	PUSH	Y
	CALL	SCAN
	JRNC	SKIP
	PUSH	H
	INX	H	;ADJUST POINTER  TO K2 BUFFER
	INX	H
	INX	H
	CALL	CLSOT
	XRA	A	;REMOVE IT FROM OUTPUT LIST
	STAX	B
	DCX	B
	STAX	B
	POP	H
SKIP:	POP	Y
	POP	B	;GET <FNAM> LENGTH
	POP	D	;RETURN ADDRESS
	INX	H
	INX	H
	INX	H
	CALL	MOVNAM
	JRC	YEOF	;SET END OF FILE, BAD FILENAME
	CALL	OPNIN	;REOPEN FILE
	JRC	YEOF	;SET END OF FILE, NO SUCH FILE EXISTS
;READ FIRST BYTE AND SET EOF AND EOLN FLAGS
	CALL	BYTIN
	MOV	C,A
	JRC	YEOF
	CPI	CR
	JRZ	YEOLN
	CPI	LF
	JRZ	YEOLN
	DCX	H
	XRA	A
	MOV	M,A	;RESET EOLN FLAG
	DCX	H
	MOV	M,C	;STORE READ BYTE
	DCX	H
	MOV	M,A	;RESET EOF FLAG
	XCHG
	PCHL

;SET END OF FILE FLAG
YEOF:	DCX 	H
	DCX	H
	DCX	H
	MVI	M,1
	JMPR	YCONT

;SET EOLN INDICATER
YEOLN:	XRA	A
	DCX	H
	DCX	H
	DCX	H
	MOV	M,A	;RESET EOF FLAG
YCONT:	INX	H
	MOV	M,C	;STORE READ BYTE
	INX	H
	MVI	M,1	;SET EOLN FLAG
	XCHG
	XRA	A	;CLEAR ACCUMULATOR
	PCHL


;REWRITE OPENS A FILE TO BE WRITTEN TO BY
;THE USER UNDER THE NAME X

REWRITE:POP	D	;RETURN ADDRESS
;FIND THE FILE BUFFER IN THE LIST OR ADD IT
	PUSH	B
	CALL	CHKLST
	POP	B
;MOVE THE NAME INTO THE BUFFER
	INX	H
	INX	H
	INX	H
	CALL 	MOVNAM
	JRC	BADWRT	;BAD FILENAME
	CALL	DELETE	;DELETE ANY DUPLICATES
	CALL	OPNOT	;REOPEN IT
	XRA	A
	DCX	H
	MVI	M,1	;SET EOLN INDICATER
	DCX	H
	MOV	M,A	;RESET WRITTEN FLAG
	DCX	H
	MVI	M,1	;SET EOF INDICATER
	XCHG
	PCHL

;CHKLST EITHER FINDS THE BUFFER ADDRESS IN THE LIST,
;ADDS IT TO THE LIST, OR PRINTS AN ERROR IF MORE THAN
;MAXOUT OUTPUT FILES ARE OPEN SIMULTANEOUSLY.
CHKLST:	PUSH	Y
	CALL	SCAN
	JRNC	NOTFND
	INX	H	;CLOSE FILE IF FOUND
	INX	H
	INX	H
	CALL	CLSOT
	DCX	H
	DCX	H
	DCX	H
	POP	Y	;BUFFER IN LIST
	RET

;BUFFER ISN'T IN THE LIST, CHECK FOR SPACE
NOTFND:	POP	Y
	PUSH	Y
	PUSH	H
	MOV	H,A
	MOV	L,A
	CALL	SCAN
	JRNC	ERRTMF	;ADDRESS OF FIRST FREE SPACE IN LIST IS IN BC
	POP	H	;GET BUFFER ADDRESS
	MOV	A,H	;PUT BUFFER ADDRESS INTO LIST
	STAX	B
	DCX	B
	MOV	A,L
	STAX	B
	POP	Y
	RET

;TOO MANY OUTPUT FILES OPEN SIMULTANEOUSLY
ERRTMF:	LXI	H,ERRMES
	JMP	PERROR
ERRMES:	DB	'Too many open output file','s'+80H

;BADWRT BAD FILENAME ON OUTPUT FILE
;FATAL ERROR
BADWRT:	LXI	H,BNAM
	JMP	PERROR
BNAM:	DB	'Bad output file nam','e'+80H

;SCAN CHECKS THE OUTPUT FILE LIST FOR THE CONTENTS
;OF HL. Y POINTS TO THE START OF THE LIST
;SCAN SETS THE CARRY AND RETURNS THE ELEMENTS ADDRESS IN BC
SCAN:	LXI	B,OUTLST	;POINT TO BEGINNING OF LIST
	DADY	B
	MOV	A,L
	MVI	B,MAXOUT*2
CONTLK:	CMP	0(Y)
	JRZ	FNDLOW
	INX	Y
	INX	Y
	DCR	B
	DJNZ	CONTLK
	XRA	A	;ELEMENT NOT FOUND
	RET

;FOUND LOW BYTE
FNDLOW:	MOV	A,H
	INX	Y
	DCR	B
	CMP	0(Y)
	JRZ	FNDIT
	MOV	A,L
	INX	Y
	DJNZ	CONTLK
	XRA	A	;ELEMENT NOT FOUND
	RET

;FOUND ELEMENT IN LIST
FNDIT:	PUSH	Y
	POP	B
	XRA	A
	STC
	RET


;MOVNAM MOVES THE FILENAME FROM TI BUFFER
;STACK INTO THE FILE BUFFER AREA
;MOVNAM IS CALLED WITH A ZERO.
;DE CONTAINING THE FIRST RETURN ADDRESS
;HL CONTAINING THE FILE BUFFER ADDRESS
;AND THE FILENAME ON THE STACK
;MOVNAM MUST RETURN THESE REGISTERS UNCHANGED
;AND THE FILENAME REMOVED FROM THE STACK
;THE LENGTH OF THE STRING TO BE MOVED IS IN C

STAKSP	EQU	3

MOVNAM:	CALL	TIN	;EXHAUST TI BUFFER
	JRNC	MOVNAM
	PUSH	H	;FILE BUFFER ADDRESS
	LXI	H,STAKSP;GET DISPLACEMENT
	DAD	S
	XRA	A
	MOV	B,A
	DAD	B	;ADD LENGTH
	PUSH	H	;NEW STACK POINTER
;MOVE FILENAME TO THE TI BUFFER
	MOV	B,C
TOTI:	MOV	C,M
	CALL	TOUT
	DCX	H
	DJNZ	TOTI
;MOVE A CARRIAGE RETURN INTO TI BUFFER
	MVI	C,CR
	CALL	TOUT
;PARSE FILENAME AND MOVE IT INTO BUFFER AREA
	POP	B	;NEW STACK POINTER
	POP	H	;FILE BUFFER ADDRESS
	CALL	FILNAM
	EXAF
EMPBUF:	CALL	TIN
	CPI	CR
	JRNZ	EMPBUF
	EXAF
	PUSH	B	;NEW SP
	XTHL
	POP	B	;GET FILE BUFFER ADDRESS
	XTHL		;GET SECOND RETURN ADDRESS AND SAVE LOW BYTE
	MOV	A,L
	XTHL		;RESTORE NEW SP
	MOV	M,D	;FIRST RETURN ADDRESS
	DCX	H
	MOV	M,E
	MOV	D,B	;FILE BUFFER ADDRESS
	MOV	E,C
	POP	B	;SECOND RETURN ADDRESS
	MOV	C,A
	SPHL		;REMOVE FILENAME FROM STACK
	XCHG		;FILE BUFFER ADDRESS
	POP	D	;FIRST RETURN ADDRESS
	PUSH	B	;SECOND RETURN ADDRESS
	MVI	A,0	;CLEAR ACC WITHOUT DISTURBING CARRY
	RET


;WRITELN WRITES THE PARAMETER LIST TO THE SPECIFIED
;OUTPUT FILE, SETS THE END OF FILE FLAG,
;AND APPENDS A CARRIAGE RETURN AND LINE FEED
;TO TERMINATE THE CURRENT LINE 

SYSLOC	EQU	5	;SYSTEM LOCATIONS

WRITEL:	PUSH	X	;SAVE X
	CALL	PNTR
	PUSH	X	;SAVE BEGINNING
;IDENTIFY THE FILE TYPE
	MOV	B,0(X) 
	CMP	B
	JRNZ	CONSOL
;NON-CONSOLE FILE
	CALL	BUFADR
;SET BUFFER FLAGS
	MVI	M,1	;SET EOF
	INX	H
	MVI	M,1	;SET WRITTEN
	INX	H
	MVI	M,1	;SET EOLN
	INX	H	;HL POINTS TO K2 BUFFER
	JMPR	TEXT

;CONSOLE FILE
;ALL CONSOLE FILES MUST BE TEXT
CONSOL:	MOV	H,A
	MOV	L,A

;TEXT FILE
TEXT:	CALL	TXTFIL

;APPEND THE CARRIAGE RETURN AND LINE FEED
ADDCR:	MVI	C,CR
	CALL	PRINT
	MVI	C,LF
	CALL	PRINT
;CLEAN UP STACK AND RETURN
CLEAN:	POP	H	;BEGINNING OF LIST
	INX	H
	POP	X	;RESTORE OLD X
	POP	D	;RETURN ADDRESS
	SPHL		;REMOVE LIST FROM STACK
	XCHG		;RETURN ADDRESS
	PCHL

;WRITE WRITES THE PARAMETER LIST TO THE SPECIFIED
;OUTPUT FILE, SETS THE END OF FILE FLAG, RESETS THE
;END OF LINE FLAG, AND SETS THE WRITE INDICATER FLAG

WRITE:	PUSH	X	;SAVE X
	CALL	PNTR
	PUSH	X	;SAVE BEGINNING
;IDENTIFY FILE TYPE
	MOV	B,0(X)
	CMP	B
	JRNZ	CONSO2
;NON- CONSOLE FILE
	CALL	BUFADR
;SET BUFFER FLAGS
	MVI	M,1	;SET EOF
	INX	H
	MVI	M,1	;SET WRITTEN
	INX	H
	MOV	M,A	;RESET EOLN
	INX	H	;HL POINTS TO OPSYS  BUFFER
;TEST FOR NON-TEXT FILE
	CMP	B
	JNZ	NONTXT
	JMPR	TEXT2

;CONSOLE FILE
;ALL CONSOLE FILES MUST BE TEXT FILES
CONSO2:	MOV	H,A
	MOV	L,A

;TEXTFILE
TEXT2:	CALL	TXTFIL
;CLEAN UP STACK AND RETURN
	JR	CLEAN	;CLEAN UP AND RETURN

;PNTR SETS UP THE POINTERS FOR WRITING
PNTR:	LXI	X,SYSLOC
	DADX	S
	DADX	B	;X POINTS TO START OF LIST
	MOV	D,B
	MOV	E,C	;COUNT IN DE
	RET

;BUFADR PUTS THE BUFFER ADDRESS IN HL FOR NON-CONSOLE FILES
BUFADR:	DCX	D
	DCX	X
	MOV	B,0(X)	;FILE TYPE
	DCX	D
	DCX	X
	MOV	H,0(X)	;BUFFER ADDRESS
	DCX	D
	DCX	X
	MOV	L,0(X)
	DCX	X
	DCX	D
	RET

;PROCESS PARAMETER LIST
;THE ODD WORDS IDENTIFY THE PARAMETER TYPE
;1-BOOLEAN,2-INTEGER,3-CHARACTER,4-SCALAR
;THE EVEN WORDS ARE THE VALUE OF THE PARAMETER
;TEST FOR THE END OF LIST

TXTFIL:	MOV	A,D
	ORA	E
	RZ		;LIST EXHAUSTED:RETURN
NXTPAR:	XRA	A	;CLEAR A
	MOV	B,0(X)
	DCX	X	;POINTER
	DCX	D	;BYTE COUNT
	DCR	B
	CZ	BOOL	;BOOLEAN
	DCR	B
	CZ	INTEG	;INTEGER
	DCR	B
	CZ	CHAR	;CHARACTER
	DCR	B
	CZ	SCALAR	;SCALAR
	JMPR	TXTFIL

;SCALARS ARE PRINTED BY CALCULATING THE ADDRESS AND PRINTING
;THE SYMBOLIC NAME OF THE SCALAR
SCALAR:	LXI	B,-4	;FIX...
	DADX	B	;....PARAMETER LIST POINTER
	XCHG
	DAD	B	;....BYTE COUNT
	PUSH	H	;SAVE BYTE COUNT
	PUSH	D	;SAVE FILE POINTER
	MOV	B,4(X)	;MINIMUM SYMBOL LENGTH
	MOV	L,3(X)	;GET SCALAR VALUE
	MOV	H,A	;IN THE HL PAIR
	DAD	H	;X2
	DAD	H	;X4
	DAD	H	;X8  SYMBOLS ARE 8 CHARS EACH
	MOV	D,2(X)	;GET HIGH BYTE OF BASE ADDRESS
	MOV	E,1(X)	;GET LOW BYTE
	DAD	D	;CALCULATE ADDR OF THIS SYMBOL
	MVI	D,8	;MAXIMUM LENGTH IS EIGHT
SCLR1:	MOV	C,M	;LOOP TO PRINT THE SYMBOL
	MOV	A,C	;CHECK FOR A SPACE
	CPI	' '
	JRZ	SCLR2	;YES..GO PAD
	INX	H	;BUMP SYMBOL POINTER
	XTHL		;SWITCH POINTERS
	CALL	PRINT	;PRINT IT
	XTHL		;SWITCH POINTERS
	DCR	D
	JRZ	SCLR2	;NO MORE SYMBOL
	DJNZ	SCLR1	;CHECK FIELD LENGTH
	INR	B
	JR	SCLR1	;AND GO DO NEXT CHAR
SCLR2:	POP	H	;POINT TO FILE
	POP	D	;GET BYTE COUNT
	MVI	C,' '	;GET A SPACE
SCLR2A:	DCR	B	;CHECK FOR MORE SPACES
	RZ		;NO...RETURN
	CALL	PRINT	;YES..PRINT ONE
	JR	SCLR2A	;CHECK AGAIN
;
;CHARACTER OUTPUTS A CHARACTER STRING TO THE FILE
CHAR:	MOV	B,-2(X)		;CALCULATE LENGTHS
	MOV	A,0(X)
	SUB	B		;FIGURE HOW MUCH PADDING
	EXAF			;SAVE PADDING COUNT
	DCX	X		;BUMP POINTER AND COUNTER
	DCX	X
	DCX	D
	DCX	D
CHAR1:	DCX	X
	DCX	D
	MOV	C,0(X)		;GET NEXT CHARACTER
	CALL	PRINT
	DJNZ	CHAR1		;DO FOR ALL CHARACTERS IN THE STRING
	EXAF	
	DCX	X
	DCX	D
	RM			;RETURN IS NO PADDING REQUIRED
	RZ
	MOV	B,A
	MVI	C,' '
CHAR2:	CALL	PRINT
	DJNZ	CHAR2
	RET

;BOOLEAN PRINTS EITHER TRUE OR FALSE
;RIGHT JUSTIFIED IN A FIELD OF THE SIZE SPECIFIED IN THE BYTE
;OF THE PARAMETER LIST

BOOL:
	IF	NOT COMPILER	;DON'T USE WITH COMPILER
	DCX	X
	DCX	X
	DCX	D
	DCX	D
	PUSH	D	;SAVE BYTE COUNT
	CMP	1(X)	;GET VALUE
	MOV	A,2(X)	;GET FIELD SIZE
	LXI	B,4	;LENGTH OF 'TRUE'
	LXI	D,TRUE	;ACTUAL MESSAGE
	JRC	ISTRUE
	XCHG
	DAD	B	;NOT TRUE...
	XCHG
	INR	C	;POINT TO 'FALSE'
ISTRUE:	SUB	C	;COMPUTE PADDING
	EXAF		;SAVE PADDING COUNT
	MOV	B,C
FIT1A:	LDAX	D	;GET CHARACTER
	MOV	C,A
	CALL	PRINT	;PRINT IT
	INX	D	;BUMP POINTER
	DJNZ	FIT1A
	POP	D	;RESTORE BYTE COUNT
	EXAF	
	RC		;FIELD NEEDS EXPANDING
	RZ		;FIELD A PERFECT FIT
	MOV	B,A
	MVI	C,' '
BLANKS:	CALL	PRINT
	DJNZ	BLANKS
	RET		;DONE

TRUE:	DB	'TRUE'
	DB	'FALSE'
	ENDIF

;INTEGER OUTPUTS THE INTEGER RIGHT JUSTIFIED
;IN THE FIELD WIDTH SPECIFIED BY THE NEXT BYTE
;IN THE PARAMETER LIST.  IF THE NUMBER IS TOO 
;BIG FOR THE FIELD, THE FIELD IS EXTENDED ON 
;THE RIGHT.

INTEG:	DCX	D
	DCX	D
	DCX	D
	PUSH	D	;BYTE COUNTER
	MOV	D,-1(X)	;GET VALUE
	MOV	E,-2(X)
	PUSH	X
	POP	B
	LXI	X,-6	;RESERVE STACK SPACE FOR DIGIT STRING
	DADX	S
	SPIX
	PUSH	H	;FILE BUFFER ADDRESS
	PUSH	B	;PARAMETER LIST POINTER
	LXI	B,5
	DADX	B	;DIGIT STRING POINTER
	BIT	7,D	;TEST SIGN
	JRZ	POSNUM
	MVI	0(X),'-';NEGATIVE NUMBER
	DCX	X
	XRA	A	;CLEAR CARRY
	MOV	H,A
	MOV	L,A
	MOV	B,A
	DSBC	D
	JMPR	NUM

POSNUM:	XCHG		;POSITIVE NUMBER
	MOV	0(X),A	;ZERO SIGN BYTE
	DCX	X
NUM:	MOV	C,A	;ZERO CHARACTER COUNT
	LXI	D,10000
	CALL	FIGURE
	LXI	D,1000
	CALL	FIGURE
	LXI	D,100
	CALL	FIGURE
	LXI	D,10
	CALL	FIGURE
	MOV	B,L	;LAST DIGIT
	CALL	ADIGIT
	MOV	B,A
	DADX	B
	INX	X	;X POINTS TO THE SIGN
	MOV	A,0(X)
	CPI	'-'
	JRNZ	CHK0
	INR	C
	JMPR	NEGA

CHK0:	CMP	C
	JRNZ	POSN
	MVI	0(X),'0'	;OUTPUT A ZERO
	INR	C
	JMPR	NEGA

POSN:	DCX	X
NEGA:	MOV	B,C
	POP	H
	MOV	A,M	;GET FIELD  LENGTH
	XTHL		;FILE BUFFER ADDRESS
;			;SAVE PARAMETER LIST POINTER
	SUB	B
	JRC	PERFIT	;EXTEND THE FIELD TO MATCH
	JRZ	PERFIT	;FIELD MATCHES
	MOV	D,A
	MVI	C,' '	;PAD THE NUMBER TO MATCH THE FIELD
PAD:	CALL	PRINT
	DCR	D
	JRNZ	PAD
PERFIT:	MOV	C,0(X)	;PRINT THE DIGIT STRING
	CALL	PRINT
	DCX	X
	DJNZ	PERFIT
;NUMBER IS PRINTED CLEANUP MESS AND RETURN
	POP	X	;RESTORE LIST POINTER
	DCX	X
	DCX	X
	DCX	X
	XCHG		;REMOVE DIGIT STRING FROM STACK
	LXI	H,6
	DAD	S
	SPHL
	XCHG
	POP	D	;RESTORE PARAMETER BYTE COUNTER
	XRA	A	;CLEAR A
	RET

;FIGURE COUNTS HOW MANY TIMES DE GOES INTO HL
FIGURE:	XRA	A	;CLEAR CARRY
	DCR	B
CONT:	INR	B	;COUNTER
	DSBC	D
	JRNC	CONT
TOOFAR:	DAD	D	;PUT BACK LAST TRY

;ADIGIT ADDS A DIGIT TO THE STRING ON THE STACK
;IF THE FIRST NON-ZERO DIGIT HAS BEEN
;ENCOUNTERED. IT ALSO INCREMENTS THE DIGIT COUNTER.

ADIGIT:	CMP	B
	JRNZ	NUDIG
	CMP	C	;DIGIT IS A 0
	RZ		;FIRST DIGIT
NUDIG:	MVI	A,30H	;ASCII
	ADD	B
	MOV	0(X),A	;ADD DIGIT TO STRING
	DCX	X
	INR	C	;DIGIT COUNTER
	XRA	A
	MOV	B,A
	RET


;NONTXT OUTPUTS A DATA STREAM TO A NON-TEXT DISK FILE
NONTXT:
	IF	NOT COMPILER	;DON'T USE WITH COMPILER
	PUSH	H	;SAVE FILE BUFFER ADDRESS
NONTX1:	LXI	B,-4	;UPDATE PARAMETER POINTER
	DADX	B
	XCHG
	DAD	B
	XCHG
	MOV	H,2(X)	;GET BYTE COUNT
	MOV	L,1(X)
NTLP:	MOV	C,0(X)	;GET NEXT DATA BYTE
	DCX	X	;POINTER
	DCX	H	;BYTE COUNT
	DCX	D	;PARAMETER COUNT
	XTHL
	CALL	DIS	;TO THE DATA
	XTHL
	MOV	A,H	;DONE?
	ORA	L
	JRNZ	NTLP
	MOV	A,D	;END OF PARAMETER LIST
	ORA	E	;ALL PARAMETERS ARE EITHER TEXT OR NON-TEXT
	JRNZ	NONTX1
	POP	H	;FILE BUFFER COUNT
	JMP	CLEAN
	ENDIF

;BUFFER ADDRESS IS NON-ZERO AND TO THE CONSOLE CRT
;IF THE FILE BUFFER ADDRESS IS ZERO.

PRINT:	XRA	A	;KEEP THE A-REG A ZERO
	CMP	H
	JRNZ	DIS
	CMP	L
	JRNZ	DIS
	CALL	CO	;CONSOLE
	XRA	A
	RET

DIS:	CALL	BYTOT	;DISK FILE
	XRA	A
	RET


	NLIST
;
;
;UNSTRUCTURED RELOPS
;HL<OP>DE
;
; STATUS BITS
EQBIT:	EQU	1		;HL = DE
LTBIT:	EQU	2		;HL < DE
GTBIT:	EQU	4		;HL > DE

;NOT EQUALS
INE:	MOV	A,D		;DO EQUALS, NOT EQUALS SEPERATELY
	CMP	H		;SEE IF H = D
	JRNZ	MTRUE		;NO, -> HL <> DE
	MOV	A,E		;SEE IF L = E
	SUB	L
	JR	FINREL		;GO FINISH THIS RELOP

;EQUALS
IEQUL:	MOV	A,D		;COMPARE D, H
	CMP	H
	JRNZ	FALSE		;IF H <> D THEN HL <> DE
	MOV	A,E
	CMP	L		;IF E = L  THEN HL =  DE
	JRZ	MTRUE
	JR	FALSE		;OTHERWIZE HL <> DE

;GREATER THAN OR EQUAL TO
IGE:	CALL	CMPINT		;COMPARE INTEGERS
	ANI	GTBIT+EQBIT	;GREATER THAN OR EQUAL TO
	JR	FINREL		;GO FINISH THIS RELOP

;LESS THAN OR EQUAL TO
ILE:	CALL	CMPINT		;COMPARE INTEGERS
	ANI	LTBIT+EQBIT	;LESS THAN OR EQUAL TO
	JR	FINREL		;GO FINISH THIS RELOP

;GREATER THAN
IGT:	CALL	CMPINT		;COMPARE INTEGERS
	ANI	GTBIT		;GREATER THAN
	JR	FINREL		;GO FINISH THIS RELOP

;LESS THAN
ILT:	CALL	CMPINT		;COMPARE INTEGERS
	ANI	LTBIT		;LESS THAN
	JR	FINREL		;GO FINISH THIS RELOP


;
; ACTUALLY COMPARE TWO INTEGERS
;
CMPINT:	MOV	A,D		;CHECK FOR DIFFERENT SIGNS
	XRA	H
	MOV	A,D
	JM	DFSN		;YES...DIFFERENT SIGNS
	CMP	H		;COMPARE HIGH BYTES
	JRNZ	CMPDN1		;FOUND THE MOST SIGNIFICANT DIFFERENCE
	MOV	A,E		;COMPARE LOW BYTES
	CMP	L
	MVI	A,EQBIT		;ASSUME INTEGERS ARE EQUAL
	RZ			;YES...DONE COMPARING
CMPDN1:	MVI	A,LTBIT		;ASSUME HL < DE, -> CARRY NOT SET
	RNC			;YES....HL < DE
	MVI	A,GTBIT		;OTHERWIZE HL > DE
	RET			;RETURN
DFSN:	ADD	A		;SHIFT HIGH BIT OF D INTO THE CARRY
	JR	CMPDN1		;AND SET APPROPRIATE FLAGS

FINREL:	RZ			;DONE IF RELOP IS FALSE
MTRUE:	XRA	A		;CONDITION IS TRUE, CLEAR A, SET CARRY
	STC
	RET

	LIST
MTRUE1	POP	D
	POP	H
	JR	MTRUE

FALSE:	XRA	A		;CONDITION IS FALSE, CLEAR A, RESET CARRY
	RET


;EOLN RETURNS THE CARRY SET IF THE END OF LINE FLAG IN THE BUFFER
;IS SET AND RETURNS THE CARRY RESET IF IT ISN'T. IT EXPECTS HL TO CONTAIN
;THE FILE BUFFER ADDRESS.
;MUST BE CALLED WITH A 0
;EOLN( 0 ) IS DEFINED AS EOLN ON THE CONSOLE
;EOLN MUST PRESERVE REGISTERS BECAUSE IT IS CALLED BY INPUT ROUTINES

EOLN:	XRA	A
	PUSH	H
	CMP	H		;CHECK FOR CONSOLE POINTER
	JRNZ	FEOLN		;NO...CHECK FILE EOLN
	PUSH	D
	LHLD	6
	LXI	D,-PUTP
	DAD	D
	MOV	A,M		; A := fill pointer.
	DCX	H
	CMP	M		; fill pointer - text_in_pointer
	JRC	MTRUE1		; Branch if end of line.
	MOV	E,M
	MVI	D,0
	DAD	D
	INX	H		; HL points to next character to read.
	MOV	A,M
	CPI	CR		; EOLN is also true if we about to read a CR.
	JRZ	MTRUE1
	POP	D
	POP	H
	JR	FALSE

FEOLN:	INX	H		;THE EOLN FLAG IS THE THIRD BYTE OF THE BUFFER
	INX	H
	CMP	M
	POP	H
	JRZ	FALSE
	JMPR	MTRUE

;EOF RETURNS THE CARRY SET IF END OF FILE IS TRUE AND RESET IF IT IS
;FALSE. IT EXPECTS HL TO CONTAIN THE BUFFER ADDRESS.
;A REG MUST BE 0

EOF:	XRA	A
	CMP	H		;FOR CONSOLE FILES END OF FILE IS ALWAYS FALSE
	JRZ	FALSE
	CMP	M
	JRNZ	MTRUE
	JMPR	FALSE


;FTXTIN ALLOWS THE USER TO FILL THE PASCAL TXTIN BUFFER
FTXTIN:	MOV	H,A		;SET HL TO LENGTH OF STRING+1
	MOV	L,C
	INX	H
	DAD	SP		;POINT TO STRING
	PUSH	H		;SAVE THIS POINTER
	MOV	B,C		;MOVE COUNT TO B-REGISTER
FTXT2:	CALL	TIN		;FIRST EMPTY THE BUFFER
	CPI	CR
	JRNZ	FTXT2
FTXT3:	MOV	C,M		;GET CHAR
	CALL	TOUT
	DCX	H		;BUMP POINTER
	DJNZ	FTXT3		;CHECK FOR MORE
	MVI	C,CR
	CALL	TOUT		;ADD A CR
	POP	H
	POP	D		;GET RETURN ADDRESS
	INX	H		;FIX STACK
	SPHL
	XRA	A
	XCHG			;AND...
	PCHL			;...RETURN

	NLIST

;STRUCTURED RELOPS
;THESE ROUTINES ARE CALLED WITH THE LENGTH OF
;THE PARAMETERS IN BC, AND THE PARAMETERS
;ARE ON THE STACK IMMEDIATELY UNDERNEATH THE
;RETURN ADDRESS. THE BYTE IN THE PARAMETER OCCUPYING
;THE HIGHEST MEMORY LOCATION IS THE MOST SIGNIFICANT.
;EXPRESSIONS ARE EVALUATED A<COND>B WHERE A IS
;THE PARAMETER OCCUPYING THE HIGHER MEMORY ADDRESSES.
;THE ROUTINES REMOVE THE PARAMETERS FROM THE STACK
;WHEN THEY RETURN AND SET THE CARRY IF THE
;CONDITION IS TRUE.

Z0012	EQU	 6		;SYSTEM LOCATIONS

;STRUCTURED EQUALS
SEQUL:	CALL	Z0009
	RET

;STRUCTURED NOT EQUALS
SNE:	CALL	Z0009
	CMC			;COMPLEMENT THE CARRY
	RET

;STRUCTURED GREATER THAN
SGT:	CALL	Z0010
	RET

;STRUCTURED LESS THAN OR EQUALS
SLE:	CALL	Z0010
	CMC			;COMPLEMENT THE CARRY
	RET

;STRUCTURED LESS THAN
SLT:	CALL	Z0011
	RET

;STRUCTURED GREATER THAN OR EQUALS
SGE:	CALL	Z0011
	CMC			;COMPLEMENT CARRY
	RET

;Z0009 EVALUATES THE EQUALS CONDITION AND SETS THE CARRY
Z0009:	PUSH	X
	LXI	X,Z0012
	DADX	S
	PUSH	X
	POP	H		;HL POINTS TO SECOND OPERAND
	DADX	B		;X POINTS TO FIRST OPERAND
;COMPARE THE TWO OPERANDS BYTE BY BYTE
Z0001:	MOV	A,0(X)
	INX	X
	CCI 
	JRNZ	Z0008
	JV	Z0001

;THE TWO OPERANDS ARE IDENTICAL
;CONDITION IS TRUE, CLEAN UP AND SET THE CARRY
Z0014:	XTIX			;RESTORE IX
	POP	H		;GET NEW SP
	POP	D		;GET FIRST RETURN ADDR
	POP	B		;GET SECOND RETURN ADDR
	SPHL			;SET NEW STACK POINTER
	PUSH	B		;RESTORE SECOND RETURN ADDR
	XCHG			;RETURN ADDR -> HL
	XRA	A		;CLEAR ACCUMULATOR
	STC			;SET THE CARRY
	PCHL			;RETURN

;THE TWO OPERANDS ARE NOT EQUAL
Z0008:	DADX	B		;NEW STACK POINTER
;CONDITION IS FALSE, CLEAN UP AND RESET THE CARRY
Z0013:	XTIX			;RESTORE IX
	POP	H		;GET NEW SP
	POP	D		;GET FIRST RETURN ADDR
	POP	B		;GET SECOND RETURN ADDR
	SPHL			;SET NEW STACK POINTER
	PUSH	B		;RESTORE SECOND RETURN ADDR
	XCHG			;RETURN ADDR -> HL
	XRA	A		;CLEAR ACCUMULATOR
	PCHL			;RETURN

;Z0010 EVALUATES THE GREATER THAN CONDITION AND SETS THE CARRY
Z0010:	PUSH	X
	LXI	X,Z0012-1
	DADX	S
	DADX	B
	PUSH	X
	POP	H		;HL POINTS TO SECOND OPERAND
	DADX	B		;X POINTS TO FIRST OPERAND
	PUSH	X		;BEGINNING OF PARAMETER LIST

;COMPARE THE TWO OPERANDS BYTE BY BYTE
Z0002:	MOV	A,M
	CMP	0(X)
	DCX	X
	DCX	H
	JRC	Z0004
	JRNZ	Z0006
	DCX	B    
	XRA	A		;CLEAR CARRY AND CHECK FOR THE END OF PARAMETERS
	CMP	B
	JRNZ	Z0002
	CMP	C
	JRNZ	Z0002
; OPERANDS ARE ACTUALLY IDENTICAL
Z0006:	POP	X
	INX	X
	JMPR	Z0013

;THE GREATER THAN CONDITION IS TRUE
Z0004:	POP	X
	INX	X
	JMPR	Z0014

;Z0011 ACTUALLY EVALUATES THE LESS THAN CONDITION AND SETS THE CARRY
; ACCORDINGLY
Z0011:	PUSH	X
	LXI	X,Z0012-1
	DADX	S
	DADX	B
	PUSH	X
	POP	H		;HL POINTS TO SECOND OPERAND
	DADX	B		;X POINTS TO FIRST OPENAND
	PUSH	X		;BEGINNING OF PARAMETER LIST

;COMPARE THE TWO OPERANDS BYTE BY BYTE
Z0003:	MOV	A,M
	CMP	0(X)
	DCX	X
	DCX	H
	JRC	Z0006
	JRNZ	Z0004
	DCX	B    
	XRA	A		;CLEAR CARRY AND CHECK FOR THE END OF PARAMETERS
	CMP	B
	JRNZ	Z0003
	CMP	C
	JRNZ	Z0003
	JR	Z0006

	LIST

;INPUT ROUTINES

;READLN INPUTS DATA FROM THE FILE INTO THE LISTED 
;PARAMETERS.  THEN ADVANCES THE POINTER IN THE FILE TO
;THE BEGINNING OF THE NEXT LINE IN THE FILE AND SETS THE
;END OF LINE FLAG. IF THE END OF FILE IS REACHED BEFORE
;THE END OF THE PARAMETER LIST A FATAL ERROR IS DETECTED
;AND EXECUTION IS TERMINATED.

READ:	CALL	READIT		;READ WHAT'S IN THE LIST
	RET			;AND RETURN

READLN:	CALL	READIT
;IF WE'RE AT THE END OF A LINE THEN DON'T SCAN AT ALL
;OTHERWISE, SEARCH FOR THE NEXT CARRIAGE RETURN, LINE FEED
SKCR:	CALL	EOLN		;CHECK FOR EOL
	RC			;YES...RETURN
	CALL	INPUT		;NO....SKIP ANOTHER CHARACTER
	JR	SKCR

;INPUT IS CALLED WITH THE PASCAL FILE BUFFER ADDRESS IN HL
;IT RETURNS THE NEXT READ BYTE IN REGISTER A.
;INPUT CAN CHANGE ONLY THE A REGISTER AND C REGISTER
INPUT:	MOV	A,H
	ORA	A
	JRNZ	NCONS

;ZERO ADDRESS IN HL MEANS INPUT IS FROM THE CONSOLE WITH NO LOOK AHEAD.
	CALL	TIN
	JM	LSTCR
	MVI	L,0
	RET
;CARRIAGE RETURN ENCOUNTERED CHECK FOR END OF INPUT ITEM
LSTCR:	CPI	'C'&3FH	;CHECK FOR CTRL-C
	JZ	ERROR
	DCR	L	;CHECK FOR FIRST BYTE OF ITEM
	CZ	TXTIN	;GET MORE IF THIS IS THE FIRST CALL
	CALL	TIN	;GET FIRST CHARACTER AND RETURN TO CALLER
	CPI	'C'&3FH	;CHECK FOR CTRL-C
	JZ	ERROR
	CPI	LF
	RNZ
	MVI	A,CR
	RET		;DON'T RETURN A LINE FEED, USE A CR INSTEAD

;NON-ZERO ADDRESS IN HL MEANS DISK FILE INPUT
NCONS:	PUSH	B
	PUSH	D
	XRA	A
	CMP	M	;CHECK FOR READ BEYOND END OF FILE
	JRNZ	RBEOF
	MOV	D,H
	MOV	E,L
	INX	H
	INX	H
	INX	H
	CALL	BYTIN	;GET NEXT CHARACTER
	JRC	GEOF
	CPI	EOFMRK	; Test for end of file mark.
	JRZ	GEOF
	MOV	B,A
	CPI	CR
	JRZ	NCR	;NEXT CHARACTER A CR
	CPI	LF
	JRZ	NLF
FIN:	XRA	A
	DCX	H
	MOV	M,A	;RESET EOLN
FIN1:	DCX	H
	MOV	C,M	;READ LOOK AHEAD
	MOV	M,B
	DCX	H
	MOV	M,A	;RESET	EOF
	MOV	A,C
NTXIT:	CPI	CR	;THE CHARACTER OCCUPYING THE POSITION MARKER
	JRZ	MAKBLK	;IS DEFINED TO BE A BLANK.
	CPI	LF
	JRNZ	NOBLK
MAKBLK:	MVI	A,' '
NOBLK:	POP	D
	POP	B
	CPI	' '	;SET FLAGS LIKE TIN
	RET

;NEXT CHARACTER IS A CARRIAGE RETURN
NCR:	XCHG
	INX	H
	MOV	A,M
	CPI	CR
	JRZ	SKIPCH
	CPI	LF
	JRZ	SKIPCH
	XCHG
SETEL:	DCX	H
	MVI	M,1	;SET EOLN
	XRA	A
	JR	FIN1

;READ ANOTHER BYTE
SKIPCH:	XCHG
	CALL	BYTIN
	JRC	GEOF
	MOV	B,A
	CPI	CR
	JRZ	SETEL
	CPI	LF
	JRZ	SETEL
	JR	FIN

;NEXT CHARACTER IS A LINE FEED
NLF:	XCHG
	INX	H
	MOV	A,M
	CPI	CR
	JRZ	SKIPCH
	XCHG
	CPI	LF
	JRZ	SETEL
	JMPR	FIN

;END OF FILE
GEOF:	DCX	H
	MVI	M,1	;SET EOLN
	DCX	H
	MOV	C,M	;READ LOOK AHEAD
	MOV	M,A
	MOV	A,C
	DCX	H
	MVI	M,1	;SET EOF
	JR	NTXIT


;READ BEYOND END OF FILE, FATAL ERROR
RBEOF:	LXI	H,EOFMES
	JMP	PERROR
EOFMES:	DB	'Read beyond EO','F'+80H

;PROCESS THE PARAMETER LIST, THE ODD WORDS SPECIFY THE TYPE
;1-BOOLEAN, 2-DOUBLE BYTE INTEGER, 3-CHARACTER,4-SINGLE BYTE INTEGER.
;THE EVEN WORDS ARE THE ADDRESS OF THE PARAMETER.
;FILE BUFFER ADDRESS ALREADY IN HL

RSSLOC	EQU	5	;SKIP RETURN ADDRESSES

READIT:	PUSH	X
	LXI	X,RSSLOC
	MOV	D,B	;NUMBER OF PARMS
	MOV	E,C
	DADX	SP	;EACH PARAMETER IS 4 BYTES LONG
	DADX	D	;SET X TO START OF PARAMETER LIST
	DADX	D	;SET X TO START OF PARAMETER
	DADX	D	;SET X TO START OF PARAMETER
	DADX	D	;SET X TO START OF PARAMETER
	PUSH	X	;NEW STACK POINTER

;IX POINTS TO NEXT BYTE ON PARAMETER LIST
;DE HOLDS THE NUMBER OF BYTES IN THE PARAMETER LIST
	MOV	H,A	;ASSUME CONSOLE FILE UNTIL
	MOV	L,A	;PROVEN OTHERWIZE
	CMP	-2(X)	;IDENTIFY FILE TYPE
	JRNZ	BEGIN	;CONSOLE FILE...GO PROCESS PARAMETER LIST
	MOV	H,0(X)	;FILE BUFFER ADDRESS
	DCX	X
	DCX	D
	MOV	L,0(X)
	DCX	X
	DCX	X
	DCX	X
;TEXT OR NON-TEXT FILE
	CMP	1(X)
	JNZ	NTXT

;TEST FOR THE END OF LIST
BEGIN:	MOV	A,D
	ORA	E
	JRZ	THREW	;ZERO COUNT
;GET PARAMETER TYPE
NEWPAR:	XRA	A
	CMP	H
	JRNZ	NEWP1	;CHECK FOR CONSOLE FILE
	INR	L	;INDICATE FIRST CHARACTER
NEWP1:	MOV	B,-2(X)
	DCR	B
	CZ	BOOLE	;BOOLEAN
	DCR	B
	CZ	RINTEG	;INTEGER
	DCR	B
	CZ	CHARA	;CHARACTER
	DCR	B
	DCR	B
	DCR	B
	CZ	FLTIN	;GET A FLOATING POINT NUMBER
	DCX	D	;COUNTER
	LXI	B,-4	;POINTER
	DADX	B
	JR	BEGIN

;REMOVE PARAMETER LIST FROM STACK, RESTORE X, AND RETURN
THREW:	XCHG
	POP	H	;POP NEW STACK POINTER
	MOV	M,D	;SAVE BUFFER ADDRESS
	DCX	H
	MOV	M,E
	POP	X	;RESTORE X
	POP	D	;SECOND RETURN ADDRESS
	POP	B	;FIRST RETURN ADDRESS
	SPHL		;NEW STACK POINTER
	POP	H	;FILE BUFFER ADDRESS
	PUSH	B	;FIRST RETURN ADDRESS
	PUSH	D	;SECOND RETURN ADDRESS
	RET		;RETURN

;CHARACTER READS THE NEXT CHARACTER IN FROM THE FILE
;AND MOVES IT TO THE APPROPRIATE LOCATION.
CHARA:	MOV	B,-3(X)	;GET LENGTH
	PUSH	H	;FILE BUFFER ADDRESS
	MOV	H,0(X)	;GET ADDRESS OF VARIABLE
	MOV	L,-1(X)
	XTHL
	JR	CHST
;INPUT THE CHARACTERS
STRIN:	XTHL		;SWITCH VARIABLE ADDRESS WITH
	CALL	EOF	;RECOGNIZE END OF FILE AS A TERMINATER
	JRC	FILLIN
	CALL	EOLN
	JRC	FILLIN
CHST:	CALL	INPUT
	CPI	CR	;CHECK FOR A BLANK LINE
	JRZ	FILLIN
	XTHL		;FILE BUFFER ADDRESS
	MOV	M,A	;STORE CHARACTER
	DCX	H
	DJNZ	STRIN
	POP	H	;FILE BUFFER ADDRESS
	RET

;FILLIN PADS STRING OUT TO REQUIRED LENGTH WITH BLANKS
FILLIN:	XTHL
FILLN1:	MVI	M,' '
	DCX	H
	DJNZ	FILLN1
	POP	H	;FILE BUFFER ADDRESS
	RET

	NLIST


;BOOLEAN READS THE CHARACTER STRING TRUE OR
;FALSE FROM THE INPUT FILE AND TRANSFORMS T TO 1
;AND F TO 0 AND STORES IT IN THE APPROPRIATE PLACE.
BOOLE:
	IF	NOT COMPILER	;DON'T USE WITH COMPILER
	CALL	INPUT
	CPI	'T'
	JRZ	TRUIN	;TRUE
	CPI	'F'	;FALSE
	JRZ	FALIN
	CPI	' '	;A BLANK
	JRZ	BOOLE
	JMP	ERRTYP	;TYPE ERROR

;TRUE, FIND THE E OR ' ' OR CR OR LF OR SKIP AT MOST THE NEXT 
;THREE CHARACTERS.
TRUIN:	MVI	B,3
	CALL	SKIM
	MVI	B,1	;VARIABLE GETS ONE
	JMPR	STOBOO

;FALSE, FIND THE E,' ',OR SKIP AT MOST FOUR CHARACTERS.
FALIN:	MVI	B,4
	CALL	SKIM
	MVI	B,0	;VARIABLE GETS 0

;GET VARIABLE LOCATION
STOBOO:	PUSH	H	;SAVE BUFFER ADDRESS
	MOV	H,0(X)
	MOV	L,-1(X)
;STORE BOOLEAN VALUE
	MOV	M,B
	XRA	A	;CLEAR A
	MOV	B,A	;CLEAR B
	POP	H	;RESTORE  BUFFER ADDRESS
	RET

;SKIM SCANS THE NEXT N CHARACTERS (N IN B) OF THE INPUT 
;STREAM  AND STOPS AFTER THE FIRST E OR ' '.
SKIM:	CALL	INPUT	;GET THE NEXT CHARACTER
	CPI	'E'
	RZ		;E FOUND
	CPI	' '
	RZ		;BLANK FOUND
	CPI	','	;COMMA FOUND
	RZ
	CALL	EOF	;RECOGNIZE END OF FILE AS A TERMINATER
	RC
	DJNZ	SKIM
	RET
	ENDIF

;RINTEG GETS THE INTEGER FROM THE INPUT FILE AND STORES IT
RINTEG:
	IF	NOT COMPILER	;DON'T USE WITH COMPILER
	MOV	B,-3(X)
	DCR	B
	JRNZ	INT2	;DOUBLE BYTE INTEGER

;INT1 CONVERTS A CHARACTER STRING TO A SINGLE BYTE
;BYTE INTEGER IN THE RANGE FROM 0 TO 255.  IT PRODUCES
;AN ERROR MESSAGE IF THE CHARACTER STRING REPRESENTS A
;NUMBER LARGER THAN THIS.

INT1:	CALL	CONV	;GET THE NUMBER IN BC
	CMP	B	;CHECK THE SIZE
	JRZ	SMPOS	;POSITIVE
	CMP	H
	JNZ	ERRTYP
	PUSH	H
	LXI	H,REPROM
	CALL	TXTYP
	POP	H
	JMPR	INT1

;MOVE LOW BYTE TO MEMORY
SMPOS:	PUSH	H
	MOV	H,0(X)	;GET ADDRESS
	MOV	L,-1(X)
	MOV	M,C	;MOVE NUMBER
	POP	H	;RESTORE THE BUFFER ADDRESS
	XRA	A	;0 A
	MOV	B,A	;0 B
	RET

;INT2 CONVERTS A CHARACTER STRING TO A DOUBLE
;BYTE INTEGER IN THE RANGE FROM 32,767 TO -32768.
;IT PRODUCES AN ERROR MESSAGE.

INT2:	CALL	CONV

;MOVE NUMBER TO MEMORY, CONV CATCHES THE 15 BIT OVERFLOWS.
	PUSH	H	;SAVE BUFFER ADDRESS
	MOV	H,0(X)	;GET PARAMETER ADDRESS
	MOV	L,-1(X)
	MOV	M,B	;HI BYTE
	DCX	H
	MOV	M,C	;LOW BYTE
	POP	H
	XRA	A
	MOV	B,A
	RET

;CONVERT READS IN THE DIGITS, AND CONVERTS THEM TO
;A 15 BIT NUMBER IN THE BC REGISTER PAIR.  CONVERT 
;DETECTS 15 BIT OVERFLOWS, TRUNCATES THE RESULT TO 
;15 BITS AND CAUSES AN ERROR MESSAGE TO BE PRINTED.

CONV:	PUSH	D		;SAVE D,H
	PUSH	H
	LXI	H,0		;INITIALIZE THE RESULT
	MOV	B,H		;SIGN INDICATOR, DEFAULT +IVE
	XTHL

BLNK1:	CALL	INPUT
	CPI	' '
	JRZ	BLNK1		;LEADING BLANK?
	CPI	'-'		;MINUS SIGN?
	JRNZ	NMINUS
	INR	B		;INDICATE NEGATIVE RESULT
	JR	GETDIG
NMINUS:	CPI	'+'		;POSITIVE SIGN
	JRNZ	CHKDIG		;NO, CHECK FOR A DIGIT

GETDIG:	CALL	INPUT		;GET NEXT CHARACTER

;CHECK FOR A VALID DIGIT
CHKDIG:	CPI	'9'+1
	JRNC	OVFMSG		;TOO LARGE
	SUI	'0'
	JRC	OVFMSG		;TOO SMALL

VALDIG:	XTHL			;GET PARTIAL RESULT
	CALL	TIMES10		;MULTIPLY BY 10 AND ADD THIS DIGIT
	XTHL			;SAVE PARTIAL RESULT ON STACK
	JV	OVFMSG		;ERROR ON 15 BIT OVERFLOW
	XRA	A		;CHECK NEXT CHAR
	CMP	H		;CHECK FOR CONSOLE FILE
	JRZ	FCONS		;YES..FROM CONSOLE
	INX	H
	MOV	A,M
	DCX	H		;NO...GET LOOK AHEAD CHAR
	JR	CHKCHR		;AND GO CHECK THE CHARACTER
FCONS:	LHLD	6
	LXI	D,-GETP
	DAD	D
	MOV	E,M
	MVI	D,0
	DAD	D
	INX	H
	MOV	A,M
	LXI	H,0		;SET HL TO ZERO
CHKCHR:	CPI	'9'+1
	JRNC	NOTDIG
	SUI	'0'
	JRNC	GETDIG		;PROCESS NEXT DIGIT


;NOT DIGIT INDICATES THAT THE END OF THE STRING HAS BEEN 
;REACHED.

NOTDIG:	XRA	A
	CMP	B		;IS RESULT SUPPOSED TO BE NEGATIVE
	POP	B
	POP	D		;RESTORE ARGUMENT COUNT
	RZ			;RETURN IF RESULT IS +IVE
	MOV	A,B
	CMA
	MOV	B,A
	MOV	A,C
	CMA
	MOV	C,A
	INX	B
	XRA	A
	RET			;SIGN IS FIXED, ALL DONE!!

OVFMSG:	XRA	A		;CHECK FOR CONSOLE FILE
	CMP	H
	JRNZ	ERRTYP		;NO, FATAL ERROR
	POP	B
	POP	D
	LXI	H,REPROM	;YES, GET NEW INPUT
	CALL	TXTYP
OVF1	CALL	TIN		;CLEAR INPUT BUFFER
	CPI	CR
	JRNZ	OVF1
	LXI	H,1		;CONSOLE FILE
	JR	CONV		;GET NEXT NUMBER

; MULTIPLY A NUMBER BY TEN AND ADD IN THE DIGIT
; STORED IN THE ACCUMULATOR
TIMES10	MOV	D,H
	MOV	E,L		;COPY HL -> DE
	ORA	A		;CLEAR CARRY
	DADC	H		;X2
	RV			;RETURN IF 15 BIT OVERFLOW
	DADC	H		;X4
	RV
	DADC	D		;X5
	RV
	DADC	H		;X10
	RV
	MOV	E,A
	MVI	D,0
	DADC	D		;PLUS THE NEW DIGIT
	RET
	ENDIF

;NTXT INPUTS A DATA STREAM FROM A NON-TEXT DATA FILE
NTXT:
	IF	NOT COMPILER	;DON'T USE WITH COMPILER
	PUSH	D	;PARAMETER COUNT
	PUSH	H	;FILE BUFFER ADDRESS
	MOV	H,0(X)	;GET ADDRESS
	MOV	L,-1(X)
	MOV	D,-2(X)	;GET BYTE COUNT
	MOV	E,-3(X)
TXLP:	XTHL
	CALL	EOF
	JC	RBEOF
	INX	H
	INX	H
	INX	H
	CALL	BYTIN	;GET NEXT DATA BYTE
	DCX	H
	DCX	H
	MOV	B,M
	MOV	M,A
	MOV	A,B
	DCX	H
	JRNC	NTCONT
	MVI	M,1	;SET EOF FLAG
NTCONT:	XTHL
	MOV	M,A	;STORE IT
	DCX	H	;MEMORY ADDRESS
	DCX	D	;BYTE COUNT
	MOV	A,D	;CHECK FOR END
	ORA	E
	JRNZ	TXLP
	LXI	B,-4	;MOVE THE LIST POINTER
	DADX	B
	POP	H	;FILE BUFFER ADDRESS
	POP	D	;CHECK FOR END OF PARAMETER LIST
	DCX	D
	MOV	A,D
	ORA	E
	JRNZ	NTXT
	JMP	THREW
	ENDIF


;ERROR TYPE OF INPUT DOESN'T MATCH VARIABLE
;FATAL ERROR
ERRTYP:	LXI	H,TYPMES
	JMP	PERROR
TYPMES:	DB	'Type error on inpu','t'+80H
REPROM:	DB	'Error in number, try again',CR,LF+80H

;
; LIBRARY AND MACRO ROUTINES TO PROCESS SETS
;

; CSET IS A MACRO USED TO CONSTRUCT A SET ON THE STACK AT RUNTIME.
;
;  IF THE PARAMETER OFF1 IS ZERO, THEN OFF2 CONTAINS THE NUMBER OF BYTES
;	TO BE ALLOCATED ON THE STACK FOR THE SET.
;
;  IF THE PARAMETER OFF1 IS NON-ZERO, SPACE HAS ALREADY BEEN ALLOCATED ON
;	THE STACK AND THE SUBROUTINE CONSET IS CALLED TO SET THE RELEVANT
;	BITS IN THE SET.

	IF	NOT COMPILER	;DON'T USE WITH COMPILER
CSET:	MACRO	Q,OFF1,OFF2
	IF	OFF1
	LXI	H,OFF1
	CALL	CONSET
	ELSE
	LXI	H,-OFF2	;; ALLOCATE SPACE ON THE STACK
	DAD	S
	SPHL
	MVI	B,OFF2
CSETCL	SET	$
	MOV	M,A	;; CLEAR THE BYTES -- START WITH A NULL SET
	INX	H
	DJNZ	CSETCL
	ENDIF
	ENDMAC

;
; CONSET : A SUBROUTINE THAT SETS THE RELEVANT BIT(S) IN A SET TO INDICATE
;	THE PRESENCE OF THAT ELEMENT IN THE SET.
;
;	HL = OFFSET OF FIRST BYTE OF THE SET FROM THE TOP OF THE STACK.
;	DE = VALUE OF ELEMENT
;	 C = REPETITION COUNT ( SUBRANGES )
;
;	IF THE REPETITION COUNT IS NEGATIVE, IGNORE IT AND RETURN IMMEDIATELY
;		NO BITS ARE SET IN THIS CASE.
;
CONSET:
; IS THE REPETITION COUNT NEGATIVE ?
	INR	C
	DCR	C
	JRZ	LEGRNG	; IF NON-ZERO AND CARRY FLAG SET -- YES
	RC
LEGRNG	DAD	S	; HL -> FIRST BYTE OF THE SET
	PUSH	B
	PUSH	D
	SRLR	E	;; DE = VALUE
	SRLR	E
	SRLR	E	;  DE = NUMBER OF BYTES OFFSET FROM START OF SET
	DSUB	D	;; HL -> BYTE ON STACK
	POP	B	;; BC = VALUE
	MOV	A,C
	ANI	7	;; GET LOW THREE BITS -- OFFSET IN BYTE
	MVI	E,1	;  START WITH BIT 0
;	CPI	0	;; IS IT BIT 0 ? ( ZERO FLAG SET/CLEARED BY ANI )
	JRZ	SINIT	;; YES -- DONE
	MOV	B,A	;  B = BIT POSITION
SETBIT:	SLAR	E	;; ROTATE TO THE CORRECT BIT
	DJNZ	SETBIT
SINIT:	POP	B	;; GET RANGE ( 0..255 ), SO IT'S IN THE C REGISTER
	MOV	B,C
	INR	B	;; COUNT LESS BY ONE -- CHANGE REPETITION COUNT TO
			;   NUMBER OF BITS TO BE SET
	MOV	A,M	;; GET BYTE IN ACC
RANGE:	ORA	E	;; SET BIT
	SLAR	E	;; GO TO THE NEXT BIT
	JRNC	NOOVER	;;
	MOV	M,A	;; IF OVERFLOW, SAVE BYTE AND
	MVI	E,1	;  START AGAIN WITH BIT 0 OF THE NEXT BYTE
	DCX	H	;;
	MOV	A,M
NOOVER:	DJNZ	RANGE
	MOV	M,A	;; SAVE BYTE
	XRA	A
	RET

UNIN:	MACRO	Q,OFFSET,OFF1
	LXI	H,OFF1
	LXI	D,OFFSET
	CALL	UNION
	ENDMAC

; UNION : A ROUTINE THAT TAKES THE UNION OF TWO SETS ON THE STACK AND
;	STORES IT IN THE FIRST SET -- THE ONE AT THE HIGHER LOCATION ON
;	THE STACK.
;
;	HL = OFFSET IN  BYTES OF THE SECOND SET FROM THE TOP OF THE STACK
;	DE = OFFSET FROM START OF SECOND SET OF THE EQUIVALENT BYTE IN THE
;		FIRST SET.
;
UNION:
	CALL	SAVREG	; SAVE THE APPROPRIATE REGISERS AND SET UP POINTERS
	; HL -> START OF SECOND SET
	; DE -> START OF FIRST SET
	;  B  = SIZE OF SECOND SET
ORBIT:	MOV	A,M	;; GET BYTE FROM 2ND SET
	XCHG
	ORA	M	;; OR WITH BYTE FROM 1ST SET
	MOV	M,A	;; SAVE IT
	XCHG
	DCX	H	; GO ON TO NEXT BYTE
	DCX	D
	DJNZ	ORBIT
	POP	H	; HL = OFFSET OF SECOND SET FROM TOP OF STACK + 2
	POP	D	; DE = RETURN ADDRESS
	DADD	S	;; REMOVE THE 2ND SET FROM THE STACK
	SPHL
	XCHG		; HL = RETURN ADDRESS
	XRA	A
	PCHL

MEMB:	MACRO	Q,OFFSET,OFF2
	LXI	D,OFF2
	LXI	H,OFFSET
	CALL	INN
	ENDMAC

; INN : A ROUTINE TO TEST FOR THE MEMBERSHIP OF AN ELEMENT IN A SET.
;
;	HL = OFFSET OF ELEMENT FROM TOP OF STACK
;	DE = VALUE OF FIRST ELEMENT IN SET DIV 8
;
INN:
	DADD	S	;; POINT TO VAR
	PUSH	H
	MOV	C,M
	MOV	A,C	; A AND C REGS CONTAIN THE VALUE OF THE ELEMENT
	DCX	H	;; HL -> FIRST BYTE OF SET
;
; TO OPTIMIZE FOR STORAGE IN SETS, ONLY THE SPACE THAT ACTUALLY GETS USED
; IS ALLOCATED. FOR EXAMPLE FOR A SET OF CHAR, 16 BYTES OF STORAGE ARE
; ALLOCATED BUT FOR A SET OF 'A'..'Z' ONLY 4 BYTES OF STORAGE ARE ALLOCATED.
; SO FOR A SET OF 'A'..'Z', THE FIRST ELEMENT IN THE SET HAS AN ORDINAL
; VALUE OF 65. BEFORE THE TEST FOR MEMBERSHIP CAN BE MADE, THE POINTER TO THE
; SET HAS TO BE RESET TO POINT TO THE LOCATION OF THE ELEMENT IN THE SET WITH
; AN ORDINAL VALUE OF 0 EVEN IF IT DOES NOT EXIST.
;
	DAD	D
	SRLR	C	;; CALCULATE THE LOCATION IN THE SET
			;   OF THE ELEMENT
	SRLR	C
	SRLR	C
	ORA	A	;; CLEAR CARRY
	DSBC	B	;; POINT TO RELEVANT BYTE IN SET
	ANI	7
	MOV	B,A	;; GET POSITION WITHIN SET 
	MVI	A,1	;  START WITH BIT 0 IN THE BYTE
	JRZ	SET2	;; IF ZERO THEN DONE ( ZERO FLAG SET/CLEARED BY ANI )
SET1:	ADD	A	;; ROTATE TO CORRECT BIT POSITION
	DJNZ	SET1
SET2:	ANA	M	;; SEE IF BIT IS SET
	POP	H	;; RESET STACK POINTER
	POP	D
	SPHL
	XCHG		; RETURN ADDRESS -> HL
	INX	S	; REMOVE VAR FROM STACK
	INX	S
	JRZ	NOTIN	;; IF ZERO THEN NOT IN SET( SET/CLEARED BY ANA )
	STC		;;IS IN THE SET
NOTIN:	MVI	A,0
	PCHL

INCL:	MACRO	Q,OFFSET,OFF1
	LXI	H,OFF1
	LXI	D,OFFSET
	CALL	LTEQ
	ENDMAC

;
; LTEQ : A ROUTINE TO COMPARE TWO SETS ON THE STACK AND SEE IF THE FIRST IS
;	LESS THAN OR EQUAL TO THE SECOND AS DEFINED IN JENSEN AND WIRTH.
;
;	HL = OFFSET (IN BYTES) OF START OF SECOND SET FROM TOP OF STACK
;	DE = OFFSET (IN BYTES) FROM START OF SECOND SET OF EQUIVALENT BYTE
;			IN FIRST SET.
; FOR EXPLANATION OF WHY THE FIRST SET MAY NOT BE THE THE SAME SIZE AS THE
;	SECOND SET SEE COMMENTS IN INN ROUTINE.
;
LTEQ:
	CALL	SAVREG
;	HL -> FIRST BYTE OF SECOND SET
;	DE -> EQUIVALENT BYTE IN FIRST SET
;	 B  = SIZE OF SECOND SET ( IN BYTES )
	XCHG
	JR	LTGTEQ

SBST:	MACRO	Q,OFFSET,OFF1
	LXI	H,OFF1
	LXI	D,OFFSET
	CALL	GTEQ
	ENDMAC

;
; GTEQ : A ROUTINE TO COMPARE TWO SETS ON THE STACK AND DETERMINE IF THE
;	SECOND SET IS GREATER THAN OR EQUAL TO THE FIRST SET AS DEFINED IN
;	JENSEN AND WIRTH.
;
;	HL = OFFSET OF START OF SECOND SET FROM TOP OF STACK.
;	DE = OFFSET FROM START OF SECOND SET OF EQUIVALENT SET IN FIRST SET.
;
GTEQ:
	CALL	SAVREG
;	HL -> START OF SECOND SET
;	DE -> EQUIVALENT BYTE IN FIRST SET
;	 B  = SIZE OF SECOND SET.
;
; THE CODE HAS TO FALL THROUGH HERE !!!!
;

;
; LTGTEQ : A COMMON ROUTINE SHARED BY LTEQ AND GTEQ. IT COMPARES THE TWO SETS
;	POINTED TO BY THE HL AND DE REGISTERS. IF THE SET POINTED TO BY HL
;	IS LESS THAN OR EQUAL TO THE SET POINTED TO BY THE DE PAIR, IT
;	RETURNS WITH THE CARRY SET. ( BIT 8 OF THE ACC SET )
;
;	LTEQ CALLS IT WITH HL POINTING TO THE FIRST SET AND DE POINTING TO THE
;		SECOND SET.
;	GTEQ CALLS IT WITH HL POINTING TO THE SECOND SET AND HL POINTING TO THE
;		FIRST SET.
;
;	B = NUMBER OF BYTES IN SECOND SET.
;
LTGTEQ:
	MOV	A,M	; GET BYTE FROM ONE SET
	XCHG
	ORA	M	; COMPARE IT WITH THE OTHER SET
	XRA	M
	JRNZ	NO	; IF NZ, THEN NOT =<
	DCX	H	; DECREMENT POINTERS AND REPEAT WITH THE NEXT BYTE
	DCX	D
	XCHG
	DJNZ	LTGTEQ
	POP	H	; HL = OFFSET OF SECOND SET
	POP	D	; DE = RETURN ADDRESS
	DADD	S	; REMOVE SECOND SET FROM STACK
	SPHL
	XCHG		; HL = RETURN ADDRESS
	MVI	A,80H
	PCHL
NO:
	POP	H
	POP	D
	DADD	S
	SPHL
	XCHG
	XRA	A
	PCHL

INTR:	MACRO	Q,OFFSET,OFF1
	LXI	H,OFF1
	LXI	D,OFFSET
	CALL	INSECT
	ENDMAC

;
; INSECT : A ROUTINE TO TAKE THE INTERSECTION OF TWO SETS ON THE STACK AND
;	STORE THE RESULT IN THE FIRST. INTERSECTION IS EQUIVALENT TO THE LOGICAL
;	AND OF TWO SETS.

;
;	HL = OFFSET OF START OF SECOND SET FROM THE TOP OF STACK
;	DE = OFFSET FROM START OF SECOND SET OF EQUIVALENT BYTE IN FIRST SET
;
INSECT:
	CALL	SAVREG
;	HL -> SECOND SET
;	DE -> EQUIVALENT BYTE IN FIRST SET
;	 B  = SIZE OF SECOND SET
ANDBIT:
	LDAX	D
	ANA	M
	STAX	D
	DCX	H
	DCX	D
	DJNZ	ANDBIT
	POP	H	; HL = OFFSET OF SECOND SET
	POP	D	; DE = RETURN ADDRESS
	DADD	S	; REMOVE SECOND SET FROM STACK
	SPHL
	XCHG		; HL = RETURN ADDRESS
	XRA	A
	PCHL

DIFF:	MACRO	Q,OFFSET,OFF1
	LXI	H,OFF1
	LXI	D,OFFSET
	CALL	ORGAN
	ENDMAC

;
; ORGAN : A  ROUTINE TO TAKE THE DIFFERENCE OF TWO SETS ON THE STACK AND
;	STORE THE RESULT IN THE FIRST SET. THE DIFFERENCE OF TWO SETS IS
;	DEFINED TO BE THE ELEMENTS OF THE FIRST SET THAT ARE NOT PRESENT
;	IN THE SECOND SET.
;
;	HL = OFFSET OF START OF SECOND SET FROM TOP OF STACK
;	DE = OFFSET FROM START OF SECOND SET OF EQUIVALENT BYTE IN FIRST SET
;
ORGAN:
	CALL	SAVREG
;	HL -> SECOND SET
;	DE -> FIRST SET
;	 B  = SIZE OF SECOND SET
SETDIF:
	MOV	A,M
	XCHG
	ANA	M	; TAKE OUT THE ELEMENTS OF THE SECOND SET
			; THAT ARE NOT PRESENT IN THE FIRST SET
	XRA	M	; TAKE OUT THE ELEMENTS OF THE FIRST SET
			; THAT ARE ALSO IN THE SECOND SET
	MOV	M,A
	DCX	H
	DCX	D
	XCHG
	DJNZ	SETDIF
	POP	H	; HL = OFFSET OF SECOND SET
	POP	D	; DE = RETURN ADDRESS
	DADD	S	; REMOVE SECOND SET FROM STACK
	SPHL
	XCHG		; HL = RETURN ADDRESS
	XRA	A
	PCHL

MTCH:	MACRO	Q,OFFSET,OFF1
	LXI	H,OFF1
	LXI	D,OFFSET
	CALL	COMP
	ENDMAC

;
; COMP : A ROUTINE TO COMPARE TWO SETS ON THE STACK AND SEE IF THEY ARE EQUAL
;	THIS IS DONE BY TAKING THE EXCLUSIVE OR OF THE TWO SETS. IF THE RESULT
;	IS NOT ZERO THEN THEY ARE NOT ZERO.
;
;	HL = OFFSET OF FIRST BYTE OF SECOND SET FROM TOP OF STACK
;	DE = OFFSET FROM START OF SECOND SET OF EQUIVALENT BYTE IN THE FIRST
;		SET
;
COMP:
	CALL	SAVREG
;	HL -> SECOND SET
;	DE -> FIRST SET
;	 B  = SIZE OF SECOND SET
	MVI	C,1	; INDICATE TEST FOR EQUALITY
;
; QUERY : A ROUTINE TO TEST FOR EQUALITY/NON-EQUALITY OF TWO SETS ON THE
;	STACK. IF THE C REGISTER CONTAINS A ZERO THEN THE TEST IS FOR 
;	NON-EQUALITY AND FOR EQUALITY OTHERWISE. ON ENTRY THE HL,DE AND C
;	REGISTERS SHOULD BE THE SAME AS THEY WERE UPON ENTRY INTO COMP
;	AND FUSS.
;
QUERY:
	LDAX	D
	XRA	M
	JRNZ	NOTEQ
	DCX	H
	DCX	D
	DJNZ	QUERY	; NOT ZERO -> NOT EQUAL
	CMP	C	; IS THIS A TEST FOR EQUALITY OR NON-EQUALITY ?
	JRZ	NEQTST	; IF ZERO THEN TEST FOR NON-EQUALITY
EQTST:	POP	H	; HL = OFFSET OF SECOND SET
	POP	D	; DE = RETURN ADDRESS
	DADD	S	; REMOVE SECOND SET FROM STACK
	SPHL
	XCHG		; HL = RETURN ADDRESS
	MVI	A,80H
	PCHL
NOTEQ:
	XRA	A	; MIGHT AS WELL CLEAR THE ACC
	CMP	C	; TEST FOR NON-EQUALITY?
	JRZ	EQTST	; YES
NEQTST:	POP	H
	POP	D
	DADD	S
	SPHL
	XCHG
	PCHL

NOMT:	MACRO	Q,OFFSET,OFF1
	LXI	H,OFF1
	LXI	D,OFFSET
	CALL	FUSS
	ENDMAC

;
; FUSS : A ROUTINE TO COMPARE TWO SETS ON THE STACK AND TEST IF THEY ARE
;	NOT EQUAL. ( APOLOGIES FROM THE PROGRAMMER FOR A ROUTINE NAME THAT
;	HAS ABSOLUTELY NO RELEVANCE TO WHAT IT DOES -- I RAN OUT OF
;	IMAGINATION )
;
;	HL = OFFSET OF START OF SECOND SET FROM TOP OF STACK
;	DE = OFFSET FROM HL OF EQUIVALENT BYTE IN FIRST BYTE
;
FUSS:
	CALL	SAVREG
;	HL -> SECOND SET
;	DE -> FIRST SET
;	 B  = SIZE OF SECOND SET
	MOV	C,A	; INDICATE THAT THIS IS A TEST FOR <>
	JR	QUERY	; JUMP TO COMMON TEST CODE

;
; SAVREG : A ROUTINE TO SAVE THE HL REG AND SET UP THE POINTERS TO THE TWO
;	SETS ON THE STACK.
;
;	ON ENTRY :
;		HL = OFFSET OF SECOND SET FROM TOP OF STACK
;		DE = OFFSET FROM HL OF EQUIVALENT BYTE IN FIRST SET
;
;	ON EXIT :
;		HL -> SECOND SET
;		DE -> FIRST SET
;		 B  = SIZE OF SECOND SET ( OFFSET OF SET FROM TOP OF STACK )
;
;	THE RETURN ADDRESS IS PUSHED TWO LOCATIONS LOWER ON THE STACK AND
;		THE OFFSET OF THE SECOND SET IS STORED IN ITS OLD LOCATION.
;		THE OFFSET IS USED LATER TO CALCULATE HOW MANY BYTES TO
;		REMOVE, TO REMOVE THE SECOND SET FROM THE SET.
;
SAVREG:
	POP	B	; B = RETURN ADDRESS
	PUSH	H	; OFFSET OF SECOND SET
	PUSH	B
	MOV	B,L	; B = SIZE OF SECOND SET ( 0..255 )
	DADD	S	; SET HL TO POINT TO START OF SECOND SET
	INX	H	; CORRECT FOR OFFSET AND RETURN ADDRESS ON THE STACK
	INX	H
	INX	H
	INX	H
	INX	H
	XCHG		; DE -> SECOND SET
	DADD	D	; HL -> FIRST SET
	XCHG
	RET
	ENDIF

;
; DYNAMIC STORAGE ALLOCATION AND DE-ALLOCATION ROUTINES
;
; NEW -- ALLOCATE MORE STORAGE TO THE HEAP
;
NEW:
	IF	NOT COMPILER	;DON'T USE WITH COMPILER
	PUSH	B	;MOVE # BYTES TO ALTERNATE REGS;
	EXX		;GO TO ALTERNATE REGISTER SET
	POP	D	;GET SIZE OF ALLOCATION
	DAD	D	;ADD TO PREVIOUS TOP OF HEAP
	PUSH	H	;MOVE POINTER TO ALTERNATE REGS
	EXX
	POP	D
	MOV	M,D	;STORE IN POINTER VARIABLE
	DCX	H
	MOV	M,E
	LXI	H,-MARGIN
	DAD	S	;CHECK FOR A HEAP OVERFLOW
	DSUB	D
	JC	HPERR
	RET
	ENDIF
;
; MARK POINTER VAR WITH THE PRESENT TOP OF HEAP
;
MARK:
	IF	NOT COMPILER	;DON'T USE WITH COMPILER
	EXX
	PUSH	H	;GET THE TOP OF THE HEAP
	EXX
	POP	D	;AND STORE IT IN THE
	MOV	M,D	;POINTER USED AS AN ARGUMENT
	DCX	H	;TO THE MARK ROUTINE
	MOV	M,E
	RET
	ENDIF
;
; RELEASE STORAGE TO THE POINT SPECIFIED
RELEASE:
	IF	NOT COMPILER	;DON'T USE WITH COMPILER
	MOV	D,M	;GET THE VALUE OF THE POINTER
	DCX	H
	MOV	E,M
	PUSH	D	;MOVE POINTER TO ALTERNATE REGS
	EXX
	POP	H	;NEW TOP OF HEAP
	EXX
	RET
	ENDIF
;
;
; All calculations are done with a 31 bit mantissa and
; are then rounded to 24 bits
;
nbytes:	equ	5	;number of bytes in floating pt number
explen:	equ	1	;number of bytes in exponent
fracln:	equ	nbytes-explen	;number of bytes in mantissa
sign:	equ	7	;position of mantissa sign bit

;		these positions are relative to ix
op1:	equ	17		;position of exponent of first operand
op2	equ	11		;position of exponent of second operand
scr1:	equ	op2-nbytes	;scratch byte 1
intflg:	equ	op2+1		;is operation internal?
dc1:	equ	op1+1		;for digit counting in cvtsfp
dc2:	equ	op1+2

;		these positions are relative to op1, op2
exp:	equ	0		;position of exponent byte
msb:	equ	exp-explen	;high byte of fraction
lsb:	equ	exp-fracln	;low   "    "     "

;
; these are the floating point and BCD values for the powers
; of 10 between zero and 7 (1, 10, 100, ... 1,000,000 )
; the floating point forms contain only the fraction
; since the exponent is assumed to be 23 (lsb first)
;
ftable:
;	db	0,80h,96h,98h	; 10,000,000
	db	0,40h,42h,0fh	;  1,000,000
	db	0,0a0h,86h,1h	;    100,000
	db	0,10h,27h,0	;     10,000
	db	0,0e8h,03,0	;      1,000
	db	0,64h,0,0	;	 100
	db	0,0ah,0,0	;	  10
	db	0,01,0,0	;	   1
bcd:
;	db	00,00,00,10h	; ten million
	db	00,00,00,01h	; one million
	db	00,00,10h,00	; hundred thousand
	db	00,00,01h,00	; ten thousand
	db	00,10h,00,00	; one thousand
	db	00,01h,00,00	; one hundred
	db	10h,00,00,00	; ten
	db	01h,00,00,00	; one


;
; the floating point constant 10, in the five byte internal
; form
;
	db	0,0,0,50h	; 5/8
tentop:	db	4		;	* 16 = 10

; these macros use arg = 1 to refer to the first operand and...
;		   arg = 2 to refer to the second operand
;		   arg = y to refer to the present operand
;
rotate:	macro	arg,direction	;;rotate operand one bit
	if	'arg'-'y'	;;standard arg
	lxi	h,op!arg+msb	;;offset of the argument
	call	rotat!direction	;;call rotate routine
	else			;;use present operand
	push	y		;;move y to hl
	pop	h
	dcx	h		;;point to msb
	ora	a		;;clear carry
	call	rot!direction	;;enter rotate after addr calcs
	endif
	endmac			;;done

shift:	macro	arg,direction	;;shift right
	if	'arg'-'l'	;;do right shift
	if	'arg'-'y'	;;standard argument
	lxi	h,op!arg+exp	;;offset of the argument
	dad	d		;;hl <- addr of     "
	else			;;use current operand
	push	y
	pop	h		;;get addr of msb hl
	endif
	inr	m		;;bump exponent
	jv	fperr		;floating point error
	dcx	h
	mov	a,m		;;get msbyte
	ral			;;shift sign bit into carry
	call	rotright	;;rotate w/o clearing carry
	else			;;shift left
	call	rotatel		;;do a rotate left
	mvi	a,0		;;clear w/o disturbing carry
	rar			;;move carry to msbit
	xra	m		;;xor with msb of fp number
	mov	m,a		;;save result
	endif
	endmac

cmplmt:	macro	arg		;;2's complement operand
	if	'arg'-'y'	;;standard arg
	lxi	h,op!arg+lsb	;;get offset of lsb of operand
	call	compop		;;complement operand
	else			;;use present operand
	push	y		;;move y to hl
	pop	h
	lxi	b,lsb		;;point to lsb
	dad	b
	call	comp1		;;enter compop after addr calcs
	endif
	endmac

zchk:	macro	arg		;;check for operand = 0
	if	'arg'-'y'	;;if standard argument
	lxi	h,op!arg+msb	;;get offset
	call	zerchk		;;and check for a zero
	else			;;use current operand
	push	y
	pop	h		;;hl <- y
	dcx	h		;;make (hl) = msb
	call	zerck1		;;and check for zero
	endif
	endmac

normfp:	macro	arg		;;normalizing routine
	if	'arg'-'y'	;;use indicated argument
	lxi	b,op!arg	;;get offset of operand
	push	x		;;get base into y
	xtiy
	dady	b		;;get addr of operand into y
	call	fnorm		;;normalize
	pop	y		;;and restore y
	else			;;current operand
	call	fnorm		;;just normalize
	endmac

setupf:	macro			;;macro used to set up stack for fp
;				;;processing
	pop	b		;;get return address
	pop	d		;;get first half of op2
	pop	h		;;get second half of op2
	push	psw		;;add two bytes to op1
	push	h		;;restore op2
	push	d
	push	psw		;;add two bytes to op2
	push	x		;;save ix...
	push	y		;;...and iy
	push	b		;;restore return address
	lxi	h,0		;;make ix point to end of
	dad	s		;;the stack
	push	h
	pop	ix
	xchg			;;make de point to stack
	xra	a		;;clear carry
	mov	intflg(x),a	;;clear internal op flag
	endmac
;
;
xcfp:	macro			;;exchange top two floating point numbers
	pop	d		;;get op2 in de, hl
	pop	h
	pop	b		;;get low 16 bits of op1
	xthl			;;exchange high 16 bits of op1 & op2
	push	d		;;save low 16 bits of op2
	push	h		;;save high 16 bits of op1
	push	b		;;save low 16 bits of op1
	endmac
;
; convert an integer to floating point, or fp to ASCII
;
cvtf:	macro	where,value	;;where is the argument and what is it?
;;				;; A -> process immediate argument and push
;;				;; B -> process top of stack
;;				;; C -> process 2nd on stack
;;				;; D -> process # in de
;;				;; H -> process # in hl
;;				;; S -> convert top of stack to a string
	if	'A'-'where'	;;check for NOT A
	if	'B'-'where'	;;check for NOT B
	if	'C'-'where'	;;check for not C
	if	'D'-'where'	;;check for not D
	if	'H'-'where'	;;check for not H
;;				;;process option S
	if	value-4		;;should we attempt to convert to fixed pt
	mov	a,l		;;yes, first save fraction length
	pop	b
	pop	d		;;get fp number
	pop	h		;;get field info
	mov	h,a		;;save fraction length
	push	h		;;restore stack
	push	d
	push	b
	xra	a		;;clear acc
	call	fout		;;convert to form  ' sx.xxxxxxesxx'
	lxi	h,13		;;point to top of string
	dad	s
	push	h		;;save the parameter
	call	fxdcvt		;;try to convert to fixed point
	else			;;otherwise simply print the string
	call	fout		;;process fp -> ascii string
	endif
	else			;;process option H
	call	cvtflt		;;process # in hl
	endif
	else			;;process option D
	xchg			;;put # in hl
	call	cvtflt		;;process # in hl
	endif
	else			;;process option C
	pop	b		;;get top of stack in bc, de
	pop	d
	pop	h		;;get integer in hl
	push	d		;;save float # on stack
	push	b
	call	cvtflt		;;convert hl -> float
	xcfp			;;...and exchange op1 & op2
	endif
	else			;;process option B
	pop	h		;;get 2's complement value
	call	cvtflt		;;call routine to convert # in hl
	endif
	else			;;process option A
	lxi	h,value		;;get 16 bit value
	call	cvtflt		;;convert to float, and done!!
	endif
	endmac
;
; utility routines used by the floating point library
;
;
; cvtflt converts the 16 bit integer in hl to a floating point #
; and leaves it on the stack
;
cvtflt:	mov	b,h		;check high byte, if negative, fix value
	call	abs		;get absolute value of n
	mov	a,b		;get old high byte
	ani	80h		;mask old high bit
	ora	h		;or with absolute value
	mov	h,a		;and restore
	pop	b		;get return address
	mvi	d,15		;initial exponent, don't need intflg
	push	d		;save on stack
	inx	s		;only need one byte
	push	h		;save high 16 bits
	lxi	h,0		;save low  16 bits
	push	h
	push	h		;save scr1...
	inx	s		;..which is only one byte
	push	x
	push	y		;save ix...and iy
	push	b		;save return address
	dad	s
	push	h		;save pointer
	pop	x		;in ix...
	xchg			;...and de
	normfp	2		;normalize the number
	pop	h		;get return address
	pop	y
	pop	x		;restore index registers
	pop	d		;throw away excess bytes
	xra	a		;clear acc
	pchl			;and.....return
;
; complement an operand
;
compop:	dad	d		;and calculate addr of fpacc
comp1:	mvi	b,fracln	;process whole mantissa
	mov	a,m		;get first byte
	cma			;complement and...
	adi	1		;..add one
compl:	mov	m,a		;save present byte
	inx	h		;bump pointer
	mov	a,m		;get next byte
	cma			;complement and add
	aci	0		;carry
	djnz	compl		;check for last byte
	ret			;yes...done

;
; check number for a zero
;
zerchk:	dad	d		;and calculate address of fpacc
zerck1:	mvi	b,fracln	;process whole mantissa
	xra	a		;clear accumulator
zchka:	ora	m		;check next byte
	dcx	h		;bump pointer
	djnz	zchka		;any more?
	ret			;no, return

;
; rotate the floating point mantissa one bit
;
rotatright:			;rotate a number right one bit
	dad	d		;calculate addr of number
	ora	a		;clear carry
rotright:			;rotate w/o clearing carry
	push	b		;save bc regs
	mvi	b,fracln	;process whole mantissa
rotr:	mov	a,m		;get next byte
	rar			;...rotate...
	mov	m,a		;and replace it
	dcx	h		;bump pointer
	djnz	rotr		;check count
	pop	b		;restore bc
	ret			;done!

rotatleft:			;rotate a number left one bit
	dad	d		;calculate addr of fpacc
	ora	a		;clear carry
rotleft:			;rotate w/o clearing carry
	rar			;save carry
	push	b		;save bc
	lxi	b,lsb-msb-1	;least significant byte-1
	dad	b
	ral			;restore carry
	mvi	b,fracln	;do whole mantissa
rotl:	inx	h		;bump pointer
	mov	a,m		;get next byte
	ral			;...rotate...
	mov	m,a		;and replace it
	djnz	rotl		;check counter
	pop	b		;restore bc
	ret

;
; multiple precision op, (de) <op> (hl) -> (de)
;
mpadd:	xra	a		;clear carry
	push	b		;save b
	mvi	b,fracln	;add all bytes
mpadd1:	ldax	d		;get byte from op1
	adc	m		;add byte from op2
	stax	d		;store it
	inx	h		;bump pointers
	inx	d
	djnz	mpadd1		;any more?
	pop	b		;restore b
	ret			;no, return

mpsub:	xra	a		;clear carry
	push	b		;save b
	mvi	b,fracln
mpsub1:	ldax	d		;get byte from op1
	sbb	m		;subtract byte from op2
	stax	d		;store it
	inx	h		;bump pointers
	inx	d
	djnz	mpsub1		;any more?
	pop	b		;restore b
	ret			;no, return
;
; normalize a floating point number
;
fnorm:	xra	a		;clear acc
	mov	scr1(x),a	;set sign indicator to +ve num
	bit	sign,msb(y)	;test sign of number
	jrz	posit		;it's positive
	inr	scr1(x)		;negative...set sign indicator
	res	sign,msb(y)	;and negate fraction
posit:	zchk	y		;check number = 0
	jrnz	fpanz		;..fpacc <> 0
	mvi	exp(y),0	;set exp = 0
	ret
fpanz:	bit	sign-1,msb(y)	;check msb
	jrnz	allrot		;all rotated
	rotate	y,left		;rotate left until msb is a one
	dcr	exp(y)		;adjust exponent
	jv	fperr		;floating point error
	jr	fpanz		;try again
allrot:	dcr	scr1(x)		;check sign indicator
	rnz			;positive number, return
	bset	sign,msb(y)	;negate number and return
	ret
;
; actual routines for arithmetic and i/o
;
;
; fsub -- floating point subtraction routine
;	  must be followed by addition routine
;
fsub:	setupf			;setup for 2 operands
	mvi	a,80h		;complement sign bit
	xra	op2+msb(x)	;of the second operand
	mov	op2+msb(x),a	;and add since a + (-b) = a - b
	jr	fadd1		;jump into add routine

;
; floating point addition routine
;
fadd:	setupf			;setup for 2 oerands
fadd1:	zchk	1		;check for a zero operand
	jrz	copdon		;yes..copy and done
	zchk	2		;check for a zero facc
	jz	done2		;yes...addition finished
	bit	sign,op1+msb(x)	;make sure args >= 0
	jrz	op1pos
	res	sign,op1+msb(x)	;clear sign bit
	cmplmt	1		;<0 , negate mantissa
op1pos:	bit	sign,op2+msb(x)
	jrz	op2pos
	res	sign,op2+msb(x)	;clear sign bit
	cmplmt	2
op2pos:	mov	a,op1(x)	;get exponent of 1st op
	sub	op2(x)		; "	"     "  2nd "
;				;are they equal?
	jrz	shadd		;yes...prepare to add them
	mov	c,a		;copy difference into c-reg
	jp	posrlt		;otherwise make sure
	xra	a		;that the result is +ve
	sub	c
posrlt:	cpi	fracln-1*8	;is difference is too small
	jrc	align		;yes..go align operands
	bit	sign,c		;test sign of difference
	jz	done2		;if +ve then addition is done
copdon:	lxi	h,op1		;copy op1 <- op2
	dad	d		;point to top of op1
	xchg
	lxi	b,op2		;point to top of op2
	dad	b
	lxi	b,4		;copy 4 bytes
	lddr			;op1 <- op2
	jmp	done2		;and done
align:	bit	sign,c		;check sign of difference
	mov	b,a		;save magnitude of difference
	jrz	shop2		;op1 > op2, shift op2 right
;				;op1 < op2, shift op1 right
shop1:	shift	1,r		;shift op1 right
	djnz	shop1		;until two operands line up
	jr	shadd		;add them
shop2:	shift	2,r		;shift op2 right
	djnz	shop2
shadd:	shift	1,r		;shift both operands right
	shift	2,r		;one bit
	lxi	h,op1+lsb	;get addr of bottom of op1
	dad	d
	xchg
	push	h		;save base reg
	lxi	b,op2+lsb	;get addr of bottom of op2
	dad	b
	call	mpadd		;add aligned fractions
	pop	d		;restore base reg
	bit	sign,a		;high byte of answer is in a
	jz	done2
	cmplmt	1		;complement fraction
	bset	sign,op1+msb(x)	;set sign bit
	jmp	done2		;and done

;
; floating point multiply routine
;
fmult:
	if	not compiler	;not used by the compiler
	setupf			;setup for 2 operands
fmult1:	mov	a,op1+msb(x)	;get sign of op1
	xra	op2+msb(x)	;x-or with sign of op2
	mov	scr1(x),a	;save sign of result
	res	sign,op1+msb(x)	;clear both sign bits
	res	sign,op2+msb(x)
	mov	a,op1(x)	;get exponent of op1
	add	op2(x)		;add exponent of op2
	jv	fperr		;floating point error
	mov	op1(x),a	;save exponent of result
	lxi	h,-nbytes	;add extra variable to stack
	dad	s		;for use in intermediate
	sphl			;calculations
	push	x		;save x-reg
	lxi	b,op2+lsb	;make x-reg point to lsb of op2
	dadx	b
	xtix
	push	h		;save addr of lsb
	xra	a		;zero temporary variable
	mvi	b,nbytes	;zero correct number of bytes
zerlop:	mov	m,a		;zero this byte
	inx	h		;bump pointer
	djnz	zerlop		;and continue
	dcx	h		;correct pointer
	push	h		;make y point to this
	pop	y		;temporary variable
	mvi	b,fracln*8-1	;process all bits in mantissa
muloop:	rotate	1,right		;rotate multiplier right 1 bit
	jrnc	mult1		;carry out of lsb?
	pop	d		;yes...
	pop	h
	push	h
	push	d
	push	b		;save counter
	call	mpadd		;add multiplicand to result
	pop	b		;restore counter
	push	ix
	pop	d		;restore d
mult1:	rotate	y,right		;shift result right one bit
	djnz	muloop		;...and continue
	pop	d		;get addr of temp variable
	pop	h		;get addr of op2
	lxi	b,op1-op2	;calculate addr of op1
	dad	b
	mvi	b,fracln	;and copy to op1
coplop:	ldax	d		;get byte from temp
	mov	m,a		;store in op1
	inx	h		;bump pointers
	inx	d
	djnz	coplop
; fix stack
	lxi	h,nbytes	;size of temp variable
	dad	s		;+ stack pointer
	sphl			;is original value of sp
	bit	sign,scr1(x)	;fix sign of result
	jz	done2
	bset	sign,op1+msb(x)
	jmp	done2
	endif

;
; floating point divide routine
;
fdivd:	setupf			;setup for 2 operands
fdivd1:	zchk	2		;check for division by zero
	jz	fperr
	mov	a,op1+msb(x)	;get sign of op1
	xra	op2+msb(x)	;x-or with sign of op2
	mov	scr1(x),a	;save sign of result
	mov	a,op1(x)	;get exponent of op1
	inr	a		;compensate for algorithm
	sub	op2(x)		;subtract exponent of op2
	jv	fperr		;floating point error
	mov	op1(x),a	;save exponent of result
	res	sign,op1+msb(x)	;clear sign bits in op1...
	res	sign,op2+msb(x)	;...and op2
	lxi	h,-nbytes	;add extra variable to stack
	dad	s		;for use in intermediate
	sphl			;calculations
	push	h		;save addr of lsb
	xra	a		;zero temporary variable
	mvi	b,nbytes	;zero correct number of bytes
zerlp:	mov	m,a		;zero this byte
	inx	h		;bump pointer
	djnz	zerlp		;and continue
	dcx	h		;correct pointer
	push	h		;make y point to this
	pop	y		;temporary variable
	mvi	b,fracln*8-1	;process all bits in mantissa
divlp:	
	push	d		;save base reg
	push	b		;save counter
	lxi	h,op1		;get addresses of two operands
	dad	d
	xchg			;de <- hl = addr( op1 )
	lxi	b,op2
	dad	b		;hl = addr( op2 )
	mvi	b,fracln	;process at most all bytes
divd1:	dcx	h		;bump pointers
	dcx	d
	ldax	d		;get byte from op1
	cmp	m		;compare with byte from op2
	jrc	divd2		;too big don't subtract
	jrnz	divd1a		;continue if zero
	djnz	divd1		;stop when done
	inr	b		;make the next loop do nothing
divd1a:	dcx	h
	dcx	d
	djnz	divd1a
	inx	h
	inx	d
divd1b:	call	mpsub		;subtract divisor from dividend
	ora	a		;clear carry
divd2:	pop	b		;restore counter
	pop	d		;restore base reg
	push	psw		;save carry
	rotate	y,left		;shift result right one bit
	pop	psw		;get carry
	jrc	divd3		;don't set a bit
	bset	0,lsb(y)	;set least significant bit
divd3:	rotate	1,left		;shift dividend left 1 bit
	djnz	divlp		;...and continue
	lxi	h,op1+lsb	;calculate addr of op1
	dad	d
	pop	d		;get addr of temp variable
	mvi	b,fracln	;and copy to op1
coplp:	ldax	d		;get byte from temp
	mov	m,a		;store in op1
	inx	h		;bump pointers
	inx	d
	djnz	coplp
; fix stack
	lxi	h,nbytes	;size of temp variable
	dad	s		;+ stack pointer
	sphl			;is original value of sp
	bit	sign,scr1(x)	;fix sign of result
	jz	done2
	bset	sign,op1+msb(x)
	jmp	done2

;
; floating point output routine
;
fout:
	if	not compiler	;don't use with compiler
	pop	b		;get return address
	pop	d		;move floating point number down 2 bytes
	pop	h
	push	psw		;add two bytes above op1
	push	h		;restore op1
	push	d
	push	psw		;add two bytes after op1
	push	h
	push	d		;create op1
	push	psw		;add two bytes
	push	x
	push	y
	push	b		;save ix, iy, and return address
	lxi	h,0		;make ix point to end of
	dad	s		;the stack
	push	h
	pop	ix
	xchg			;make de point to stack
	xra	a		;clear carry
	mvi	c,' '		;output space unless negative
	bit	sign,op1+msb(x)	;check sign
	jrz	notneg
	mvi	c,'-'		;output a '-'
	res	sign,op1+msb(x)	;clear sign bit
notneg:	mov	intflg(x),c	;set internal op flag
	lxi	h,-5		;add extra workspace to stack
	dad	s		;for use in ascii string
	sphl			;construction
	xra	a		;zero temporary variable
	mvi	b,4		;zero correct number of bytes
zerstr:	mov	m,a		;zero this byte
	inx	h		;bump pointer
	djnz	zerstr		;and continue
	mov	m,a		;zero exponent in case # is zero
	push	h		;save bcd pointer
	zchk	1		;check for fp number = 0
	pop	h		;restore bcd pointer
	jz	bcdout		;yes, output it
	mvi	m,6		;initialize decimal exponent
declop:	push	h		;save pointer on stack
	bit	sign,op1(x)	;first check sign of exponent
	jrnz	less1		;negative, keep multiplying
	mvi	a,23		;process until 24 > exp > 20
	cmp	op1(x)		;now check size of exponent
	jrc	gret1		;if exp > 23 divide frac by 10
less1:	call	fptten		;op1 := op1 * 10
	pop	h		;decrement decimal exponent
	dcr	m		;and save the pointer
	jr	declop		;try again
gret1:	call	fpdten		;op1 := op1 / 10
	pop	h		;get addr of decimal exponent
	inr	m		;increment decimal exponent
	push	h		;save bcd pointer
	mov	a,op1(x)	;until exponent <= 23
	cpi	24
	jrnc	gret1		;try again
frcout:	mov	c,a		;save value of exponent
frc1:	mov	a,c		;get exponent
	cpi	23		;make sure exponent = 23
	jrz	frc2		;yes it is
	rotate	1,right		;no, shift it
	inr	c
	jr	frc1		;...and try again
frc2:	lxi	h,op1+msb	;get addr of op1
	dad	d
	push	d		;save base register
	lxi	d,ftable+3	;point to 1,000,000
	mvi	b,nbytes-1	;check all bytes after the exponent
frc2a:	ldax	d		;get byte from constant
	cmp	m		;is byte from number bigger
	jrc	frc2c		;yes, done
	jrnz	frc2b		;multiply by ten
	dcx	h
	dcx	d
	djnz	frc2a
	jr	frc2c		;done
frc2b:	pop	d		;restore base reg
	call	fptten		;op1 := op1 * 10
	rotate	1,left		;and compensate for exp = 24
	pop	h		;get bcd pointer
	dcr	m		;indicate multiplication
	jr	frc3a
frc2c:	pop	d		;restore base register
frc3:	pop	h		;get bcd pointer
frc3a:	lxi	b,-4		;addr of lsb of bcd mantissa
	dad	b		;in hl
	push	d		;save base register
	lxi	b,bcd		;save addr of first bcd value
	push	b
	push	h		;save bcd pointer
	lxi	h,op1+lsb	;get addr of op1
	dad	d
	xchg			;de <- addr of op1
	lxi	h,ftable	;addr of floating point values
	mvi	b,7		;7 bcd digits
conlop:	mvi	c,0		;count number of subtractions
conv1:	push	d		;save addr of both operands
	push	h
	inr	c		;count iterations
	call	mpsub		;subtract until result is -ive
	pop	h		;get addrs of both operands
	pop	d
	jrnc	conv1		;result is still positive
	push	d		;save addr of op1
	call	mpadd		;make result positive
	pop	y		;save addr of op1 in y
	pop	d		;bcd pointer
	xthl			;get addr of bcd constant
;				;and save addr of new
;				;floating point constant
	push	b		;save b
conv2:	dcr	c		;see if we're done subtracting
	jrz	conv4		;yes..
	ora	a		;clear carry
	mvi	b,4		;four byte bcd number
	push	d		;save operands
	push	h
conv3:	ldax	d		;get present bcd value
	adc	m		;add in value from constant
	daa			;decimal adjust
	stax	d		;and save
	inx	h		;bump pointers
	inx	d
	djnz	conv3		;check counter
	pop	h		;get original pointers
	pop	d
	jr	conv2		;and try again
conv4:	lxi	b,4		;point to next bcd constant
	dad	b
	pop	b		;restore b
	xthl			;get addr of fp constant
;				;and save addr of bcd constant
	push	d		;save addr of bcd number
	push	y		;get addr of op1
	pop	d
	djnz	conlop		;and continue
	pop	d		;addr of bcd number
	lxi	h,4
	dad	d		;get addr of exponent
	pop	b		;throw away pointer to ftable
	pop	b		;get stack pointer
bcdout:	push	x		;get addr of op1 in y
	pop	y
	lxi	b,op1-2		;interested in bytes after decimal point
	xra	a		;clear carry...
	dady	b		;...and add
	mov	e,intflg(x)	;get leading space or -
	mvi	4(y),' '	;leading space
	mov	3(y),e		;save in string space
	mov	e,m		;save exponent in e
	dcx	h		;point to msb of fraction
	mvi	a,30h		;ascii '0'
	add	m		;form ascii of high digit
	mov	2(y),a		;save in output string
	mvi	1(y),'.'	;now the decimal point
	mvi	b,6		;process 6 digits
outlp:	bit	0,b		;decrement hl on even counter
	jrnz	outlp1
	dcx	h		;bump pointer
outlp1:	rld			;get next digit
	mov	0(y),a		;save byte in string
	dcx	y		;bump pointer
	djnz	outlp		;for 3 bytes
	mov	b,e		;get exponent in b
	mvi	0(y),'E'	;for exponent
	mvi	c,'+'		;assume exponent is +ve
	bit	7,b
	jrz	posexp		;yes, exp is positive
	mvi	c,'-'
	mov	a,b
	neg			;otherwise make it positive
	mov	b,a
posexp:	mov	-1(y),c		;save sign of exponent
	xra	a		;convert to bcd
	cmp	b		;check for zero exponent
	jrz	conxp1
	xra	a		;clear carry
conexp:	inr	a
	daa
	djnz	conexp
conxp1:	mov	m,a		;save so rld will work
	mvi	a,30h		;put 3 in high nybble
	rld			;get 1st digit
	mov	-2(y),a		;tens digit of exponent
;	mvi	a,30h		;put 3 in high nybble
	rld			;get 2nd digit
	mov	-3(y),a		;one digit of exponent
	lxi	h,5		;throw away bcd number
	dad	s
	sphl
	pop	h
	pop	y
	pop	x		;restore all regs
	xra	a		;clear accumulator
	pchl			;done!!
	endif
;
; floating point input routine
;
fpp:	equ	0		;for status byte
fps:	equ	1		;for status byte
fppb:	equ	1		;for status byte, corresponds to bit 0
fpsb:	equ	2		;for status byte, corresponds to bit 1
fltin:
	if	not compiler	;don't use with compiler
	push	d		;save parm counter
	push	h		;save file pointer
	lxi	d,-2		;point to string we're going to create
	xchg
	dad	s		;..and save pointer in de
	xchg
	mvi	b,0		;b indicate sign of result
fp1:	call	input		;get 1st char from input routine
	cpi	' '
	jrz	fp1		;skip leading spaces
	cpi	'-'		;check for a leading sign
	jrz	ngflt		;yes...negate floating point result
	cpi	'+'
	cz	input		;skip over + sign
	inr	b		;inr, dcr -> 0
ngflt:	dcr	b		;set b according to sign of number
	push	b		;save sign indicator
	cnz	input		;skip over a minus sign
	inx	s		;only save one byte
	mvi	b,0		;indicator for # parsing status
	jr	ckdg1		;don't read another digit
ckdg:	call	input
ckdg1:	cpi	'0'		;check for a digit
	jc	errtyp		;not a digit, error
	cpi	10+'0'
	jnc	errtyp		;not a digit, error
	jr	fpch1		;don't do another input
fpchrs:	call	input		;get the character we just looked at...
fpch1:	push	psw		;..and save it on the stack
	inx	s		;only save one character
	call	look		;look at next character
	cpi	'.'		;check for a decimal point
	jrz	fpoint		;yes, do special processing
	cpi	'e'		;check for a scale factor
	jrz	fpscal		;yes, process it
	cpi	'E'		;check for a scale factor
	jrz	fpscal		;yes
	cpi	'0'		;if not a digit, then we're done
	jrc	fpdn		;yes...done!
	cpi	10+'0'
	jrc	fpchrs		;not done!
fpdn:	mvi	a,' '		;end the string with a space
	push	psw
	xchg			;hl -> string on the stack
	push	h		;save string pointer
	call	cvtsfp		;convert the string to a floating point #
	mov	b,h		;copy lsbytes to bc
	mov	c,l
	pop	h		;get string pointer
	push	h		;and save it
	inx	h		;bump to sign indicator
	inr	m		;see if we should negate
	jrnz	fppos		;no, number is +ive
	bset	sign,e		;set sign bit
fppos:	mov	h,0(x)		;get pointer to input variable
	mov	l,-1(x)
	mov	m,d		;save floating point number
	dcx	h
	mov	m,e
	dcx	h
	mov	m,b
	dcx	h
	mov	m,c		;all saved!!!!
	pop	h		;get pointer to string
	sphl			;..and use it to restore the stack
	pop	h		;throw away two now useless bytes
	pop	h		;get file pointer
	pop	d		;get parm counter
	mvi	b,0		;clear b
	ret
fpoint:	bit	fpp,b		;see if it's too late for a decimal point
	jrnz	fpdn		;yes, we're done with this #
	mvi	b,fppb		;set appropriate bit
	jr	fpchrs		;and process more characters
fpscal:	bit	fps,b		;see if it's too late for a scale factor
	jrnz	fpdn		;yes, we're done with this #
	mvi	b,fpsb+fppb
	call	input		;save scale factor on string
	push	psw
	inx	s
	call	look		;look for a leading sign on the exponent
	cpi	'-'
	jrz	scalsn		;yes, do a scale sign
	cpi	'+'
	jrnz	ckdg		;no, go get some digits
scalsn:	call	input		;save scale sign
	push	psw
	inx	s
	jr	ckdg		;make sure that the next one's a digit
	endif
;
; look -- routine to look one character ahead
;
look:
	if	not compiler	;don't use with compiler
	xra	a		;check for console/disk file
	cmp	h
	jrnz	ntcns		;not a console file
	push	d		;save de

	lhld	6
	lxi	d,-getp
	dad	d		; HL points to text_in_pointer
	mov	e,m
	mvi	d,0
	dad	d
	inx	h		; HL points to next character to read.
	mov	a,m
	lxi	h,0		;indicate console file
	pop	d		;restore de
	ret			;done!
ntcns:	inx	h		;get look ahead char from disk file
	mov	a,m
	dcx	h		;restore pointer
	ret			;done!
	endif

;
; divide a floating point number by ten
;
fpdten:	lxi	h,op2		;get pointer to op2
	dad	d
	push	d		;save base reg
	xchg			;de <- pointer to op2
	lxi	h,tentop	;hl <- pointer to 10
	lxi	b,nbytes
	lddr			;op2 <- 10
	pop	d		;restore base reg
	jmp	fdivd1

;
; multiply a floating point number by ten
;
fptten:	lxi	h,op2		;get pointer to op2
	dad	d
	push	d		;save base reg
	xchg			;get pointer to op1
	lxi	b,op1
	dad	b
	lxi	b,nbytes	;copy op1 -> op2
	lddr
	pop	d		;restore base reg
	inr	exp+op1(x)	;x2
	jv	fperr		;overflow error
	inr	exp+op1(x)	;x4
	jv	fperr
	call	fadd1		;x5
	inr	exp+op1(x)	;x10
	rnv			;return if no error
;
; fperr - return a zero and set the carry bit
;
fperr:	xra	a		;clear acc
	cmp	intflg(x)	;test for internal operations
	jc	flterr		;record a floating point error
	spix			;set stack pointer
	pop	d		;de <- return address
	pop	y		;restore iy....
	pop	x		;...and ix
	lxi	h,nbytes+7	;remove op2, 2 scratch bytes and op1
	dad	s
	sphl			;fix stack pointer
	lxi	h,0		;save zero (op1) on the stack
	push	h
	push	h
	xchg			;return addr -> hl
	xra	a		;clear accumulator
	stc			;set carry to indicate error
	pchl			;return

;
; convert a string to a floating point number
;
cvtsfp:	lxi	d,0
	mvi	b,7
addzer:	push	d		;add 14 bytes of zeroes to the stack
	djnz	addzer
	push	x		;save ix, iy and hl
	push	y
	push	h
	xchg			;hl <- 0
	dad	s		;hl = sp
	push	h
	pop	x		;ix = sp
	inr	intflg(x)	;set internal operations flag
	xchg			;de = sp
nxtdig:	pop	h		;get next digit
	mov	a,m
	dcx	h		;bump and save pointer
	push	h
	cpi	'.'		;check for a decimal point
	jrz	fractn		;yes, go indicate a fraction
	cpi	'e'		;check for a scale factor
	jrz	scale
	cpi	'E'
	jrz	scale
	cpi	' '		;check for end of number
	jrz	eofpn
	dcr	dc1(x)		;add another notch to the digit counter
	call	fptten		;op1 := op1 * 10
	pop	h		;get digit again
	push	h
	inx	h
	mov	a,m
	sui	'0'		;strip ascii bias
	lxi	h,op2		;make op2 = new digit
	dad	d
	mvi	m,7		;exponent
	dcx	h
	mov	m,a		;high byte of mantissa
	xra	a		;acc <- 0
	dcx	h
	mov	m,a		;store a zero into this byte of mantissa
	dcx	h
	mov	m,a		;store a zero into this byte of mantissa
	dcx	h
	mov	m,a		;store a zero into this byte of mantissa
	normfp	2		;normalize this number, and ....
	call	fadd1		;add
	jr	nxtdig		;do next digit
fractn:	mvi	dc1(x),0	;indicate no decimal digits yet
	mvi	dc2(x),0ffh	;fix mask to allow decimal digits
	jr	nxtdig		;go do next digit
eofpn:	xra	a		;clear acc
	pop	h		;throw away string pointer
	jr	scal6		;and go do some scaling
scale:	pop	h		;get pointer to string
	xra	a		;clear acc
	mov	c,a		;clear c
	mov	a,m		;get first char of scale factor
	cpi	'-'		;check for a leading sign
	jrnz	scal2		;no leading minus sign
	mov	c,a		;set c to indicate a negative exponent
	jr	scal3
scal2:	cpi	'+'		;check for a leading plus sign
	jrnz	scal4		;no, keep processing
scal3:	dcx	h		;skip over sign and keep processing
scal4:	mov	a,m		;get first digit
	sui	'0'		;strip ascii bias
	jc	fperr		;make sure than 0 <= exp <= 9
	cpi	10
	jnc	fperr
	mov	b,a		;save the digit
	dcx	h		;bump the pointer
	mov	a,m		;get next digit
	cpi	' '		;check for end of exponent
	jrz	scal5
	sui	'0'		;strip ascii bias
	jc	fperr
	cpi	10
	jnc	fperr
	push	d		;save stack pointer
	mov	d,a		;save ones digit
	mov	a,b		;get tens digit
	add	a		;x2
	add	a		;x4
	add	b		;x5
	add	a		;x10
	add	d		; + ones digit
	pop	d		;restore stack pointer
	mov	b,a		;save exponent in b
scal5:	mov	a,b		;get exponent
	bit	0,c		;check for negative exponent
	jrz	scal6		;no, don't negate
	neg			;negate acc
scal6:	mov	b,a		;save signed exponent
	mov	a,dc1(x)	;get input bias
	ana	dc2(x)		;...and...
	add	b		;form corrected scale factor
	jm	dcnst		;negative exp requires division
	jrz	cvtdn		;zero -> done
	mov	b,a		;save it
mcnst:	push	b		;save counter
	call	fptten		;multiply by ten
	pop	b		;get counter
	djnz	mcnst		;continue until done
	jr	cvtdn
dcnst:	neg			;make counter positive
	mov	b,a		;save in b
dcnst2:	push	b		;save counter
	call	fpdten		;divide op1 by ten
	pop	b		;get counter
	djnz	dcnst2		;continue until done
cvtdn:	pop	y		;restore y
	pop	x		;restore x
	lxi	h,8		;throw away work space
	dad	s
	sphl
	pop	h		;get op1
	pop	d
	pop	b		;throw away scratch bytes
	xra	a		;clear acc
	ret
$cvth	call	cvtsfp		;convert to float
	ret			;return with two msb's in de
$cvtl	call	cvtsfp		;convert to float
	xchg
	ret			;return with two lsb's in de

;
; truncate and round functions (used to convert float -> integer)
;
round:	pop	h		;get return address
	pop	d		;get low word
	xthl			;get high word
	push	h		;save high word
	push	d		;save low word
	mov	d,a		;set op2 = .5
	mov	e,a
	mov	h,a
	mvi	a,80h		;make sign of op2 = sign of op1
	ana	l
	ori	40h		;set bit to the right of the binary pt
	mov	l,a		;save as high byte of mantissa
	push	h		;save op2
	push	d
	call	fadd		;increase the magnitude of op1 by .5
	pop	d		;get number to truncate
	pop	h
	jr	trunc2		;...and go truncate
trunc:	pop	h		;get return address
	pop	d		;get low word of #
	xthl			;get high word
trunc2:	mov	e,d		;throw away low 8 bits
	mov	d,l
	bit	sign,h		;check for negative exponent
	jrnz	zeroi		;return zero integer
	mvi	a,15		;# of shifts assuming zero exponent
	sub	h		;get actual # of shifts
	jrc	zeroi		;number too big return zero
	jrz	dones		;done shifting
	res	sign,d		;clear sign bit
	mov	b,a		;install counter
shft:	srlr	d		;shift high byte
	rrar	e		;rotate low byte
	djnz	shft		;continue until done
dones:	xra	a		;clear acc, carry
	bit	sign,l		;check sign bit
	rz			;sign is +ive, return now!
	lxi	h,0		;negate de
	dsbc	d		;by subtracting
dntngt:	xchg			;return integer in de
	ret
zeroi:	lxi	d,0		;return a value of zero
	xra	a		;clear acc
	ret
;
; done2 -- done with a two operand operation
;
done2:	normfp	1		;first normalize result
	push	x		;restore de as stack index
	pop	d
	xra	a		;clear acc, carry
	cmp	intflg(x)	;check internal op flag
	rnz			;return if operation is internal
	pop	d		;de <- return address
	pop	y		;restore iy....
	pop	x		;...and ix
;remove op2, 2 scratch bytes and extra byte of op1 from stack
	lxi	h,nbytes+3
	dad	s
	sphl			;fix stack pointer
	xchg			;return addr -> hl
	xra	a		;clear accumulator
	pchl			;return

;
; floating point relational operators
;
frelop:	macro	flags		;;do a relop and check the correct flags
	call	cmpops		;;compare the operands
	ani	flags		;;check the return flags
	jr	relfin		;;...and finish the relop
	endmac
fpgt:	frelop	gtbit		;check the greater than bit
fpgte:	frelop	gtbit+eqbit	;check the greater than and equal to bits
fplt:	frelop	ltbit		;check the less than bit
fplte:	frelop	ltbit+eqbit	;check the less than and equal to bits
fpeq:	frelop	eqbit		;check equal to bit
fpneq:	frelop	ltbit+gtbit	;check less than and greater than bits
relfin:	mvi	a,0		;clear accumulator
	rz			;return false if status bit wasn't set
	stc			;otherwize set the carry bit
	ret			;and return
;
; compare two floating point operands
;
cmpops:	push	x		;save ix
	lxi	x,6		;make ix point to bottom of op2
	xra	a		;clear the carry and...
	dadx	s
	mov	c,6(x)		;get sign of op1
	mov	e,2(x)		;get sign of op2
	mov	a,c
	xra	e		;check for like signs
	jm	dfsgns		;no, different signs
	mov	a,7(x)		;yes, get exponents and toggle
	xri	80h		;the high order bit in order to
	mov	b,a		;check the relative magnitudes
	mov	a,3(x)		;now do op2
	xri	80h
	cmp	b		;check against op1.exponent
	jrnz	fpdiff		;they're different
	mov	a,e		;get high byte of op2's mantissa
	cmp	c		;check against op1's
	jrnz	fpdiff		;they're diferent
	mov	a,1(x)		;get middle byte of op2's mantissa
	cmp	5(x)		;compare against op1's
	jrnz	fpdiff
	mov	a,0(x)		;get low byte of op2's mantissa
	cmp	4(x)		;check against op1's
	jrnz	fpdiff
	mvi	a,eqbit		;op1 = op2
	jr	cmpdon		;done comparing
dfsgns:	slar	e		;get sign bit of op2 into carry
	jr	fpdf1		;don't check signs
fpdiff:	bit	sign,c		;check sign bit
	jrz	fpdf1		;both numbers +ive
	cmc			;both numbers negative, reverse test
fpdf1:	jrc	obig		;if carry then op1 > op2
	mvi	a,ltbit		;op1 < op2
	jr	cmpdon
obig:	mvi	a,gtbit		;op1 > op2
cmpdon:	pop	x		;restore ix
	pop	d		;get return address
	pop	h		;get second return address
	pop	b		;kill op2
	pop	b
	pop	b		;kill op1
	xthl			;restore second return address
	xchg			;hl <- return address
	pchl			;return
	if	not compiler
;
; routine to convert a number to fixed point format
;
;     const exp = 13;
; 	  maxlen = 12;
;     type string = array[ 1..14 ] of char;
; procedure format( var x: string );
;     var  tpowr: integer;
; 	 fracln, i, j: 0..255;
; 	 y: array[ 1..22 ] of char;
; 	 sign: char;
; 	fixed: boolean;
;     begin
FXD037
FXDCVT:
	ENTR	D,2,29
; 	fixed := false; (* assume no success *)
	MOV	-6(IX),A
; 	sign := x[ 2 ];
	LXI	H,11
	ILOD	H,1,-1
	RCHK	H,0,127
	MOV	-5(IX),L
; 	tpowr := -1;
	MVI	0(IX),255
	MVI	-1(IX),255
; 	(*$R- *) fracln := ord( x[ tpowr ] ); (*$R+ *)
R	SET	         0
	MOV	L,-1(IX)
	MOV	H,0(IX)
	RCHK	H,1,14
	XCHG
	MOV	H,11(IX)
	MOV	L,10(IX)
	DSUB
	INX	H
	MOV	D,A
	MOV	E,M
	RCHK	D,0,255
	MOV	-4(IX),E
R	SET	         1
; 	tpowr := ord( x[ exp ] ) * 10 + ord( x[ exp+1 ] ) - 11 * ord( '0' );
	LXI	H,11
	ILOD	H,1,-12
	LXI	D,10
	MULT	D,0
	PUSH	H
	LXI	H,11
	ILOD	H,1,-13
	POP	D
	DADD	D,0
	PUSH	H
	LXI	H,48
	LXI	D,11
	MULT	D,0
	POP	D
	XCHG
	DSUB	D,0
	MOV	0(IX),H
	MOV	-1(IX),L
; 	if x[ exp-1 ] = '-' then tpowr := -tpowr;
	LXI	H,11
	ILOD	H,1,-11
	LXI	D,45
	EQUL	D,0
	JNC	FXD120
	MOV	L,-1(IX)
	MOV	H,0(IX)
	NEGT	H
	MOV	0(IX),H
	MOV	-1(IX),L
FXD120
; 	for i := 1 to 22 do y[ i ] := '0';
	MVI	-3(IX),1
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	PUSH	H
	LXI	H,22
	XTHL
FXD148
	MOV	D,A
	MOV	E,M
	XTHL
	PUSH	H
	GE	D,0
	JNC	FXD149
	MOV	H,A
	MOV	L,-3(IX)
	RCHK	H,1,22
	XCHG
	LXI	H,-6
	ADDR	IX
	MVI	M,48
	CTRL
	POP	H
	XTHL
	INR	M
	JNZ	FXD148
FXD149
	POP	D
FXD168
	POP	D
; 	if (tpowr >= 0) and (tpowr+2+fracln <= maxlen) then begin
	MOV	L,-1(IX)
	MOV	H,0(IX)
	MOV	D,A
	MOV	E,A
	GE	D,0
	JNC	FXD173
	MOV	L,-1(IX)
	MOV	H,0(IX)
	INX	H
	INX	H
	MOV	D,A
	MOV	E,-4(IX)
	DADD	D,0
	LXI	D,12
	LE	D,0
	JNC	FXD170
; 	    fixed := true;
	MVI	-6(IX),1
; 	    y[ 1 ] := x[ 3 ];
	LXI	H,11
	ILOD	H,1,-2
	RCHK	H,0,127
	MOV	-7(IX),L
; 	    if tpowr > 6 then begin
	MOV	L,-1(IX)
	MOV	H,0(IX)
	LXI	D,6
	GRET	D,0
	JNC	FXD216
; 		for i := 5 to 10 do y[ i-3 ] := x[ i ];
	MVI	-3(IX),5
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	PUSH	H
	LXI	H,10
	XTHL
FXD233
	MOV	D,A
	MOV	E,M
	XTHL
	PUSH	H
	GE	D,0
	JNC	FXD234
	MOV	H,A
	MOV	L,-3(IX)
	DCX	H
	DCX	H
	DCX	H
	RCHK	H,1,22
	XCHG
	LXI	H,-6
	ADDR	IX
	MOV	D,A
	MOV	E,-3(IX)
	RCHK	D,1,14
	PUSH	H
	MOV	H,11(IX)
	MOV	L,10(IX)
	DSUB
	INX	H
	MOV	D,A
	MOV	E,M
	RCHK	D,0,127
	POP	H
	MOV	M,E
	CTRL
	POP	H
	XTHL
	INR	M
	JNZ	FXD233
FXD234
	POP	D
FXD260
	POP	D
; 		for i := 7 to tpowr do y[ i+1 ] := '0';
	MVI	-3(IX),7
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	PUSH	H
	MOV	L,-1(IX)
	MOV	H,0(IX)
	XTHL
FXD269
	MOV	D,A
	MOV	E,M
	XTHL
	PUSH	H
	GE	D,0
	JNC	FXD270
	MOV	H,A
	MOV	L,-3(IX)
	INX	H
	RCHK	H,1,22
	XCHG
	LXI	H,-6
	ADDR	IX
	MVI	M,48
	CTRL
	POP	H
	XTHL
	INR	M
	JNZ	FXD269
FXD270
	POP	D
FXD290
	POP	D
; 		end
; 	    else begin
	JMP	FXD293
FXD216
; 		for i := 2 to tpowr+1 do y[ i ] := x[ i+3 ];
	MVI	-3(IX),2
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	PUSH	H
	MOV	L,-1(IX)
	MOV	H,0(IX)
	INX	H
	XTHL
FXD304
	MOV	D,A
	MOV	E,M
	XTHL
	PUSH	H
	GE	D,0
	JNC	FXD305
	MOV	H,A
	MOV	L,-3(IX)
	RCHK	H,1,22
	XCHG
	LXI	H,-6
	ADDR	IX
	MOV	D,A
	MOV	E,-3(IX)
	INX	D
	INX	D
	INX	D
	RCHK	D,1,14
	PUSH	H
	MOV	H,11(IX)
	MOV	L,10(IX)
	DSUB
	INX	H
	MOV	D,A
	MOV	E,M
	RCHK	D,0,127
	POP	H
	MOV	M,E
	CTRL
	POP	H
	XTHL
	INR	M
	JNZ	FXD304
FXD305
	POP	D
FXD332
	POP	D
; 		for i := 3 to 8-tpowr do y[ tpowr+i ] := x[ i+2+tpowr ];
	MVI	-3(IX),3
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	PUSH	H
	MOV	L,-1(IX)
	MOV	H,0(IX)
	LXI	D,8
	XCHG
	DSUB	D,0
	XTHL
FXD341
	MOV	D,A
	MOV	E,M
	XTHL
	PUSH	H
	GE	D,0
	JNC	FXD342
	MOV	L,-1(IX)
	MOV	H,0(IX)
	MOV	D,A
	MOV	E,-3(IX)
	DADD	D,0
	RCHK	H,1,22
	XCHG
	LXI	H,-6
	ADDR	IX
	MOV	D,A
	MOV	E,-3(IX)
	INX	D
	INX	D
	PUSH	H
	MOV	L,-1(IX)
	MOV	H,0(IX)
	DADD	D,0
	RCHK	H,1,14
	XCHG
	MOV	H,11(IX)
	MOV	L,10(IX)
	DSUB
	INX	H
	MOV	D,A
	MOV	E,M
	RCHK	D,0,127
	POP	H
	MOV	M,E
	CTRL
	POP	H
	XTHL
	INR	M
	JNZ	FXD341
FXD342
	POP	D
FXD371
	POP	D
; 		end;
FXD293
; 	    end;
FXD170
FXD172	EQU  FXD170
FXD173	EQU  FXD172
; 	if (tpowr < 0) and (fracln+2 <= maxlen) then begin
	MOV	L,-1(IX)
	MOV	H,0(IX)
	MOV	D,A
	MOV	E,A
	LESS	D,0
	JNC	FXD380
	MOV	H,A
	MOV	L,-4(IX)
	INX	H
	INX	H
	LXI	D,12
	LE	D,0
	JNC	FXD377
; 	    fixed := true;
	MVI	-6(IX),1
; 	    y[ 2+abs( tpowr ) ] := x[ 3 ];
	MOV	L,-1(IX)
	MOV	H,0(IX)
	CALL	L10015
	INX	H
	INX	H
	RCHK	H,1,22
	XCHG
	LXI	H,-6
	ADDR	IX
	XCHG
	LXI	H,11
	ILOD	H,1,-2
	RCHK	H,0,127
	XCHG
	MOV	M,E
; 	    for i := 3 to 8 do y[ i+abs( tpowr ) ] := x[ i+2 ];
	MVI	-3(IX),3
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	PUSH	H
	LXI	H,8
	XTHL
FXD436
	MOV	D,A
	MOV	E,M
	XTHL
	PUSH	H
	GE	D,0
	JNC	FXD437
	MOV	H,A
	MOV	L,-3(IX)
	PUSH	H
	MOV	L,-1(IX)
	MOV	H,0(IX)
	CALL	L10015
	POP	D
	DADD	D,0
	RCHK	H,1,22
	XCHG
	LXI	H,-6
	ADDR	IX
	MOV	D,A
	MOV	E,-3(IX)
	INX	D
	INX	D
	RCHK	D,1,14
	PUSH	H
	MOV	H,11(IX)
	MOV	L,10(IX)
	DSUB
	INX	H
	MOV	D,A
	MOV	E,M
	RCHK	D,0,127
	POP	H
	MOV	M,E
	CTRL
	POP	H
	XTHL
	INR	M
	JNZ	FXD436
FXD437
	POP	D
FXD470
	POP	D
; 	    tpowr := 0;  (* fudge to allow mutual code later on *)
	MOV	0(IX),A
	MOV	-1(IX),A
; 	    end;
FXD377
FXD379	EQU  FXD377
FXD380	EQU  FXD379
; 	if fixed then begin
	CMP	-6(IX)
	JNC	FXD480
; 	    y[ tpowr+2 ] := '.';
	MOV	L,-1(IX)
	MOV	H,0(IX)
	INX	H
	INX	H
	RCHK	H,1,22
	XCHG
	LXI	H,-6
	ADDR	IX
	MVI	M,46
; 	    for i := 1 to 14 do x[ i ] := ' ';
	MVI	-3(IX),1
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	PUSH	H
	LXI	H,14
	XTHL
FXD508
	MOV	D,A
	MOV	E,M
	XTHL
	PUSH	H
	GE	D,0
	JNC	FXD509
	MOV	H,A
	MOV	L,-3(IX)
	RCHK	H,1,14
	XCHG
	MOV	H,11(IX)
	MOV	L,10(IX)
	DSUB
	INX	H
	MVI	M,32
	CTRL
	POP	H
	XTHL
	INR	M
	JNZ	FXD508
FXD509
	POP	D
FXD528
	POP	D
; 	    j := tpowr+2+fracln;
	MOV	L,-1(IX)
	MOV	H,0(IX)
	INX	H
	INX	H
	MOV	D,A
	MOV	E,-4(IX)
	DADD	D,0
	RCHK	H,0,255
	MOV	-2(IX),L
; 	    for i := 1 to j do x[ i+(maxlen-j+2) ] := y[ i ];
	MVI	-3(IX),1
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	PUSH	H
	MOV	H,A
	MOV	L,-2(IX)
	XTHL
FXD545
	MOV	D,A
	MOV	E,M
	XTHL
	PUSH	H
	GE	D,0
	JNC	FXD546
	MOV	H,A
	MOV	L,-3(IX)
	MOV	D,A
	MOV	E,-2(IX)
	PUSH	H
	LXI	H,12
	DSUB	D,0
	INX	H
	INX	H
	POP	D
	DADD	D,0
	RCHK	H,1,14
	XCHG
	MOV	H,11(IX)
	MOV	L,10(IX)
	DSUB
	INX	H
	MOV	D,A
	MOV	E,-3(IX)
	RCHK	D,1,22
	PUSH	H
	LXI	H,-6
	ADDR	IX
	MOV	D,A
	MOV	E,M
	RCHK	D,0,127
	POP	H
	MOV	M,E
	CTRL
	POP	H
	XTHL
	INR	M
	JNZ	FXD545
FXD546
	POP	D
FXD578
	POP	D
; 	    x[ maxlen-j+2 ] := sign;
	MOV	H,A
	MOV	L,-2(IX)
	LXI	D,12
	XCHG
	DSUB	D,0
	INX	H
	INX	H
	RCHK	H,1,14
	XCHG
	MOV	H,11(IX)
	MOV	L,10(IX)
	DSUB
	INX	H
	MOV	D,A
	MOV	E,-5(IX)
	RCHK	D,0,127
	MOV	M,E
; 	    end;
FXD480
; 	end;
	EXIT	D,2
;
; the following floating point functions are here:
;	arctan, cos, exp, ln, sin, sqrt
;
F	SET	         0
; (*
;  * intrinsic function for calculating arctangent
;  *)
; function arctan( x: real ): real;
;     const
; 	   a1 = 3.7092563;
; 	   a2 = -7.10676;
; 	   a3 = -0.26476862;
; 	   b0 = 0.17465544;
; 	   b1 = 6.762139;
; 	   b2 = 3.3163354;
; 	   b3 = 1.44863154;
;     var i,k: real;
;         schg : boolean;	(* is a sign change necessary *)
;         constant: real;(* constant to be added to result *)
;     begin
arctan:
FCT037
	ENTR	D,2,13
;         constant := 0.0;	(* assume no fudge factor *)
	MOV	H,A
	MOV	L,A
	PUSH	H
	PUSH	H
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-9
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
;         schg := false;	(* assume no sign change *)
	MOV	-8(IX),A
;         if x < 0.0 then begin
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	MOV	H,A
	MOV	L,A
	PUSH	H
	PUSH	H
	LESS	D,-4
	JNC	FCT051
; 	    schg := true;
	MVI	-8(IX),1
; 	    x := -x
; 	    end;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	NEGT	E
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,13
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
FCT051
;         if x > 1.0 then begin
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,320
	MOV	D,A
	MOV	E,A
	PUSH	H
	PUSH	D
	GRET	D,-4
	JNC	FCT073
; 	    schg := not schg;
	CMP	-8(IX)
	JRC	FCT083
FCT082
FCT084	EQU  FCT082
FCT087	EQU  FCT084
	INR	A
FCT083
	MOV	L,A
	XRA	A
	MOV	H,A
	RCHK	H,0,1
	MOV	-8(IX),L
; 	    constant := halfpi;
	LXI	H,356
	LXI	D,-30739
	PUSH	H
	PUSH	D
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-9
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	    x := 1.0 / x
	LXI	H,320
	MOV	D,A
	MOV	E,A
	PUSH	H
	PUSH	D
; 	    end;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	FDVD	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,13
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
FCT073
; 	i := x * x;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	MULT	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-4
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	k := x * (b0 + a1 /
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,-423
	LXI	D,27760
	PUSH	H
	PUSH	D
	LXI	H,630
	LXI	D,-19911
	PUSH	H
	PUSH	D
; 			(b1 + i + a2 /
	LXI	H,876
	LXI	D,12728
	PUSH	H
	PUSH	D
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
	DADD	D,-4
	LXI	H,1009
	LXI	D,-19127
	PUSH	H
	PUSH	D
; 			    (b2 + i + a3 /
	LXI	H,618
	LXI	D,8043
	PUSH	H
	PUSH	D
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
	DADD	D,-4
	LXI	H,-61
	LXI	D,-14368
	PUSH	H
	PUSH	D
; 				(b3 + i) ) ) );
	LXI	H,348
	LXI	D,-18848
	PUSH	H
	PUSH	D
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
	DADD	D,-4
	FDVD	D,-4
	DADD	D,-4
	FDVD	D,-4
	DADD	D,-4
	FDVD	D,-4
	DADD	D,-4
	MULT	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
;         if schg then k := -k;
	CMP	-8(IX)
	JNC	FCT135
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	LXI	B,4
	LDIR
	NEGT	E
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
FCT135
;         arctan := constant + k
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-12
	DADD	B
	LXI	B,4
	LDIR
;         end;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	LXI	B,4
	LDIR
	DADD	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,17
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	EXIT	D,4
; 
; (*
;  * intrinsic function for calculating natural log
;  *)
; function ln( x: real ): real;
;     var i,k,k1: real;
;         a: integer;
;     begin
ln:
FCT153
	ENTR	D,2,14
; 	if x < 0.0 then x := abs( x );
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	MOV	H,A
	MOV	L,A
	PUSH	H
	PUSH	H
	LESS	D,-4
	JNC	FCT155
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	CALL	FPABS
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,13
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
FCT155
;         x := (x - 1.0)/(x + 1.0);
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,320
	MOV	D,A
	MOV	E,A
	PUSH	H
	PUSH	D
	DSUB	D,-4
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,320
	MOV	D,A
	MOV	E,A
	PUSH	H
	PUSH	D
	DADD	D,-4
	FDVD	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,13
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	i := x * x;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	MULT	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-8
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	a := 1;
	MOV	-12(IX),A
	MVI	-13(IX),1
;         k := 0.0;
	MOV	H,A
	MOV	L,A
	PUSH	H
	PUSH	H
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-4
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	repeat
; 	    k1 := k;
FCT209
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
	dcx	d
	PUSH	IX
	POP	H
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	    k := k + (x / a);
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	MOV	L,-13(IX)
	MOV	H,-12(IX)
	PUSH	H
	CVTF	B
	FDVD	D,-4
	DADD	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-4
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	    x := x * i;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-11
	DADD	B
	LXI	B,4
	LDIR
	MULT	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,13
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	    a := a + 2;
	MOV	L,-13(IX)
	MOV	H,-12(IX)
	INX	H
	INX	H
	MOV	-12(IX),H
	MOV	-13(IX),L
; 	    until k = k1;
	CTRL
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	LXI	B,4
	LDIR
	EQUL	D,-4
	JNC	FCT209
; 	ln := k * 2.0;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
	dcx	d	;point to exponent
	xchg
	inr	m	;increase exponent by 1 to multiply by 2
	xchg
	PUSH	IX
	POP	H
	LXI	B,17
	DADD	B
	XCHG
	LXI	B,4
	LDDR
;         end;
	EXIT	D,4
; 
; (*
;  * intrinsic function for e to the x
;  *)
; function exp( x: real ):real;
;     var i,k,k1: real;
;         a: 0..255;
;     begin
FCT256
expfct:
	ENTR	D,2,13
;         i := 1;
	CVTF	A,1
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-8
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	a := 0;
	MOV	-12(IX),A
; 	k := 1;
	CVTF	A,1
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-4
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	repeat
; 	    k1 := k;
FCT276
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
	dcx	d
	PUSH	IX
	POP	H
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	    a := a + 1;
	MOV	H,A
	MOV	L,-12(IX)
	INX	H
	RCHK	H,0,255
	MOV	-12(IX),L
; 	    i := (i * x) / a;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-11
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	MULT	D,-4
	MOV	H,A
	MOV	L,-12(IX)
	PUSH	H
	CVTF	B
	FDVD	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-8
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	    k := k + i
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
; 	    until k = k1;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-11
	DADD	B
	LXI	B,4
	LDIR
	DADD	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-4
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
	CTRL
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	LXI	B,4
	LDIR
	EQUL	D,-4
	JNC	FCT276
;         exp := k;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
	dcx	d
	PUSH	IX
	POP	H
	LXI	B,17
	DADD	B
	XCHG
	LXI	B,4
	LDDR
;         end;
	EXIT	D,4
; 
; (*
;  * intrinsic function for sine
;  *)
; function sin( x: real ):real;
;     const   a1 = 1.5707949;
; 	    a3 = -0.64592098;
; 	    a5 = 0.07948766;
; 	    a7 = -0.004362476;
; 	    piu2 = 0.6366197724;	(* 2 / pi *)
;     var x2: real;
;         schg: boolean;
;     begin
FCT321
sin:
	ENTR	D,2,5
;         schg := false;
FCC321
	MOV	-4(IX),A
;         while x > halfpi do begin
FCT330
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,356
	LXI	D,-30739
	PUSH	H
	PUSH	D
	GRET	D,-4
	JNC	FCT329
; 	    x := x - pi;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,612
	LXI	D,-30739
	PUSH	H
	PUSH	D
	DSUB	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,13
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	    schg := not schg
; 	    end;
	CMP	-4(IX)
	JRC	FCT347
FCT346
FCT348	EQU  FCT346
FCT351	EQU  FCT348
	INR	A
FCT347
	MOV	L,A
	XRA	A
	MOV	H,A
	RCHK	H,0,1
	MOV	-4(IX),L
	CTRL
	JMP	FCT330
FCT329
;         while x <= -halfpi do begin
FCT354
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,356
	LXI	D,-30739
	PUSH	H
	PUSH	D
	NEGT	E
	LE	D,-4
	JNC	FCT353
; 	    x := x + pi;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,612
	LXI	D,-30739
	PUSH	H
	PUSH	D
	DADD	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,13
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	    schg := not schg
; 	    end;
	CMP	-4(IX)
	JRC	FCT371
FCT370
FCT372	EQU  FCT370
FCT375	EQU  FCT372
	INR	A
FCT371
	MOV	L,A
	XRA	A
	MOV	H,A
	RCHK	H,0,1
	MOV	-4(IX),L
	CTRL
	JMP	FCT354
FCT353
; 	x := x * piu2;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,81
	LXI	D,31937
	PUSH	H
	PUSH	D
	MULT	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,13
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	x2 := x * x;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	MULT	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	x := (((a7*x2 + a5)*x2 + a3)*x2 + a1)*x;
	LXI	H,-1593
	LXI	D,31116
	PUSH	H
	PUSH	D
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	LXI	B,4
	LDIR
	MULT	D,-4
	LXI	H,-687
	LXI	D,25910
	PUSH	H
	PUSH	D
	DADD	D,-4
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	LXI	B,4
	LDIR
	MULT	D,-4
	LXI	H,210
	LXI	D,-21111
	PUSH	H
	PUSH	D
	DADD	D,-4
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	LXI	B,4
	LDIR
	MULT	D,-4
	LXI	H,356
	LXI	D,-30745
	PUSH	H
	PUSH	D
	DADD	D,-4
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	MULT	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,13
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
;         if schg then x := -x;
	CMP	-4(IX)
	JNC	FCT410
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	NEGT	E
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,13
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
FCT410
;         sin := x;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	dcx	d
	PUSH	IX
	POP	H
	LXI	B,17
	DADD	B
	XCHG
	LXI	B,4
	LDDR
;         end;
	EXIT	D,4
; 
; (*
;  * intrinsic function for cosine
;  *)
; function cos( x: real ):real;
;     var x2: real;
;         schg: boolean;
;     begin
FCT429
cos:
	ENTR	D,2,5
; 	cos := sin( x + halfpi )
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,356
	LXI	D,-30739
	PUSH	H
	PUSH	D
	DADD	D,-4
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,13
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
;         end;
	JMP	FCC321
; 
; (*
;  * intrinsic function for square root
;  *)
; function sqrt( x:real ): real;
;     var j,i,k: real;
;     begin
FCT443
sqrt:
	ENTR	D,2,12
;         i := 0.0;
	MOV	H,A
	MOV	L,A
	PUSH	H
	PUSH	H
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-4
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	if x < 0.0 then x := abs( x );
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	MOV	H,A
	MOV	L,A
	PUSH	H
	PUSH	H
	LESS	D,-4
	JNC	FCT451
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	ldir
	CALL	FPABS
	LXI	H,3
	DADD	S
	XCHG
	PUSH	IX
	POP	H
	LXI	B,13
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
FCT451
;         j := x / 2.0;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	dcx	d	;point to exponent
	xchg
	dcr	m	;decrement exponent to divide
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-8
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
;         if x <> 0.0 then repeat
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	MOV	H,A
	MOV	L,A
	PUSH	H
	PUSH	H
	NEQL	D,-4
	JNC	FCT477
; 	    k := i;
FCT485
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
	dcx	d
	PUSH	IX
	POP	H
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	    i := j;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-11
	DADD	B
	LXI	B,4
	LDIR
	dcx	d
	PUSH	IX
	POP	H
	LXI	B,-4
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	    j := (x / j + j )/2.0;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,10
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-11
	DADD	B
	LXI	B,4
	LDIR
	FDVD	D,-4
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-11
	DADD	B
	LXI	B,4
	LDIR
	DADD	D,-4
	LXI	H,3
	DADD	S
	dcr	m	;decrement exponent to divide by 2
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-8
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	POP	H
	POP	H
; 	    until (j = i) or (j = k);
	CTRL
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-11
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-7
	DADD	B
	LXI	B,4
	LDIR
	EQUL	D,-4
	JC	FCT511
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-11
	DADD	B
	LXI	B,4
	LDIR
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	DCX	H
	DCX	H
	DCX	H
	LXI	B,4
	LDIR
	EQUL	D,-4
	JNC	FCT485
FCT484
FCT511	EQU  FCT484
FCT477
;         sqrt := j
;         end;
	LXI	H,-4
	DADD	S
	SPHL
	XCHG
	PUSH	IX
	POP	H
	LXI	B,-11
	DADD	B
	LXI	B,4
	LDIR
	dcx	d
	PUSH	IX
	POP	H
	LXI	B,17
	DADD	B
	XCHG
	LXI	B,4
	LDDR
	EXIT	D,4
F	SET	         1
	else
;;dummy labels for when the compiled program is the compiler itself
arctan:
cos:
expfct:
ln:
sqrt:
sin:
fxdcvt:
	endif
;
; PASCAL INSTRINSIC ROUTINE ENTRY POINTS
;
L10009	EQU	WRITELN
L10010	EQU	READLN
L10011	EQU	WRITE
L10012	EQU	READ
L10015	EQU	ABS
L10016	EQU	FPABS
L10017	EQU	SQR
L10018	EQU	FPSQR
L10020	EQU	EOLN
L10021	EQU	EOF
L10022	EQU	RESET
L10023	EQU	REWRITE
L10024	EQU	FTXTIN
L10025	EQU	CHAIN
L10026	EQU	NEW
L10027	EQU	MARK
L10028	EQU	RELEASE
L10029	EQU	TRUNC
L10030	EQU	ROUND
L10031	EQU	ARCTAN
L10032	EQU	COS
L10033	EQU	EXPFCT
L10034	EQU	LN
L10035	EQU	SQRT
L10036	EQU	SIN

;
; PASCAL PROGRAM
;

