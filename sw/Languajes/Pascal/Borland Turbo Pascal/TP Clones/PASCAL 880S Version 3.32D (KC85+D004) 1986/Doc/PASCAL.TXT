.po12
              P A S C A L - C O M P I L E R 
              -----------------------------
              f}r robotron-Kleincomputer 85/1

1.   Laden des Compilers, Speicherkonfiguration
Ihò  Kleincomputeò muş miô mindestenó eineí RAM-Erweiterungsmoduì 
ausger}steô seiî (KC85/2,3º  vorl{ufiç genaõ eiî 16K-Modul)®  Daó 
Ladeî  voî deò Kassettå erfolgô voí Betriebssysteí OÓ  auó  durcè 
das Kommando
                           PASCAL

Nacè beendeteí Ladevorganç starteô deò Compileò automatisch®  Auæ 
dem Bildschirm erscheint

Toğ oæ RAM¿  Eó handelô sicè uí deî RAM-Toğ f}ò deî Compiler® Siå 
             haben jetzt
      ENTER  oder eine Zahl zwischen
      19916  und 32767 bei einem Erweiterungsmodul oder zwischen
      19916  und 49151 bei zwei Erweiterungsmodulen einzugeben.
             Diå  Eingabå  voî  ENTEÒ wirkô wiå diå  Eingabå  voî 
             32767 bzw. 49151. Danach erscheint
Toğ  oæ RAÍ foò 'T'¿   Eó handelô sicè uí deî RAM-Toğ f}ò daó  zõ 
             erzeugende Objektcode-Programm. Sie k|nnen jetzt
      ENTER  oder eine Zahl zwischen
       6912  und 32767 bei einem Erweiterungsmodul oder zwischen
       691²  unä 4915± beé zweé Erweiterungsmoduleî eingeben® Diå 
             Eingabå  voî ENTEÒ bewirkô diå ]bernahmå deó Toğ  oæ 
             RAÍ  aló  Toğ  oæ RAÍ foò  'T'®  Aló  n{chstå  Fragå 
             erscheint 
Tablå Size¿  Eó  handelô sicè uí diå L{ngå  deó internen Arbeits-
             speicheró  deó Compilers¬  diå voî deò Anzahì deò ií 
             Programí benutzteî Variablen¬ Prozeduren¬ Funktioneî 
             etc. abh{ngt. Jetzt kann
      ENTER  oder eine angemessen gro~e
       Zahì  ¾= 3² eingegebeî werden® Diå Eingabå voî ENTEÒ wirkô 
             wie die Eingabe von ENTIER (Top of RAM - 19612)/16).

Hinweise“ 
a©    Antworteî  Siå  auæ allå dreé Frageî miô  ENTER¬  sï  stehô 
      Ihneî  f}ò Quelltexô unä Objektcode-Programí deò Speicher
      bereicè von
      20402 bis 32767 bei einem Erweiterungsmodul und von
      21426 bis 49151 bei zwei Erweiterungsmodulen zur Verf}gung.
      Deò internå Arbeitsspeicheò deó Compileró isô 82² bzw® 184¶ 
      Bytå lang.

b©    Diå  angegebeneî  untereî  Schrankeî besitzeî nuò theoreti-
      scheî Werô unä lasseî sicè nuò beé extreí kurzeî Programmeî 
      verwenden.

c©    Dá diå  beé Toğ oæ RAÍ foò 'T§ verlangtå Zahì  unteò  1638´ 
      liegeî  darf¬  isô  eó  m|glich¬   Objektcode-Programmå  zõ 
      erzeugen, die keinen RAM-Erweiterungsmodul ben|tigen!
.paŠ2.   Beschreibung des Sprachumfangs
2.1. PASCAL - Symbole

Bezeichneò  (Identifier© m}sseî miô eineí Buchstabeî beginneî unä 
k|nneî  einå  Folgå  voî Klein- unä  Gro~buchstabeî  unä  Zifferî 
enthalten, z.B.
                a, B, a1B, ...
Bezeichner¬   diå   sicè   iî  deî  ersteî   1°   Zeicheî   nichô 
unterscheiden, werden als identisch angesehen.

a) Arithmetische und logische Verkn}pfungen
- - - - - - - - - - - - - - - - - - - - - -
   Ergibtzeichen             :=
   Real- und Integerzahlen   +  -  *  /  
   Integerzahlen             DIV  MOD
   Boolesche Variable       OR  AND  NOT

b) Relationen
- - - - - - - 
   =  <>  <  >  <=  >=
   IN (f}r SET-Arithmetik)

c) Klammern, Trennzeichen etc.
- - - - - - - - - - - - - - - -
   ( | ) | [Taste SHIFT 0|]  Taste @ | (* f}r { |  *) f}r } |
   . | , | : | ; | .. |   Taste ^ | ' | # | $ | 

d) Programm-Grundstrukturen
- - - - - - - - - - - - - -
   PROGRAM      BEGIN     END.     FUNCTION     PROCEDURE

e) Deklarationen
- - - - - - - - -
   TYPE     LABEL     ARRAY...OF...     PACKED ARRAY... OF...
   VAR      CONST     SET               RECORD...END

f) Schleifen
- - - - - - -
   FOR ... := ... TO ... DO ...          WHILE ... DO ...
   FOR ... := ... DOWNTO ... DO ...      REPEAT ... UNTIL ...
   Achtung¡  Diå  Relatioî zwischeî Anfangs- unä Endausdrucë wirä 
   bei beiden Formen der FOR-Anweisung nicht }berpr}ft.

g) Verzweigungen
- - - - - - - - -
   IF ... THEN ... ELSE ...         CASE ... OF ... END
   GOTÏ     Daó  Sprungzieì  muş ií  gleicheî  Blocë  liegeî  unä 
            mitteló LABEL deklariert sein.

h) Records
- - - - - -
   WITH ... DO ...

i) Pointer (dynamische Variable)
- - - - - - - - - - - - - - - - -
   NIL

k) Rekursiv gegenseitig definierte Funktionen und Prozeduren
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   FORWARD
Š2.2. Identifikatoren

a) Konstanten
- - - - - - -
   FALSE     TRUE     MAXINT     Es gilt MAXINT = 32767

b) Type-Konstanten
- - - - - - - - - -
   INTEGEÒ     Mitteló  vorgesetzteí £ k|nneî Integeò aló Hexade-
               zimalzahleî  programmierô werden® Iî deî WRITE-An-
               weisungeî  kanî  durcè diå Formatangabå  :n:È  diå 
               Ausgabå  iî Hexadezimalforí erreichô werdeî  (î  - 
               Konstante bzw. Ausdruck vom Integer-Typ)
    Beispiel: 1210D = 4BAH . Die Anweisung
                              WRITE(1210:n:H) 

    ergibt f}r n=1:    A ... niederwertigstes Halbbyte (Nibble)
               n=2:   BA ... niederwertiges Byte
             n=3,4: 04BA ... vollst{ndige Hexazahl
               î>4º rechtsb}ndigeó Schreibeî  voî 04BÁ ií angege-
                     beneî Format.
   REAÌ        Diå Real-Zahleî  werdeî iî 4-Byte-Gleitkommaarith-
               metik verkn}pft.
   CHAR
   BOOLEAN

c) Arithmetische, mathematische und Boolesche Funktionen
- - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   ROUND(R)      FRAC(R)      ODD(I)      ENTIER(R)
   TRUNC(R)      ABS(R)       SQR(R)      SQRT(R)
   EXP(R)        LN(R)        TAN(R)      ARCTAN(R)
   COS(R)        SIN(R)    
  
   RANDOÍ      Erzeugunç  voî ganzzahligeî  Zufallszahleî  Ú  miô 
               °  <½ Ú <½ 255®  (Durcè  Abfragå deó Refreshregis
               ters)
   EOLÎ        Wirä  TRUE¬  falló  zuletzô geleseneó  Zeicheî  CÒ 
               (Code 13) war, sonst FALSE.
       Beispiel: Eingabe einer Zeichenkette variabler L{nge
                 I:=1;
                 REPEAT READ(A I); I:=I+1 UNTIL EOLN

d) Prozeduren f}r dynamische Variable
- - - - - - - - - - - - - - - - - - - 
   NEW(P)      Erzeugung einer dynamischen Variablen
   RELEASE(P©  Abmeldunç  alleò   nacè  Ğ  erzeugteî  dynamischeî 
               Variablen
   MARK(P)     Markierung der dynamischen Variablen P

e) Ordnungsfunktionen f}r Skalartypen
- - - - - - - - - - - - - - - - - - - -
   ORD(A©      lieferô  Positioî deó Skalarwerteó Á iî deò  durcè                
               deî Tyğ voî Á festgelegteî Wertemenge
   CHR(I©      lieferô ASCII-Zeichen¬  Steuerzeicheî odeò Grafik-
               zeichen mit Code I
   SUCC(A)     Nachfolger von A
               z.B. SUCC(3) = 4, SUCC ('B') = 'C'
   PRED(A)     Vorg{nger von A, z.B. PRED(TRUE) = FALSE
.paŠf) Ein- und Ausgabe
- - - - - - - - - - 
   READ(A©     READLN(A©  Achtung¡  Beií Leseî voî  Zeichenketteî 
                          auó  deí  Eingabepuffeò isô  daó  erstå 
                          Zeichen stets CR (Code 13).
   WRITE(A)    WRITELN(A)
       Beispiel: zur Formatsteuerung 
                 VAR X:REAL; I:INTEGER;
                   .
                   .
                 WRITE(X:10:2,I:6:H)
   PAGÅ          Seitenvorschuâ  aí  Druckeò   bzw®  L|scheî  deó 
                 Bildschirmes 
   INCH          Tastaturabfrage, entspricht INKEY$ bei BASIC
   INP(P©    OUT(P,C©     Entsprichô deî Assembleranweisungeî  IÎ 
                          unä  OUT®   Ğ  isô  einå   Kanaladresså 
                          (°  <½ Ğ <½ 255© unä Ã  einå  Konstantå 
                          odeò Variablå voí Tyğ CHAR.
          Beispiel:   OUT(136, CHR(12))
                      bewirkô   diå  Umschaltunç  auæ  20-Zeilen-
                      Format.    
g) Speicherzugriff
- - - - - - - - - -
   SIZE(V)     L{nge der Variablen V in Byte
   ADDR(V)     Adresse des ersten Byte der Variablen V
   POKE(N,V)   Eintragen des Wertes der Variablen V ab Adresse N
   PEEK(N,T©   Beginnenä  beé Adresså Î wirä  deò  Speicherinhalô 
               entsprechenä  deí  angegebeneî Tyğ Ô  ausgewertet® 
               Tyğ Ô daræ seinº  INTEGER¬  CHAR¬  REAÌ odeò ARRAÙ 
               [1...n] OF...

h) Benutzung von Maschinen-Code
- - - - - - - - - - - - - - - -
   INLINE(F©   Einf}geî deò  durcè diå Zahlenfolgå Æ  definierteî 
               Code-Anweisungen
       Beispielº  Ausgabå  deò System-Uhrzeiô iî  Std:Min:Seã  aâ 
                 aktuelleò Kursorposition
       INLINE(14,17,205,5,0,80,89,14,24,205,5,0)

   USER(N)   Aufruf eines Code-Programmes mit Adresse N

f) Programm-Abbruch
- - - - - - - - - -
   HALÔ        Beendeô   deî  Programmlauæ  miô   Ausschrifô  deó 
               Befehlsz{hlers

3.   Kommandos
3.1. Hauptkommandos

Â        R}ckkehò zuí Betriebssystem® Diå erneutå Aktivierunç deó 
         Compilers kann durch die Kommandos
               PASNEW  f}r neuen Quelltext
               PASOLD  f}r Beibehaltung des alten Quelltextes
         erfolgen.
Cî       ]bersetzeî   aâ   Zeilå  î   bió    Programmende®   Nacè 
         fehlerfreieò ]bersetzunç kanî auæ diå Fragå RUN¿  miô  Ù 
         odeò Î geantworteô werden®  Beé fehlerhafteí Texô werdeî 
         diå Fehleò angezeigô (s.Abschn.5)® Auó deò Fehleranzeigå 
         kanî  durcè  Å zuí Editiereî deò aktuelleî odeò durcè  Ğ 
         zuí  Editiereî  deò  vorhergehendeî  Zeilå  }bergegangeî 
         werden.ŠD n,m    L|schen der Zeilen n bis m
Å n,m,f,ó ]berganç zuí Editoò auæ ersteí Zeicheî deò Zeilå n® Diå 
         gesamtå    Zeilå    î   wirä   vorheò    ausgeschrieben® 
         Unterkommandos s. Abschn.3.3.
Æ  n,m,f,ó  ]berganç  zuí Editoò auæ ersteí  Zeicheî  deò  ersteî 
         Zeichenkettå  f¬   diå  zwischeî  deî  Zeileî  î  unä  í 
         vorkommt. Unterkommandos s. Absch. 3.3.
G,,æ     Ladeî deó  miô Ğ n,m,æ gesicherteî Quelltexteó  voî  deò 
         Kassette®  Isô  bereitó  Quelltexô vorhanden¬  wirä  deò 
         gesamtå Quelltexô voî Zeilennummeò ± aî miô Schrittweitå 
         1 neu numeriert.
É n,í    Automatischå Erzeugunç deò Zeilennummern¬  beginnenä beé 
         î  miô Schrittweitå m®  Durcè diå Tastå STOĞ kanî dieseò 
         Modus beendet werden.
K n      Stellt das Listen auf Gruppen zu n Zeilen ein.
L n,m    Listen des Quelltextes von  Zeile n bis Zeile m.
M n,m    Die Zeile n wird zus{tzlich als Zeile m eingef}gt.
Î n,í    Neunumerierunç deó gesamten“ Textes¬  beginnenä miô Zeilå 
         n, Schrittweite wird m
Ğ  n,m,æ Sicherî  deó  Quelltexteó voî  Zeilå î  bió  í  auæ  deò 
         Kassette unter dem Namen f
R        Starten des zuletzt }bersetzten Programmes
Ô  n,,æ  ]bersetzeî aâ  Zeilå î bió Programmendå unä Sicherî  deò 
         ]bersetzunç   unteò  deí  Nameî  f®   Nacè  fehlerfreieò 
         ]bersetzunç  kanî  auæ  diå  Fragå  Ok¿  miô  Ù  odeò  Î 
         geantworteô werden®  Ersô auæ diå Antworô Ù erfolgô  diå 
         Verbindunç   deò  Bibliotheë  (etwá  µ  kByte©  miô  deí 
         Objektprogramm¬  wobeé  deò Compileò zerst|rô  wird®  Eó 
         entstehô eiî selbst{ndiç lauff{higeó Code-Programm¬  daó 
         nach Wiedereinlesen automatisch startet.
V        Anzeige des Parameterspeichers in der Form
                         n   m
                         f
                         s
Ø        Lieferô   diå   Anfangsadresså    deó   Quelltexteó   iî 
         Hexadezimaldarstellung

3.2. Verk}rzte und wiederholte Kommandos
F}ò diå vieò Kommandoparameteò n¬ m¬ f¬ ó existierô eiî Speicher¬ 
deò  nacè  jedeò Kommandoeingabå miô deî neueî Parameterî  belegô 
wird®   Ií   Kommandï  nichô  belegtå  Parameteò  bleibeî   dabeé 
unver{ndert®  Anschlie~enä erfolgô diå Ausf}hrunç deó  Kommandos¬ 
wobeé  diå Parameteò auó deí Parameterspeicheò verwendeô  werden® 
Nacè  deí  Einleseî deó Compileró haô deò  Parameterspeicheò  deî 
Zustand
   10, 10, leere Zeichenkette, leere Zeichenkette
so da~ z.B. das Kommando
   I     gleichbedeutend mit I10,10
und das Kommando
   I ,5  gleichbedeutend mit I10,5

isô   (isô eiî ausgelasseneò Parameteò nichô deò letzte¬  sï  muş 
das ihm zugeh|rige Komma gesetzt werden).
   Auó  dieseî  Regelî  ergibô  sicè  diå  M|glichkeit¬  beé  ofô 
verwendeten Kommandos die Parametereingabe abzuk}rzen.
Beispieì  1:“ Solì nuò diå Zeilå î editierô werdeî unä dabeé keinå 
            Unterst}tzunç durcè  Zeichenketten-Vorwahì  erfolgen¬ 
            so gen}gt das Kommando
                   E n
.paŠBeispieì 2:“ Editiereî mehrereò Programmzeileî zwischeî deî Zeileî 
            î unä m®  Voraussetzunç ist¬ daş eó eiî Zeicheî gibt¬ 
            daó  iî  alleî zõ editierendeî Zeileî enthalteî  ist¬ 
            z.B. das Zeichen Space.
     Kommando:     E n,m,Space
            Nacè  deí Editiereî deò  Zeilå î erreicheî Siå  durcè 
            evtl® wiederholtå Anwendunç deó Unterkommandooó Æ diå 
            n{chstå Zeilå ií Edit-Modus®  Zuí Ausschreibeî dieseò 
            Zeile k|nnen Sie das Unterkommando L verwenden.
Ausnahmen
C        ]bersetzen ab niedrigster Zeilennummer
D n,m    Verk}rzung nicht m|glich
E n      weitere Verk}rzung nicht m|glich
K        wirkt wie Kommando K 12
Ì  n,í   Weglasseî  voî  î  bewirkô  daó  Listeî  aâ  niedrigsteò 
         Zeilennummer, Weglassen von m das Listen bis Textende
N n,m    Verk}rzung nicht m|glich

3.3. Unterkommandos des Editors
Nachdeí durcè Å ..® odeò Æ ..® daó Editiereî er|ffneô ist¬ steheî 
folgende Unterkommandos zur Verf}gung.
Spacå    bewirkô  diå zeichenweiså ]bernahmå auó deò alteî iî diå 
         neue Zeile
-->      }bernimmt bis zur n{chsten Tabulatorposition
<--      baut die neue Zeile wieder zeichenweise ab
Ã        Stellô auæ Korrigiereî um® Deò Kursoò isô jetzô '+'® Diå 
         alten Zeichen werden jetzt durch neue }berschrieben.
         <-- r}ckt l|schend zur}ck
         ENTER beendet das Unterkommando C
Æ        suchô diå  n{chstå Zeichenkettå f¬  deò Kursoò wirä  auæ 
         die erste Position dieser Zeichenkette gesetzt
É        Stellô  uí  auæ Zeicheî einf}gen®  Deò  Kursoò isô  jetzô
         §  '®  Auæ  Kursorpositioî  kanî eiî  Zeicheî  eingef}gô 
         werden.
         --> Erzeugung von Leerzeichen
         <-- r}ckt l|schend zur}ck
         ENTER beendet das Unterkommando I
Ë        l|schô  daó   Zeicheî  auæ  Kursorposition®  Mehrmaligeó 
         Dr}ckeî voî Ë bewirkô diå L|schunç deò n{chsteî  Zeicheî 
         (ohne Reaktion auf den Bildschirm)
Ì        schreibô diå aktuellå Zeilå aus¬ }bernimmô dabeé bereitó 
         get{tigtå  Korrektureî  unä  stellô deî Kursoò  auæ  daó 
         erste Zeichen dieser Zeile
Ñ        beendeô diå Korrektuò deò Zeile¬  ohnå dereî Korrektureî 
         zu }bernehmen und beendet die Arbeit mit dem Editor
Ò        wiå  L¬  diå bereitó get{tigteî Korrektureî werdeî  abeò 
         nicht }bernommen
Ó        ersetzô  diå zuletzô gefundenå Zeichenkettå æ durcè  diå 
         Zeichenkette a und geht zum Unterkommando F }ber
Ø        stellô uí auæ Weiterschreibeî zuí Endå deò Zeile® Kursoò 
         und weitere Funktionen wie bei I
Z        l|scht ab Kursorposition bis zum Zeilenende
ENTEÒ    beendeô diå Korrektuò deò Zeilå unä  diå Arbeiô miô  deí 
         EDITOR
.paŠ4.   Kontrollfunktionen des Compilers
Deò   Compileò  haô  einå  Reihå  voî   Kontrollfunktionen¬   diå 
abgeschalteô werdeî k|nnen¬ uí diå Bearbeitungsgeschwindigkeiô zõ 
erh|hen®   Siå   werdeî   geschalteô  durcè   daó   entsprechendå 
Funktionszeicheî   miô    vorangestellteí   ¤   innerhalâ   eineó 
Kommentars¬  z.B®  (*$L-*)®  Diå Kontrollfunktioneî L¬ O¬ Ã unä Ó 
sinä standardm{~iç auæ « eingestellt¬ diå Kontrollfunktioî É auf,  
die Kontrollfunktion P auf Bildschirm.
Kontrollfunktioî  L:“  Ií  Zustanä L«  wirä  beií  ]bersetzeî  deò 
Quelltexô miô deî Objektcode-Adresseî gelistet® Beé L- werdeî diå 
Zeilen nur dann gelistet, wenn in ihnen Fehler auftreten.

Kontrollfunktioî   O:“   Allå  Gleitkommaoperationeî   sowiå   diå 
Multiplikatioî  unä  Divisioî  beé Ganzzahleî  unterliegeî  eineò 
st{ndigeî ]berlaufkontrolle®  Beé O« werdeî aucè diå Additioî unä 
Subtraktion  von Ganzzahlen dieser Kontrolle unterzogen.

Kontrollfunktioî C:“ Deò Zustanä C« wirä w{hrenä deó Programmlaufó 
iî alleî Schleifen¬  Funktioneî unä Prozedureî  diå Tastatuò  auæ 
Dr}ckeî deò Stoptastå }berpr}ft¬ gegebenenfalló deò  Programmlauæ 
unterbrocheî  unä  auæ  einå  weiterå  Tastenbedienunç  gewartet® 
Nochmaligeó  Dr}ckeî deò Stoptastå f}hrô jetzô zuí  Abbruch¬  auæ 
jedå  anderå Tastå wirä daó Programí fortgestzt®  Beé C- wirä auæ 
die Tastaturkontrolle verzichtet.

Kontrollfunktioî   S:“  Siå  kontrollierô  diå   Ausdehnunç    deó 
Kellerspeichers (Stack). Bei S- unterbleibt diese Kontrolle.

Kontrollfunktioî I:“ Beé deò Relationsbildunç miô ¼ ¬  ¾ ¬ <½ ¬ >½ 
voî  Ganzzahleî  kanî eó zõ ]berlauæ  kommen¬  wenî  Unterschiedå 
gr|~eò  aló  MAXINÔ  auftreten®   Beé  I«  bleibeî  allå  solcheî 
Vergleichå  korrekt¬   beé  I- entf{llô  dieså  Kontrolle®   Einå 
entsprechendå Situatioî tritô beé Vergleicheî miô Realzahleî auf¬ 
wenî  deò Unterschieä gr|~eò aló 3.4E3¸ ist¬  siå kanî abeò nichô 
vermieden werden.

Kontrollfunktioî  P:“ Siå steuerô diå Ausgabå zuí Bildschirí  odeò 
zuí Drucker.  Daó Kommandï Ğ wirkô umschaltend¬  eó folgô nichô « 
oder -.

5.   Fehlermeldungen des Compilers
Verwendete Abk}rzungen: w.e. wird erwartet, n.e. nicht erlaubt
                        n.l. nicht lesbar,  f.   fehlt
                        zug. zugeh|rig,     n.v. nicht vergleichb

 1. Zahl zu gro~                  17. TO oder DOWNTO w.e.
 2. ; oder END fehlt              18. ( w.e.
 3. nicht deklarierter Name       19. Typ von Ausdruck unklar
 4. Name w.e.                     20. OF w.e.
 5. :=in Konstantendefinition     21. , w.e.
 6. =w.e.                         22. : w.e.
 7. Dieser Name hier n.e.         23. PROGRAM w.e.
 8. :=w.e.                        24. Variable als Parameter w.e.
 9. ) w.e.                        25. BEGIN w.e.
10. falscher Typ                  26. Var. als Param. v.READ w.e.
11. .w.e.                         27. Ausdr}cke dieses Typs n.v.
12. Faktor w.e.                   28. INTEGER oder REAL w.e.
13. Konstante w.e.                29. Dieser Variablentyp n.l.
14. Name ist keine Konstante      30. Name ist kein Typ
15. THEN w.e.                     31. Exponent in REAL-Zahl w.e.
16. DO w.e.                       32. Skalare Darstellung w.e.Š33. Null-String (CHR(0)) n.e.
34. w.e.
35. w.e.
36. Indextyp von ARRAY mu~ skalar sein
37. ..w.e.
38. In ARRAY-Dekl. w. oder  , e.
39. untere Gr|~e gr|~er als obere
40. SET ist zu gro~ (}ber 256 El)
41. Typname f}r Funktionswert w.e.
42. , oder in SET w.e.
43. .. oder , oder in SET w.e.
44. Parametertyp durch Typname w.e.
45. Leere Menge als erster Faktor n.e.
46. Skalar bzw. REAL wird erw.
47. Skalar w.e.
48. Die Mengen sind nicht vertr{gl.
49.  und f}r Mengenvergl. n.e.
50. FORWARD, LABEL, CONST, VAR, TYPE, BEGIN w.e.
51. Hexazahl w.e.
52. Cannot poke sets
53. ARRAY zu gro~
54. END oder ; in Record-Dekl. w.e.
55. ARRAY-Name w.e.
56. Variable nach WITH w.e.
57. Var. nach WITH vom RECORD-Type w.e.
58. Zum Feld-Selektor fehlt zug. WITH
59. Nach LABEL vorzeichenlose ganze Zahl w.e.
60. Nach GOTO vorz.lose ganze Zahl
61. Marke von falschem Niveau
62. nicht deklarierte Marke
63. Par. v. SIZE mu~ Variable sein
64.
65.
66.
67. Druckformat f}r INT fehlerh.
68. Strings d}rfen kein EOLN enth.
69. Par. v. NEW, MARK, RELEASE mu~ vom Pointertyp sein
70. Par. v. ADDR mu~ Variable sein


                   XXXXXXXXXXXXXXXXXXXXXXXXX


Juli 1986
Dipl.-Math. Manfred Lehmann und Dr. Klaus Vetters

Postanschrift:         Dr. Klaus Vetters
                       Gartenheimallee 2
 
                       Dresden

                       8 0 2 1
