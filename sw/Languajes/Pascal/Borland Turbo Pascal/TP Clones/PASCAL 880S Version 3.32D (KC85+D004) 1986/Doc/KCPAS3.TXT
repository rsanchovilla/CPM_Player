.po10
.pl68
.pn30
.heKC PASCAL                    #                Sprachbeschreibung
.op  
 
Folgende Anweisungen sind m|glich:

a)  Wertzuweisung

Mitteló  deò  Wertzuweisunç wirä eineò Variableî deò  Werô  eineó 
Ausdruckó zugewiesen® Diå Wertzuweisunç wirä nuò ausgef}hrt¬ wenî 
deò   Tyğ   deò  Variableî  unä  deó  Ausdruckó  identiscè   odeò 
typvertr{glich ist.

Variablentyp    INTEGER   REAL   CHAR   BOOLEAN

INTEGER            +       -      -        -
REAL               +       +      -        -
CHAR               -       -      +        -
BOOLEAN            -       -      -        +

'+' bedeutet, da~ die Zuweisung erlaubt ist.


b)  Prozeduranweisung

Prozedureî  sinä  entwedeò  ií  Deklarationsteiì  definierô  odeò 
steheî aló vordefiniertå Standardbezeichneò zuò Verf}gunç  (siehå 
4.6.)®   Diå   Verwendunç   dieseò  Prozedurbezeichneò  miô   deò 
geforderten Parameterliste















Bild 16: Parameterliste

nennô maî einå Prozeduranweisung®  Prozedureî unä Funktioneî sinä 
aló Parameteò nichô zugelassen®  Prozedureî unä Funktioneî k|nneî 
iî Anweisungeî verwendeô werden¬ bevoò siå deklarierô wurden® Daó 
ist durch das Wortsymbol FORWARD m|glich, z.B

PROCEDURE Zeichne(z1,z2,z3,z4:REAL);FORWARD;
PROCEDURE Auswertung(a,b:boolean);
VAR x,y:integer;
BEGIN            
 .
 .
READ(x,y);
Zeichne(a,b,x,y);
 .Š .
END;
PROCEDURE Zeichne;
BEGIN
 .
 .
END;


c)  Verbundanweisung

Einå  Verbundanweisunç  bestehô auó eineò beliebigeî  Anzahì  voî 
Einzelanweisungen¬  diå  }beò  diå Wortsymbolå BEGIÎ unä  ENÄ  zõ 
eineí  Blocë  zusammengefa~ô  werdeî  unä  syntaktiscè  aló  einå 
Anweisunç   fungieren®   Daó  Semikoloî  dienô  aló  Trennzeicheî 
zwischeî  deî  Einzelanweisungen»   nacè  deò  letzteî  Anweisunç 
brauchô keiî Semikoloî mehò zõ stehen.

Verbundanweisungeî werdeî iî bedingten¬  iî Zyklenanweisungeî unä 
iî Prozedur- sowiå Funktionendeklarationeî ben|tigt.


d©  Bedingtå Anweisung

Eó  gibô  zweé Formeî deò bedingteî Anweisung¬  diå  IF- unä  diå 
CASE-Anweisung.
Diå  Anweisungeî k|nneî wiederuí  Verbundanweisungeî  sein®  Einå 
leerå  CASE-Anweisunç  isô nichô gestattet®  Einå  CASE-Anweisunç 
kanî  entwedeò miô eineí ELSE-Zweiç (wirä  ausgef}hrt¬  wenî  diå 
Auswahlbedingunç  miô  keineò CASE-Markå }bereinstimmt© odeò  miô 
ENÄ abgeschlosseî werden.


e)  Anfangsgepr}fte Schleifenanweisung (WHILE...DO...)

Diå  Anweisunç wirä solangå ausgef}hrt¬  wiå diå  Berechnunç  deó 
Ausdruckó  deî Werô TRUÅ liefert®  Isô deò Werô deó Ausdruckó voò 
deí ersteî Schleifendurchlauæ bereitó FALSE¬  wirä diå  Anweisunç 
keiî einzigeó Maì ausgef}hrt.


f)  Endgepr}fte Schleifenanweisung (REPEAT...UNTIL...)

Diå  Anweisunç  wirä mindestenó einmaì durchlaufen®  Aí Endå  deò 
Schleifå  wirä  deò Ausdrucë gepr}fô unä ergibô beé  FALSÅ  eineî 
erneuteî Schleifendurchlauf¬ bió deò Ausdrucë TRUÅ wird.


g) Z{hlanweisung (FOR...TO/DOWNTO...DO...)

Diå  Steueranweisunç  daræ nuò einå unstrukturiertå Variablå  unä 
keiî  Parameteò  sein®  Siå wirä uí  +±  bzw®  -±  weitergez{hlt® 
Anfangs- unä Endwerô symbolisiereî Ausdr}cke¬ dereî Wertå miô deí 
Tyğ  deò Steuervariablå vertr{glicè seiî m}ssen®  Isô deò Endwerô 
voî  vornhereiî }berschritteî bzw®  unterschritten¬  sï wirä  diå 
Anweisung nicht ausgef}hrt.
Šh)  WITH-Anweisung

Innerhalâ deò WITH-Anweisunç k|nneî diå  Recordkomponentenvariab
len¬  diå durcè diå WITH-Variablå spezifizierô sind¬ alleiî durcè 
deî Recordkomponentenbezeichneò angegebeî werden¬  d.h®  ohnå diå 
Angabå deò Recordvariableî voranzustellen.(siehe 4.3.4.2.)


i)  Sprunganweisung

]beò  diå GOTO-Anweisunç isô deò Sprunç zõ eineò  Markå  m|glich¬ 
diå  sicè ií selbeî Blocë unä iî deò selbeî Ebenå  befindet®  Diå 
Markå  isô  einå INTEGER-Zahì unä wirä durcè Doppelpunkô voî  deò 
folgendeî Anweisunç getrennt®  Markeî m}sseî durcè daó Wortsymboì 
LABEÌ  iî  deí  Block¬   iî  deí  siå  verwendeô  werdeî  sollen¬ 
deklarierô sein.


4.6. Standardprozeduren und -funktionen

4.6.1. Prozeduren und Funktionen zur Ein- und Ausgabe
-----------------------------------------------------

WRITE

Diå  Prozeduò WRITÅ wirä verwendet¬  uí Dateî auæ deí  Bildschirí 
odeò Druckeò auszugeben.
Wenî  deò auszugebendå Ausdrucë voí CHARACTER-Tyğ ist¬  danî gibô 
WRITÅ  (e© deî 8-bit-Wert¬  deò durcè deî Werô deó  Ausdruckeó  å 
dargestellô wird¬ aí Bildschirí odeò Druckeò aus.

Beachteº  CHÒ  (n©   ergibô daó Steuerzeicheî  n;  diå  m|glicheî          
          Steuerzeicheî sinä ií BASIC- Handbucè zõ ersehen.

Allgemeiî gilt:

WRITÅ (P1¬ P2¬ ..® Pn)» entspricht:
BEGIÎ WRITE(P1);WRITE(P2);......;WRITE(Pn© END;
      Diå Parameteò P1,P2,...Pî k|nneî einå deò folgendeî 
      Formeî haben:

      (e© odeò (e:m© odeò (e:m:n© odeò (e:m:H)

wobeé f}ò e¬  m¬ î Zahleî einzusetzeî sinä unä È deò unmittelbarå 
Buchstabå ist.

µ F{llå sinä zõ betrachten:

a© å isô voî INTEGER-Tyğ unä (e© odeò (e:m© wirä benutzt:

Deò  Werô  voî å wirä iî eineî Zeichenstrinç  miô  abschlie~endeí 
Leerzeicheî  umgewandelt®  Einå Verl{ngerunç deó Stringó  mitteló 
f}hrendeò  Leerzeicheî  kanî  durcè Angabå  voî  m¬  welcheó  diå 
Gesamtl{ngå  deó Stringó angibt¬  erreichô werden®  Wenî í  nichô 
ausreichenä ist¬ uí å auszugebeî odeò í nichô vorhandeî ist¬ danî 
wirä å vollst{ndiç miô abschlie~endeí Leerzeicheî ausgegebeî  unä 
í  wirä ignoriert®  Wenî diå durcè í festgelegtå L{ngå deò  L{ngå Švoî  å ohnå nachfolgendeî Leerzeicheî entspricht¬  wirä keiî  ab
schlie~endeó Leerzeicheî ausgegeben.
     
b© å isô voí INTEGER-Tyğ unä (e:m:H© wirä benutzt:

Iî  dieseí Falì erfolgô diå Ausgabå hexadezimal®  Falló m=±  odeò 
m=²  ist¬  wirä  deò  Werô (å MOÄ 16  © ausgegeben¬  d.h®  diå  í 
h|chstwertigeî  Hex-Zifferî  ausgegeben®  Wenî  m>´  ist¬  werdeî 
f}hrendå   Leerzeicheî  hinzugef}hrt®   F}hrendå  Nulleî   werdeî 
angef}gt¬ wï eó notwendiç ist.

Beispiel:      WRITÅ (2049:m:H);
    
               m=± ergibtº 1
               m=² ergibtº 01
               m=³ ergibtº 0801
               m=´ ergibtº 0801
               m=µ ergibtº  0801

c© å isô voí REAL-Tyğ unä (e)¬ (e:m© odeò (e:m:n© wirä benutzt

Deò Werô voî å wirä iî eineî Zeichenstring¬  deò einå reellå Zahì 
darstellt¬  umgewandelt®  Daó Formaô deò Darstellunç wirä durcè î 
festgelegt® 
Falló î nichô vorhandeî ist¬ wirä diå Zahì iî deò Exponentialforí 
(miô  Mantisså unä Exponent© ausgegeben®  Wenî diå  Zahì  negatiö 
ist¬  wirä  eiî Minuszeicheî voò deò Mantisse¬  anderenfalló  eiî 
Leerzeicheî ausgegeben®  Diå Zahì wirä immeò miô mindestenó eineò 
Nachkommastellå  unä  miô maximaì µ Nachkommastelleî  ausgegeben® 
Deò Exponenô wirä immeò miô Vorzeicheî notiert.

Darauó  folgt¬  daş  diå minimalå L{ngå  deò  exponentiellen Dar
stellunç ¸ Zeicheî betr{gt® Wenî í   ¸ ist¬ wirä diå vollst{ndigå 
Darstellunç  voî  1²  Zeicheî genommen®  Wenî ¸  ½ í  ½  1²  ist¬ 
werdeî mehò odeò wenigeò Dezimalstelleî ausgegeben®  Isô í ¾  12¬  
werdeî f}hrendå Leerzeicheî angef}gô :

Beispiel:      WRITE(-4.75Å+19:m);
               m=·            ergibtº -4.75000E+19
               m=¸            ergibtº -4.7E+19
               m=1°           ergibtº -4.750E+19
               m=1²           ergibtº -4.75000E+19
               m=1³           ergibtº  -4.75000E+19

Wirä  diå  Forí (e:m:n© benutzt,sï wirä diå Zahì å iî  Festkomma
darstellunç   ausgegeben¬  wobeé î diå Zahì deò  Nachkommastelleî 
angibt®  Solangå diå L{ngå í nichô ausreichenä groş  ist¬  werdeî 
keinå  f}hrendeî Leerzeicheî ausgegeben®  Wenî n=° ist¬  isô  diå 
Ausgabå  einå  ganzå  Zahl®  Falló  å zõ  groş  ist¬  uí  iî  deí 
angegebeneî  Felä dargestellô zõ werden¬  erfolgô diå Ausgabå  ií 
exponentiellen Formaô (siehå oben).

Beispiel:      WRITE(2E2:6:2©    ergibtº 200.00
               WRITE(2E2:8:2©    ergibtº   200.0°   
               WRITE(77.888:6:1© ergibtº   77.9
               WRITE(77.8888:2©  ergibtº  7.78888E+01
               WRITE(77.888:4:0© ergibtº   78Šd© å isô voí CHARACTER- odeò STRING-Typ:

Sowohì  (e© aló aucè (e:m© k|nneî verwendeô werden®  Daó  Zeicheî 
odeò  deò  Strinç  werdeî miô eineò minimaleî L{ngå  voî  ±  (beé 
Zeichen©  odeò deò L{ngå deò Stringó (beé STRING-Typen©  ausgege
ben®  F}hrendå  Leerzeicheî werdeî angef}gt¬  wenî í  ausreichenä 
groş  ist.

z.B.
10 PROGRAM StringEinAusgabe;
20 VAR string:ARRAY^1..10_ OF char;
30          a:integer;
40 BEGIN
50 write(chr(12),'Geben Sie bitte einen String von max. 10 
   Zeichen ein! ');
60 readln; (*Uebergehen der eoln-Marke*)
70 read(string);
80 FOR a:=1 to 13 do writeln(string:a)  end.
   
e© å isô voî BOOLEAN-Typ:

(e©  unä  (e:m©  k|nneî verwendeô werden®  'TRUE§  odeò   'FALSE§ 
werdeî  iî Abh{ngigkeiô voí boolscheî Werô  å  ausgegeben¬  wobeé 
einå minimalå L{ngå voî ´ bzw® µ verwendeô wird.


WRITELN  

Ausgabeî  mitteló  WRITELÎ  schlie~eî  miô  Zeilenvorschub/Wagen
r}cklauæ ab¬ d.h® miô eineí WRITÅ (CHR(10),CHR(13)).

         WRITELN(P1,P2......,P3)» entspricht
         BEGIÎ  WRITÅ(P1¬P2,...,P3);WRITELÎ END;


PAGÅ 

Diå  Prozeduò PAGÅ entsprichô eineí WRITÅ (CHR(12))»  unä bewirkô 
eiî L|scheî deó Bildschirmes.


READ

Diå Prozeduò REAÄ liesô Dateî voî deò Tastatur® Dieó erfolgô }beò 
eineî  Puffer¬  deò  sicè iî deî Runtimeó  befindet®  Dieseò  isô 
anfangó leeò (bió auæ einå Zeilenende-Markierung)®  Maî kanî sicè 
deî Zugrifæ auæ dieseî Puffeò sï vorstellen¬  daş eiî Textfensteò 
}beò  deî Puffeò gelegô wird¬  durcè welcheó jeweiló eiî  Zeicheî 
sichtbaò  ist®  Wenî  dieseó Textfensteò }beò  eineò  Zeilenende-
Markierunç  liegt¬  wirä voò deí Abschluş deò READ-Operatioî einå 
neuå Textzeilå voî deò Tastatuò iî deî Puffeò gelesen® 
 
          REAÄ (V1¬ ....,Vn)» entspricht:
          BEGIÎ REAÄ (V1)» READ(V2);.....;REAÄ(Vn© END;
 
wobeé V1¬  V2¬  usw® voí Tyğ CHARACTER¬ STRING¬ INTEGEÒ odeò REAÌ 
seiî  m}ssen®  W{hrenä deò Eingabå k|nneî diå Steuertasteî (siehå ŠAbschnitô 2.1.© benutzô werden.

´ F{llå sinä zõ betrachten:

a© Ö isô voí CHARACTER-Typ

Iî  dieseí Falì liesô REAÄ (V© nuò eiî Zeicheî auó  deí  Eingabe
puffeò unä weisô eó Ö zu® Wenî daó Textfensteò }beò eineò Zeilen
markierunç  (CHÒ (13)© liegt¬  lieferô diå Funktioî EOLÎ deî Werô 
TRUÅ unä einå neuå Textzeilå wirä voî deò Tastatuò  gelesen®       
Achtung !:
Nacè deí Starô deó Programmó isô EOLN=TRUE¬ d.h® falló zuersô eiî 
REAÄ eineó CHARACTER-Tyğ erfolgt¬  wirä eiî CHR(13© }bergebeî unä 
daraufhiî  einå  neuå  Zeilå  voî  deò  Tastatuò   gelesen®   Eiî 
anschlie~endeó  REAÄ eineó CHARACTERó }bergibô daó erstå  Zeicheî 
dieseò Zeile¬ vorausgesetzt¬ siå isô nichô leer®(Siehå aucè unteò 
READLN)

b© Ö isô voí STRING-Typ

Wirä  eiî Strinç mitteló REAÄ gelesen¬  werdeî sï  vielå  Zeicheî 
eingelesen¬  wiå  beé  deò Stringdefinitioî aló  L{ngå  angegebeî 
wurden¬  bzw® so vielå bió EOLN=TRUÅ ist®  Falló deò Strinç durcè 
REAÄ nichô gef}llô wirä (d.h®  falló daó Zeilenendå erreichô ist¬ 
bevoò daó Stringendå erreichô ist)¬ wirä deò Resô deó Stringó miô 
CHR(0©  aufgef}llt®   Daó erm|glichô deí Programmiereò diå  L{ngå 
deó eingeleseneî Stringó zõ ermittelî (siehå vorherigeó Beispiel). 
Diå unteò a© gemachtå "Achtunç !"- Bemerkunç gilô aucè hier.

c© Ö isô voí INTEGER-Tyğ 

Iî  dieseí Falì wirä einå Reihå voî Zeicheî eingelesen¬  diå einå 
INTEGER-Zahì  darstellen®  Allå  vorausgehendeî  Leerzeicheî  unä 
Zeilenende-Markierungeî  werdeî  }bergangen®  (Daó  bedeuteô  daó 
INTEGER-Zahleî direkô eingeleseî werdeî k|nnen)® 
Wenî diå eingelesenå Zahì gr|~eò aló MAXINÔ (32767© ist¬ wirä deò 
Runtime-Fehleò  "Numbeò  toï large¢ ausgegebeî unä  daó  Programí 
gestoppt.
Wenî  daó  erstå  eingelesenå Zeicheî  (nachdeí  Leerzeicheî  unä 
Zeilenende-Markierunç  }bersprungeî  wurden©  keinå  Ziffeò  odeò 
Vorzeicheî ist¬  wirä deò Fehleò "Numbeò expected¢ angezeigô  unä 
daó Programí abgebrochen® 

d© Ö isô voí REAL-Typ

Hierbeé  wirä  einå Zeichenfolgå eingelesen¬  diå einå  REAL-Zahì 
darstellt® Allå f}hrendeî Leerzeicheî unä Zeilenende-Markierungeî 
werdeî  }bergangen¬  unä wiå beé c© muş daó erstå anderå  Zeicheî 
einå Ziffeò odeò Vorzeicheî sein®  Wenî diå Zahì zõ groş odeò  zõ 
kleiî ist¬  wirä deò Fehleò "Overflow"  angezeigt¬  wenî 'E§ ohnå 
nachfolgendeó  Vorzeicheî  odeò  Ziffeò  eingeleseî  wird¬  tritô 
Fehleò  "Exponenô  expected" auæ unä wenî eiî  Dezimalpunkô  ohnå 
nachfolgendå  Ziffeò geleseî wird¬  kommô eó zuí  Fehleò  "Numbeò 
expected"® 
Diå Zahleneingabå kanî mitteló deò boolscheî Variableî ERRFLÇ unä 
ERRCHË   programmtechniscè  }berwachô  werdeî  (siehå   Abschnitô 
4.3.3.)ŠREADLN

         READLÎ(V1¬V2,....¬Vn)» entspricht:
         BEGIÎ REAÄ(V1,V2,....¬Vn)» READLÎ END;

READLÎ liesô eineî neueî Pufferinhalô voî deò Tastatur® 
Nacè  deò Ausf}hrunç voî READLÎ wirä EOLÎ ½ FALSE¬  eó seé  denn¬ 
diå n{chstå Textzeilå isô leer.
READLÎ  kanî verwendeô werden¬  uí diå zõ Beginî deò Programmaus
f}hrunç vorhandenå leerå Zeilå zõ }berspringen¬  d.h® eó wirä eiî 
neueò Puffeò gelesen® Dieså Ma~nahmå isô n}tzlich¬ wenî zõ Beginî 
eineó Programmó eiî CHARACTEÒ eingeleseî werdeî soll¬  abeò nichô 
notwendig¬  wenî  Zahleî (dá Zeilenende-Markierungeî }bersprungeî 
werden©  odeò  Zeicheî  voî  sp{tereî  Zeileî  eingeleseî  werdeî 
sollen.

z.B.
10 PROGRAM readchar;
20 VAR ch:char;
30 BEGIN
40  REPEAT
50   WRITELN; WRITE('Geben Sie einige Zeichen ein! ');
60   READLN;
70   WHILE NOT EOLN DO
80   BEGIN
90   READ(ch);
10°   WRITELN('Daó   "',ch,'"entsprechendå  ASCII-Zeicheî   isô 
      ',ORD(ch));
110  END 
120 UNTIL ch='z'
130 END.

              
EOLN

Dieså  Standardfunktioî haô deî Werô TRUE¬  wenî aló n{chsteó  zõ 
verarbeitendeó  Zeicheî daó eoln-Zeicheî (CHR(13)© erkannô wurde¬ 
sonsô haô diå Funktioî deî Werô FALSE.


INCH

Diå Funktioî INCÈ fragô diå Tastatuò ab¬  oâ einå Tastå  gedr}ckô 
wurde®  Isô dieó deò Fall¬  lieferô diå Funktioî daó dieseò Tastå 
zugeh|rigå Zeichen¬  ansonsteî CHR(0)® Dieså Funktioî isô g}nstig 
mit deò Compiler-Direktivå C- einsetzbar.               
z.B.
10 PROGRAM inch;
20 VAR c:char;a:integer;
30 BEGIN (*$c-*)
40 REPEAT
50  a:=random(0);c:=inch;
60  IF c='z' THEN BEGIN
70   writeln('Taste ^z_ wurde ausgelesen !');halt  end 
80 UNTIL a>32766; 
90 write('zu spaet!!!')      
100 end.Š4.6.2. Arithmetische Funktionen
-------------------------------

Arithmetischå  Funktioneî sinä nuò f}ò INTEGEÒ  odeò  REAL-Zahleî 
(im folgenden mit x bezeichnet) erlaubt.

ABS(x©     lieferô deî  Absolutwerô voî x®  Daó Ergebnió isô  voí 
           gleichen Typ wie x.

           z.B. ABS(-6.93) = 6.93

SQR(x©     lieferô  daó Quadraô deò Zahì x®  Daó Ergebnió isô voí 
           gleichen Typ wie x.

           z.B. SQR(5.5) = 30.25

SQRT(x©    lieferô diå Quadratwurzeì voî deò Zahì x® Daó Ergebnió 
           ist immer vom Typ REAL.

           z.B. SQRT(100) = 1.00000E+01

FRAC(x©    lieferô diå Differenú voí Werô ø zuò n{chsô  gelegeneî 
           INTEGER-Zahì kleineò odeò gleicè x®   Daó Ergebnió isô 
           voí Tyğ REAL®  

           z.B. FRAC(2.9) = 0.9
                FRAC(-2.6) = 0.4
                FRAC(-2.4) = 0.6

ENTIER(x©  lieferô f}r deî Werô ø diå gr|~tå INTEGER-Zahì kleineò 
           oder gleich x. Das Ergebnis ist vom Typ INTEGER.

           z.B. ENTIER(2.9) = 2
                ENTIER(-2.6) = -3
                ENTIER(-2.4) = -3

           FRAÃ   unä  ENTIEÒ  dieneî  deí  Erstelleî   schnelleò 
           mathematischer Routinen.
SIN(x©     lieferô deî Sinuó voî ø aló REAL-Zahl®  Diå Variablå ø 
           ist in Bogenma~ anzugeben.

           z.B. SIN(3.14/2) = 1.00000E+00

COS(x©     lieferô deî Cosinuó voî ø aló REAL-Zahl®  Diå Variablå 
           x ist in Bogenma~ anzugeben.

           z.B. cos(3.14/3) = 5.00461E-01

TAN(x©     lieferô deî Tangenó voî ø aló REAL-Zahl®  Diå Variablå 
           x ist in Bogenma~ anzugeben.

           z.B. TAN(3.14/4) = 9.99201E-01

ARCTAN(x©  lieferô deî Winkeì ií Bogenma~¬  desseî Tangenó gleicè 
           x ist. Das Ergebnis ist vom Typ REAL.

           z.B. ARCTAN(9.99201E-01) = 7.84998E-01ŠEXP(x©     lieferô  diå  Exponentialfunktioî å hocè ø aló  reellå 
           Zahl. (e = 2.71828)

           z.B. EXP(2.5) = 1.21825E+01
                  
LN(x)      lieferô  deî nat}rlicheî Logarithmuó (zuò Basió e© voî            
           ø aló reellå Zahl;diå Variablå ø muş gr|~eò Nulì sein.

           z.B. LN(1.21825E+01) = 2.50000E+00


4.6.3. Skalarfunktionen
-----------------------

PRED(C©    lieferô  deî   Vorg{ngeò  voî  C®  Ã  kanî  voî  jedeí 
           einfachen Typ (au~er REAL) sein.

           z.B. PRED('b') = 'a'

SUCC(C©    lieferô  deî   Nachfolgeò  voî C®  Ã  kanî  voî  jedeí 
           einfachen Typ (au~er REAL) sein.

           z.B. SUCC('a') = 'b'

ODD(y©     lieferô  deî  Werô TRUÅ  f}ò  ungeradzahligå  INTEGER-
           Zahlen; gerade Zahlen ergeben FALSE.

           z.B. ODD(23) = 'TRUE'


4.6.4. Konvertierungsfunktionen
-------------------------------

ROUND(x©   rundeô  auæ  diå n{chstgelegenå INTEGER-Zahì  entspre
           chend den Rundungsregeln.

           z.B. ROUND(-6.5) = -6

TRUNC(x©   lieferô  deî ganzzahligeî Teiì (INTEGER©  deò  reelleî 
           Zahì  x®   Eó  werdeî  alsï  diå  Stelleî  hinteò  deí 
           Dezimalpunkt abgeschnitten.

           z.B. TRUNC(-7.9) = -7

CHR(y©     lieferô  daó  deí Werô voî ù  (INTEGER©  entsprechendå 
           ASCII-Zeichen.

           z.B. CHR(78) = 'N'

ORD(C©     lieferô diå Ordnungsnummeò (INTEGER© deó Werteó voî x¬ 
           innerhalâ  deò  definierteî Wertemenge¬  wobeé  ø  voî 
           jedem einfachen Typ (au~er REAL) sein kann.
  
           z.B. ORD('n') = 110
                ORD(-131) = -131
                TYPE farbe=(rot,gruen,blau);
                ORD(gruen) = 1Š4.6.5. Weitere Funktionen und Prozeduren
----------------------------------------

NEW(V)

Miô deò Prozeduò NE× isô eó m|glich¬ Speicherplatú f}ò dynamischå 
Variableî zõ reservieren®  Ö isô einå Zeigervariable¬ unä nachdeí 
NEW(V©  ausgef}hrô wurde¬  enth{lô Ö diå Adresså deò neõ zugewie
seneî  dynamischeî Variablen®  Zuò Erstellunç verketteteò  Listeî 
wirä  Ö  selbst¬  meisô aló  Bestandteiì  eineò  Recordvariablen¬ 
abgespeichert®  Diå  Gr|~å deó zõ reservierendeî  Speicherplatzeó 
h{ngô voí Tyğ voî Ö ab» deò Tyğ selbsô kanî beliebiç seiî unä isô 
identisch mit dem der dynamischen Variablen.
Der Zugriff auf die dynamische Variable erfolgt }ber V  .
Deò  erneutå Aufruæ voî NEW(V© f}hrô zõ neueò Speicherplatzreser
vierung. (siehe Abschnitt 4.3.3.)


MARK(V1)

Iî KC PASCAÌ isô diå Freigabemethodå nacè Bowleó  implementiert® 
Dabeé  wirä }beò MARK(V1© deò aktuellå Stanä deò Halde¬  auæ  deò 
diå dynamischeî Variableî abgelegô werden¬ auæ diå Zeigervariablå 
V1 gespeichert.
Deò Tyğ deò Variablen¬  auæ diå V± zeigt¬ isô gleichg}ltig¬ dá V± 
nur mit MARK und RELEASE, niemals mit NEW verwendet werden darf.


RELEASE(V1)

RELEASE(V1©  isô  nuò  nacè  MARK(V1©  zõ  verwenden¬  wobeé  diå 
Zeigervariablå  V±  zwischendurcè nichô manipulierô werdeî  darf® 
]beò deî Aufruæ voî RELEASE(V1© wirä s{mtlicheò Speicherplatú  aâ 
deò  Adresse¬  auæ  diå V± weist¬  bió zuí Endå deó Bereichó  deò 
dynamischeî  Variableî  gel|schô  unä kanî nuî  }beò  NEW(V©  neõ 
verwendeô werden® RELEASE(V1© stellô alsï wiedeò deî Zustanä her¬ 
deò  zuí  Zeitpunkô deó vorhergehendeî  Prozeduraufrufó  MARK(V1© 
existierte.
Ein Beispiel dazu ist im Abschnitt 4.3.3. zu finden.


INLINE(z1,z2,...)

Miô dieseò Prozeduò kanî Z80-Maschinencodå direkô iî daó  PASCAL-
Programí eingebundeî werden® Deò Operationscodå wirä dezimaì odeò 
hexadezimaì  (#©  aló Parameteò deò INLINE-Anweisunç  }bernommen® 
Diå  Anzahì deò Parameteò isô beliebig®  Siå werdeî  w{hrenä  deó 
]bersetzenó  aî  deò  Stelle¬  aî deò sicè  deò  Compileò  geradå 
befindet, in das Objekt-Programm eingef}gt.
Miô deí Einbaõ direkteò Maschinenbefehlå kanî daó Laufzeitverhal
teî  voî  PASCAL-Programmeî verbessert¬  sowiå speziellå  Abl{ufå 
programmiert werden.

.paŠUSER(V)

Diå Prozeduò bewirkô deî Aufruæ eineó Maschinenunterprogrammeó aî 
deò  durcè Ö spezifizierteî Adresså (INTEGER-Wert)®  Dá  INTEGER-
Zahleî   iî  Zweierkomplement-Forí  bearbeiteô   werden¬   m}sseî 
Adressen¬  diå gr|~eò aló #7FFÆ (32767© sind¬ aló negativå Zahleî 
eingegebeî werden®  G}nstigeò isô es¬  diå Speicheradresså gleicè 
aló hexadezimalå Zahì einzugeben.

z.B. USER(#C000) = USER(-16384)

Diå  aufgerufenå  Routinå muş miô deí Z80-Befehì REÔ (#C9©  endeî 
unä  daræ deî Werô ií IX-Registeò nichô }berschreiben®  Diå  dazõ 
notwendigeî Registeò A¬  B¬  C¬  D¬  E¬ H¬ Ì unä Æ werdeî voò deò 
Abarbeitunç  deó Unterprogrammó miô deî vordefinierteî  Variableî 
RA¬  RB¬ RC¬ RD¬ RE¬ RH¬ RÌ unä RÆ (odeò aucè RAF¬ RBC¬ RDE¬ RHL© 
belegô   unä   nacè   REÔ   iî   diå   vordefiniertå    Variableî 
zur}ckgeschrieben.
Diå  voí Betriebssysteí angeboteneî Maschinenunterprogrammå  sinä 
dem Systemhandbuch zu entnehmen.


HALT

Dieså Prozeduò stoppô diå Programmausf}hrunç unä gibô diå Meldunç 
"Halô  aô PC=xxxx"¬  wobeé xxxø diå hexadezimalå  Speicheradresså 
ist¬  aî  deò  deò Abbrucè erfolgte®  HALÔ kanî zusammeî miô  deí 
Compiler-Listinç  zuò  Fehlersuchå verwendeô  werdeî  (z.B®  beií 
Testen, welche Schleifen durchlaufen werden).


PEEK(X.T)

Ø  isô eiî INTEGER-Werô unä stellô diå Speicheradresså  dar¬  voî 
der Daten beliebigen Typs (T) gelesen werden k|nnen.
Diå  Datenoperationeî erfolgeî beé PEEKó unä POKEó iî  KÃ  PASCAÌ 
typischeò Datendarstellunç (siehå Abschnitô 4)® 

z.B. Im Speicher steht ab der Adresse #6000 die HEX-Bytes
     4B 43 20 50 41 53 43 41 4C

WRITE(PEEK(#6000,ARRAY^1...9_ OF CHAR));      ergibt 'KC PASCAL'
WRITE(PEEK(#6000,CHAR));                      ergibt 'K'    
WRITE(PEEK(#6000,INTEGER));                   ergibt 17227
WRITE(PEEK(#6000,REAL));                      ergibt 1.84758E+20


POKE(X,V)

POKÅ  schreibô  deî  Ausdrucë  Ö aâ Adresså  Ø  aufw{rtó  iî  deî 
Speicher®  Ø isô voí INTEGER-Tyğ unä Ö kanî voî jedeí Tyğ  (au~eò 
SET) sein.

z.B. POKE(#6000,'KC PASCAL');     POKE(-16384,2.1E-1);

.paŠADDR(V)

Ö isô eiî Variablennamå beliebigeî Typs® Diå Funktioî lieferô diå 
Speicheradresse¬  aâ  deò diå Variablå Ö ií Speicheò  steht¬  aló 
INTEGER-Zahl.


SIZE(V)
]beò  diå  Funktioî  SIZE(V©  kanî  deò  Speicherplatzbedaræ  deò 
Variableî Ö ermittelô werden.


TOUT(NAME,START,SIZE)

Miô  TOUÔ werdeî Variableî auæ eineî externeî Speicheò  abgelegt® 
Deò Dateinamå (NAME© isô voí Tyğ ARRAY^1...12_… OÆ CHAR®  Fehlendå 
Zeicheî  ií  Dateinameî sinä miô Leerzeicheî  aufzuf}llen®  STARÔ 
symbolisierô diå Startadresse¬  aâ deò diå Variablå abgespeicherô 
wirä unä SIZÅ diå Anzahì deò auszugebendeî Bytes®  STARÔ unä SIZÅ 
sinä voí INTEGER-Typ.
Solì  einå  Dateé auæ Diskettå abgespeicherô werden¬  sï  isô  ií 
Dateinamen an 9.Stelle der Punkt vorzusehen.
]beò  diå freiå Wahì deò Startadresså unä deò Gr|~å deó Speicher
bereiches¬   deò  auszulagerî  ist¬  haô  deò  Programmiereò  diå 
M|glichkeit¬  ganzå Bildschirmbereiche¬ globalå Variableî usw® iî 
einer Datei zu sichern.


TIN(NAME,START)

Miô  dieseò Prozeduò k|nneî durcè TOUÔ gesichertå Variableî  etc® 
wiedeò voí externeî Speicherger{ô geladeî werden®  Deò  Parameteò 
NAMÅ  isô wiederuí voí Tyğ ARRAY^1...12_ OÆ CHAR®  Daó  Speicher
ger{ô  wirä  nacè  eineò Dateé miô dieseí Nameî  durchsuchô  und¬ 
falló gefunden¬  iî deî Speicheò aâ Adresså STARÔ  (INTEGER-Zahl© 
geladen®  Diå  Anzahì  deò zõ ladendeî Byteó isô durcè  TOUÔ  miô 
abgespeicherô wordeî unä wirä voî dorô }bernommen® 

Beispielº  Einå  Dateé  miô 1° Zeicheî solì  ersô  auæ  Kassette¯ 
Diskettå  ausgelagerô unä diå Variablå á miô eineò andereî  Dateé 
}berschriebeî werden.’ 

10 PROGRAM EinAusgabe;
20 VAR a:ARRAY^1..10_ OF char;
30 BEGIN
40 writeln('Geben Sie max. 10 Zeichen ein !');
50 readln;read(a); writeln('a alt= ',a);
60 tout('zeichenk.alt',addr(a),size(a);
70 tin('zeichenk.neu',addr(a));
80 writeln('a neu=',a) 
90 end.

.paŠINP(P)

]beò  diå  Funktioî INĞ kanî maî direkô  auæ  deî  Z80-Input-Porô 
zugreifen, ohne die Inline-Prozedur zu benutzen.
Deò  INTEGER-Werô  Ğ wirä iî daó BC-Registerpaaò geladeî unä  deò 
Assembler-Befehì  IÎ A,(C© ausgef}hrt®  Daó Ergebnió isô voí  Tyğ 
CHAR.


OUT(P,C)

]beò  diå  Prozeduò OUÔ kanî maî direkô auæ  deî  Z80-Output-Porô 
zugreifen, ohne die Inline-Prozedur zu benutzen. 
Deò INTEGER-Werô Ğ wirä iî daó BC-Registerpaaò unä deò CHARACTER-
Werô Ã iî daó A-Registeò geladen»  danî wirä deò Assembler-Befehì 
OUT(C),A ausgef}hrt.

z.B. OUT(1,'Z');

gibt das Zeichen 'Z' an den Z80-Port 1 aus.


EXTERNAL(S1,V1,V2,...)

Diå  Prozeduò  EXTERNAÌ erm|glichô deî Aufruæ voî  externeî  ROM- 
oder von nachladbaren RSX-Befehlen. 
Damiô wirä deò Wortschatú voî KC PASCAÌ  erheblich¬  vornehmlicè 
f}ò diå Arbeiô miô Diskettensystem¬ erweitert.
Diå  EXTERNAL-Prozeduò  {hnelô  deí  Kommandï '  § ¬  daó voî deò 
Kommandoebenå zõ erreicheî ist¬  sowiå deí BASIC-Befehì '  § (diå 
einzelneî Befehlå k|nneî deí BASIC-Handbucè entnommeî werden).
S±  isô  voí  Tyğ STRINÇ unä bezeichneô deî  Nameî  deó  externeî 
Befehls®  Diå weitereî Parameteò k|nneî voí Tyğ STRING¬ CHAÒ odeò 
INTEGER sein und sind, falls ben|tigt, anzugeben.
Miô  deò Funktioî ADDR(V© kanî aucè einå Variablå aî diå  externå 
Prozedur }bergeben werden.

z.B® EXTERNAL('DISC')»      stellô aló Ein-Ausgabemediuí f}ò diå 
                            Befehle TIN, TOUT die Diskette ein.
     EXTERNAL('DIR','*.')»  gibô  daó   Dirctorù  alleò  PASCAL-
                            Quelldateien aus.

Solltå eiî RSX-Befehì ausgef}hrô werden¬ isô eó notwendig¬ vorheò 
diå  Firmware-Routinå  KÌ  LOÇ EXÔ  aufzurufen¬  diå  diå  RSX-eî 
initialisiert¬ dá nacè Abarbeitunç eineó Programmó allå Ereignis-
Warteschlangeî unä RSX-eî gel|schô werden.


RANDOM(X)

Diå  Funktioî RANDOÍ gibô einå positivå Pseudozufallszahì zur}ck® 
Sie ist vom Typ INTEGER und liegt im Bereich 0...MAXINT.
Isô  deò  zõ }bergebendå INTEGER-Parameteò  gleicè  Null¬  stellô 
RANDOM(0© diå n{chstå Zufallszahì dieseò Sequenú bereit®  Isô deò 
Parameteò  X  >0¬ sï  wirä einå neuå  Sequenú  voî  Zufallszahleî 
gestartet, wobei X selbst die erste Zufallszahl ist.
ŠAFTER(ZEIT,ZEITGEBER,PROCEDURE)

Diå  Prozeduò AFTEÒ rufô nacè Ablauæ deò durcè deî Parameteò ZEIÔ 
angegebeneî   Zeiô   (iî   Einheiteî  zõ   0,0²   Sekunden©   diå 
parameterloså  Prozeduò  PROCEDUÒE auf®  Deò Parameteò  ZEITGEBEÒ 
spezifizierô eineî deò ´ (0...3© Zeitgeber®  Zeitgebeò ³ haô  diå 
h|chstå ¬ Zeitgebeò ° diå niedrigstå Priorit{t® Diå ersteî beideî 
Parameter sind als INTEGER-Werte anzugeben.

z.B. AFTER(10,3,ZAEHLE);

startet die Prozedur  ZAEHLE durch Zeitgeber 3 nach 0,2 Sekunden.
   

EVERY(ZEIT,ZEITGEBER,PROCEDURE)

Diå  Prozeduò EVERÙ bewirkô daó Aufrufeî deò  Prozedur  PROCEDUÒE
(ohnå  Parameter©  iî regelm{~igen¬  durcè deî Parameteò  ZEIT(iî 
0,02 Sekunden) angegebenen, Zeitabst{nden. 
Ansonsten gilt das unter AFTER Vermerkte.

z.B. EVERY(10,1,ZAEHLE);

rufô  diå  Prozedur  ZAEHLÅ durcè Zeitgebeò ± allå  0,²  Sekundeî 
auf.

Achtungº   EVERY- unä  AFTER-Befehlå beeinflusseî sicè f}ò  eineî 
           bestimmten Zeitgeber gegenseitig !


REMAIN(ZEITGEBER)

Dieså  Funktioî  gibô diå verbleibendå Restzeiô deó aló  INTEGER-
Parameteò anzugebendeî Zeitgeberó (0...3© aî unä setzô ihî  au~eò 
Kraft® Daó Ergebnió isô voí Tyğ INTEGER» Nulì wirä zur}ckgegeben¬ 
wenn der entsprechende Zeitgeber ausgeschaltet war.
     

ENV(N,P1,Q1,R1,P2,Q2,R2,...)

Diå Prozeduò ENÖ definierô diå Lautst{rkeh}llkurvå f}ò deî SOUND-
Befehì  unä  isô identiscè miô deí BASIC-Befehì gleicheî  Namens® 
Siå  bewirkô daó Anschwelleî unä Abklingeî deó  Tones¬  ausgehenä 
von der Lautst{rke, die im SOUND-Befehl vorgegeben wird.
Folgende INTEGER-Parameter sind anzugeben:

N    H}llkurvennummer (1...15)

P    Schrittanzahl;
     Anzahì deò Lautst{rke{nderungeî iî eineí H}llkurvenabschnitô 
     (0...127)

Q    Schrittweite;
     Differenú zwischeî deî jeweiligeî  Lautst{rkeschritten®  Diå 
     Differenú  kanî  Wertå  zwischeî ° unä 1µ  annehmen¬  dá  ií 
     SOUND-Befehì  1¶ verschiedenå Lautst{rkegradå m|glicè  sind® 
     Weiì diå Eingabå alleò INTEGER-Wertå m|glicè ist¬  kehrô diå Š     Lautst{rkå  jedeó  Maì auæ ° zur}ck¬  wenî siå  daó  Maximuí 
     }berschritten hat.

R    Schrittzeit;
     Zeiô  zwischeî  deî  einzelneî Laust{rkeschritteî  iî  1/10° 
     Sekunden (0...255)

     Zõ  beachteî  ist¬  daş diå Daueò  alleò  Lautst{rkeschrittå 
     zusammeî nichô l{ngeò aló diå Daueò deó Tons¬  deò ií SOUND-     
     Befehì definierô ist¬  seiî sollte®  Deò Toî wirä sonsô vor
     zeitiç  abgebrocheî unä diå restlicheî  H}llkurvenabschnittå 
     werdeî nichô abgearbeitet® Isô dagegeî diå Daueò deó Tonó ií 
     SOUND-Befehì  gr|~er¬  verbleibô deò Toî f}ò  diå  restlichå 
     Zeiô auæ deò letzteî Lautst{rkestufe.

P¬ Q¬ Ò bildeî zusammeî eineî H}llkurvenabschnitt¬ voî deneî f}næ 
in einem ENV-Befehl definiert werden k|nnen.

z.B. ENV(1,3,1,2,1,0,6,2,-2,2);


Lautst{rke

   /! 
    !
15 ---
    !
   ---
    !
   ---
    !
   ---           7 = Anfangs-Lautst{rke vom SOUND-Befehl
    !                    
   ---                    
    !                                    
   ---          !-----!-----------------! 
    !           !     !                 !   
   ---    !-----!     !                 !   
    !     !           !                 !   
   -------!           !                 !-----!
    !                 !                 !     !
 7 ----!--!--!--!--!--!--!--!--!--!--!--!--!--!--!--!--!--!--!-->
    !                 !                 !     !      
   ---                !                 !     !------    Zeiô iî 
    !                 !                 !                1/100 s
   ---                !                 !                  
    !                 !                 !           
   ---                !                 !               
    !   1. Abschnitt  !  2. Abschnitt   !  3.Abschnitt
   ---
    !
   ---
    !
   ---
    !
 0 ---
ŠNebeî    dieseî   Software-H}llkurveî  gibô  eó  nocè   Hardware-
H}llkurven, die durch folgende Parameter beschrieben werden:

1.  H}llkurven-Form (gr|~er als 128)
    Dieseò   Parameteò   wirä  iî  daó   Lautst{rkeregisteò   deó 
    Tongenerators geschrieben.

2®  Niederwertigeó   Bytå  deò  H}llkurvenperiodå  (wirä  iî  daó 
    H}llkurven-Register des Tongenerators geschrieben)

3®  H|herwertigeó   Bytå   deò  H}llkurvenperiodå  (wirä  iî  daó 
    H}llkurven-Register des Tongenerators geschrieben)

Diå   Nutzunç   dieseò  Hardware-H}llkurveî  setzô   umfangreichå 
Kenntnisse der Hardware voraus.


ENT (N,P1,Q1,R1,P2,Q2,R2,...)

Diå Prozeduò ENÔ definierô diå Tonh}llkurvå f}ò deî  SOUND-Befehì 
unä  isô  identiscè  miô deí BASIC-Befehì  gleicheî  Namens®  Siå 
bewirkô kleinå Frequenzschwankungeî betreffenä deó Tones¬  deò ií 
SOUND-Befehì  definierô wird¬  d.h®  maî kanî deî Toî  iî  seineò 
Tonh|hå nocè etwaó variieren¬ etwá wiå beií Vibrato.

Folgende INTEGER-Parameter sind anzugeben:

N    H}llkurvennummer (1...15)
     Wirä  diå H}llkurvennummeò miô eineí Minuszeicheî  versehen¬ 
     danî wirä diå Tonh}llkurvå sï ofô wiederholt¬ wiå deò Dauer-     
     Parameteò  ií  SOUND-Kommandï  angibô (wirä abeò  ií  SOUND-     
     Kommandï nichô negatiö aufgerufen).

P    Schrittanzahl (0...239)
     Anzahl der Tonh|henschritte in einem Abschnitt

Q    Schrittweite (-128...127)
     Differenú  zwischeî  deî  jeweiligeî Tonh|henschritten®  Miô 
     positiveî  Schritteî  nimmô diå Tonh|hå  ab¬  miô  negativeî 
     Schritten nimmt sie zu.

R    Schrittzeit (0...255)
     Zeiô  zwischeî  deî  einzelneî  Tonh|henschritteî  iî  1/10° 
     Sekunden®  Zõ beachteî ist¬  daş diå Summå deò Schrittzeiteî 
     wiederruí  ií  richtigeî Verh{ltnió zuí  Dauer-Parameteò  ií 
     SOUND-Befehl steht (siehe ENV).

P¬ Q¬ Ò bildeî zusammeî eineî H}llkurvenabschnitt¬ voî deneî f}næ 
iî eineí ENT-Befehì definierô werdeî k|nnen®  Einå Variatioî  voî 
P¬  Ñ  unä Ò (aucè beií ENV-Befehl© }beò diå vorgegebeneî Grenzeî 
hinaus, k|nnen mitunter interessante Effekte hervorrufen.
.paŠNebeî  dieseò Forí deó schrittweiseî Ver{nderî deò Tonh|he¬  kanî 
maî  siå aucè absoluô iî deò ENT-Prozeduò  setzen®  Deò  absolutå 
H}llkurven-Abschnitô   (siehå   BASIC-Handbuch©  miô   deî   zweé 
Parametern¬ Tonperiodå unä Pausenzeit¬ entsprichô unteò KC PASCAL

240 + Tonperiode DIV 256, Tonperiode MOD 256, Pausenzeit.

Tonperiodå  isô eiî ganzzahligeò Ausdrucë zwischeî  0...409µ  unä 
entspricht der Tonh|he.
Pausenzeiô isô {quivalenô deò Schrittzeiô - deò Zeit¬  iî deò eiî 
Ton ohne Ver{nderung klingt.

Dieså  Forí deò Tonh}llkurvengenerierunç solltå jedocè  ebenfalló 
nur Hardware-Kennern vorbehalten sein.


SOUND(K,LH,TH,T,G,L,D)
 
Diå  SOUND-Prozeduò  dienô  deò Ausgabå voî T|neî }beò bió  zõ  ³ 
Kan{len®  Diå  H}llkurveî  (Ton- unä Lautst{rke-©  m}sseî  vorheò 
definierô sein®  Diå Parameteò sinä aló INTEGER-Wertå einzugeben® 
Ihrå  ausf}hrlichå Beschreibunç isô ií BASIC-Handbucè zõ  finden® 
Lediglicè diå Reihenfolgå deò Parameterangabå isô verschieden.

K    Kanalstatus (1...255), bitsignifikant


BIT   Dezimalwert
-----------------------------------------------------------------
 0         0           Ton wird zum Kanal A geschickt
 1         2           Ton wird zum Kanal B geschickt
 2         4           Ton wird zum Kanal C geschickt
 3         8           Rendezvous mit Kanal A
 4        16           Rendezvous mit Kanal B
 5        32           Rendezvous mit Kanal C
 6        64           Halte den Tonkanal
 7       128           Leere den Tonkanal


LH   Lautst{rkeh}llkurve (1...15)
     Deò Parameteò LÈ entsprichô deò H}llkurvennummeò iî deò ENV-
     Prozedur®  Damiô  wirä deò SOUND-Ausgabå  diå  entsprechendå 
     Lautst{rkeh}llkurve¬   die   vorheò  definierô  wurde¬   zuò 
     Verf}gung gestellt.

TH   Tonh}llkurve (1...15)
     Deò  Parameteò TÈ entsprichô deò  positiveî  bzw®  negativeî 
     H}llkurvennummeò iî deò ENT-Prozedur®  Damiô wirä deò SOUND-
     Ausgabå diå entsprechendå Tonh}llkurve¬ diå vorheò definierô 
     wurde¬  zuò Verf}gunç gestellt®  Isô diå H}llkurvennummeò ií 
     ENT-Befehì negativ¬ sï wirä deò Verlauæ deò Tonh}llkurvå bió 
     zuí  Endå  deò  SOUND-Ausgabå  wiederholt»  TÈ  wirä  jedocè 
     positiv angegeben.   
.paŠT    Tonperiode bzw. Tonh|he (16...3822)
     Dieser Bereich von T umspannt 8 Tonoktaven.
     z.B. T=239    Mittleres C
          T=142    Kammerton A

     Diå }beò Ô angegebenå Tonh|hå isô diå Anfangstonh|he¬ diå iî 
     ihreí  zeitlicheî  Verlauæ  mitteló deò  Tonh}llkurvå  (ENT© 
     variiert werden kann.

G    Ger{uschperiode (0...31)
     Dieseò  Parameteò  erzeugô  "Wei~eó  Rauschen"¬   womiô  diå 
     Tonausgabe begleitet werden kann.

L    Lautst{rke (0...15)
     Dieseò  Parameteò  bestimmô  diå Lautst{rkå  aí  Anfanç  deó 
     Tones®  Deò weiterå zeitlichå Verlauæ wirä }beò diå Prozeduò 
     ENV festgelegt.

D    Tondauer in 1/100 Sekunden


SQ(K)

Dieså   Funktioî  gibô  diå  Anzahì  deò  freieî  Pl{tzå  iî  deò 
Tonwarteschlange des Kanals K zur}ck, wobei

K=1  Kanal A
K=2  Kanal B und
K=4  Kanal C ist.

Daó   Ergebnió   dieseò  Funktioî  isô  voí   Tyğ   INTEGEÒ   unä 
bitsignifikant, wobei die einzelnen Bits folgende Bedeutung haben:

Bit 0, 1, 2   Anzahl der freien Pl{tze in der Warteschlange
Biô 3¬ 4¬ µ   Rendezvous-Zustanä aí obereî Endå deò Warteschlange 
Biô ¶         daó  oberå Endå deò Warteschlangå befindeô sicè  ií 
              Haltezustand
Bit 7         der Kanal ist gerade aktiv


ONSQ(KANAL,PROCEDURE)

Dieså  Prozeduò  erm|glichô deî Aufruæ eineò  weitereî  Prozedur¬ 
falló  beé deò Tonausgabå eiî Platú iî deò  Tonwarteschlangå  deó 
betreffendeî Kanaló freé gewordeî ist® KANAÌ isô eiî ganzzahligeò 
Ausdrucë miô gleichen Werten wie unter SQ(K).


INITEVENT(ZEITGEBER,PROCEDURE)

Dieså  Funktioî initialisierô eineî Ereignis-Blocë f}ò  synchronå 
Ereignisså   unä  }bergibô  aló  Ergebnió   diå   Speicheradresså 
(INTEGER©  auæ  deò  diå PROCEDURÅ beginnô unä beé  Eintritô  deó 
Ereignisseó   aufgerufeî  werdeî  soll®   Deò   INTEGER-Parameteò 
ZEITGEBEÒ gibô diå Ereignis-Klasså bzw® deî Zeitgebeò an.
Miô   dieseò   Funktioî   kanî   deò   Programmiereò   auæ    deî 
Betriebssystemkerî zugreifen.