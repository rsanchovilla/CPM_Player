; ----------------------------------------------------------------------------
;Micro-Soft Altair BASIC 3.2 (4K) - Annotated Disassembly
;	
;Copyright 1975, Bill Gates, Paul Allen, Monte Davidoff
;Source: http://altairbasic.org/ compiled by Reuben Harris
;Additional cleanup, relocation by Charles Mangin, March, 2019
;patched to run on CP/M-80 By Roberto Sancho, Dec 2019
; ----------------------------------------------------------------------------

; Ported to CP/M By Roberto Sancho Dec 2019
; Changes
;    - uses m80 syntax
;    - uses CPM BDOS for console i/o
;    - convert console typed chars to uppercase
;    - fix parity flag to allow working on z80 using code from Patches to Altair 
;      Extended BASIC 4.0 to allow it to run on a Z80, by Mike Douglas, June 16, 2013 
;    - allow ^H (BackSpace) to delete last type char
;    - SYSTEM command to return to CP/M
;    - LOAD "file.ext" to load a progran from cp/m ascii file
;      on files, allow lowercase chars. Basic commands must be in uppercase
;      if file not found, prints "?IO ERROR"

	aseg
        org 0100h

        jmp CPMStart

BIN_Start:        
        .phase 0000h
        .8080
        
Start:	DI
        JMP Init	

	DW 0490h	
	DW 07F9h	

SyntaxCheck:
	MOV A,M	;A=Byte of BASIC program.
	XTHL	;HL=return address.
	CMP M	;Compare to byte expected.
	INX H	;Return address++;
	XTHL	;
	JNZ SyntaxError	;Error if not what was expected.
NextChar:
	INX H	
	MOV A,M	
	CPI 3Ah	
	RNC	
	JMP NextChar_tail	
OutChar:
	PUSH PSW	
	LDA TERMINAL_X	
	JMP OutChar_tail	
	NOP	
CompareHLDE:
	MOV A,H	
	SUB D	
	RNZ	
	MOV A,L	
	SUB E	
	RET	
TERMINAL_Y:	DB 01	
TERMINAL_X:	DB 00	
FTestSign:
	LDA FACCUM+3	
	ORA A	
	JNZ FTestSign_tail	
	RET	
PushNextWord:
	XTHL	
	SHLD L003A+1	
	POP H	
	MOV C,M	
	INX H	
	MOV B,M	
	INX H	
	PUSH B	
L003A:	JMP L003A	

KW_INLINE_FNS:
	DW Sgn	
	DW Int	
	DW Abs	
	DW FunctionCallError	
	DW Sqr	
	DW Rnd	
	DW Sin	
KW_ARITH_OP_FNS:
	DB 79h
	DW FAdd	;+
	DB 79h
	DW FSub	;-
	DB 7Ch 
	DW FMul	;*
	DB 7Ch 
	DW FDiv	;/
KEYWORDS:
	DC "END"	; 80
	DC "FOR"	; 81
	DC "NEXT"	; 82
	DC "DATA"	; 83
	DC "INPUT"	; 84
	DC "DIM"	; 85
	DC "READ"	; 86
	DC "LET"	; 87
	DC "GOTO"	; 88
	DC "RUN"	; 89
	DC "IF"		; 8A
	DC "RESTORE"	; 8B
	DC "GOSUB"	; 8C
	DC "RETURN"	; 8D
	DC "REM"	; 8E
	DC "STOP"	; 8F
	DC "PRINT"	; 90
	DC "LIST"	; 91
	DC "CLEAR"	; 92
	DC "NEW"	; 93
;
	DC "TAB("	; 94
	DC "TO"		; 95
	DC "THEN"	; 96
	DC "STEP"	; 97
;
	DB 0ABh		; "+"	98
	DB 0ADh		; "-"	99
	DB 0AAh		; "*"	9A
	DB 0AFh		; "/"	9B
	DB 0BEh		; ">"	9C
	DB 0BDh		; "="	9D
	DB 0BCh		; "<"	9E
;
	DC "SGN"	; 9F
	DC "INT"	; A0
	DC "ABS"	; A1
	DC "USR"	; A2
	DC "SQR"	; A3
	DC "RND"	; A4
	DC "SIN"	; A5
	
	DB 0	
 	
KW_GENERAL_FNS:
	DW Stop			;END
	DW For			;FOR
	DW Next			;NEXT
	DW FindNextStatement	;DATA
	DW Input		;INPUT
	DW Dim			;DIM
	DW Read			;READ
	DW Let			;LET
	DW Goto			;GOTO
	DW Run			;RUN
	DW If			;IF
	DW Restore		;RESTORE
	DW Gosub		;GOSUB
	DW Return		;RETURN
	DW Rem			;REM
	DW Stop			;STOP
	DW Print		;PRINT
	DW List			;LIST
	DW Clear		;CLEAR
	DW New			;NEW

ERROR_CODES:
	DC "NF"		; NEXT without FOR.
	DC "SN"		; Syntax Error
	DC "RG"		; RETURN without GOSUB.
	DC "OD"		; Out of Data
	DC "FC"		; Illegal Function Call
	DC "OV"		; Overflow.
	DC "OM"		; Out of memory.
	DC "US"		; Undefined Subroutine
	DC "BS"		; Bad Subscript
	DC "DD"		; Duplicate Definition
	DC "/0"		; Division by zero.
ID_IO_ERR_COD:
	DC "ID"		; Invalid in Direct mode.
 	DB ','		; 
 	
LINE_BUFFER:
	DW 0000,0000,0000,0000h	;72 chars
	DW 0000,0000,0000,0000h	;
	DW 0000,0000,0000,0000h	;
	DW 0000,0000,0000,0000h	;
	DW 0000,0000,0000,0000h	;
	DW 0000,0000,0000,0000h	;
	DW 0000,0000,0000,0000h	;
	DW 0000,0000,0000,0000h	;
	DW 0000,0000,0000,0000h	;		

DIM_OR_EVAL:	DB 00h		; 
INPUT_OR_READ:	DB 00h		; 
PROG_PTR_TEMP:	DW 0000h	;
L015F:		DW 0000h	;
CURRENT_LINE:	DW 0000h	;
STACK_TOP:	DW 0F1Ah	; RELOCATE***
PROGRAM_BASE:	DW 0000h	;
VAR_BASE:	DW 0000h	;
VAR_ARRAY_BASE:	DW 0000h	;
VAR_TOP:	DW 0000h	;
DATA_PROG_PTR:	DW 0000h	;
FACCUM:		DB 00,00,00,00	;
FTEMP:		DB 00
FBUFFER:	DW 0000,0000,0000
		DW 0000,0000,0000
		DB 00	

szError:	DC 	" ERROR"	 
		DB 00	
szIn:		DC 	" IN "
		DB 00	
szOK:		DB 13
		DC 	"OK"
		DB 13,0
		
GetFlowPtr:
	LXI H,0004h	;HL=SP+4 (ie get word
	DAD SP		;just past return addr)
	MOV A,M		;
	INX H		;
	CPI 81h		;'FOR'?
	RNZ		;Return if not 'FOR'
	RST 6		; RST PushNextWord	;PUSH (HL)
	XTHL		;POP HL (ie HL=(HL))
	RST 4		; RST CompareHLDE	;HL==DE?
	LXI B,000Dh	;
	POP H		;Restore HL
	RZ		;Return if var ptrs match.
	DAD B		;HL+=000D
	JMP GetFlowPtr+4	;Loop
	
CopyMemoryUp:
	CALL CheckEnoughMem;
	PUSH B	;Exchange BC with HL.
	XTHL	;
	POP B	;
CopyMemLoop:
	RST 4	;HL==DE?
	MOV A,M	;
	STAX B	;
	RZ	;Exit if DE reached.
	DCX B	;
	DCX H	;
	JMP CopyMemLoop	;
CheckEnoughVarSpace:
	PUSH H	;
	LHLD VAR_TOP	;
	MVI B,00h	;BC=C*4
	DAD B	;
	DAD B	;
	CALL CheckEnoughMem;
	POP H	;
	RET	;
CheckEnoughMem:
	PUSH D	;
	XCHG	;
	LXI H,0FFDEh;	;HL=-34 (extra 2 bytes for return address)
	DAD SP	;
	RST 4	;
	XCHG	;
	POP D	;
	RNC	;
OutOfMemory:
	MVI E,0Ch	;
	DB 01	;LXI B,....	;
SyntaxError:
	MVI E,02h	;
	DB 01	;LXI B,....	;
DivideByZero:
	MVI E,14h	;
Error:
	CALL ResetStack	;
	CALL NewLine	;
	LXI H,ERROR_CODES	;
	MOV D,A	;
	MVI A,'?'	;Print '?'
	RST 03	;RST OutChar	;
	DAD D	;HL points to error code.
	MOV A,M	;
	RST 03	;RST OutChar 11 011 111	;Print first char of code.
	RST 02	;RST NextChar 11 010 111	;
	RST 03	;RST OutChar	;Print second char of code.
	LXI H,szError	;Print " ERROR".
	CALL PrintString	;
	LHLD CURRENT_LINE	;
	MOV A,H	;
	ANA L	;
	INR A	;
	CNZ PrintIN	;
	DB 01	;LXI B,....	;LXI over Stop and fall into Main
Stop:
	RNZ	;Syntax Error if args.
	POP B	;Lose return address.
Main:
	LXI H,szOK	 
	CALL Init	
GetNonBlankLine:
	LXI H,0FFFFh	;
	SHLD CURRENT_LINE	;
	CALL InputLine	; 
	RST 02	;RST NextChar	; 
	INR A	;
	DCR A	; 
	JZ GetNonBlankLine	; 
	PUSH PSW	 
	CALL LineNumberFromStr	 
	PUSH D	 
	CALL Tokenize	 
	MOV B,A	
	POP D	 
	POP PSW	 
	JNC Exec	 
StoreProgramLine:
	PUSH D	;Push line number
	PUSH B	;Push line length
	RST 02	;RST NextChar	;Get first char of line
	ORA A	;Zero set if line is empty (ie removing a line)
	PUSH PSW	;Preserve line-empty flag
	CALL FindProgramLine	;Get nearest program line address in BC.
	PUSH B	;Push line address.
	JNC InsertProgramLine	;If line doesn't exist, jump ahead to insert it.
RemoveProgramLine:
	XCHG	;DE=Next line address.
	LHLD VAR_BASE	;
RemoveLine:
	LDAX D	;Move byte of program remainder down
	STAX B	;in memory.
	INX B	;
	INX D	;
	RST 4	;Loop until DE==VAR_BASE, ie whole
	JNZ RemoveLine	;program remainder done.
	MOV H,B	;
	MOV L,C	;Update VAR_BASE from BC.
	SHLD VAR_BASE	;
InsertProgramLine:
	POP D	;DE=Line address (from 224)
	POP PSW	;Restore line-empty flag (see above)
	JZ UpdateLinkedList;If line is empty, then we don't need to insert it so can jump ahead.
	LHLD VAR_BASE	;
	XTHL	;HL = Line length (see 21D)
	POP B	;BC = VAR_BASE
	DAD B	;HL = VAR_BASE + line length.
	PUSH H	;
	CALL CopyMemoryUp	;Move remainder of program so there's enough space for the new line.
	POP H	;
	SHLD VAR_BASE	;Update VAR_BASE
	XCHG	;HL=Line address, DE=VAR_BASE
	MOV M,H	;???
	INX H	;Skip over next line ptr (updated below)
	INX H	;
	POP D	;DE = line number (see 21C)
	MOV M,E	;Write line number to program line memory.
	INX H	;
	MOV M,D	;
	INX H	;
CopyFromBuffer:
	LXI D,LINE_BUFFER	;Copy the line into the program.
	LDAX D	;
	MOV M,A	;
	INX H	;
	INX D	;
	ORA A	;
	JNZ CopyFromBuffer+3;
UpdateLinkedList:
	CALL ResetAll	;
	INX H	;
	XCHG	;
L0265:	MOV H,D	;
	MOV L,E	;
	MOV A,M	;If the pointer to the next line is a null
	INX H	;word then we've reached the end of the
	ORA M	;program, job is done, and we can jump back
	JZ GetNonBlankLine	;to let the user type in the next line.
	INX H	;Skip over line number.
	INX H	;
	INX H	;
	XRA A	;
L0271:	CMP M	;
	INX H	;
	JNZ L0271	;
	XCHG	;
	MOV M,E	;
	INX H	;
	MOV M,D	;
	JMP L0265	;
FindProgramLine:
	LHLD PROGRAM_BASE	;
	MOV B,H	;BC=this line
	MOV C,L	;
	MOV A,M	;If we've found two consecutive
	INX H	;null bytes, then we've reached the end
	ORA M	;of the program and so return.
	DCX H	;
	RZ	;
	PUSH B	;Push this line address
	RST 6	;Push (next line address)
	RST 6	;Push (this line number)
	POP H	;HL = this line number
	RST 4	;Compare line numbers
	POP H	;HL = next line address
	POP B	;BC = this line address
	CMC	;
	RZ	;Return carry set if line numbers match.
	CMC	;
	RNC	;Return if we've reached a line number greater than the one required.
	JMP FindProgramLine+3	
New:	RNZ	 
	LHLD PROGRAM_BASE	 
	XRA A	
	MOV M,A	
	INX H	
	MOV M,A	
	INX H	 
	SHLD VAR_BASE	 
Run:	RNZ	
ResetAll:
	LHLD PROGRAM_BASE	
	DCX H	
Clear:
	SHLD PROG_PTR_TEMP	
	CALL Restore	
	LHLD VAR_BASE	
	SHLD VAR_ARRAY_BASE	
	SHLD VAR_TOP	
ResetStack:
	POP B	
	LHLD STACK_TOP	
	SPHL	
	XRA A	
	MOV L,A	
	PUSH H	
	PUSH B	
	LHLD PROG_PTR_TEMP	
	RET	
InputLineWith:
	MVI A,'?'	;Print '?'
	RST 03	;RST OutChar	;
	MVI A,' '	;Print ' '
	RST 03	;RST OutChar	;
	CALL InputLine	;
	INX H	;
Tokenize:
	MVI C,05	;Initialise line length to 5.
	LXI D,LINE_BUFFER	;ie, output ptr is same as input ptr at start.
	MOV A,M	;
	CPI ' '	;
	JZ WriteChar	;
	MOV B,A	;
	CPI '"'	;
	JZ FreeCopy	;
	ORA A	;
	JZ Exit	;
	PUSH D	;Preserve output ptr.
	MVI B,00	;Initialise Keyword ID to 0.
LdKwTb1:LXI D,KEYWORDS-1	;
	PUSH H	;Preserve input ptr.
	DB 3Eh	;LXI over get-next-char
KwCompare:
	RST 02 	; RST 01	; SyntaxCheck0	;Get next input char
	INX D	;
	LDAX D	;Get keyword char to compare with.
	ANI 7Fh	;Ignore bit 7 of keyword char.
	JZ NotAKeyword	;If keyword char==0, then end of keywords reached.
	CMP M	;Keyword char matches input char?
	JNZ NextKeyword	;If not, jump to get next keyword.
	LDAX D	;
	ORA A	;
	JP KwCompare	;
	POP PSW	;Remove input ptr from stack. We don't need it.
	MOV A,B	;A=Keyword ID
	ORI 80h	;Set bit 7 (indicates a keyword)
	DB 0F2h	;JP ....	;LXI trick again.
NotAKeyword:
	POP H	;Restore input ptr
	MOV A,M	;and get input char
	POP D	;Restore output ptr
WriteChar:	INX H	;Advance input ptr
	STAX D	;Store output char
	INX D	;Advance output ptr
	INR C	;C++ (arf!).
	SUI 8Eh	;If it's not the
	JNZ Tokenize+5	;
	MOV B,A	;B=0
FreeCopyLoop:
	MOV A,M	;A=Input char
	ORA A	;If char is null then exit
	JZ Exit	;
	CMP B	;If input char is term char then
	JZ WriteChar	;we're done free copying.
FreeCopy:
	INX H	;
	STAX D	;
	INR C	;
	INX D	;
	JMP FreeCopyLoop	;
NextKeyword:
	POP H	;Restore input ptr
	PUSH H	;
	INR B	;Keyword ID ++;
	XCHG	;HL=keyword table ptr
NextKwLoop:
	ORA M	;Loop until
	INX H	;bit 7 of previous
	JP NextKwLoop	;keyword char is set.
	XCHG	;DE=keyword ptr, HL=input ptr
	JMP KwCompare+2	;
Exit:
	LXI H,LINE_BUFFER-1	;
	STAX D	;
	INX D	;
	STAX D	;
	INX D	;
	STAX D	;
	RET	;
Backspace:
	DCR B	;Char count--;
	DCX H	;Input ptr--;
	RST 03	;RST OutChar	;Print backspace char.
	JNZ InputNext	;
ResetInput:
	RST 03	;RST OutChar	;
	CALL NewLine	;
InputLine:
	LXI H,LINE_BUFFER	;
	MVI B,01	;
InputNext:
	CALL InputChar	;
	CPI 0Dh	;
	JZ TerminateInput	;
	CPI ' '	;If < ' '
	JC InputNext	;or
	CPI 7Dh	;> '}'
	JNC InputNext	;then loop back.
	CPI '@'	;
	JZ ResetInput	;
        CPI '_'	;
	JZ Backspace	;
L035D:	MOV C,A	;
	MOV A,B	;
	CPI 48h	;
	MVI A,07	;
	JNC L036A	;
	MOV A,C	;Write char to LINE_BUFFER.
	MOV M,C	;
	INX H	;
	INR B	;
L036A:	RST 03	;RST OutChar	;
	JMP InputNext	;
OutChar_tail:
	CPI 48h	;
	CZ NewLine	;
	INR A	;
	STA TERMINAL_X	;
WaitTermReady:
	IN 00	;
	ANI 80h	;
	JNZ WaitTermReady	;
	POP PSW	;
	OUT 01	;
	RET	;
InputChar:
	IN 00	; 
	ANI 01	; 
	JNZ InputChar	;
	IN 01	; 
	ANI 7Fh	; 
	RET	;
List:
	CALL LineNumberFromStr	
	RNZ	
	POP B	;?why get return address?
	CALL FindProgramLine	
	PUSH B	
ListNextLine:
	POP H	
	RST 6	
	POP B	
	MOV A,B	
	ORA C	
	JZ Main	
	CALL TestBreakKey	
	PUSH B	
	CALL NewLine	
	RST 6	
	XTHL	
	CALL PrintInt	
	MVI A,' '	
	POP H	
ListChar:
	RST 03	;RST OutChar	
	MOV A,M	
	ORA A	
	INX H	
	JZ ListNextLine	
	JP ListChar	
	SUI 7Fh	;A is now keyword index + 1.
	MOV C,A	
	PUSH H	
LdKwTb2:LXI D,KEYWORDS	
	PUSH D	
ToNextKeyword:
	LDAX D	
	INX D	
	ORA A	
	JP ToNextKeyword	
	DCR C	
	POP H	
	JNZ ToNextKeyword-1	
PrintKeyword:
	MOV A,M	
	ORA A	
	JM ListChar-1	
	RST 03	;RST OutChar	
	INX H	
	JMP PrintKeyword	
For:
	CALL Let	
	XTHL	
	CALL GetFlowPtr	
	POP D	
	JNZ L03E2	
	DAD B	
	SPHL	
L03E2:	XCHG	
	MVI C,08	
	CALL CheckEnoughVarSpace	
	PUSH H	
	CALL FindNextStatement	
	XTHL	
	PUSH H	
	LHLD CURRENT_LINE	
	XTHL	
	RST 01	; SyntaxCheck; SyntaxCheck	
	DB 95h	;KWID_TO	
	CALL EvalExpression	
	PUSH H	
	CALL FCopyToBCDE	
	POP H	
	PUSH B	
	PUSH D	
	LXI B,8100h	
	MOV D,C	
	MOV E,D	
	MOV A,M	
	CPI 97h	;KWID_STEP	
	MVI A,01h	
	JNZ PushStepValue	
	CALL EvalExpression+1	
	PUSH H	
	CALL FCopyToBCDE	
	RST 05	; FTestSign	
	POP H	
PushStepValue:
	PUSH B	
	PUSH D	
	PUSH PSW	
	INX SP	
	PUSH H	
	LHLD PROG_PTR_TEMP	
	XTHL	
EndOfForHandler:
	MVI B,81h	
	PUSH B	
	INX SP	
ExecNext:
	CALL TestBreakKey	
	MOV A,M	
	CPI ':'	
	JZ Exec	
	ORA A	
	JNZ SyntaxError	
	INX H	
	MOV A,M	
	INX H	
	ORA M	
	INX H	
	JZ Main	
	MOV E,M	
	INX H	
	MOV D,M	
	XCHG	
	SHLD CURRENT_LINE	
	XCHG	
Exec:	RST 02	;RST NextChar	
	LXI D,ExecNext	
	PUSH D	
	RZ	
	SUI 80h	
	JC Let	
	CPI 14h	
TrapTk: JNC SyntaxError	
	RLC	;BC = A*2
	MOV C,A	
	MVI B,00h	
	XCHG	
	LXI H,KW_GENERAL_FNS	
	DAD B	
	MOV C,M	
	INX H	
	MOV B,M	
	PUSH B	
	XCHG	
	RST 02	;RST NextChar	
	RET	
NextChar_tail:
	CPI ' '	
	JZ NextChar	
	CPI '0'	
	CMC	
	INR A	
	DCR A	
	RET	
Restore:
	XCHG	
	LHLD PROGRAM_BASE	
	DCX H	
L046E:	SHLD DATA_PROG_PTR	
	XCHG	
	RET	
TestBreakKey:
	IN 00	;Exit if no key pressed.
	ANI 01	;
	RNZ	;
	CALL InputChar	;
	CPI 03h	;Break key?
	JMP Stop	
CharIsAlpha:
	MOV A,M	
	CPI 'A'	
	RC	
	CPI 'Z'+1	
	CMC	
	RET	
GetSubscript:
	RST 02	;RST NextChar	
	CALL EvalExpression	
	RST 05	; FTestSign	
	JM FunctionCallError	
	LDA FACCUM+3	
	CPI 90h	
	JC FAsInteger	
FunctionCallError:
	MVI E,08h	
	JMP Error	
LineNumberFromStr:
	DCX H	
	LXI D,0000	
NextLineNumChar:
	RST 02	;RST NextChar	
	RNC	
	PUSH H	
	PUSH PSW	;Preserve flags
	LXI H,1998h	;Decimal 6552
	RST 4	
	JC SyntaxError	
	MOV H,D	
	MOV L,E	
	DAD D	
	DAD H	
	DAD D	
	DAD H	
	POP PSW	
	SUI '0'	
	MOV E,A	
	MVI D,00h	
	DAD D	
	XCHG	
	POP H	
	JMP NextLineNumChar	
Gosub:
	MVI C,03h	
	CALL CheckEnoughVarSpace	
	POP B	
	PUSH H	
	PUSH H	
	LHLD CURRENT_LINE	
	XTHL	
	MVI D,8Ch	
	PUSH D	
	INX SP	
	PUSH B	
Goto:
	CALL LineNumberFromStr	
	RNZ	
	CALL FindProgramLine	
	MOV H,B	
	MOV L,C	
	DCX H	
	RC	
	MVI E,0Eh	
	JMP Error	
Return:
	RNZ	
	MVI D,0FFh	
	CALL GetFlowPtr	
	SPHL	
	CPI 8Ch	
	MVI E,04h	
	JNZ Error	
	POP H	
	SHLD CURRENT_LINE	
	LXI H,ExecNext	
	XTHL	
FindNextStatement:
	DB 01,3Ah ;LXI B,..3A	
Rem:
	DB 10h	
	NOP	
FindNxtStatementLoop:
	MOV A,M	
	ORA A	
	RZ	
	CMP C	
	RZ	
	INX H	
	JMP FindNxtStatementLoop	
Let:
	CALL GetVar	
	RST 01	; SyntaxCheck	
	DB 9Dh	
AssignVar:
	PUSH D	
	CALL EvalExpression	
	XTHL	
	SHLD PROG_PTR_TEMP	
	PUSH H	
	CALL FCopyToMem	
	POP D	
	POP H	
	RET	
If:
	CALL EvalExpression	
	MOV A,M	
	CALL FPush	
	MVI D,00	
GetCompareOpLoop:
	SUI 9Ch	; KWID_>	
	JC GotCompareOp	
	CPI 03h	
	JNC GotCompareOp	
	CPI 01h
	RAL	
	ORA D	
	MOV D,A	
	RST 02	;RST NextChar	
	JMP GetCompareOpLoop	
GotCompareOp:
	MOV A,D	
	ORA A	
	JZ SyntaxError	
	PUSH PSW	
	CALL EvalExpression	
	RST 01	; SyntaxCheck	
	DB 96h	;KWID_THEN	
	DCX H	
	POP PSW	
	POP B	
	POP D	
	PUSH H	
	PUSH PSW	
	CALL FCompare	
	INR A	
	RAL	
	POP B	
	ANA B	
	POP H	
	JZ Rem	
	RST 02	;RST NextChar	
	JC Goto	
	JMP Exec+5	
	DCX H	
	RST 02	;RST NextChar	
Print:
	JZ NewLine	
	RZ	
	CPI '"'	
	CZ PrintString-1	
	JZ Print-2	
	CPI 94h	;KWID_TAB	 
	JZ Tab	
	PUSH H	
	CPI ','	
	JZ ToNextTabBreak	
	CPI ';'	
	JZ ExitTab	
	POP B	
	CALL EvalExpression	
	PUSH H	
	CALL FOut	
	CALL PrintString	
	MVI A,' '	
	RST 03	;RST OutChar	
	POP H	
	JMP Print-2	
TerminateInput:
	MVI M,00h	
	LXI H,LINE_BUFFER-1	
NewLine:
	MVI A,0Dh	
	STA TERMINAL_X	
	RST 03	;RST OutChar	
	MVI A,0Ah	
	RST 03	;RST OutChar	
	LDA TERMINAL_Y	
PrintNullLoop:
	DCR A	
	STA TERMINAL_X	
	RZ	
	PUSH PSW	
	XRA A	
	RST 03	;RST OutChar	
	POP PSW	
	JMP PrintNullLoop	
	INX H	
PrintString:
	MOV A,M	
	ORA A	
	RZ	
	INX H	
	CPI '"'	
	RZ	
	RST 03	;RST OutChar	
	CPI 0Dh
	CZ NewLine	
	JMP PrintString	
ToNextTabBreak:
	LDA TERMINAL_X	
	CPI 38h
	CNC NewLine	
	JNC ExitTab	
CalcSpaceCount:
	SUI 0Eh	
	JNC CalcSpaceCount	
	CMA	
	JMP PrintSpaces	
Tab:
	CALL GetSubscript	
	RST 01	; SyntaxCheck	
	DB 29h	;')'	
	DCX H	
	PUSH H	
	LDA TERMINAL_X	
	CMA	
	ADD E	
	JNC ExitTab	
PrintSpaces:	INR A	
	MOV B,A	
	MVI A,' '	
PrintSpaceLoop:
	RST 03	;RST OutChar	
	DCR B	
	JNZ PrintSpaceLoop	
ExitTab:
	POP H	
	RST 02	;RST NextChar	
	JMP Print+3	
Input:
	PUSH H	
	LHLD CURRENT_LINE	
	MVI E,16h	
	INX H	
	MOV A,L	
	ORA H	
	JZ Error	
	CALL InputLineWith	
	JMP L05FA+1	
Read:
	PUSH H	
	LHLD DATA_PROG_PTR	
L05FA:
	ORI 0AFh
	;XRA A	
	STA INPUT_OR_READ	
	XTHL	
	DB 01	;LXI B,....	
ReadNext:
	RST 01	; SyntaxCheck	
	DB 2Ch	;','	
	CALL GetVar	
	XTHL	
	PUSH D	
	MOV A,M	
	CPI ','	
	JZ GotDataItem	
	ORA A
	JNZ SyntaxError	
	LDA INPUT_OR_READ	
	ORA A	
	INX H	
	JNZ NextDataLine+1	
	MVI A,'?'	
	RST 03	;RST OutChar	
	CALL InputLineWith	
GotDataItem:
	POP D	
	INX H	
	CALL AssignVar	
	XTHL	
	DCX H	
	RST 02	;RST NextChar	
	JNZ ReadNext	
	POP D	
	LDA INPUT_OR_READ	
	ORA A	
	RZ	
	XCHG	
	JNZ L046E	
NextDataLine:
	POP H	
	RST 6	
	MOV A,C	
	ORA B	
	MVI E,06h	
	JZ Error	
	INX H	
	RST 02	;RST NextChar	
	CPI 83h	;KWID_DATA	 
	JNZ NextDataLine	
	POP B	
	JMP GotDataItem	
Next:
	CALL GetVar	
	SHLD PROG_PTR_TEMP	
	CALL GetFlowPtr	
	SPHL	
	PUSH D	
	MOV A,M	
	INX H	
	PUSH PSW	
	PUSH D	
	MVI E,00h	
	JNZ Error	
	CALL FLoadFromMem	
	XTHL	
	PUSH H	
	CALL FAddMem	
	POP H	
	CALL FCopyToMem	
	POP H	
	CALL FLoadBCDEfromMem	
	PUSH H	
	CALL FCompare	
	POP H	
	POP B	
	SUB B	
	CALL FLoadBCDEfromMem	
	JZ ForLoopIsComplete	
	XCHG	
	SHLD CURRENT_LINE	
	MOV L,C	
	MOV H,B	
	JMP EndOfForHandler	
ForLoopIsComplete:
	SPHL	
	LHLD PROG_PTR_TEMP	
	JMP ExecNext	
EvalExpression:
	DCX H	
	MVI D,00h	
	PUSH D	
	MVI C,01h	
	CALL CheckEnoughVarSpace	
	CALL EvalTerm	
	SHLD L015F	
ArithParse:
	LHLD L015F	
	POP B	
	MOV A,M	
	MVI D,00h	
	SUI 98h	;KWID_PLUS	
	RC	
	CPI 04h
	RNC	
	MOV E,A	
	RLC	
	ADD E	
	MOV E,A	
	LXI H,KW_ARITH_OP_FNS	
	DAD D	
	MOV A,B	
	MOV D,M	
	CMP D	
	RNC	
	INX H	
	PUSH B	
	LXI B,ArithParse	
	PUSH B	
	MOV C,D	;???
	CALL FPush	
	MOV D,C	
	RST 6	
	LHLD L015F	
	JMP EvalExpression+3	
EvalTerm:
	RST 02	;RST NextChar	
	JC FIn	
	CALL CharIsAlpha	
	JNC EvalVarTerm	
	CPI 98h	;KWID_PLUS	
	JZ EvalTerm	
	CPI '.'	
	JZ FIn	
	CPI 99h	;KWID_MINUS	
	JZ EvalMinusTerm	
	SUI 9Fh	
	JNC EvalInlineFn	
EvalBracketed:
	RST 01	; SyntaxCheck	
	DB 28h	;'('	
	CALL EvalExpression	
	RST 01	; SyntaxCheck	
	DB 29h	;')'	
	RET	
EvalMinusTerm:
	CALL EvalTerm	
	PUSH H	
	CALL FNegate	
	POP H	
	RET	
EvalVarTerm:
	CALL GetVar	
	PUSH H	
	XCHG	
	CALL FLoadFromMem	
	POP H	
	RET	
EvalInlineFn:
	MVI B,00h	
	RLC	
	MOV C,A	
	PUSH B	
	RST 02	;RST NextChar	
	CALL EvalBracketed	
	XTHL	
	LXI D,06F1h	
	PUSH D	
	LXI B,KW_INLINE_FNS	
	DAD B	
	RST 6	
	RET	
DimContd:
	DCX H	
	RST 02	;RST NextChar	
	RZ	
	RST 01	; SyntaxCheck	
	DB 2Ch	;','	
Dim:
	LXI B,DimContd	
	PUSH B	
	DB 0F6h	
GetVar:
	XRA A	
	STA DIM_OR_EVAL	
	MOV B,M	
	CALL CharIsAlpha	
	JC SyntaxError	
	XRA A	
	MOV C,A	
	RST 02	;RST NextChar	
	JNC 072Eh	
	MOV C,A	
	RST 02	;RST NextChar	
	SUI '('	
	JZ GetArrayVar	
	PUSH H	
	LHLD VAR_ARRAY_BASE	
	XCHG	
	LHLD VAR_BASE	
FindVarLoop:
	RST 4	
	JZ AllocNewVar	
	MOV A,C	
	SUB M	
	INX H	
	JNZ L0747	
	MOV A,B	
	SUB M	
L0747:	INX H	
	JZ L0782	
	INX H	
	INX H	
	INX H	
	INX H	
	JMP FindVarLoop	
AllocNewVar:
	POP H	;HL=prog ptr
	XTHL	;(SP)=prog ptr, HL=ret.addr.
	PUSH D	;
	LXI D,06F6h	;an address inside EvalTerm
	RST 4	;
	POP D	;
	JZ AlreadyAllocd	;
	XTHL	;(SP)=ret.addr, HL=prog ptr.
	PUSH H	;Prog ptr back on stack
	PUSH B	;Preserve var name on stack
	LXI B,0006h	
	LHLD VAR_TOP	
	PUSH H	
	DAD B	
	POP B	
	PUSH H	
	CALL CopyMemoryUp	
	POP H	
	SHLD VAR_TOP	
	MOV H,B	
	MOV L,C	
	SHLD VAR_ARRAY_BASE	
InitVarLoop:
	DCX H	
	MVI M,00h	
	RST 4	
	JNZ InitVarLoop	
	POP D	
	MOV M,E	
	INX H	
	MOV M,D	
	INX H	
L0782:	XCHG	
	POP H	
	RET	
AlreadyAllocd:
	STA FACCUM+3	;A was set to zero at 075A.
	POP H	
	RET	
GetArrayVar:
	PUSH B	
	LDA DIM_OR_EVAL	
	PUSH PSW	
	CALL GetSubscript	
	RST 01	; SyntaxCheck	
	DB 29h	;')'	
	POP PSW	
	STA DIM_OR_EVAL	
	XTHL	
	XCHG	
	DAD H	
	DAD H	
	PUSH H	
	LHLD VAR_ARRAY_BASE	
	DB 01h	;LXI B,....	
FindArray:
	POP B	
	DAD B	
	XCHG	
	PUSH H	
	LHLD VAR_TOP	
	RST 4	
	XCHG	
	POP D	
	JZ AllocArray	
	RST 6	
	XTHL	
	RST 4	
	POP H	
	RST 6	
	JNZ FindArray	
	LDA DIM_OR_EVAL	
	ORA A	
	MVI E,12h	
	JNZ Error	
L07BF:	POP D	
	DCX D	
	XTHL	
	RST 4	
	MVI E,10h	
	JNC Error	
	POP D	
	DAD D	
	POP D	
	XCHG	
	RET	
AllocArray:
	MOV M,E	
	INX H	
	MOV M,D	
	INX H	
	LXI D,002Ch	
	LDA DIM_OR_EVAL	
	ORA A	
	JZ L07E1
	POP D	
	PUSH D	
	INX D	
	INX D	
	INX D	
	INX D	
L07E1:	PUSH D	
	MOV M,E	
	INX H	
	MOV M,D	
	INX H	
	PUSH H	
	DAD D	
	CALL CheckEnoughMem	
	SHLD VAR_TOP	
	POP D	
InitElements:
	DCX H	
	MVI M,00h	
	RST 4	
	JNZ InitElements	
	JMP L07BF	
FWordToFloat:
	MOV D,B	
	MVI E,00h	
	MVI B,90h	;exponent=2^16
	JMP FCharToFloat+5	;
FAddOneHalf:
	LXI H,ONE_HALF	;Load BCDE with (float) 0.5.
FAddMem:
	CALL FLoadBCDEfromMem	
	JMP FAdd+2	
FSub:
	POP B	;Get lhs in BCDE.
	POP D	;
	CALL FNegate	;Negate rhs and slimily
	DB 21h	;LXI H,....	;LXI into FAdd + 2.
FAdd:
	POP B	;Get lhs in BCDE.
	POP D	;
	MOV A,B	;If lhs==0 then we don't need
	ORA A	;to do anything and can just
	RZ	;exit.
	LDA FACCUM+3	;If rhs==0 then exit via a copy
	ORA A	;of lhs to FACCUM.
	JZ FLoadFromBCDE	;
	SUB B	;A=rhs.exponent-lhs.exponent.
	JNC L082C	;If rhs' exponent >= lhs'exponent, jump ahead.
	CMA	;Two's complement the exponent
	INR A	;difference, so it's correct.
	XCHG	;
	CALL FPush	;Push old rhs
	XCHG	;
	CALL FLoadFromBCDE	;rhs = old lhs
	POP B	;lhs = old rhs.
	POP D	;
L082C:	PUSH PSW	;Preserve exponent diff
	CALL FUnpackMantissas	
	MOV H,A	;H=sign relationship
	POP PSW	;A=exponent diff.
	CALL FMantissaRtMult	;Shift lhs mantissa right by (exponent diff) places.
	ORA H	;A=0 after last call, so this tests
	LXI H,FACCUM	;the sign relationship.
	JP FSubMantissas	;Jump ahead if we need to subtract.
	CALL FAddMantissas	;
	JNC FRoundUp	;Jump ahead if that didn't overflow.
	INX H	;Flip the sign in FTEMP_SIGN.
	INR M	; 
	JZ Overflow	;Error out if exponent overflowed.
	CALL FMantissaRtOnce;Shift mantissa one place right
	JMP FRoundUp	;Jump ahead.
FSubMantissas:
	XRA A	;B=0-B
	SUB B	;
	MOV B,A	;
	MOV A,M	;E=(FACCUM)-E
	SBB E	;
	MOV E,A	;
	INX H	;
	MOV A,M	;D=(FACCUM+1)-D
	SBB D	
	MOV D,A	
	INX H	
	MOV A,M	;C=(FACCUM+2)-C
	SBB C	;
	MOV C,A	;
FNormalise:
	CC FNegateInt	; 
 	MVI H,00h	;
	MOV A,C	;Test most-significant bit of mantissa
	ORA A	;and jump ahead if it's 1.
	JM FRoundUp	;
NormLoop:
	CPI 0E0h	;If we've shifted 32 times,
	JZ FZero	;then the number is 0.
	DCR H	;
	MOV A,B	;Left-shift extra mantissa byte
	ADD A	; 
	MOV B,A	; 
	CALL FMantissaLeft	;Left-shift mantissa.
	MOV A,H	;
	JP NormLoop	;Loop
	LXI H,FACCUM+3	;
	ADD M	;
	MOV M,A	;Since A was a -ve number, that certainly should
	JNC FZero	;have carried, hence the extra check for zero.
	RZ	;?why?
FRoundUp:
	MOV A,B	;A=extra mantissa byte
	LXI H,FACCUM+3	;
	ORA A	;If bit 7 of the extra mantissa byte
	CM FMantissaInc	;is set, then round up the mantissa.
	MOV B,M	;B=exponent
	INX H	;
	MOV A,M	;A=FTEMP_SIGN
	ANI 80h	;
	XRA C	;Bit 7 of C is always 1. Thi
	MOV C,A	;
	JMP FLoadFromBCDE	;Exit via copying BCDE to FACCUM.
FMantissaLeft:
	MOV A,E	
	RAL	
	MOV E,A	
	MOV A,D	
	RAL	
	MOV D,A	
	MOV A,C	
	ADC A	
	MOV C,A	
	RET	
FMantissaInc:
	INR E	
	RNZ	
	INR D	
	RNZ	
	INR C	
	RNZ	
	MVI C,80h	;Mantissa overflowed to zero, so set it
	INR M	;to 1 and increment the exponent.
	RNZ	;And if the exponent overflows...
Overflow:
	MVI E,0Ah	
	JMP Error	
FAddMantissas:
	MOV A,M	
	ADD E	
	MOV E,A	
	INX H	
	MOV A,M	
	ADC D	
	MOV D,A	
	INX H	
	MOV A,M	
	ADC C	
	MOV C,A	
	RET	
FNegateInt:
	LXI H,FTEMP	
	MOV A,M	
	CMA	
	MOV M,A	
	XRA A	
	MOV L,A	
	SUB B	
	MOV B,A	
	MOV A,L	
	SBB E	
	MOV E,A	
	MOV A,L	
	SBB D	
	MOV D,A	
	MOV A,L	
	SBB C	
	MOV C,A	
	RET	
FMantissaRtMult:
	MVI B,00h	;Initialise extra mantissa byte
	INR A	
	MOV L,A	
RtMultLoop:
	XRA A	
	DCR L	
	RZ	
	CALL FMantissaRtOnce	
	JMP RtMultLoop	
FMantissaRtOnce:
	MOV A,C	
	RAR	
	MOV C,A	
	MOV A,D	
	RAR	
	MOV D,A	
	MOV A,E	
	RAR	
	MOV E,A	
	MOV A,B	;NB: B is the extra
	RAR	;mantissa byte.
	MOV B,A	;
	RET	;
FMul:
	POP B	;Get lhs in BCDE
	POP D	;
	RST 05	; FTestSign	;If rhs==0 then exit
	RZ	;
	MVI L,00h	;L=0 to signify exponent add
	CALL FExponentAdd	
	MOV A,C	
	STA FMulInnerLoop+13	
	XCHG	
	SHLD FMulInnerLoop+8	
	LXI B,0000h	
	MOV D,B	
	MOV E,B	
	LXI H,FNormalise+3	
	PUSH H	
	LXI H,FMulOuterLoop	
	PUSH H	
	PUSH H	
	LXI H,FACCUM	
FMulOuterLoop:
	MOV A,M	;A=FACCUM mantissa byte
	INX H	;
	PUSH H	;Preserve FACCUM ptr
	MVI L,08h	;8 bits to do
FMulInnerLoop:
	RAR	;Test lowest bit of mantissa byte
	MOV H,A	;Preserve mantissa byte
	MOV A,C	;A=result mantissa's high byte
	JNC L0919	;If that bit of multiplicand was 0, then skip over adding mantissas.
	PUSH H	;
	LXI H,0000h	;
	DAD D	;
	POP D	;
	ACI 00	;A=result mantissa high byte. This gets back to C
	XCHG	;in the call to FMantissaRtOnce+1.
L0919:	CALL FMantissaRtOnce+1	
	DCR L	
	MOV A,H	;Restore mantissa byte and
	JNZ FMulInnerLoop	;jump back if L is not yet 0.
PopHLandReturn:
	POP H	;Restore FACCUM ptr
	RET	;Return to FMulOuterLoop, or if finished that then exit to FNormalise
FDivByTen:
	CALL FPush	;
	LXI B,8420h	;BCDE=(float)10;
	LXI D,0000h	
	CALL FLoadFromBCDE	
FDiv:
	POP B	 
	POP D	
	RST 05	; FTestSign	 
	JZ DivideByZero	
	MVI L,0FFh	 
	CALL FExponentAdd	
	INR M	 
	INR M	
	DCX H	
	MOV A,M	
	STA L095F+1	
	DCX H	
	MOV A,M	
	STA L095F-3	
	DCX H	
	MOV A,M	
	STA L095F-7	
	MOV B,C	
	XCHG	
	XRA A	
	MOV C,A	
	MOV D,A	
	MOV E,A	
	STA L095F+4	
FDivLoop:
	PUSH H	
	PUSH B	
	MOV A,L	
	SUI 00h	
	MOV L,A	
	MOV A,H	
	SBI 00	
	MOV H,A	
	MOV A,B	
L095F:	SBI 00	
	MOV B,A	
	MVI A,00h	
	SBI 00	
	CMC	
	JNC L0971	
	STA L095F+4h	
	POP PSW	
	POP PSW	
	STC	
	DB 0D2h	;JNC ....	
L0971:	POP B	
	POP H	
	MOV A,C	
	INR A	
	DCR A	
	RAR	
	JM FRoundUp+1	
	RAL	
	CALL FMantissaLeft	
	DAD H	
	MOV A,B	
	RAL	
	MOV B,A	
	LDA L095F+4h	
	RAL	
	STA L095F+4h	
	MOV A,C	
	ORA D	
	ORA E	
	JNZ FDivLoop	
	PUSH H	
	LXI H,FACCUM+3	
	DCR M	
	POP H	
	JNZ FDivLoop	
	JMP Overflow	
FExponentAdd:
	MOV A,B	 
	ORA A	
	JZ FExponentAdd+31	
	MOV A,L	;A=0 for add, FF for subtract.
	LXI H,FACCUM+3	;
	XRA M	;XOR with FAccum's exponent.
	ADD B	;Add exponents
	MOV B,A	;
	RAR	;Carry (after the add) into bit 7.
	XRA B	;XOR with old bit 7.
	MOV A,B	;
	JP FExponentAdd+30	;If
	ADI 80h	 
	MOV M,A	 
	JZ PopHLandReturn	 
	CALL FUnpackMantissas	
	MOV M,A	
	DCX H	
	RET	
	ORA A	
	POP H	;Ignore return address so we'll end
	JM Overflow	
FZero:	XRA A	
	STA FACCUM+3	
	RET	
FMulByTen:
	CALL FCopyToBCDE	
	MOV A,B	
	ORA A	
	RZ	
	ADI 02	
	JC Overflow	
	MOV B,A	
	CALL FAdd+2	
	LXI H,FACCUM+3	
	INR M	
	RNZ	
	JMP Overflow	
FTestSign_tail:
	LDA FACCUM+2	
	DB 0FEh	
InvSignToInt:
	CMA	
SignToInt:
	RAL	
	SBB A	
	RNZ	
	INR A	
	RET	
Sgn:
	RST 05	; FTestSign	
FCharToFloat:
	MVI B,88h	;ie 2^8
	LXI D,0000h	
	LXI H,FACCUM+3	
	MOV C,A	
	MOV M,B	
	MVI B,00h	
	INX H	
	MVI M,80h	
	RAL	
	JMP FNormalise	
Abs:
	RST 05	; FTestSign	
	RP	
FNegate:
	LXI H,FACCUM+2	
	MOV A,M	
	XRI 80h	
	MOV M,A	
	RET	
FPush:
	XCHG	
	LHLD FACCUM	
	XTHL	
	PUSH H	
	LHLD FACCUM+2	
	XTHL	
	PUSH H	
	XCHG	
	RET	
FLoadFromMem:
	CALL FLoadBCDEfromMem	
FLoadFromBCDE:
	XCHG	
	SHLD FACCUM	
	MOV H,B	
	MOV L,C	
	SHLD FACCUM+2	
	XCHG	
	RET	
FCopyToBCDE:
	LXI H,FACCUM	
FLoadBCDEfromMem:
	MOV E,M	
	INX H	
	MOV D,M	
	INX H	
	MOV C,M	
	INX H	
	MOV B,M	
IncHLReturn:
	INX H	
	RET	
FCopyToMem:
	LXI D,FACCUM	
	MVI B,04h	
FCopyLoop:
	LDAX D	
	MOV M,A	
	INX D	
	INX H	
	DCR B	
	JNZ FCopyLoop	
	RET	
FUnpackMantissas:
	LXI H,FACCUM+2	
	MOV A,M	;
	RLC	;Move FACCUM's sign to bit 0.
	STC	;Set MSB of FACCUM mantissa,
	RAR	;FACCUM's sign is now in carry.
	MOV M,A	;
	CMC	;Negate FACCUM's sign.
	RAR	;Bit 7 of A is now FACCUM's sign.
	INX H	;Store negated FACCUM sign at FTEMP_SIGN.
	INX H	;
	MOV M,A	;
	MOV A,C	;
	RLC	;Set MSB of BCDE mantissa,
	STC	;BCDE's sign is now in carry.
	RAR	;
	MOV C,A	;
	RAR	;Bit 7 of A is now BCDE's sign
	XRA M	;XORed with FTEMP_SIGN.
	RET	;
FCompare:
	MOV A,B	 
	ORA A	
	JZ FTestSign	
	LXI H,InvSignToInt	 
	PUSH H	
	RST 05	; FTestSign	
	MOV A,C	
	RZ	
	LXI H,FACCUM+2	
	XRA M	
	MOV A,C	
	RM	
	CALL FIsEqual	
	RAR	
	XRA C	
	RET	
FIsEqual:
	INX H	
	MOV A,B	
	CMP M	
	RNZ	
	DCX H	
	MOV A,C	
	CMP M	
	RNZ	
	DCX H	
	MOV A,D	
	CMP M	
	RNZ	
	DCX H	
	MOV A,E	
	SUB M	
	RNZ	;
	POP H	;Lose 0A5E
	POP H	;Lose 09DE
	RET	;Return to caller
FAsInteger:
	MOV B,A	;
	MOV C,A	
	MOV D,A	
	MOV E,A	
	ORA A	
	RZ	
	PUSH H	
	CALL FCopyToBCDE	
	CALL FUnpackMantissas	
	XRA M	;Get sign back
	MOV H,A	
	CM FMantissaDec	
	MVI A,98h	
	SUB B	;by (24-exponent) places?
	CALL FMantissaRtMult	;WHY?
	MOV A,H	
	RAL	
	CC FMantissaInc	
	MVI B,00h	;Needed for FNegateInt.
	CC FNegateInt	
	POP H	
	RET	
FMantissaDec:
	DCX D	;DE--
	MOV A,D	;If DE!=FFFF...
	ANA E	;
	INR A	;
	RNZ	;... then return
	DCR C	;C--
	RET	;
Int:
	LXI H,FACCUM+3	;
	MOV A,M	;
	CPI 98h	;
	RNC	;
	CALL FAsInteger	;
	MVI M,98h	;
	MOV A,C	;
	RAL	;
	JMP FNormalise	;
FIn:
	DCX H	;
	CALL FZero	;
	MOV B,A	;B=count of fractional digits
	MOV D,A	;D=exponent sign
	MOV E,A	;E=exponent
	CMA	;C=decimal_point_done (FF for no, 00 for yes)
	MOV C,A	;
FInLoop:
	RST 02	;RST NextChar	
	JC ProcessDigit	
	CPI '.'	
	JZ L0AE4	
	CPI 'E'	
	JNZ ScaleResult	
GetExponent:
	RST 02	;RST NextChar	
	DCR D	
	CPI 99h	;KWID_MINUS	
	JZ NextExponentDigit	
	INR D	
	CPI 98h	;KWID_PLUS	
	JZ NextExponentDigit	
	DCX H	
NextExponentDigit:
	RST 02	;RST NextChar	
	JC DoExponentDigit	
	INR D	
	JNZ ScaleResult	
	XRA A	
	SUB E	
	MOV E,A	
	INR C	;C was FF, so here it
L0AE4:
	INR C	;becomes 01.
	JZ FInLoop	;If C is now zero
ScaleResult:
	PUSH H	
	MOV A,E	
	SUB B	
DecimalLoop:
	CP DecimalShiftUp	
	JP DecimalLoopEnd	
	PUSH PSW	
	CALL FDivByTen	
	POP PSW	
	INR A	
DecimalLoopEnd:
	JNZ DecimalLoop	
	POP H	
	RET	
DecimalShiftUp:
	RZ	
	PUSH PSW	
	CALL FMulByTen	
	POP PSW	
	DCR A	
	RET	
ProcessDigit:
	PUSH D	
	MOV D,A	
	MOV A,B	
	ADC C	
	MOV B,A	
	PUSH B	
	PUSH H	
	PUSH D	
	CALL FMulByTen	
	POP PSW	
	SUI '0'	
	CALL FPush	
	CALL FCharToFloat	
	POP B	
	POP D	
	CALL FAdd+2	
	POP H	
	POP B	
	POP D	
	JMP FInLoop	
DoExponentDigit:
	MOV A,E	
	RLC	
	RLC	
	ADD E	
	RLC	
	ADD M	
	SUI '0'	
	MOV E,A	
	JMP NextExponentDigit	
PrintIN:
	PUSH H	
	LXI H,szIn	
	CALL PrintString	
	POP H	
PrintInt:
	XCHG	;DE=integer
	XRA A	;A=0 (ends up in C)
	MVI B,98h	;B (ie exponent) = 24
	CALL FCharToFloat+5	
	LXI H,PrintString-1	
	PUSH H	
FOut:
	LXI H,FBUFFER	
	PUSH H	
	RST 05	; FTestSign	
	MVI M,' '	
	JP DoZero	
	MVI M,'-'	
DoZero:
	INX H	
	MVI M,'0'	
	JZ NullTerm-3	
	PUSH H	
	CM FNegate	
	XRA A	
	PUSH PSW	
	CALL ToUnder1000000	
ToOver100000:
	LXI B,9143h	;BCDE=(float)100,000.
	LXI D,4FF8h	;
	CALL FCompare	;If FACCUM >= 100,000
Fix2zJ:	JPO PrepareToPrint	;then jump to PrepareToPrint.
	POP PSW	;A=DecExpAdj
	CALL DecimalShiftUp+1	;FACCUM*=10; DecExpAdj--;
	PUSH PSW	;
	JMP ToOver100000	
L0B71:
	CALL FDivByTen	
	POP PSW	
	INR A	;DecExpAdj++;
	PUSH PSW	
	CALL ToUnder1000000	
PrepareToPrint:
	CALL FAddOneHalf	
	INR A	
	CALL FAsInteger	
	CALL FLoadFromBCDE	
	LXI B,0206h	
	POP PSW	;A=DecExpAdj+6.
	ADD C	;
	JM L0B95	;If A<1 or A>6 Then goto fixme.
	CPI 07h	;
	JNC L0B95	;
	INR A	;
	MOV B,A	;
	MVI A,01h	;A=1, indicating scientific notation.
L0B95:
	DCR A	;
	POP H	;HL=output buffer
	PUSH PSW	;Preserve decimal exponent adjustment (and preserve zero flag used to indicate scientific notation wanted).
	LXI D,DECIMAL_POWERS	
NextDigit:
	DCR B	
	MVI M,'.'	
	CZ IncHLReturn	;0A27 just happens to inc HL and RET.
	PUSH B	;
	PUSH H	;
	PUSH D	;DE=>decimal power
	CALL FCopyToBCDE	;Store BCDE to FACCUM.
	POP H	;HL=>decimal power.
	MVI B,'0'-1	;
DigitLoop:
	INR B	;
	MOV A,E	;
	SUB M	;
	MOV E,A	;
	INX H	;
	MOV A,D	;
	SBB M	;
	MOV D,A	;
	INX H	;
	MOV A,C	;
	SBB M	;
	MOV C,A	;
	DCX H	;
	DCX H	;
	JNC DigitLoop	;
	CALL FAddMantissas	;
	INX H	;???
	CALL FLoadFromBCDE	;
	XCHG	;
	POP H	;HL=output buffer
	MOV M,B	;
	INX H	;
	POP B	;B=decimal point place
	DCR C	;C=digits remaining, minus one.
	JNZ NextDigit	;
	DCR B	;
	JZ L0BDB	;
L0BCF:
	DCX H	;
	MOV A,M	;
	CPI '0'	;
	JZ L0BCF	;
	CPI '.'	;
	CNZ IncHLReturn	;
L0BDB:
	POP PSW	;
	JZ NullTerm	;
	MVI M,'E'	;Write 'E'
	INX H	;
	MVI M,'+'	;Write '+' or '-'
	JP L0BEB	;
	MVI M,'-'	;Write '-' if it's negative, also
	CMA	;two's complement the decimal exponent
	INR A	;so printing it will work.
L0BEB:
	MVI B,'0'-1	;
ExpDigitLoop:
	INR B	;
	SUI 0Ah	;
	JNC ExpDigitLoop	;
	ADI 3Ah	;Adding '0'+10 gives us the 2nd digit
	INX H	;of the exponent.
	MOV M,B	;Write first digit.
 	INX H	;
	MOV M,A	;Write second digit of exponent.
	INX H	;
NullTerm:
	MOV M,C	;Null byte terminator.
	POP H	;
	RET	;
ToUnder1000000:
	LXI B,9474h	;
	LXI D,23F7h	;
	CALL FCompare	;
	POP H	;
Fix1zJ: JPO L0B71	;
	PCHL	;
ONE_HALF:
	DB 0,0,0,80h	; DD 0.5	 
DECIMAL_POWERS:
	DB 0A0h,86h,01h	; DT 100000	 
	DB  10h,27h,00h	; DT 10000	 
	DB 0E8h,03h,00h	; DT 1000	 
	DB  64h,00h,00h	; DT 100	 
	DB  0Ah,00h,00h	; DT 10	 
	DB  01h,00h,00h	; DT 1	 
Sqr:
	RST 05	; FTestSign	;
	JM FunctionCallError;
	RZ	;
	LXI H,FACCUM+3	;
	MOV A,M	;
	RAR	;
	PUSH PSW	;
	PUSH H	;
	MVI A,40h	;
	RAL	;
	MOV M,A	;
	LXI H,FBUFFER	;
	CALL FCopyToMem	;
	MVI A,04h	;
SqrLoop:
	PUSH PSW	;
	CALL FPush	;
	LXI H,FBUFFER	;
	CALL FLoadBCDEfromMem	
	CALL FDiv+2	
	POP B	
	POP D	
	CALL FAdd+2	
	LXI B,8000h	
	MOV D,C	
	MOV E,C	
	CALL FMul+2	
	POP PSW	
	DCR A	
	JNZ SqrLoop	
	POP H	
	POP PSW	
	ADI 0C0h	
	ADD M	
	MOV M,A	
	RET	
Rnd:
	RST 05	; FTestSign	
	JM L0C7C	
	LXI H,RND_SEED	
	CALL FLoadFromMem	
	RZ	
	LXI B,9835h	
	LXI D,447Ah	
	CALL FMul+2	
	LXI B,6828h	
	LXI D,0B146h	
	CALL FAdd+2	
L0C7C:	CALL FCopyToBCDE	
	MOV A,E	
	MOV E,C	
	MOV C,A	
	MVI M,80h	
	DCX H	
	MOV B,M	
	MVI M,80h	
	CALL FNormalise+3	
	LXI H,RND_SEED	
	JMP FCopyToMem	
RND_SEED:
	DB 52h,0C7h,4Fh,80h	
Sin:
	CALL FPush	;ush x
	LXI B,8349h	;CDE=2p
	LXI D,0FDBh	;
	CALL FLoadFromBCDE	;hs = 2p
	POP B	;hs = x
	POP D	;
	CALL FDiv+2	;=x/2p
	CALL FPush	;
	CALL Int	;hs = INT(u)
	POP B	;hs = u
	POP D	;
	CALL FSub+2	;=u-INT(u)
	LXI B,7F00h	;CDE=0.25
	MOV D,C	;
	MOV E,C	;
	CALL FSub+2	;
	RST 05	; FTestSign	;
	STC	;set carry (ie no later negate)
	JP NegateIfPositive	;
	CALL FAddOneHalf	;
	RST 05	;
	ORA A	;resets carry (ie later negate)
NegateIfPositive:
	PUSH PSW	;
	CP FNegate	;
	LXI B,7F00h	;CDE=0.25
	MOV D,C	;
	MOV E,C	;
	CALL FAdd+2	;
	POP PSW	;
	CNC FNegate	;
	CALL FPush	;
	CALL FCopyToBCDE	;
	CALL FMul+2	; = x*x
	CALL FPush	;ush x*x
	LXI H,TAYLOR_SERIES	;
	CALL FLoadFromMem	;
	POP B	;
	POP D	;
	MVI A,04h	;
TaylorLoop:
	PUSH PSW	;ush #terms remaining
	PUSH D	;ush BCDE
	PUSH B	;
	PUSH H	;
	CALL FMul+2	;
	POP H	;
	CALL FLoadBCDEfromMem	;
	PUSH H	;
	CALL FAdd+2	;
	POP H	;
	POP B	;
	POP D	;
	POP PSW	;op #terms remaining into A.
	DCR A	;ecrement #terms and loop back if not
	JNZ TaylorLoop	;one all 4 of them.
	JMP FMul	;
TAYLOR_SERIES:
	DB 0BAh,0D7h, 1Eh,86h	;DD 39.710670	 
	DB  64h, 26h, 99h,87h	;DD -76.574982	 
	DB  58h, 34h, 23h,87h	;DD 81.602234	 
	DB 0E0h, 5Dh,0A5h,86h	;DD -41.341675	 
	DB 0DAh, 0Fh, 49h,83h	;DD 6.283185	 
L0D17:
	DB 0,0,0,0,0,0,0,0,0,0

Init:	LXI H,0F1Ah	; *** STACK_TOP RELOCATE
	SPHL	;
	SHLD STACK_TOP	;
	IN 01	;
	MVI C,0FFh	;
	LXI D,ConfigIOcode	;
	PUSH D	;
	LDA 0FFFh	; *** RELOCATE
	MOV B,A	;
	IN 0FFh	;
	RAR	;
	JC L0D42-1	;
	ANI 0Ch	;
	JZ L0D42	;
	MVI B,10h	;
	MOV A,B	;
L0D42:	STA L0D8D-1	;
	IN 0FFh	;
	RAL	;
	RAL	;
	MVI B,20h	;
L0D4B:	LXI D,0CA02h	;
	RC	;
	RAL	;
	MOV B,E	;
	DCR E	;
	RC	;
	RAL	;
	JC L0D6F	;
	MOV B,E	;
	LXI D,0C280h	;
	RAL	;
	RNC	;
	RAL	;
	MVI A,03h	;
	CALL L0D8B	;
	DCR A	;
	ADC A	;
	ADD A	;
	ADD A	;
	INR A	;
	CALL L0D8B	;
	STC	;
	JMP L0D4B	;
L0D6F:	XRA A	;
	CALL L0D8B	;
	CALL L0D87	;
	CALL L0D87	;
	MOV C,E	;
	CMA	;
	CALL L0D87	;
	MVI A,04h	;
	DCR M	;
	CALL L0D8B	;
	DCR M	;
	DCR M	;
	DCR M	;
L0D87:	LXI H,L0D8D-1	;
	INR M	;
L0D8B:	OUT 00	;
L0D8D:	RET	;
ConfigIOcode:
	MOV H,D	;
	MOV L,B	;
	SHLD InputChar+3	;
	MOV A,H	;
	ANI 0C8h	;
	MOV H,A	;
	SHLD TestBreakKey+3	;
	XCHG	;
	SHLD WaitTermReady+3	;
	LDA L0D8D-1	;
	STA InputChar+1	;
	STA TestBreakKey+1	;
	INR A	;
	STA InputChar+8	;
	ADD C	;
	STA WaitTermReady+1	;
	INR A	;
	STA InputChar-2	;
	LXI H,0FFFFh	;
	SHLD CURRENT_LINE	;
	CALL NewLine	;
	LXI H,szMemorySize	;
	CALL PrintString	
	CALL InputLineWith	
	RST 02	;RST NextChar	
	ORA A	
	JNZ L0DDE	
	LXI H,UnusedMemory	
FindMemTopLoop:
	INX H	
	MVI A,37h	
	MOV M,A	
	CMP M	
	JNZ DoneMemSize	
	DCR A	
	MOV M,A	
	CMP M	
	JZ FindMemTopLoop	
	JMP DoneMemSize	
L0DDE:
	LXI H,LINE_BUFFER	
	CALL LineNumberFromStr	
	ORA A	
	JNZ SyntaxError	
	XCHG	
	DCX H	
DoneMemSize:
	DCX H	
	PUSH H	
GetTerminalWidth:
	LXI H,szTerminalWidth	
	CALL PrintString	
	CALL InputLineWith	
	RST 02	;RST NextChar	
	ORA A	
	JZ DoOptionalFns	
	LXI H,LINE_BUFFER	
	CALL LineNumberFromStr	
	MOV A,D	
	ORA A	
	JNZ GetTerminalWidth	
	MOV A,E	
	CPI 10h	
	JC GetTerminalWidth	
	STA OutChar_tail+1	
CalcTabBrkSize:
	SUI 0Eh	
	JNC CalcTabBrkSize	
	ADI 1Ch	
	CMA	
	INR A	
	ADD E	
	STA ToNextTabBreak+4	
DoOptionalFns:
	LXI H,OPT_FN_DESCS	
OptionalFnsLoop:
	RST 6	
	LXI D,szWantSin	
	RST 4	
	JZ L0E32	
	RST 6	
	XTHL	
	CALL PrintString	
	CALL InputLineWith	
	RST 02	;RST NextChar	
	POP H	
	CPI 'Y'	
L0E32:	POP D	
	JZ InitProgramBase	
	CPI 'N'	
	JNZ DoOptionalFns	
	RST 6	
	XTHL	
	LXI D,FunctionCallError	
	MOV M,E	
	INX H	
	MOV M,D	
	POP H	
	JMP OptionalFnsLoop	
InitProgramBase:
	XCHG	
	MVI M,00h	
	INX H	
	SHLD PROGRAM_BASE	
	XTHL	
	LXI D,0F1Ah	; *** RELOCATE STACK_TOP	
	RST 4	
	JC OutOfMemory	
	POP D	
	SPHL	
	SHLD STACK_TOP	
	XCHG	
	CALL CheckEnoughMem	
	MOV A,E	
	SUB L	
	MOV L,A	
	MOV A,D	
	SBB H	
	MOV H,A	
	LXI B,0FFF0h	
	DAD B	
	CALL NewLine	
	CALL PrintInt	
	LXI H,szVersionInfo	
	CALL PrintString	
	LXI H,PrintString	
	SHLD Main+4	
	CALL New+1	
	LXI H,Main	
	SHLD Start+2	
	PCHL	

OPT_FN_DESCS:
	DW L0D17	
 	DW szWantSin	
 	DW KW_INLINE_FNS+12	
 	DW Sin	
 	DW szWantRnd	
 	DW KW_INLINE_FNS+10	
 	DW Rnd	
 	DW szWantSqr	
 	DW KW_INLINE_FNS+8	

 	DW Sqr	

szWantSin:
	DC "WANT SIN"
	DB 0
szWantRnd:	
	DC "WANT RND"
	DB 0
szWantSqr:	
	DC "WANT SQR"
	DB 0

szTerminalWidth:
	DC "TERMINAL WIDTH"
	DB 0

szVersionInfo:	
	DC " BYTES FREE"
	DB 13,13
	DC "BASIC VERSION 3.2"
	DB 13
	DC "[4K VERSION]"
	DB 13,0

szMemorySize:
	DC "MEMORY SIZE"
	DB 0

UnusedMemory:	DB 00, 00

	.dephase
BIN_End:	


                ;--------------------------------------------------------------------------
                ;
                ;  fixPrty - Fix Parity Bit
                ;	This routine will fix the parity bit in the status flags and leave
                ;	all other status flags unaffected IF the instruction to fix
                ;	fix modifed the accumulator. For example, subtract, add, inc,
                ;	dec, etc., will be properly adjusted. However, for compare
                ;	instructions, parity is computed on the result of the compare
                ;	subtraction, not the value in A.
                ;
                ;  8080 status flags in memory (from PUSH PSW)
                ;     7  6  5  4  3  2  1  0
                ;     S  Z  0  AC 0  P  1  C
                ;
                ;--------------------------------------------------------------------------
fixPrty:push	b		;save bc for later restore
        push	psw		;move a and status flags into b,c
        pop	b		;   (parity bit in c is wrong)
        ora	a		;real parity flag now correct for 8080
        mov	a,c		;a=flags with parity wrong
        jpe	setPrty		;if parity even, go set parity flag
        ani	0fbh		;otherwise, clear the parity flag
        jmp	fixExit
setPrty:ori	4		;set the parity flag
fixExit:mov	c,a		;c=final 8080 sbb status flags
        push	b		;put a and flags on stack
        pop	psw		;and put them back in a and in flags
        pop	b		;restore bc
        ret

	.z80

ZeroPage:
        DS 256

bdos    equ 5
ctrlz   equ 3

SaveZP: ; Copy Zero Page -> Save Area
        ld hl, 0
        ld de, ZeroPage
        ld bc,  256
MovMem: ld a, (hl)
        ld (de), a
        inc hl
        inc de
        dec bc
        ld a, b
        or c
        jp nz,MovMem
        ret

RestoreZP: ; Copy Save Area -> Zero Page
        ld hl, ZeroPage
        ld de, 0
        ld bc,  256
        jp MovMem

SwapZP: ; Swap Zero Page <-> Save Area
        ld hl, 0
        ld de, ZeroPage
        ld bc,  256
svzp2:  ld a, (hl)
        ld (zpswp), a
        ld a, (de)
        ld (hl), a
        ld a, (zpswp)
        ld (de), a
        inc hl
        inc de
        dec bc
        ld a, b
        or c
        jp nz,svzp2
        ret
zpswp:  db 0;         

MoveBASIC: ; move basic to original location at 0000h
	ld bc, BIN_End-BIN_Start
        ld hl, BIN_Start
        ld de, 0
        jp MovMem
	
Wait1TermReady:	; replacement for WaitTermReady
	ld a, 0 ; holds modified value during config 
	ld a, 0 ; holds modified value during config
	pop af
	jp CPMOutChar
Wait2TermReady:

Input1Char:	; replacement for InputChar
	ld a, 0 ; holds modified value during config 
	ld a, 0 ; holds modified value during config
	jp CPMInChar
Input2Char:

Test1BreakKey:
	ld a, 0 ; holds modified value during config 
	ld a, 0 ; holds modified value during config
	jp CPMBrkChar
Test2BreakKey:

CPMBrkChar:	
	push hl
	push de
	push bc
	call SwapZP
	ld c,6 		; bdos call read console non blocking
	ld e,255
	call bdos
        ld (ch), a
	call SwapZP
        ld a,(ch)
	pop bc
	pop de
	pop hl
	cp ctrlz
	jp z,Stop
	ret

CPMOutChar:     
        and 7fh
        ret z
        ld (ch), a
	push bc
	push de
	push hl
	call SwapZP
        ld a,(ch)
        ld e,a
        ld c,2		; BDOS Console Output
        call bdos
	call SwapZP
	pop hl
	pop de
	pop bc	
	ld a,(ch)
	or a
	ret

CPMInChar:     
	push bc
	push de
	push hl
	call SwapZP
	ld a, (tapes)	; check if input from file
	cp 1
	jp nz, cpmin1	; no, continue to keyboard input
	call TAPIN	; yes, read from file
	cp 3
	jp nz, cpmin2	; not ^C, so process char read from file as it was read from keyboard 
	ld a, 0		; yes, is ^C so terminate reading
	ld (tapes), a
	call closef
	ld a,3		; return 
	jp cpmin2
cpmin1: ld c,6		; BDOS Direct Console I/O, read nonblocking
        ld e,255
        call 5
	or a
	jp z, cpmin1
	cp 'z'+1
	jp nc,cpmin2
	cp 'a'
	jp c,cpmin2
	sub 'a'-'A'
cpmin2: ld (ch), a
	call SwapZP
	pop hl
	pop de
	pop bc
	ld a, (ch)
	cp 3		; Pressed ^C ?
	jp z, Stop
	and 7fh
	ret
	
RAMTOP: DW 0 ; RAM Top addr (first unavailable addr) 	
tapes:  db 0 ; 0=i/o from kbs/console, 1=input from cpm file, 2=output to cpm file

PatchBASIC:
        ; Patch char input
        ld hl, Input1Char
        ld de, InputChar
        ld bc,  Input2Char-Input1Char
        call MovMem
        ; Patch char output
        ld hl, Wait1TermReady
        ld de, WaitTermReady
        ld bc,  Wait2TermReady-Wait1TermReady
        call MovMem
        ; Patch break char test
        ld hl, Test1BreakKey
        ld de, TestBreakKey
        ld bc,  Test2BreakKey-Test1BreakKey
        call MovMem
        ; Patch to fix 8080 flag usage (parity) that does not work in z80 cpu
        ; Patch 0C07    E2 0B71         Fix1zJ:	JPO L0B71	;
	ld a, 0c3h	; Jump opcode
	ld (Fix1zJ), a
	ld hl, Fix1z
	ld (Fix1zJ+1), hl
	; Patch 0B66    E2 0B7A         Fix2zJ:	JPO PrepareToPrint	;then jump to PrepareToPrint.
	ld a, 0c3h	; Jump opcode
	ld (Fix2zJ), a
	ld hl, Fix2z
	ld (Fix2zJ+1), hl
	; Patch backspace char handling
	ld a, 0c3h	; Jump opcode
	ld (InputNext), a
	ld hl, Input1Next
	ld (InputNext+1), hl
	; Patch keywords table address when using it to tokenize
	; LdKwTb1:LXI D,KEYWORDS-1	;
	; LdKwTb2:LXI D,KEYWORDS		
	ld hl, KeyWords2-1
	ld (LdKwTb1+1), hl
	ld hl, KeyWords2
	ld (LdKwTb2+1), hl
	; Patch to trap new tokens for save/load/system 
	; TrapTk: JNC SyntaxError	
	ld hl, ExecNewCommands
	ld (TrapTk+1), hl;
	; patch input to make sure ID error is setup
	; Input:	PUSH H	
	;		LHLD CURRENT_LINE -> call FixImp
	ld a, 0cdh	; call opcode
	ld (Input+1), a
	ld hl, FixImp
	ld (Input+2), hl
	; set default tape mode to none (input/output from kwyboard)
	ld a,0
	ld (tapes), a
	ret
	
Fix1z:  call fixPrty
	jp po, L0B71
	jp Fix1zJ+3
		
Fix2z:  call fixPrty
	jp po, PrepareToPrint
	jp Fix2zJ+3
	
FixImp: push af
	ld a, 'D'		; convert IO error in ID error
	ld (ID_IO_ERR_COD+1),a
	pop af
	ld hl,(CURRENT_LINE)
	ret
	
Input1Next:
	call InputChar	;
	cp 0dh	;
	jp z,TerminateInput	;
        cp 08h	;
	jp z,Back1space	;
	cp 32	;If < ' '
	jp c,InputNext	;or
	cp 7dh	;> '}'
	jp nc,InputNext	;then loop back.
	cp '@'	;
	jp z,ResetInput	;
	jp L035D

Back1space:
	ld a,b		; b=char count in line+1
	cp 1
	jp nz, bk1	
	ld a,0		; empty line, nothing to backspace
	jp InputNext
bk1:	push hl
	push de
	push bc
	call SwapZP
	ld a, 08h	; BackSpace
        ld e,a
        ld c,2		; BDOS Console Output
        call bdos
	ld a, ' '	; erase char
        ld e,a
        ld c,2		; BDOS Console Output
        call bdos
	call SwapZP
	pop bc
	pop de
	pop hl
	ld a, 08h	; BackSpace
	jp BackSpace	
	
ExecNewCommands:
	; was	TrapTk:	jp nc, SyntaxError
	jp c, TrapTk+3	; regular command, execute it
	; now check for new commands
	cp 26h		; load command
	jp z,Load
	cp 27h		; system command
	jp z,System
	jp SyntaxError	; not a new command -> proceed to syntax error
	
System:	RST 10h	;RST NextChar	
	ret nz	;if args syntax error
	jp CPMExit

Load: 	RST 10h	;RST NextChar	
	jp z, SyntaxError	;if no args syntax error
	cp '"'	
	jp nz, SyntaxError	;if arg is not string literal then systema error
	push bc
	push de
	push hl
	inc hl
	ld (NBYTES), hl		; save pointer to begin of filename
	call SwapZP
	ld de,(NBYTES)		; load pointer to begin of filename
	call OPENFR
	push af
	call SwapZP
	pop af
	pop hl
	pop de
	pop bc
	or a 
	jp nz, IOErr
	ld a,1
	ld (tapes), a
	jp FindNextStatement	; open file ok
IOErr:	ld a, 'O'		; convert ID error in IO error
	ld (ID_IO_ERR_COD+1),a
	ld e, 16h
	jp Error		; I/O error
	
;
; RSV-OPENF/CLOSEF FUNCTIONS FOR LOAD/SAVE FILE UNDER CPM 
;     RETURNS 0 ON OK, NOT ZERO ON I/O ERROR
;
        .Z80

CNTRLZ	EQU	1AH		;control-z (end-of-file mark)

TAPIN:	LD	A,(FCB)		;READ CHAR FROM FILE
	CP	255		;IF (FCB)=FF THERE IS NO FILE OPEN
	JP	Z,TAPBRK	;IF NO FILE OPEN END TAPE READ
	CALL	TYPE1		;GET CHAR FROM FILE C=CHAR, A=0 OK, A<>0 ERROR/EOF
	OR	A
	JP	NZ,TAPBRK	;IF ERROR/EOF->RETURN ^C TO CALLER
	LD	A,C
	CP      13
	RET	NZ		;RET IF CHAR FROM FILE NOT <CR>
        LD	C,6		;CHAR FROM FILE=<CR> -> CHECK KBD FOR ^C
        LD	E,255
        CALL    BDOS
        CP	3
        JP	Z,TAPBRK	;IF ^C PRESSED->RETURN ^C TO CALLER
        LD	A,13
	RET
TAPBRK:	LD	A,3
	RET	
        
CLOSEF: LD	A,(FCB)		;IF (FCB)=FF THERE IS NO FILE OPEN
	CP	255
	RET	Z
	CALL	CLOSFCB		;  ELSE CLOSE FILE IN FCB
CLRFCB:	LD	A,255
	LD	(FCB),A
	RET
        
OPENFR:	CALL	CONVERT		;convert file name.
	OR	A
	JP	NZ,TYPERR	;wild cards not allowed.
	CALL	OPENFCB		;open the file.
	CP	255
	JP	Z,TYPERR	;not there?
	LD	HL,NBYTES	;initialize byte counter.
	LD	(HL),0FFH	;set to read first sector.	
	LD 	A,0		;return A=0 -> OK
	RET
	
TYPE1:	LD	HL,NBYTES
TYPE2:	LD	A,(HL)		;have we written the entire sector?
	CP	128
	JP	C,TYPE3
	PUSH	HL		;yes, read in the next one.
	CALL	READFCB
	POP	HL
	OR	A
	JP	NZ,TYPERR2	;end or error?
	XOR	A		;ok, clear byte counter.
	LD	(HL),A
TYPE3:	INC	(HL)		;count this byte.
	LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
	CALL	ADDHL
	LD	A,(HL)
	LD      C,A
	CP	CNTRLZ		;end of file mark?
	JP	Z,TYPERR2
	LD 	A,0		;return A=0 -> OK
	RET			; C=CHAR READ
;
;   Get here on an end of file or read error or open error.
;
TYPERR2:CALL	CLOSFCB
TYPERR:	CALL	CLRFCB
  	LD	A,255		;eof found
        RET
;
;   Add (HL)=(HL)+(A)
;
ADDHL:	ADD	A,L
	LD	L,A
	RET	NC		;take care of any carry.
	INC	H
	RET	
;
;   Convert the name in (de) to (FCB).
;   Format a file name (convert * to '?', etc.). On return,
; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
; the position within the fcb for the name (either 0 or 16).
;
CONVERT:LD	HL,FCB
	LD	A,(DE)		;get first character of filename
	OR	A
	JP	NZ,CONVRT1
	LD	A,1		;error: empty filename
	RET
CONVRT1:SBC	A,'A'-1		;might be a drive name, convert to binary.
	LD	B,A		;and save.
	INC	DE		;check next character for a ':'.
	LD	A,(DE)
	CP	':'
	JP	Z,CONVRT2
	DEC	DE		;nope, move pointer back to the start of the line.
	LD	A,0             ;default drive
	LD	(HL),A
	JP	CONVRT3
CONVRT2:LD	(HL),B
	INC	DE
;
;   Convert the basic file name.
;
CONVRT3:LD	B,08H
CONVRT4:CALL	CHECK
	JP	Z,CONVRT8
	INC	HL
	CP	'*'		;note that an '*' will fill the remaining
	JP	NZ,CONVRT5	;field with '?'.
	LD	(HL),'?'
	JP	CONVRT6
CONVRT5:LD	(HL),A
	INC	DE
CONVRT6:DEC	B
	JP	NZ,CONVRT4
CONVRT7:CALL	CHECK		;get next delimiter.
	JP	Z,GETEXT
	INC	DE
	JP	CONVRT7
CONVRT8:INC	HL		;blank fill the file name.
	LD	(HL),' '
	DEC	B
	JP	NZ,CONVRT8
;
;   Get the extension and convert it.
;
GETEXT:	LD	B,03H
	CP	'.'
	JP	NZ,GETEXT5
	INC	DE
GETEXT1:CALL	CHECK
	JP	Z,GETEXT5
	INC	HL
	CP	'*'
	JP	NZ,GETEXT2
	LD	(HL),'?'
	JP	GETEXT3
GETEXT2:LD	(HL),A
	INC	DE
GETEXT3:DEC	B
	JP	NZ,GETEXT1
GETEXT4:CALL	CHECK
	JP	Z,GETEXT6
	INC	DE
	JP	GETEXT4
GETEXT5:INC	HL
	LD	(HL),' '
	DEC	B
	JP	NZ,GETEXT5
GETEXT6:LD	B,3
GETEXT7:INC	HL
	LD	(HL),0
	DEC	B
	JP	NZ,GETEXT7
;
; Check to see if this is an ambigeous file name specification.
; Set the (A) register to non zero if it is.
;
	LD	BC,11		;set name length.
	LD	HL,FCB	
GETEXT8:INC	HL
	LD	A,(HL)
	CP	'?'		;any question marks?
	JP	NZ,GETEXT9
	INC	B		;count them.
GETEXT9:DEC	C
	JP	NZ,GETEXT8
	LD	A,B
	OR	A
	RET     NZ		;do niot allow ? in filename
	LD 	A,(FCB)
	OR	A
	JP	Z,GETEXTA
	DEC	A
	LD	E,A
	LD	C,14		;DSKSEL
	CALL	BDOS		
	OR	A
	RET	NZ		;not ready?
GETEXTA:LD	DE,TBUFF
	LD	C,26		;SETDMA
	CALL 	BDOS
	RET	
;
; Check character at (DE) for legal command input. Note that the
; zero flag is set if the character is a delimiter.
;
CHECK:	LD	A,(DE)
	OR	A
	RET	Z
	CP	'='
	RET	Z
	CP	'_'
	RET	Z
	CP	'.'
	RET	Z
	CP	':'
	RET	Z
	CP	';'
	RET	Z
	CP	'<'
	RET	Z
	CP	'>'
	RET	Z
	CP	'"'	; close filename literal
	RET	Z
	RET	
;
;   Routine to open file at (FCB).
;
OPENFCB:XOR	A		;clear the record number byte at fcb+32
	LD	(FCB+32),A
	LD	DE,FCB
	LD	C,15
	CALL 	BDOS		;open file (error if file does not exist)
	RET
;
;   Routine to read file at (FCB).
;
READFCB:LD	DE,FCB
	LD	C,20
	CALL 	BDOS
	RET
;
;   Routine to close file at (FCB).
;
CLOSFCB:LD	DE,FCB
	LD	C,16
	CALL 	BDOS
	RET


;
; File control block setup by the CCP.
;
FCB	EQU	5CH		;default file control block.
TBUFF	EQU	80H		;i/o buffer and command line storage.
NBYTES:	DW	0		;byte counter used by tape command
CH:	DB	0		;save char

	
KeyWords2:	
	DC "END"	; 80
	DC "FOR"	; 81
	DC "NEXT"	; 82
	DC "DATA"	; 83
	DC "INPUT"	; 84
	DC "DIM"	; 85
	DC "READ"	; 86
	DC "LET"	; 87
	DC "GOTO"	; 88
	DC "RUN"	; 89
	DC "IF"		; 8A
	DC "RESTORE"	; 8B
	DC "GOSUB"	; 8C
	DC "RETURN"	; 8D
	DC "REM"	; 8E
	DC "STOP"	; 8F
	DC "PRINT"	; 90
	DC "LIST"	; 91
	DC "CLEAR"	; 92
	DC "NEW"	; 93
;
	DC "TAB("	; 94
	DC "TO"		; 95
	DC "THEN"	; 96
	DC "STEP"	; 97
;
	DB 0ABh		; "+"	98
	DB 0ADh		; "-"	99
	DB 0AAh		; "*"	9A
	DB 0AFh		; "/"	9B
	DB 0BEh		; ">"	9C
	DB 0BDh		; "="	9D
	DB 0BCh		; "<"	9E
;
	DC "SGN"	; 9F
	DC "INT"	; A0
	DC "ABS"	; A1
	DC "USR"	; A2
	DC "SQR"	; A3
	DC "RND"	; A4
	DC "SIN"	; A5
	
	DC "LOAD"	; A6	; New commands
	DC "SYSTEM"	; A7

	DB 0	
			
CPMExit: ; Exit to CPM
        call RestoreZP
        jp 0

CPMStart:
        ld hl, (6) 	; BDOS vector signals the end of tpa address
        dec hl
        ld (RAMTOP), hl
        call SaveZP
        call MoveBASIC
        call PatchBASIC
        jp InitBASIC                                

InitBASIC:	
	ld hl, (RAMTOP)
	ld bc, 0ff80h
	add hl, bc
	ld (STACK_TOP), hl
	ld sp, hl
	
	ld hl, 0FFFFh	
	ld (CURRENT_LINE), hl
	call NewLine	
	ld hl, szMemorySize	
	call PrintString	
	call InputLineWith	
	rst 10h			; RST NextChar 
	or a			; if a=0 -> user just hit return
	jp nz, iL0DDE	
	ld hl, (STACK_TOP)	
	jp iDoneMemSize	
iL0DDE:
	ld hl,LINE_BUFFER	
	CALL LineNumberFromStr	; de=number
	or a			; a=0 if is input line is a number
	jp nz, SyntaxError	
	ex de,hl
	dec hl
iDoneMemSize:
        dec hl 
        push hl
iGetTerminalWidth:
	ld hl,szTerminalWidth	
	CALL PrintString	
	CALL InputLineWith	
	RST 10h	;RST NextChar		
	or a
	jp z, iDoOptionalFns	
	ld hl,LINE_BUFFER	
	CALL LineNumberFromStr	
	ld a,d
	or a
	jp nz,iGetTerminalWidth	
	ld a,e
	cp 10h	
	jp c,iGetTerminalWidth	
	ld (OutChar_tail+1),a
iCalcTabBrkSize:
	sub 0Eh	
	jp nc,iCalcTabBrkSize	
	add a,1Ch	
	cpl
	inc a
	add a,e	
	ld (ToNextTabBreak+4),a
iDoOptionalFns:
	ld hl, OPT_FN_DESCS	
iOptionalFnsLoop:
	RST 30h	
	ld de, szWantSin	
	RST 20h
	jp z,iL0E32	
	RST 30h
	ex (sp),hl
	CALL PrintString	
	CALL InputLineWith	
	RST 10h	;RST NextChar	
	pop hl
	cp 'Y'	
iL0E32:	pop de
	jp z,iInitProgramBase	
	cp 'N'	
	jp nz,iDoOptionalFns	
	RST 30h	
	ex (sp),hl
	ld de,FunctionCallError	
	ld (hl),e
	inc hl
	ld (hl),d
	pop hl
	jp iOptionalFnsLoop	
iInitProgramBase:
        ex de,hl
	ld hl, EndOfBASIC+1
	ld (hl), 0
	ld (PROGRAM_BASE), hl
	ex (sp),hl		; hl=addr typed on MEMORY? or RAMTOP if user just hit return
	push hl
	ld hl, (STACK_TOP)	; de=stack_top = current high addr of basic
	ex de,hl
	pop hl
	RST 20h	                ; calc hl-de
	jp nc,OutOfMemory	
	pop de
	ld sp,hl
	ld (STACK_TOP),hl
	ex de,hl
	CALL CheckEnoughMem	
	ld a,e
	sub l 
	ld l,a
	ld a,d
	sbc a,h
	ld h,a
	ld bc, 0fff0h
	add hl,bc
	CALL NewLine	
	CALL PrintInt	
	ld hl, szVersionInfo	 
	CALL PrintString	
	ld hl, PrintString	
	ld (Main+4), hl
	CALL New+1	
	ld hl, Main	
	ld (Start+2), hl
	jp (hl)	

EndOfBASIC: 
	db 0

	end
	
	
	; Falta BACKSP
	; control de error OM/SN hace crash