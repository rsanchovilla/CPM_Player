	SUBTTL	Common file for BASIC interpreter
	.SALL	

CONTO	SET	15			;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	SET	0			;FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2	

	.PRINTX	/EXTENDED/


	.PRINTX	/LPT/

	.PRINTX	/CPM DISK/


	.PRINTX	/Z80/

	.PRINTX	/FAST/

	.PRINTX	/5.0 FEATURES/

	.PRINTX	/ANSI COMPATIBLE/
	ENDIF

CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	SET	80			;TERMINAL LINE LENGTH 
LPTLEN	SET	132
BUFLEN	SET	255			;LONG LINES
NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
					;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	SET	4

STRSIZ	SET	3
NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES

NUMTMP	SET	10

MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
					;NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES
CPMWRM	SET	0			;CP/M WARM BOOT ADDR
CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR
	CSEG	
TRUROM	SET	0
	PAGE
	TITLE	BISTRS	BASIC Interpreter String  routines/WHG/PGA etc.
	EXTRN	MOVRM
	EXTRN	ARYTAB,BLTUC,CONINT,CRFIN,DSCTMP,ERRLS,ERROR,ERRSO,ERRST
	EXTRN	EVAL,FACLO,FCERR,FOUT,FRETOP,FRMEQL,FRMEVL,FRMPRN
	EXTRN	GETBYT,MEMSIZ,OUTDO,POPHRT,PTRGET,SIGNS,SNERR
	EXTRN	STREND,TEMPPT,TEMPST,TSTOP,VALTYP,VARTAB,SNGFLT,TEMP8
	EXTRN	GIVDBL,FIN,ARYTA2,CHKSTR
	PUBLIC	LHSMID
	EXTRN	ARYTA2,FINDBL,GETBCD,PRMPRV,TEMP9,VMOVE
	EXTRN	GETYPR
	EXTRN	CHRGTR,DCOMPR,SYNCHR
	EXTRN	IADAHL
	PUBLIC	CHR$,STRPRT,STROUI,LEN,FRESTR,STRCMP,VAL,ASC,ASC2,STRLTI
	PUBLIC	STROUT,FRETMS,FRETMP,RIGHT$,LEFT$,GARBA2,STR$
	PUBLIC	FRE,STRLIT,STRCPY,CAT,STRLT3,MID$
	PUBLIC	STRINI,STRIN1,STRAD1,PUTDEI
;
; THE FOLLOWING ROUTINE COMPARES TWO STRINGS
; ONE WITH DESC IN [D,E] OTHER WITH DESC. IN [FACLO, FACLO+1]
; A=0 IF STRINGS EQUAL
; A=377 IF B,C,D,E .GT. FACLO
; A=1 IF B,C,D,E .LT. FACLO
;
STRCMP:	CALL	FRESTR			;FREE UP THE FAC STRING, AND GET THE
					;POINTER TO THE FAC DESCRIPTOR IN [H,L]
	MOV	A,M			;SAVE THE LENGTH OF THE FAC STRING IN [A]
	INX	H
	MOV	C,M			;SAVE THE POINTER AT THE FAC STRING
					;DATA IN [B,C]
	INX	H
	MOV	B,M
	POP	D			;GET THE STACK STRING POINTER
	PUSH	B			;SAVE THE POINTER AT THE FAC STRING DATA
	PUSH	PSW			;SAVE THE FAC STRING LENGTH
	CALL	FRETMP			;FREE UP THE STACK STRING AND RETURN
					;THE POINTER TO THE STACK STRING DESCRIPTOR
					;IN [H,L]
	POP	D			;[D]=LENGTH OF FAC STRING
	MOV	E,M			;[E]=LENGTH OF STACK STRING
	INX	H
	MOV	C,M			;[B,C]=POINTER AT STACK STRING
	INX	H
	MOV	B,M
	POP	H			;GET BACK 2ND CHARACTER POINTER
CSLOOP:	MOV	A,E			;BOTH STRINGS ENDED
	ORA	D			;TEST BY OR'ING THE LENGTHS TOGETHER
	RZ				;IF SO, RETURN WITH A ZERO
	MOV	A,D			;GET FACLO STRING LENGTH
	SUI	1			;SET CARRY AND MAKE [A]=255 IF [D]=0
	RC				;RETURN IF THAT STRING ENDED
	XRA	A			;MUST NOT HAVE BEEN ZERO, TEST CASE
	CMP	E			;OF B,C,D,E STRING HAVING ENDED FIRST
	INR	A			;RETURN WITH A=1
	RNC				;TEST THE CONDITION
;HERE WHEN NEITHER STRING ENDED
	DCR	D			;DECREMENT BOTH CHARACTER COUNTS
	DCR	E
	LDAX	B			;GET CHARACTER FROM B,C,D,E STRING
	INX	B
	CMP	M			;COMPARE WITH FACLO STRING
	INX	H			;BUMP POINTERS (INX DOESNT CLOBBER CC'S)
	JZ	CSLOOP			;IF BOTH THE SAME, MUST BE MORE TO STRINGS
	CMC				;HERE WHEN STRINGS DIFFER
	JMP	SIGNS			;SET [A] ACCORDING TO CARRY
	SUBTTL	STRING FUNCTIONS
	EXTRN	FOUTO,FOUTH
	PUBLIC	STRO$,STRH$
; THE STRO$ FUNCTION TAKES A NUMBER AND GIVES
; A STRING WITH THE CHARACTERS THE NUMBER WOULD GIVE IF
; OUTPUT IN OCTAL
;
STRO$:	CALL	FOUTO			;PUT OCTAL NUMBER IN FBUFFR
	JMP	STR$1			;JUMP INTO STR$ CODE

; STRH$ SAME AS STRO$ EXCEPT USES HEX INSTEAD OF OCTAL
STRH$:	CALL	FOUTH			;PUT HEX NUMBER IN FBUFFR
	JMP	STR$1			;JUMP INTO STR$ CODE
;
; THE STR$ FUNCTION TAKES A NUMBER AND GIVES
; A STRING WITH THE CHARACTERS THE OUTPUT OF THE NUMBER
; WOULD HAVE GIVEN
;
STR$:
					;IS A NUMERIC
	CALL	FOUT			;DO ITS OUTPUT
STR$1:	CALL	STRLIT			;SCAN IT AND TURN IT INTO A STRING
	CALL	FREFAC			;FREE UP THE TEMP
	LXI	B,FINBCK
	PUSH	B			;SET UP ANSWER IN NEW TEMP
;
; STRCPY CREATES A COPY OF THE STRING
; WHOSE DESCRIPTOR IS POINTED TO BY [H,L].
; ON RETURN [D,E] POINTS TO DSCTMP
; WHICH HAS THE STRING INFO (LENGTH,WHERE COPIED TO)
;
STRCPY:	MOV	A,M			;GET LENGTH
	INX	H			;MOVE UP TO THE POINTER
	PUSH	H			;GET POINTER TO POINTER OF ARG
	CALL	GETSPA			;GET THE SPACE
	POP	H			;FIND OUT WHERE STRING TO COPY
	MOV	C,M
	INX	H
	MOV	B,M
	CALL	STRAD2			;SETUP DSCTMP
	PUSH	H			;SAVE POINTER TO DSCTMP
	MOV	L,A			;GET CHARACTER COUNT INTO [L]
	CALL	MOVSTR			;MOVE THE CHARS IN
	POP	D			;RESTORE POINTER TO DSCTMP
	RET				;RETURN

STRIN1:	MVI	A,1			;MAKE ONE CHAR STRING (CHR$, INKEY$)
STRINI:	CALL	GETSPA			;GET SOME STRING SPACE ([A] CHARS)
STRAD2:	LXI	H,DSCTMP		;GET DESC. TEMP
STRAD1:	PUSH	H			;SAVE DESC. POINTER
	MOV	M,A			;SAVE CHARACTER COUNT
PUTDEI:	INX	H			;STORE [D,E]=POINTER TO FREE SPACE
	MOV	M,E
	INX	H
	MOV	M,D
	POP	H			;AND RESTORE [H,L] AS THE DESCRIPTOR POINTER
	RET	
;
; STRLT2 TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
; IS POINTED BY [H,L]+1 AND BUILDS A DESCRIPTOR FOR IT.
; THE DESCRIPTOR IS INITIALLY BUILT IN DSCTMP, BUT PUTNEW
; TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
; AT THE TEMPORARY IN FACLO. THE CHARACTERS OTHER THAN
; ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN [B]
; AND [D]. IT THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
; OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE CALL. ON RETURN
; THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
; BY [H,L] AND IS IN [A], BUT THE CONDITION CODES ARE
; NOT SET UP.
;
	PUBLIC	STRLT2
STRLIT:	DCX	H
STRLTI:	MVI	B,34			;ASSUME STR ENDS ON QUOTE
STRLT3:	MOV	D,B
STRLT2:	PUSH	H			;SAVE POINTER TO START OF LITERAL
	MVI	C,255			;INITIALIZE CHARACTER COUNT
STRGET:	INX	H
	MOV	A,M			;GET CHAR
	INR	C			;BUMP CHARACTER COUNT
	ORA	A			;IF 0, (END OF LINE) DONE
	JZ	STRFIN			;TEST
	CMP	D
	JZ	STRFIN
	CMP	B			;CLOSING QUOTE
	JNZ	STRGET			;NO, GO BACK FOR MORE
STRFIN:	CPI	34			;IF QUOTE TERMINATES THE STRING
	CZ	CHRGTR			;SKIP OVER THE QUOTE
	PUSH	H			;SAVE POINTER AT END OF STRING
	MOV	A,B			;WERE WE SCANNING AN UNQUOTED STRING?
	CPI	44
	JNZ	NTTRLS			;IF NOT, DON'T SUPPRESS TRAILING SPACES
	INR	C			;FIX [C] WHICH IS THE CHARACTER COUNT
LPTRLS:	DCR	C			;DECREMENT UNTIL WE FIND A NON-SPACE CHARACTER
	JZ	NTTRLS			;DON'T GO PAST START (ALL SPACES)
	DCX	H			;LOOK AT PREVIOUS CHARACTER
	MOV	A,M
	CPI	' '
	JZ	LPTRLS			;IF SO CONTINUE LOOKING
NTTRLS:	POP	H
	XTHL	
	INX	H
	XCHG				;GET POINTER TO TEMP
	MOV	A,C			;GET CHARACTER COUNT IN A
	CALL	STRAD2			;SAVE STR INFO
;
; SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP
; WE WANT TO SETUP A TEMP DESCRIPTOR WITH DCSTMP IN IT
; PUT A POINTER TO THE DESCRIPTOR IN FACLO AND FLAG THE 
; RESULT AS TYPE STRING
;
	PUBLIC	PUTNEW
PUTNEW:	LXI	D,DSCTMP		;[D,E] POINT AT RESULT DESCRIPTOR
	PUBLIC	PUTTMP
	DB	76Q			;SKIP THE NEXT BYTE ("MVI AL,")
PUTTMP:	PUSH	D			;SAVE A POINTER TO THE START OF THE STRING
	LHLD	TEMPPT			;[H,L]=POINTER TO FIRST FREE TEMP
	SHLD	FACLO			;POINTER AT WHERE RESULT DESCRIPTOR WILL BE
	MVI	A,3
	STA	VALTYP			;FLAG THIS AS A STRING
	CALL	VMOVE			;AND MOVE THE VALUE INTO A TEMPORARY
	LXI	D,DSCTMP+3		;IF THE CALL IS TO PUTTMP, [D,E]
					;WILL NOT EQUAL DSCTMP +3
	CALL	DCOMPR			;DSCTMP IS JUST BEYOND THE TEMPS
					;AND IF TEMPPT POINTS AT IT THERE
					;ARE NO FREE TEMPS
	SHLD	TEMPPT			;SAVE NEW TEMPORARY POINTER
	POP	H			;GET THE TEXT POINTER
	MOV	A,M			;GET CURRENT CHARACTER INTO [A]
	RNZ	
	LXI	D,0+ERRST		;"STRING TEMPORARY" ERROR
	JMP	ERROR			;GO TELL HIM
;
; PRINT THE STRING POINTED TO BY [H,L] WHICH ENDS WITH A ZERO
; IF THE STRING IS BELOW DSCTMP IT WILL BE COPIED INTO STRING SPACE
;
STROUI:	INX	H			;POINT AT NEXT CHARACTER
STROUT:	CALL	STRLIT			;GET A STRING LITERAL
;
; PRINT THE STRING WHOSE DESCRIPTOR IS POINTED TO BY FACLO.
;
STRPRT:	CALL	FREFAC			;RETURN TEMP POINTER BY FACLO
	CALL	GETBCD			;[D]=LENGTH [B,C]=POINTER AT DATA
	INR	D			;INCREMENT AND DECREMENT EARLY
					;TO CHECK FOR NULL STRING
STRPR2:	DCR	D			;DECREMENT THE LENGTH
	RZ				;ALL DONE
	LDAX	B			;GET CHARACTER TO PRINT
	CALL	OUTDO
	CPI	13
	CZ	CRFIN
	INX	B			;POINT TO THE NEXT CHARACTER
	JMP	STRPR2			;AND PRINT IT...
	PAGE
	SUBTTL	STRING GARBAGE COLLECTION - GETSPA, GARBAG
;
; GETSPA - GET SPACE FOR CHARACTER STRING
; MAY FORCE GARBAGE COLLECTION.
;
; # OF CHARS (BYTES) IN [A]
; RETURNS WITH POINTER IN [D,E] OTHERWISE IF CANT GET SPACE
; BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
;
	PUBLIC	GETSPA
GETSPA:	ORA	A			;MUST BE NON ZERO. SIGNAL NO GARBAG YET
	DB	16Q			;"MVI C" AROUND THE NEXT BYTE 
TRYGI2:	POP	PSW			;IN CASE COLLECTED WHAT WAS LENGTH?
	PUSH	PSW			;SAVE IT BACK
	LHLD	STREND
	XCHG				;IN [D,E]
	LHLD	FRETOP			;GET TOP OF FREE SPACE IN [H,L]
	CMA				;-# OF CHARS
	MOV	C,A			;IN [B,C]
	MVI	B,255
	DAD	B			;SUBTRACT FROM TOP OF FREE
	INX	H
	CALL	DCOMPR			;COMPARE THE TWO
	JC	GARBAG			;NOT ENOUGH ROOM FOR STRING, OFFAL TIME
	SHLD	FRETOP			;SAVE NEW BOTTOM OF MEMORY
	INX	H			;MOVE BACK TO POINT TO STRING
	XCHG				;RETURN WITH POINTER IN [D,E]
	PUBLIC	PPSWRT
PPSWRT:	POP	PSW			;GET CHARACTER COUNT
	RET				;RETURN FROM GETSPA

GARBAG:	POP	PSW			;HAVE WE COLLECTED BEFORE?
	LXI	D,0+ERRSO		;GET READY FOR OUT OF STRING SPACE ERROR
	JZ	ERROR			;GO TELL USER HE LOST
	CMP	A			;SET ZERO FLAG TO SAY WEVE GARBAGED
	PUSH	PSW			;SAVE FLAG BACK ON STACK
	LXI	B,TRYGI2		;PLACE FOR GARBAG TO RETURN TO.
	PUSH	B			;SAVE ON STACK
GARBA2:	LHLD	MEMSIZ			;START FROM TOP DOWN
FNDVAR:	SHLD	FRETOP			;LIKE SO
	LXI	H,0			;GET DOUBLE ZERO
	PUSH	H			;SAY DIDNT SEE VARS THIS PASS
	LHLD	STREND			;FORCE DVARS TO IGNORE STRINGS
					;IN THE PROGRAM TEXT (LITERALS, DATA)
	PUSH	H			;FORCE FIND HIGH ADDRESS
	LXI	H,TEMPST		;GET START OF STRING TEMPS
TVAR:	XCHG				;SAVE IN [D,E]
	LHLD	TEMPPT			;SEE IF DONE
	XCHG				;FLIP
	CALL	DCOMPR			;TEST
					;CANNOT RUN IN RAM SINCE IT STORES TO MESS UP BASIC
	LXI	B,TVAR			;FORCE JUMP TO TVAR
	JNZ	DVAR2			;DO TEMP VAR GARBAGE COLLECT

	LXI	H,PRMPRV		;SETUP ITERATION FOR PARAMETER BLOCKS
	SHLD	TEMP9
	LHLD	ARYTAB			;GET STOPPING POINT IN [H,L]
	SHLD	ARYTA2			;STORE IN STOP LOCATION
	LHLD	VARTAB			;GET STARTING POINT IN [H,L]

SVAR:	XCHG	
	LHLD	ARYTA2			;GET STOPPING LOCATION
	XCHG	
	CALL	DCOMPR			;SEE IF AT END OF SIMPS
	JZ	ARYVAR
	MOV	A,M			;GET VALTYP
	INX	H			;BUMP POINTER TWICE
	INX	H			;
	INX	H			;POINT AT THE VALUE
	PUSH	PSW			;SAVE VALTYP
	CALL	IADAHL			;AND SKIP OVER EXTRA CHARACTERS AND COUNT
	POP	PSW
	CPI	3			;SEE IF ITS A STRING
	JNZ	SKPVAR			;IF NOT, JUST SKIP AROUND IT
	CALL	DVARS			;COLLECT IT
	XRA	A			;AND DON'T SKIP ANYTHING MORE
SKPVAR:	MOV	E,A
	MVI	D,0			;[D,E]=AMOUNT TO SKIP
	DAD	D
	JMP	SVAR			;GET NEXT ONE
ARYVAR:	LHLD	TEMP9			;GET LINK IN PARAMETER BLOCK CHAIN
	MOV	A,M			;GO BACK ONE LEVEL
	INX	H
	MOV	H,M
	MOV	L,A
	ORA	H			;WAS THAT THE END?
	XCHG				;SETUP TO START ARRAYS
	LHLD	ARYTAB
	JZ	ARYVA4			;OTHERWISE GARBAGE COLLECT ARRAYS
	XCHG	
	SHLD	TEMP9			;SETUP NEXT LINK IN CHAIN FOR ITERATION
	INX	H			;SKIP CHAIN POINTER
	INX	H
	MOV	E,M			;PICK UP THE LENGTH
	INX	H
	MOV	D,M
	INX	H
	XCHG				;SET [D,E]= ACTUAL END ADDRESS BY
	DAD	D			;ADDING BASE TO LENGTH
	SHLD	ARYTA2			;SET UP STOP LOCATION
	XCHG	
	JMP	SVAR

ARYVA2:	POP	B			;GET RID OF STACK GARBAGE
ARYVA4:	XCHG				;SAVE ARYVAR IN [D,E]
	LHLD	STREND			;GET END OF ARRAYS
	XCHG				;FLIP BACK
	CALL	DCOMPR			;SEE IF DONE WITH ARRAYS
	JZ	GRBPAS			;YES, SEE IF DONE COLLECTING
	MOV	A,M			;GET THE VALUE TYPE INTO [A]
	INX	H
	PUSH	PSW			;SAVE THE VALTYP
	INX	H			;SKIP THE NAME CHARACTERS
	INX	H
	CALL	IADAHL			;SKIP THE EXTRA CHARACTERS
	MOV	C,M			;PICK UP THE LENGTH
	INX	H
	MOV	B,M
	INX	H
	POP	PSW			;RESTORE THE VALTYP
	PUSH	H			;SAVE POINTER TO DIMS
	DAD	B			;ADD TO CURRENT POINTER POSITION
	CPI	3			;SEE IF ITS A STRING
	JNZ	ARYVA2			;IF NOT JUST SKIP IT
	SHLD	TEMP8			;SAVE END OF ARRAY
	POP	H			;GET BACK CURRENT POSITION
	MOV	C,M			;PICK UP NUMBER OF DIMS
	MVI	B,0			;MAKE DOUBLE WITH HIGH ZERO
	DAD	B			;GO PAST DIMS
	DAD	B			;BY ADDING ON TWICE #DIMS (2 BYTE GUYS)
	INX	H			;ONE MORE TO ACCOUNT FOR #DIMS.
ARYSTR:	XCHG				;SAVE CURRENT POSIT IN [D,E]
	LHLD	TEMP8			;GET END OF ARRAY
	XCHG				;FIX [H,L] BACK TO CURRENT
	CALL	DCOMPR			;SEE IF AT END OF ARRAY
	JZ	ARYVA4			;END OF ARRAY, TRY NEXT ARRAY
	LXI	B,ARYSTR		;ADDR OF WHERE TO RETURN TO
DVAR2:	PUSH	B			;GOES ON STACK
DVAR:
DVARS:	XRA	A
	ORA	M			;SEE IF ITS THE NULL STRING
	INX	H
	MOV	E,M
	INX	H
	MOV	D,M
	INX	H			;[D,E]=POINTER AT THE VALUE
	RZ				;NULL STRING, RETURN
	MOV	B,H			;MOVE [H,L] TO [B,C]
	MOV	C,L
	LHLD	FRETOP			;GET POINTER TO TOP OF STRING FREE SPACE
	CALL	DCOMPR			;IS THIS STRINGS POINTER .LT. FRETOP
	MOV	H,B			;MOVE [B,C] BACK TO [H,L]
	MOV	L,C
	RC				;IF NOT, NO NEED TO MESS WITH IT FURTHUR
	POP	H			;GET RETURN ADDRESS OFF STACK
	XTHL				;GET MAX SEEN SO FAR & SAVE RETURN ADDRESS
	CALL	DCOMPR			;LETS SEE
	XTHL				;SAVE MAX SEEN & GET RETURN ADDRESS OFF STACK
	PUSH	H			;SAVE RETURN ADDRESS BACK
	MOV	H,B			;MOVE [B,C] BACK TO [H,L]
	MOV	L,C
	RNC				;IF NOT, LETS LOOK AT NEXT VAR
	POP	B			;GET RETURN ADDR OFF STACK
	POP	PSW			;POP OFF MAX SEEN
	POP	PSW			;AND VARIABLE POINTER
	PUSH	H			;SAVE NEW VARIABLE POINTER
	PUSH	D			;AND NEW MAX POINTER
	PUSH	B			;SAVE RETURN ADDRESS BACK
	RET				;AND RETURN
;
; HERE WHEN MADE ONE COMPLETE PASS THRU STRING VARS
;
GRBPAS:	POP	D			;POP OFF MAX POINTER
	POP	H			;AND GET VARIABLE POINTER
	MOV	A,L			;GET LOW IN
	ORA	H			;SEE IF ZERO POINTER
	RZ				;IF END OF COLLECTION,
					;THEN MAYBE RETURN TO GETSPA
	DCX	H			;CURRENTLY JUST PAST THE DESCRIPTOR
	MOV	B,M			;[B]=HIGH BYTE OF DATA POINTER
	DCX	H
	MOV	C,M			;[B,C]=POINTER AT STRING DATA
	PUSH	H			;SAVE THIS LOCATION SO THE POINTER
					;CAN BE UPDATED AFTER THE STRING IS
					;MOVED
	DCX	H
	MOV	L,M			;[L]=STRING LENGTH
	MVI	H,0			;[H,L] GET CHARACTER COUNT
	DAD	B			;[H,L]=POINTER BEYOND STRING
	MOV	D,B
	MOV	E,C			;[D,E]=ORIGINAL POINTER
	DCX	H			;DON'T MOVE ONE BEYOND STRING
	MOV	B,H			;GET TOP OF STRING IN [B,C]
	MOV	C,L
	LHLD	FRETOP			;GET TOP OF FREE SPACE
	CALL	BLTUC			;MOVE STRING
	POP	H			;GET BACK POINTER TO DESC.
	MOV	M,C			;SAVE FIXED ADDR
	INX	H			;MOVE POINTER
	MOV	M,B			;HIGH PART
	MOV	L,C
	MOV	H,B			;[H,L]=NEW POINTER
	DCX	H			;FIX UP FRETOP
	JMP	FNDVAR			;AND TRY TO FIND HIGH AGAIN

	PAGE
	SUBTTL	STRING CONCATENATION
;
; THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS
; THE FACLO CONTAINS THE FIRST ONE AT THIS POINT,
; [H,L] POINTS BEYOND THE + SIGN AFTER IT
;
CAT:	PUSH	B			;PUT OLD PRECEDENCE BACK ON
	PUSH	H			;SAVE TEXT POINTER
	LHLD	FACLO			;GET POINTER TO STRING DESC.
	XTHL				;SAVE ON STACK & GET TEXT POINTER BACK
	CALL	EVAL			;EVALUATE REST OF FORMULA
	XTHL				;SAVE TEXT POINTER, GET BACK DESC.
	CALL	CHKSTR
	MOV	A,M
	PUSH	H			;SAVE DESC. POINTER.
	LHLD	FACLO			;GET POINTER TO 2ND DESC.
	PUSH	H			;SAVE IT
	ADD	M			;ADD TWO LENGTHS TOGETHER
	LXI	D,0+ERRLS		;SEE IF RESULT .LT. 256
	JC	ERROR			;ERROR "LONG STRING"
	CALL	STRINI			;GET INITIAL STRING
	POP	D			;GET 2ND DESC.
	CALL	FRETMP
	XTHL				;SAVE POINTER TO IT
	CALL	FRETM2			;FREE UP 1ST TEMP
	PUSH	H			;SAVE DESC. POINTER (FIRST)
INCSTR	SET	2

INCSTR	SET	1
	LHLD	DSCTMP+INCSTR		;GET POINTER TO FIRST
	XCHG				;IN [D,E]
	CALL	MOVINS			;MOVE IN THE FIRST STRING
	CALL	MOVINS			;AND THE SECOND
	LXI	H,TSTOP			;CAT REENTERS FORMULA EVALUATION AT TSTOP
	XTHL	
	PUSH	H			;TEXT POINTER OFF FIRST
	JMP	PUTNEW			;THEN RETURN ADDRESS OF TSTOP


MOVINS:	POP	H			;GET RETURN ADDR
	XTHL				;PUT BACK, BUT GET DESC.
	MOV	A,M			;[A]=STRING LENGTH
	INX	H
	MOV	C,M			;[B,C]=POINTER AT STRING DATA
	INX	H
	MOV	B,M
	MOV	L,A			;[L]=STRING LENGTH
MOVSTR:	INR	L
MOVLP:	DCR	L			;SET CC'S
	RZ				;0, NO BYTE TO MOVE
	LDAX	B			;GET CHAR
	STAX	D			;SAVE IT
	INX	B			;MOVE POINTERS
	INX	D
	JMP	MOVLP			;KEEP DOING IT
	PAGE
	SUBTTL	FREE UP STRING TEMPORARY - FRESTR, FREFAC, FRETMP, FRETMS
;
; FRETMP IS PASSED A POINTER TO A STRING DESCRIPTOR IN [D,E]
; THIS VALUE IS RETURNED IN [H,L]. ALL THE OTHER REGISTERS ARE MODIFIED.
; A CHECK TO IS MADE TO SEE IF THE STRING DESCRIPTOR [D,E] POINTS
; TO IS THE LAST TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
; IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF TEMPPT.
; IF A TEMPORARY IS FREED UP, A FURTHER CHECK IS MADE TO SEE IF THE
; STRING DATA THAT THAT STRING TEMPORARY POINTED TO IS THE
; THE LOWEST PART OF STRING SPACE IN USE.
; IF SO, FRETMP IS UPDATED TO REFLECT THE FACT THAT THAT SPACE IS NO
; LONGER IN USE.
;
	PUBLIC	FREFAC
FRESTR:	CALL	CHKSTR			;MAKE SURE ITS A STRING
FREFAC:	LHLD	FACLO
	PUBLIC	FRETM2
FRETM2:	XCHG				;FREE UP THE TEMP IN THE FACLO
FRETMP:	CALL	FRETMS			;FREE UP THE TEMPORARY
	XCHG				;PUT THE STRING POINTER INTO [H,L]
	RNZ	
	PUSH	D			;SAVE [D,E] TO RETURN IN [H,L]
	MOV	D,B			;[D,E]=POINTER AT STRING
	MOV	E,C
	DCX	D			;SUBTRACT ONE
	MOV	C,M			;[C]=LENGTH OF THE STRING FREED UP
	LHLD	FRETOP			;SEE IF ITS THE FIRST 
					;ONE IN STRING SPACE
	CALL	DCOMPR
	JNZ	NOTLST			;NO SO DON'T ADD
	MOV	B,A			;MAKE [B]=0
	DAD	B			;ADD
	SHLD	FRETOP			;AND UPDATE FRETOP
NOTLST:	POP	H			;GET POINTER AT CURRENT DESCRIPTOR
	RET	
FRETMS:	LHLD	TEMPPT			;GET TEMP POINTER
	DCX	H			;LOOK AT WHAT IS IN THE LAST TEMP
	MOV	B,M			;[B,C]=POINTER AT STRING
	DCX	H			;DECREMENT TEMPPT BY STRSIZ
	MOV	C,M
	DCX	H
	CALL	DCOMPR			;SEE IF [D,E] POINT AT THE LAST 
	RNZ				;RETURN NOW IF NOW FREEING DONE
	SHLD	TEMPPT			;UPDATE THE TEMP POINTER SINCE
					;ITS BEEN DECREMENTED BY 4
	RET	
	PAGE
	SUBTTL	STRING FUNCTIONS - LEN, ASC, CHR$
;
; THE FUNCTION LEN($) RETURNS THE LENGTH OF THE
; STRING PASSED AS AN ARGUMENT
;
LEN:	LXI	B,SNGFLT		;CALL SNGFLT WHEN DONE
	PUSH	B			;LIKE SO
LEN1:	CALL	FRESTR			;FREE UP TEMP POINTED TO BY FACLO
	XRA	A			;FORCE NUMERIC FLAG
	MOV	D,A			;SET HIGH OF [D,E] TO ZERO FOR VAL
	MOV	A,M
	ORA	A			;SET CONDITION CODES ON LENGTH
	RET				;RETURN
;
; THE FOLLOWING IS THE ASC($) FUNCTION. IT RETURNS AN INTEGER
; WHICH IS THE DECIMAL ASCII EQUIVALENT
;
ASC:
	LXI	B,SNGFLT		;WHERE TO GO WHEN DONE
	PUSH	B			;SAVE RETURN ADDR ON STACK
ASC2:	CALL	LEN1			;SET UP ORIGINAL STR
	JZ	FCERR			;NULL STR, BAD ARG.
	INX	H			;BUMP POINTER
	MOV	E,M			;[D,E]=POINTER AT STRING DATA
	INX	H
	MOV	D,M
	LDAX	D			;[A]=FIRST CHARACTER
	RET	
;
; CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
; CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARG (#)
; WHICH MUST BE .LE. 255.
;
CHR$:	CALL	STRIN1			;GET STRING IN DSCTMP
	CALL	CONINT			;GET INTEGER IN RANGE
INCSTR	SET	2

INCSTR	SET	1
	PUBLIC	SETSTR,FINBCK
SETSTR:	LHLD	DSCTMP+INCSTR		;GET ADDR OF STR
	MOV	M,E			;SAVE ASCII BYTE
FINBCK:	POP	B			;RETURN TO HIGHER LEVEL &
					;SKIP THE CHKNUM CALL.
	JMP	PUTNEW			;GO CALL PUTNEW

	PUBLIC	STRNG$
STRNG$:	CALL	CHRGTR			;GET NEXT CHAR FOLLOWING "STRING$"
	CALL	SYNCHR
	DB	'('			;MAKE SURE LEFT PAREN
	CALL	GETBYT			;EVALUATE FIRST ARG (LENGTH)
	PUSH	D			;SAVE IT
	CALL	SYNCHR
	DB	54O			;COMMA
	CALL	FRMEVL			;GET FORMULA ARG 2
	CALL	SYNCHR
	DB	')'			;EXPECT RIGHT PAREN
	XTHL				;SAVE TEXT POINTER ON STACK, GET REP FACTOR
	PUSH	H			;SAVE BACK REP FACTOR
	CALL	GETYPR			;GET TYPE OF ARG
	JZ	STRSTR			;WAS A STRING
	CALL	CONINT			;GET ASCII VALUE OF CHAR
	JMP	CALSPA			;NOW CALL SPACE CODE
STRSTR:	CALL	ASC2			;GET VALUE OF CHAR IN [A]
CALSPA:	POP	D			;GET REP FACTOR IN [E]
	CALL	SPACE2			;INTO SPACE CODE, PUT DUMMY ENTRY
					;ON STACK POPPED OFF BY FINBCK
	PUBLIC	SPACE$
SPACE$:	CALL	CONINT			;GET NUMBER OF CHARS IN [E]
	MVI	A,32			;GET SPACE CHAR
SPACE2:	PUSH	PSW			;SAVE CHAR
	MOV	A,E			;GET NUMBER OF CHARS IN [A]
	CALL	STRINI			;GET A STRING THAT LONG
	MOV	B,A			;COUNT OF CHARS BACK IN [B]
	POP	PSW			;GET BACK CHAR TO PUT IN STRING
	INR	B			;TEST FOR NULL STRING
	DCR	B
	JZ	FINBCK			;YES, ALL DONE
	LHLD	DSCTMP+INCSTR		;GET DESC. POINTER
SPLP$:	MOV	M,A			;SAVE CHAR
	INX	H			;BUMP PTR
					;DECR COUNT
	DCR	B
	JNZ	SPLP$			;KEEP STORING CHAR
	JMP	FINBCK			;PUT TEMP DESC WHEN DONE
	PAGE
	SUBTTL	STRING FUNCTIONS - LEFT$, RIGHT$, MID$
;
; THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
; IT TAKES THE LEFTMOST # CHARS OF THE STR.
; IF # IS .GT. THAN THE LEN OF THE STR, IT RETURNS THE WHOLE STR.
;
LEFT$:	CALL	PREAM			;TEST THE PARAMETERS
	XRA	A			;LEFT NEVER CHANGES STRING POINTER
LEFT3:	XTHL				;SAVE TEXT POINTER
	MOV	C,A			;OFFSET NOW IN [C]
	DB	76Q			;SKIP THE NEXT BYTE WITH "MVI A,"
;
; THIS IS PRINT USINGS ENTRY POINT INTO LEFT$
;
	PUBLIC	LEFTUS
LEFTUS:	PUSH	H			;THIS IS A DUMMY PUSH TO OFFSET
					;THE EXTRA POP IN PUTNEW
LEFT2:	PUSH	H			;SAVE DESC. FOR  FRETMP
	MOV	A,M			;GET STRING LENGTH
	CMP	B			;ENTIRE STRING WANTED?
	JC	ALLSTR			;IF #CHARS ASKED FOR.GE.LENGTH,YES
	MOV	A,B			;GET TRUNCATED LENGTH OF STRING
	DB	21Q			;SKIP OVER MVI USING "LXI D,"
ALLSTR:	MVI	C,0			;MAKE OFFSET ZERO
	PUSH	B			;SAVE OFFSET ON STACK
	CALL	GETSPA			;GET SPACE FOR NEW STRING
	POP	B			;GET BACK OFFSET
	POP	H			;GET BACK DESC POINTER.
	PUSH	H			;BUT KEEP ON STACK
	INX	H			;MOVE TO STRING POINTER FIELD
	MOV	B,M			;GET POINTER LOW
	INX	H			;
	MOV	H,M			;POINTER HIGH
	MOV	L,B			;GET LOW IN  L
	MVI	B,0			;GET READY TO ADD OFFSET TO POINTER
	DAD	B			;ADD  IT
	MOV	B,H			;GET OFFSET POINTER IN [B,C]
	MOV	C,L
	CALL	STRAD2			;SAVE INFO IN DSCTMP
	MOV	L,A			;GET#  OF CHARS TO  MOVE IN L
	CALL	MOVSTR			;MOVE THEM IN
	POP	D			;GET BACK DESC. POINTER
	CALL	FRETMP			;FREE IT UP.
	JMP	PUTNEW			;PUT TEMP IN TEMP LIST

RIGHT$:	CALL	PREAM			;CHECK ARG
	POP	D			;GET DESC. POINTER
	PUSH	D			;SAVE BACK FOR LEFT
	LDAX	D			;GET PRESENT LEN OF STR
	SUB	B			;SUBTRACT 2ND PARM
	JMP	LEFT3			;CONTINUE WITH LEFT CODE
;
; MID ($,#) RETURNS STR WITH CHARS FROM # POSITION
; ONWARD. IF # IS GT LEN($) THEN RETURN NULL STRING.
; MID ($,#,#) RETURNS STR WITH CHARS FROM # POSITION
; FOR #2 CHARS. IF #2 GOES PAST END OF STRING, RETURN
; AS MUCH AS POSSIBLE.
;
MID$:	XCHG				;PUT THE TEXT POINTER IN [H,L]
	MOV	A,M			;GET THE FIRST CHARACTER
	CALL	PREAM2			;GET OFFSET OFF STACK AND MAKE
	INR	B
	DCR	B			;SEE IF EQUAL TO ZERO
	JZ	FCERR			;IT MUST NOT BE 0
					;SURE DOES NOT = 0.
	PUSH	B			;PUT OFFSET ON TO THE STACK
	CALL	MIDRST			;DUPLICATE OF CODE CONDITIONED OUT
					;BELOW
	POP	PSW			;GET OFFSET BACK IN A
	XTHL				;SAVE TEXT POINTER, GET DESC.
	LXI	B,LEFT2			;WHERE TO RETURN TO.
	PUSH	B			;GOES ON STACK
	DCR	A			;SUB ONE FROM OFFSET
	CMP	M			;POINTER PAST END OF STR?
	MVI	B,0			;ASSUME NULL LENGTH STR
	RNC				;YES, JUST USE NULL STR
	MOV	C,A			;SAVE OFFSET OF CHARACTER POINTER
	MOV	A,M			;GET PRESENT LEN OF STR
	SUB	C			;SUBTRACT INDEX (2ND ARG)
	CMP	E			;IS IT TRUNCATION
	MOV	B,A			;GET CALCED LENGTH IN B
	RC				;IF NOT USE PARTIAL STR
	MOV	B,E			;USE TRUNCATED LENGTH
	RET				;RETURN TO LEFT2
;
; THE VAL FUNCTION TAKES A STRING AND TURN IT INTO
; A NUMBER BY INTERPRETING THE ASCII DIGITS. ETC..
; EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
; BY REPLACING THE CHARACTER BEYOND THE STRING, VAL
; IS MERELY A CALL TO FLOATING INPUT (FIN).
;
VAL:	CALL	LEN1			;DO SETUP, SET RESULT=REAL
	JZ	SNGFLT			;MAKE SURE TYPE SET UP OK IN EXTENDED
	MOV	E,A			;GET LENGTH OF STR
	INX	H			;TO HANDLE THE FACT THE IF
	MOV	A,M
	INX	H
	MOV	H,M			;TWO STRINGS "1" AND "2"
	MOV	L,A			;ARE STORED NEXT TO EACH OTHER
	PUSH	H			;AND FIN IS CALLED POINTING TO
	DAD	D			;THE FIRST TWELVE WILL BE RETURNED
	MOV	B,M			;THE IDEA IS TO STORE 0 IN THE
	MOV	M,D			;STRING BEYOND THE ONE VAL
	XTHL				;IS BEING CALLED ON
	PUSH	B			;THE FIRST CHARACTER OF THE NEXT STRING
	DCX	H			;***CALL CHRGET TO MAKE SURE
	CALL	CHRGTR			;VAL(" -3")=-3
	CALL	FINDBL			;IN EXTENDED, GET ALL THE PRECISION WE CAN
	POP	B			;GET THE MODIFIED CHARACTER OF THE NEXT
					;STRING INTO [B]
	POP	H			;GET THE POINTER TO THE MODIFIED CHARACTER
	MOV	M,B			;RESTORE THE CHARACTER
					;IF STRING IS HIGHEST IN STRING SPACE
					;WE ARE MODIFYING [MEMSIZ] AND
					;THIS IS WHY [MEMSIZ] CAN'T BE USED TO STORE
					;STRING DATA BECAUSE WHAT IF THE
					;USER TOOK VAL OFF THAT HIGH STRING
	RET	
;USED BY RIGHT$ AND LEFT$ FOR PARAMETER CHECKING AND SETUP
PREAM:	XCHG				;PUT THE TEXT POINTER IN [H,L]
	CALL	SYNCHR
	DB	')'			;PARAM LIST SHOULD END
;USED BY MID$ FOR PARAMETER CHECKING AND SETUP
PREAM2:	POP	B			;GET RETURN ADDR OFF STACK
	POP	D			;GET LENGTH OF ARG OFF STACK
	PUSH	B			;SAVE RETURN ADDR BACK ON
	MOV	B,E			;SAVE INIT LENGTH
	RET	

	PAGE
	SUBTTL	STRING FUNCTIONS - INSTR

; THIS IS THE INSTR FUCNTION. IT TAKES ONE OF TWO
; FORMS: INSTR(I%,S1$,S2$) OR INSTR(S1$,S2$)
; IN THE FIRST FORM THE STRING S1$ IS SEARCHED FOR THE
; CHARACTER S2$ STARTING AT CHARACTER POSITION I%.
; THE SECOND FORM IS IDENTICAL, EXCEPT THAT THE SEARCH
; STARTS AT POSITION 1. INSTR RETURNS THE CHARACTER
; POSITION OF THE FIRST OCCURANCE OF S2$ IN S1$.
; IF S1$ IS NULL, 0 IS RETURNED. IF S2$ IS NULL, THEN
; I% IS RETURNED, UNLESS I% .GT. LEN(S1$) IN WHICH
; CASE 0 IS RETURNED.

	PUBLIC	INSTR
INSTR:	CALL	CHRGTR			;EAT FIRST CHAR
	CALL	FRMPRN			;EVALUATE FIRST ARG
	CALL	GETYPR			;SET ZERO IF ARG A STRING.
	MVI	A,1			;IF SO, ASSUME, SEARCH STARTS AT FIRST CHAR
	PUSH	PSW			;SAVE OFFSET IN CASE STRING
	JZ	WUZSTR			;WAS A STRING
	POP	PSW			;GET RID OF SAVED OFFSET
	CALL	CONINT			;FORCE ARG1 (I%) TO BE INTEGER
	ORA	A			;DONT ALLOW ZERO OFFSET
	JZ	FCERR			;KILL HIM.
	PUSH	PSW			;SAVE FOR LATER
	CALL	SYNCHR
	DB	44			;EAT THE COMMA
	CALL	FRMEVL			;EAT FIRST STRING ARG
	CALL	CHKSTR			;BLOW UP IF NOT STRING
WUZSTR:	CALL	SYNCHR
	DB	44			;EAT COMMA AFTER ARG
	PUSH	H			;SAVE THE TEXT POINTER
	LHLD	FACLO			;GET DESCRIPTOR POINTER
	XTHL				;PUT ON STACK & GET BACK TEXT PNT.
	CALL	FRMEVL			;GET LAST ARG
	CALL	SYNCHR
	DB	')'			;EAT RIGHT PAREN
	PUSH	H			;SAVE TEXT POINTER
	CALL	FRESTR			;FREE UP TEMP & CHECK STRING
	XCHG				;SAVE 2ND DESC. POINTER IN [D,E]
	POP	B			;GET TEXT POINTER IN B
	POP	H			;DESC. POINTER FOR S1$
	POP	PSW			;OFFSET
	PUSH	B			;PUT TEXT POINTER ON BOTTOM
	LXI	B,POPHRT		;PUT ADDRESS OF POP H, RET ON
	PUSH	B			;PUSH IT
	LXI	B,SNGFLT		;NOW ADDRESS OF [A] RETURNER
	PUSH	B			;ONTO STACK
	PUSH	PSW			;SAVE OFFSET BACK
	PUSH	D			;SAVE DESC. OF S2
	CALL	FRETM2			;FREE UP S1 DESC.
	POP	D			;RESTORE DESC. S2
	POP	PSW			;GET BACK OFFSET
	MOV	B,A			;SAVE UNMODIFIED OFFSET
	DCR	A			;MAKE OFFSET OK
	MOV	C,A			;SAVE IN C
	CMP	M			;IS IT BEYOND LENGTH OF S1?
	MVI	A,0			;IF SO, RETURN ZERO. (ERROR)
	RNC	
	LDAX	D			;GET LENGTH OF S2$
	ORA	A			;NULL??
	MOV	A,B			;GET OFFSET BACK
	RZ				;ALL IF S2 NULL, RETURN OFFSET
	MOV	A,M			;GET LENGTH OF S1$
	INX	H			;BUMP POINTER
	MOV	B,M			;GET 1ST BYTE OF ADDRESS
	INX	H			;BUMP POINTER
	MOV	H,M			;GET 2ND BYTE
	MOV	L,B			;GET 1ST BYTE SET UP
	MVI	B,0			;GET READY FOR DAD
	DAD	B			;NOW INDEXING INTO STRING
	SUB	C			;MAKE LENGTH OF STRING S1$ RIGHT
	MOV	B,A			;SAVE LENGTH OF 1ST STRING IN [B]
	PUSH	B			;SAVE COUNTER, OFFSET
	PUSH	D			;PUT 2ND DESC (S2$) ON STACK
	XTHL				;GET 2ND DESC. POINTER
	MOV	C,M			;SET UP LENGTH
	INX	H			;BUMP POINTER
	MOV	E,M			;GET FIRST BYTE OF ADDRESS
	INX	H			;BUMP POINTER AGAIN
	MOV	D,M			;GET 2ND BYTE
	POP	H			;RESTORE POINTER FOR 1ST STRING

CHK1:	PUSH	H			;SAVE POSITION IN SEARCH STRING
	PUSH	D			;SAVE START OF SUBSTRING
	PUSH	B			;SAVE WHERE WE STARTED SEARCH
CHK:	LDAX	D			;GET CHAR FROM SUBSTRING
	CMP	M			; = CHAR POINTER TO BY [H,L]
	JNZ	OHWELL			;NO
	INX	D			;BUMP COMPARE POINTER
	DCR	C			;END OF SEARCH STRING?
	JZ	GOTSTR			;WE FOUND IT!
	INX	H			;BUMP POINTER INTO STRING BEING SEARCHED
					;DECREMENT LENGTH OF SEARCH STRING
	DCR	B
	JNZ	CHK			;END OF STRING, YOU LOSE
RETZER:	POP	D			;GET RID OF POINTERS
	POP	D			;GET RID OF GARB
	POP	B			;LIKE SO
RETZR1:	POP	D
	XRA	A			;GO TO SNGFLT.
	RET				;RETURN

GOTSTR:	POP	H
	POP	D			;GET RID OF GARB
	POP	D			;GET RID OF EXCESS STACK
	POP	B			;GET COUNTER, OFFSET
	MOV	A,B			;GET ORIGINAL SOURCE COUNTER
	SUB	H			;SUBTRACT FINAL COUNTER
	ADD	C			;ADD ORIGINAL OFFSET (N1%)
	INR	A			;MAKE OFFSET OF ZERO = POSIT 1
	RET				;DONE


OHWELL:	POP	B
	POP	D			;POINT TO START OF SUBSTRING
	POP	H			;GET BACK WHERE WE STARTED TO COMPARE
	INX	H			;AND POINT TO NEXT CHAR
					;DECR. # CHAR LEFT IN SOURCE STRING
	DCR	B
	JNZ	CHK1			;TRY SEARCHING SOME MORE
	JMP	RETZR1			;END OF STRING, RETURN 0

	PAGE
	SUBTTL	STRING FUNCTIONS - LEFT HAND SIDE MID$
LHSMID:	CALL	SYNCHR
	DB	'('			;MUST HAVE ( 
	CALL	PTRGET			;GET A STRING VAR
	CALL	CHKSTR			;MAKE SURE IT WAS A STRING
	PUSH	H			;SAVE TEXT POINTER
	PUSH	D			;SAVE DESC. POINTER
	XCHG				;PUT DESC. POINTER IN [H,L]
	INX	H			;MOVE TO ADDRESS FIELD
	MOV	E,M			;GET ADDRESS OF LHS IN [D,E]
	INX	H			;BUMP DESC. POINTER
	MOV	D,M			;PICK UP HIGH BYTE OF ADDRESS
	LHLD	STREND			;SEE IF LHS STRING IS IN STRING SPACE
	CALL	DCOMPR			;BY COMPARING IT WITH STKTOP
	JC	NCPMID			;IF ALREADY IN STRING SPACE
					;DONT COPY.

					;9/23/79 Allow MID$ on field strings
	EXTRN	TXTTAB
	LHLD	TXTTAB
	CALL	DCOMPR			;Is this a fielded string?
	JNC	NCPMID			;Yes, Don't copy!!
	POP	H			;GET BACK DESC. POINTER
	PUSH	H			;SAVE BACK ON STACK
	CALL	STRCPY			;COPY THE STRING LITERAL INTO STRING SPACE
	POP	H			;GET BACK DESC. POINTER
	PUSH	H			;BACK ON STACK AGAIN
	CALL	VMOVE			;MOVE NEW DESC. INTO OLD SLOT.
NCPMID:	POP	H			;GET DESC. POINTER
	XTHL				;GET TEXT POINTER TO [H,L] DESC. TO STACK
	CALL	SYNCHR
	DB	54O			;MUST HAVE COMMA
	CALL	GETBYT			;GET ARG#2 (OFFSET INTO STRING)
	ORA	A			;MAKE SURE NOT ZERO
	JZ	FCERR			;BLOW HIM UP IF ZERO
	PUSH	PSW			;SAVE ARG#2 ON STACK
	MOV	A,M			;RESTORE CURRENT CHAR
	CALL	MIDRST			;USE MID$ CODE TO EVALUATE POSIBLE THIRD ARG.
	PUSH	D			;SAVE THIRD ARG ([E]) ON STACK
					;MUST HAVE = SIGN
	CALL	FRMEQL			;EVALUATE RHS OF THING.
	PUSH	H			;SAVE TEXT POINTER.
	CALL	FRESTR			;FREE UP TEMP RHS IF ANY.
	XCHG				;PUT RHS DESC. POINTER IN [D,E]
	POP	H			;TEXT POINTER TO [H,L]
	POP	B			;ARG #3 TO C.
	POP	PSW			;ARG #2 TO A.
	MOV	B,A			;AND [B]
	XTHL				;GET LHS DESC. POINTER TO [H,L]
					;TEXT POINTER TO STACK
	PUSH	H			;SAVE TEXT POINTER
	LXI	H,POPHRT		;GET ADDR TO RETURN TO
	XTHL				;SAVE ON STACK & GET BACK TXT PTR.
	MOV	A,C			;GET ARG #3
	ORA	A			;SET CC'S
	RZ				;IF ZERO, DO NOTHING
	MOV	A,M			;GET LENGTH OF LHS
	SUB	B			;SEE HOW MANY CHARS IN EMAINDER OF STRING
	JC	FCERR			;CANT ASSIGN PAST LEN(LHS)!
	INR	A			;MAKE PROPER COUNT
	CMP	C			;SEE IF # OF CHARS IS .GT. THIRD ARG
	JC	BIGLEN			;IF SO, DONT TRUNCATE
	MOV	A,C			;TRUNCATE BY USING 3RD ARG.
BIGLEN:	MOV	C,B			;GET OFFSET OF STRING IN [C]
	DCR	C			;MAKE PROPER OFFSET
	MVI	B,0			;SET UP [B,C] FOR LATER DAD B.
	PUSH	D			;SAVE [D,E]
	INX	H			;POINTER TO ADDRESS FIELD.
	MOV	E,M			;GET LOW BYTE IN [E]
	INX	H			;BUMP POINTER
	MOV	H,M			;GET HIGH BYTE IN [H]
	MOV	L,E			;NOW COPY LOW BYTE BACK TO [L]
	DAD	B			;ADD OFFSET
	MOV	B,A			;SET COUNT OF LHS IN [B]
	POP	D			;RESTORE [D,E]
	XCHG				;MOVE RHS. DESC. POINTER TO [H,L]
	MOV	C,M			;GET LEN(RHS) IN [C]
	INX	H			;MOVE POINTER
	MOV	A,M			;GET LOW BYTE OF ADDRESS IN [A]
	INX	H			;BUMP POINTER.
	MOV	H,M			;GET HIGH BYTE OF ADDRESS IN [H]
	MOV	L,A			;COPY LOW BYTE TO [L]
	XCHG				;ADDRESS OF RHS NOW IN [D,E]
	MOV	A,C			;IS RHS NULL?
	ORA	A			;TEST
	RZ				;THEN ALL DONE.
; NOW ALL SET UP FOR ASSIGNMENT.
; [H,L] = LHS POINTER
; [D,E] = RHS POINTER
; C = LEN(RHS)
; B = LEN(LHS)

MID$LP:	LDAX	D			;GET BYTE FROM RHS.
	MOV	M,A			;STORE IN LHS
	INX	D			;BUMP RHS POINTER
	INX	H			;BUMP LHS POINTER.
	DCR	C			;BUMP DOWN COUNT OF RHS.
	RZ				;IF ZERO, ALL DONE.
					;IF LHS ENDED, ALSO DONE.
	DCR	B
	JNZ	MID$LP			;IF NOT DONE, MORE COPYING.
	RET				;BACK TO NEWSTT

MIDRST:	MVI	E,255			;IF TWO ARG GUY, TRUNCATE.
	CPI	')'
	JZ	MID2			;[E] SAYS USE ALL CHARS
					;IF ONE ARGUMENT THIS IS CORRECT
	CALL	SYNCHR
	DB	44			;COMMA? MUST DELINEATE 3RD ARG.
	CALL	GETBYT			;GET ARGUMENT  IN  [E]
MID2:	CALL	SYNCHR
	DB	')'			;MUST BE FOLLOWED BY )
	RET				;ALL DONE.

	SUBTTL	FRE  FUNCTION AND INTEGER TO FLOATING  ROUTINES
FRE:
	CALL	GETYPR
	JNZ	CLCDIF
	CALL	FREFAC			;FREE UP ARGUMENT AND SETUP
					;TO GIVE FREE STRING SPACE
	CALL	GARBA2			;DO GARBAGE COLLECTION
CLCDIF:	LHLD	STREND
	XCHG	
	LHLD	FRETOP			;TOP OF FREE AREA
	JMP	GIVDBL			;RETURN [H,L]-[D,E]
	END	
                                                                                                         