	SUBTTL	Common file for BASIC interpreter
	.SALL	

CONTO	SET	15			;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	SET	0			;FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2	

	.PRINTX	/EXTENDED/


	.PRINTX	/LPT/

	.PRINTX	/CPM DISK/


	.PRINTX	/Z80/

	.PRINTX	/FAST/

	.PRINTX	/5.0 FEATURES/

	.PRINTX	/ANSI COMPATIBLE/
	ENDIF

CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	SET	80			;TERMINAL LINE LENGTH 
LPTLEN	SET	132
BUFLEN	SET	255			;LONG LINES
NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
					;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	SET	4

STRSIZ	SET	3
NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES

NUMTMP	SET	10

MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
					;NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES
CPMWRM	SET	0			;CP/M WARM BOOT ADDR
CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR
	CSEG	
TRUROM	SET	0
	PAGE
	TITLE	BIMISC	BASIC Interpreter miscellaneous routines/WHG/PGA etc.
	EXTRN	ARYTAB,BRKTXT,CRDO,CRDONZ,CURLIN,DATPTR,ERROR,FADDS
	EXTRN	FCERR,FCOMP,FNDFOR,FNDLIN,FRETOP,FRMEVL,INCHRI,INLIN,LINGET
	EXTRN	MEMSIZ,MOVFM,MOVMF,MOVRM,NEWSTT,OLDLIN,OLDTXT,OVERR,PTRGET
	EXTRN	SNERR,STREND,SUBFLG,OUTDO,SAVTXT,CHRCON

	EXTRN	TOPMEM
	EXTRN	TEMP,TEMPPT,TEMPST,TMERR,TXTTAB,USERR,VALTYP,VARTAB
	EXTRN	ERRCN,ERRFIN,ERROM,GETBYT,STPRDY,NFERR,INTID2,NXTCON
	PUBLIC	SYNCHR,DCOMPR
	EXTRN	CHRGTR
	EXTRN	GETYPR
	EXTRN	VMOVE,PRMLEN,PRMLN2,DEFTBL,FRQINT,FUNACT,IADD,ICOMP,NOFUNS,PRMSTK
	EXTRN	OPTFLG,OPTVAL
	PUBLIC	STOPRG
	PUBLIC	TON,TOFF
	EXTRN	ONEFLG,ONELIN,TRCFLG,SAVSTK
	EXTRN	NXTFLG
	PUBLIC	CLEARC,SCRATH,STOP,ISLET,ISLET2,STKINI,GETSTK,SCRTCH
	PUBLIC	STPEND,BLTU,CONT,BLTUC,ENDS,GTMPRT,RUNC,STPEND,ENDCON,RESTOR
	PUBLIC	STOP,RESFIN,STKERR,REASON,OMERR
	PUBLIC	NEXT
;
; THIS IS THE BLOCK TRANSFER ROUTINE
; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD
;
; [H,L] = DESTINATION OF HIGH ADDRESS
; [D,E] = LOW ADDRESS TO BE TRANSFERRED
; [B,C] = HIGH ADDRESS TO BE TRANSFERRED
;
; A CHECK IS MADE TO MAKE SURE A REASONABLE AMOUNT
; OF SPACE REMAINS BETWEEN THE TOP OF THE STACK AND
; THE HIGHEST LOCATION TRANSFERRED INTO
;
; ON EXIT [H,L]=[D,E]=LOW [B,C]=LOCATION LOW WAS MOVED INTO
;
BLTU:	CALL	REASON			;CHECK DESTINATION TO MAKE
					;SURE THE STACK WON'T BE OVERRUN
BLTUC:	PUSH	B			;EXCHANGE [B,C] AND [H,L]
	XTHL	
	POP	B
BLTLOP:	CALL	DCOMPR			;SEE IF WE ARE DONE
	MOV	A,M			;GET THE WORD TO TRANSFER
	STAX	B			;TRANSFER IT
	RZ	
	DCX	B
	DCX	H			;BACKUP FOR NEXT GUY
	JMP	BLTLOP
;
; THIS ROUTINE IS USED TO MAKE SURE A CERTAIN NUMBER
; OF LOCATIONS REMAIN AVAILABLE FOR THE
; STACK. THE CALL IS :
;	MVI	C,NUMBER OF 2 BYTE ENTRIES NECESSARY
;	CALL	GETSTK
;
; THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
; AN ARBITRARY AMOUNT OF STUFF ON THE STACK
; (I.E. ANY RECURSIVE ROUTINE LIKE FRMEVL)
; IT IS ALSO CALLED BY ROUTINES SUCH AS "GOSUB" AND "FOR"
; WHICH MAKE PERMANENT ENTRIES ON THE STACK
; ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
; NUMLEV STACK LOCATIONS NEED NOT CALL THIS
;
GETSTK:	PUSH	H			;SAVE [H,L]
	LHLD	MEMSIZ
	MVI	B,0
	DAD	B
	DAD	B			;SEE IF WE CAN HAVE THIS MANY
;
; [H,L]= SOME ADDRESS
; [H,L] IS EXAMINED TO MAKE SURE AT LEAST NUMLEV
; LOCATIONS REMAIN BETWEEN IT AND THE TOP OF THE STACK
;
CONS1	SET	256-(2*NUMLEV)
	MVI	A,CONS1			;SET [H,L]=-[H,L]-2*NUMLEV
	SUB	L
	MOV	L,A
	MVI	A,255
	SBB	H
	JC	OMERR			;IN CASE [H,L] WAS TOO BIG(MBM 3/18**)
	MOV	H,A			;NOW SEE IF [SP] IS LARGER
	DAD	SP			;IF SO, CARRY WILL BE SET
	POP	H			;GET BACK ORIGINAL [H,L]
	RC				;WAS OK?
OMERR:

					;FOR SPACE REASONS LEAVE THIS CODE OUT

					;ONLY IMPORTANT IN VERSIONS WHERE
					;STACK CONTEXT SURVIVES OTHER ERRORS
	LHLD	TOPMEM
	DCX	H			;UP SOME MEMORY SPACE
	DCX	H			;MAKE SURE THE FNDFOR STOPPER IS SAVED
	SHLD	SAVSTK			;PLACE STACK IS RESTORED FROM
OMERRR:	LXI	D,0+ERROM		;"OUT OF MEMORY"
	JMP	ERROR
	EXTRN	GARBA2
REASON:	CALL	REALLY			;ENOUGH SPACE BETWEEN STRING & STACK
	RNC				;YES
	PUSH	B			;SAVE ALL REGS
	PUSH	D
	PUSH	H
	CALL	GARBA2			;DO A GARBAGE COLLECTION
	POP	H			;RESTORE ALL REGS
	POP	D
	POP	B
	CALL	REALLY			;ENOUGH SPACE THIS TIME?
	RNC				;YES
	JMP	OMERRR			;NO, GIVE "OUT OF MEMORY BUT DONT TOUCH STACK
REALLY:	PUSH	D			;SAVE [D,E]
	XCHG				;SAVE [H,L] IN [D,E]
	LHLD	FRETOP			;GET WHERE STRINGS ARE
	CALL	DCOMPR			;IS TOP OF VARS LESS THAN STRINGS?
	XCHG				;BACK TO [D,E]
	POP	D			;RESTORE [D,E]
	RET				;DONE
	PAGE
	SUBTTL	NODSKS, SCRATCH (NEW), RUNC, CLEARC, STKINI, QINLIN
	PUBLIC	NODSKS
	EXTRN	FILPTR,MAXFIL
; THE CODE BELOW SETS THE FILE MODE TO 0 (CLOSED) FOR ALL FCB'S
NODSKS:	LDA	MAXFIL			;GET LARGEST FILE #
	MOV	B,A			;INTO B FOR COUNTER
	LXI	H,FILPTR		;POINT TO TABLE OF FILE DATA BLOCKS
	XRA	A			;MAKE A ZERO TO MARK FILES AS CLOSED
	INR	B
LOPNTO:	MOV	E,M			;GET POINTER TO FILE DATA BLOCK IN [D,E]
	INX	H
	MOV	D,M
	INX	H
	STAX	D			;MARK FILE AS CLOSED (MODE ZERO)
	DCR	B
	JNZ	LOPNTO			;LOOP UNTIL DONE
	EXTRN	CLSALL
	CALL	CLSALL
	XRA	A
					;DONT WIPE OUT INIT MESSAGE ON SCREEN(NEW DOES CLEAR SCREEN)
;
; THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL
; AS VARIABLE SPACE
;
SCRATH:	RNZ				;MAKE SURE THERE IS A TERMINATOR
SCRTCH:
	LHLD	TXTTAB			;GET POINTER TO START OF TEXT
	CALL	TOFF			;TURN OFF TRACE. SET [A]=0.
	EXTRN	PROFLG
	STA	PROFLG			;NO LONGER A PROTECTED FILE
	EXTRN	AUTFLG
	STA	AUTFLG			;CLEAR AUTO MODE
	EXTRN	PTRFLG
	STA	PTRFLG			;SAY NO POINTERS EXIST
	MOV	M,A			;SAVE AT END OFF TEXT
	INX	H			;BUMP POINTER
	MOV	M,A			;SAVE ZERO
	INX	H			;BUMP POINTER
	SHLD	VARTAB			;NEW START OF VARIABLES
RUNC:
	LHLD	TXTTAB			;POINT AT THE START OF TEXT
	DCX	H
;
; CLEARC IS A SUBROUTINE WHICH INITIALIZES THE VARIABLE AND
; ARRAY SPACE BY RESETING ARYTAB [THE END OF SIMPLE VARIABLE SPACE]
; AND STREND [THE END OF ARRAY STORAGE]. IT FALLS INTO STKINI
; WHICH RESETS THE STACK. [H,L] IS PRESERVED.
;
CLEARC:	SHLD	TEMP			;SAVE [H,L] IN TEMP
	EXTRN	MRGFLG
	LDA	MRGFLG			;DOING A CHAIN MERGE?
	ORA	A			;TEST
	JNZ	LEVDTB			;LEAVE DEFAULT TABLE ALONE
	XRA	A
	STA	OPTFLG			;INDICATE NO "OPTION" HAS BEEN SEEN
	STA	OPTVAL			;DEFAULT TO "OPTION BASE 0"
	MVI	B,26			;INITIALIZE THE DEFAULT VALTYPE TABLE
	LXI	H,DEFTBL		;POINT AT THE FIRST ENTRY
LOPDFT:	MVI	M,4			;LOOP 26 TIMES STORING A DEFAULT VALTYP
	INX	H			;FOR SINGLE PRECISION
					;COUNT OFF THE LETTERS
	DCR	B
	JNZ	LOPDFT			;LOOP BACK, AND SETUP THE REST OF THE TABLE
LEVDTB:
	EXTRN	RNDCOP,RNDX,MOVE
	EXTRN	RNDCNT
	LXI	D,RNDCOP		;RESET THE RANDOM NUMBER GENERATOR
	LXI	H,RNDX			;SEED IN RNDX
	CALL	MOVE
	LXI	H,RNDCNT-1		;AND ZERO COUNT REGISTERS
	XRA	A
	MOV	M,A
	INX	H
	MOV	M,A
	INX	H
	MOV	M,A
	XRA	A
	STA	ONEFLG			;RESET ON ERROR FLAG FOR RUNS
	MOV	L,A			;RESET ERROR LINE NUMBER
	MOV	H,A			;BY SETTING ONELIN=0.
	SHLD	ONELIN
	SHLD	OLDTXT			;MAKE CONTINUING IMPOSSIBLE
	LHLD	MEMSIZ
	EXTRN	CHNFLG
	LDA	CHNFLG			;ARE WE CHAINING?
	ORA	A			;TEST
	JNZ	GODFRE			;FRETOP IS GOOD, LEAVE IT ALONE
	SHLD	FRETOP			;FREE UP STRING SPACE
GODFRE:	XRA	A			;MAKE SURE [A] IS ZERO, CC'S SET
	CALL	RESTOR			;RESTORE DATA
	LHLD	VARTAB			;GET START OF VARIABLE SPACE
	SHLD	ARYTAB			;SAVE IN START OF ARRAY SPACE
	SHLD	STREND			;AND END OF VARIABLE STORAGE
	EXTRN	CLSALL
	LDA	MRGFLG			;DOING CHAIN MERGE?
	ORA	A
	CZ	CLSALL			;IF SO, DONT CLOSE FILES...
;
; STKINI RESETS THE STACK POINTER ELIMINATING
; GOSUB & FOR CONTEXT.  STRING TEMPORARIES ARE FREED
; UP, SUBFLG IS RESET, CONTINUING IS DISALLOWED,
; AND A DUMMY ENTRY IS PUT ON THE STACK. THIS IS SO
; FNDFOR WILL ALWAYS FIND A NON-"FOR" ENTRY AT THE BOTTOM
; OF THE STACK. [A]=0 AND [D,E] IS PRESERVED.
;
STKINI:	POP	B			;GET RETURN ADDRESS HERE
	LHLD	TOPMEM
	DCX	H			;TAKE INTO ACCOUNT FNDFOR STOPPER
	DCX	H
	SHLD	SAVSTK			;MAKE SURE SAVSTK OK JUST IN CASE.
	INX	H			;INCREMENT BACK FOR SPHL
	INX	H
STKERR:	SPHL				;INITIALIZE STACK
	LXI	H,TEMPST
	SHLD	TEMPPT			;INITIALIZE STRING TEMPORARIES
	EXTRN	CLROVC
	CALL	CLROVC			;BACK TO NORMAL OVERFLOW PRINT MODE
	EXTRN	FINLPT
	CALL	FINLPT
	EXTRN	FINPRT
	CALL	FINPRT			;CLEAR PTRFIL, OTHER I/O FLAGS
	XRA	A			;ZERO OUT A
	MOV	H,A			;ZERO OUT H
	MOV	L,A			;ZERO OUT L
	SHLD	PRMLEN			;FLAG NO ACTIVE PARAMETERS
	STA	NOFUNS			;INDICATE NO USER FUNCTIONS ACTIVE
	SHLD	PRMLN2			;NO PARAMETERS BEING BUILT
	SHLD	FUNACT			;SET NUMBER OF FUNCTIONS ACTIVE TO 0
	SHLD	PRMSTK			;AND NO PARAMETER BLOCKS ON THE STACK
	STA	SUBFLG			;ALLOW SUBSCRIPTS
	PUSH	H			;PUT ZERO (NON $FOR,$GOSUB)
					;ON THE STACK
	PUSH	B			;PUT RETURN ADDRESS BACK ON
GTMPRT:	LHLD	TEMP			;GET SAVED [H,L]
	RET	

	PAGE
	SUBTTL	DCOMPR, SYNCHR - REPLACEMENTS FOR COMPAR & SYNCHK IN RSTLES VERSION
	PUBLIC	SYNCHR
DCOMPR:	MOV	A,H			;REPLACEMENT FOR "COMPAR" RST
	SUB	D
	RNZ	
	MOV	A,L
	SUB	E
	RET	

SYNCHR:	MOV	A,M			;REPLACEMENT FOR "SYNCHK" RST
	XTHL	
	CMP	M
	JNZ	SYNERR
	INX	H
	XTHL	
	INX	H			;LOOK AT NEXT CHAR
	MOV	A,M			;GET IT
	CPI	':'			;IS IT END OF STATMENT OR BIGGER
	RNC	
SYNCON:	JMP	CHRCON			;REST OF CHRGET
SYNERR:	JMP	SNERR
	SUBTTL	RESTORE, STOP, END

RESTOR:	XCHG				;SAVE [H,L] IN [D,E]
	LHLD	TXTTAB
	JZ	BGNRST			;RESTORE DATA POINTER TO BEGINNING OF PROGRAM
	XCHG				;TEXT POINTER BACK TO [H,L]
	CALL	LINGET			;GET THE FOLLOWING LINE NUMBER
	PUSH	H			;SAVE TEXT POINTER
	CALL	FNDLIN			;FIND THE LINE NUMBER
	MOV	H,B			;GET POINTER TO LINE IN [H,L]
	MOV	L,C
	POP	D			;TEXT POINTER BACK TO [D,E]
	JNC	USERR			;SHOULD HAVE FOUND LINE
BGNRST:
	DCX	H			;INITIALIZE DATPTR TO [TXTTAB]-1
RESFIN:	SHLD	DATPTR			;READ FINISHES COME TO RESFIN
	XCHG				;GET THE TEXT POINTER BACK
	RET	
STOP:	RNZ				;RETURN IF NOT CONTROL-C AND MAKE
					;SURE "STOP" STATEMENTS HAVE A TERMINATOR
STOPRG:
	INR	A
	JMP	CONSTP
					;TO TYPE THE BREAK MESSAGE
ENDS:	RNZ				;MAKE SURE "END" STATEMENTS HAVE A TERMINATOR
	PUSH	PSW			;PRESERVE CONDITION CODES OVER CALL TO CLSALL
	CZ	CLSALL
	POP	PSW			;RESTORE CONDITION CODES
CONSTP:	SHLD	SAVTXT			;SAVE FOR "CONTINUE"
	LXI	H,TEMPST		;RESET STRING TEMP POINTER
	SHLD	TEMPPT			;SAVE IN CASE ^C PRINT USING
	DB	41Q			;"LXI H," OVER NEXT TWO
STPEND:	ORI	377O			;SET NON-ZERO TO FORCE PRINTING OF BREAK MESSAGE
	POP	B			;POP OFF NEWSTT ADDRESS
ENDCON:	LHLD	CURLIN			;SAVE CURLIN
	PUSH	H			;SAVE LINE TO PRINT
	PUSH	PSW			;SAVE THE MESSAGE FLAG
					;ZERO MEANS DON'T PRINT "BREAK"
	MOV	A,L
	ANA	H			;SEE IF IT WAS DIRECT
	INR	A
	JZ	DIRIS			;IF NOT SET UP FOR CONTINUE
	SHLD	OLDLIN			;SAVE OLD LINE #
	LHLD	SAVTXT			;GET POINTER TO START OF STATEMENT
	SHLD	OLDTXT			;SAVE IT
DIRIS:
	EXTRN	CNTOFL
	XRA	A
	STA	CNTOFL			;FORCE OUTPUT
	CALL	FINLPT
	CALL	CRDONZ			;PRINT CR IF TTYPOS .NE. 0
	POP	PSW			;GET BACK ^C FLAG
	LXI	H,BRKTXT		;"BREAK"
	JNZ	ERRFIN			;CALL STROUT AND FALL INTO READY
	JMP	STPRDY			;POP OFF LINE NUMBER & FALL INTO READY
	PAGE
	SUBTTL	CTRLPT, DDT, CONT, NULL, TRON, TROFF
	PUBLIC	CTRLPT,CTROPT
CTROPT:	MVI	A,CONTO			;PRINT AN ^O.
CTRLPT:	PUSH	PSW			;SAVE CURRENT CHAR
	SUI	3			;CONTROL-C?
	JNZ	NTCTCT			;NO
	EXTRN	PRTFLG
	STA	PRTFLG			;DISPLAY ^C ONLY(NOT ON LPT)
	STA	CNTOFL			;RESET ^O FLAG
NTCTCT:
	MVI	A,'^'			;PRINT UP-ARROW.
	CALL	OUTDO			;SEND IT
	POP	PSW			;GET BACK CONTROL CHAR.
	ADI	100O			;MAKE PRINTABLE
	CALL	OUTDO			;SEND IT
	JMP	CRDO			;AND THEN SEND CRLF.
CONT:	LHLD	OLDTXT			;A STORED TEXT POINTER OF
					;ZERO IS SETUP BY STKINI
					;AND INDICATES THERE IS NOTHING
					;TO CONTINUE
	MOV	A,H			;"STOP","END",TYPING CRLF
	ORA	L			;TO "INPUT" AND ^C SETUP OLDTXT
RESERR:	LXI	D,0+ERRCN		;"CAN'T CONTINUE"
	JZ	ERROR
	XCHG				;SAVE [H,L]
	LHLD	OLDLIN
	SHLD	CURLIN			;SET UP OLD LINE # AS CURRENT LINE #
	XCHG				;RESTORE [H,L] 
	RET	
	EXTRN	NULCNT
	PUBLIC	NULL
NULL:	CALL	GETBYT
	RNZ				;MAKE SURE THERE IS A TERMINATOR
	INR	A			;CODE AT CRDO EXPECTS AT LEAST 1
	STA	NULCNT			;CHANGE NUMBER OF NULLS
	RET	
TON:	DB	76Q			;"MVI A," NON-ZERO QUANTITY
TOFF:	XRA	A			;MAKE [A]=0 FOR NO TRACE
	STA	TRCFLG			;UPDATE THE TRACE FLAG
	RET	
	PAGE
	SUBTTL	SWAP, ERASE
	EXTRN	SWPTMP
	PUBLIC	SWAP
SWAP:	CALL	PTRGET			;[D,E]=POINTER AT VALUE #1
	PUSH	D			;SAVE THE POINTER AT VALUE #1
	PUSH	H			;SAVE THE TEXT POINTER
	LXI	H,SWPTMP		;TEMPORARY STORE LOCATION
	CALL	VMOVE			;SWPTMP=VALUE #1
	LHLD	ARYTAB			;GET ARYTAB SO CHANGE CAN BE NOTED
	XTHL				;GET THE TEXT POINTER BACK
					;AND SAVE CURRENT [ARYTAB]
	CALL	GETYPR
	PUSH	PSW			;SAVE THE TYPE OF VALUE #1
	CALL	SYNCHR
	DB	44			;MAKE SURE THE VARIABLES ARE
					;DELIMITED BY A COMMA
	CALL	PTRGET			;[D,E]=POINTER AT VALUE #2
	POP	B			;[B]=TYPE OF VALUE #1
	CALL	GETYPR			;[A]=TYPE OF VALUE #2
	CMP	B			;MAKE SURE THEY ARE THE SAME
	JNZ	TMERR			;IF NOT, "TYPE MISMATCH" ERROR
	XTHL				;[H,L]=OLD [ARYTAB] SAVE THE TEXT POINTER
	XCHG				;[D,E]=OLD [ARYTAB]
	PUSH	H			;SAVE THE POINTER AT VALUE #2
	LHLD	ARYTAB			;GET NEW [ARYTAB]
	CALL	DCOMPR
	JNZ	FCERR			;IF ITS CHANGED, ERROR
	POP	D			;[D,E]=POINTER AT VALUE #2
	POP	H			;[H,L]=TEXT POINTER
	XTHL				;SAVE THE TEXT POINTER ON THE STACK
					;[H,L]=POINTER AT VALUE #1
	PUSH	D			;SAVE THE POINTER AT VALUE #2
	CALL	VMOVE			;TRANSFER VALUE #2 INTO VALUE #1'S OLD
					;POSITION
	POP	H			;[H,L]=POINTER AT VALUE #2
	LXI	D,SWPTMP		;LOCATION OF VALUE #1
	CALL	VMOVE			;TRANSFER SWPTMP=VALUE #1 INTO VALUE #2'S
					;OLD POSITION
	POP	H			;GET THE TEXT POINTER BACK
	RET	
	PUBLIC	ERASE
ERASE:
	MVI	A,1
	STA	SUBFLG			;THAT THIS IS "ERASE" CALLING PTRGET
	CALL	PTRGET			;GO FIND OUT WHERE TO ERASE
	JNZ	FCERR			;PTRGET DID NOT FIND VARIABLE!
	PUSH	H			;SAVE THE TEXT POINTER
	STA	SUBFLG			;ZERO OUT SUBFLG TO RESET "ERASE" FLAG
	MOV	H,B			;[B,C]=START OF ARRAY TO ERASE
	MOV	L,C
	DCX	B			;BACK UP TO THE FRONT
	DCX	B			;NO VALUE TYPE WITHOUT LENGTH=2
	DCX	B			;BACK UP ONE MORE
LPBKNM:	LDAX	B			;GET A CHARACTER. ONLY THE COUNT HAS HIGH BIT=0
	DCX	B			;SO LOOP UNTIL WE SKIP OVER THE COUNT
	ORA	A			;SKIP ALL THE EXTRA CHARACTERS
	JM	LPBKNM
	DCX	B
	DCX	B
	DAD	D			;[H,L]=THE END OF THIS ARRAY ENTRY
	XCHG				;[D,E]=END OF THIS ARRAY
	LHLD	STREND			;[H,L]=LAST LOCATION TO MOVE UP
ERSLOP:	CALL	DCOMPR			;SEE IF THE LAST LOCATION IS GOING TO BE MOVED
	LDAX	D			;DO THE MOVE
	STAX	B
	INX	D			;UPDATE THE POINTERS
	INX	B
	JNZ	ERSLOP			;MOVE THE REST
	DCX	B
	MOV	H,B			;SETUP THE NEW STORAGE END POINTER
	MOV	L,C
	SHLD	STREND
	POP	H			;GET BACK THE TEXT POINTER
	MOV	A,M			;SEE IF MORE ERASURES NEEDED
	CPI	54O			;ADDITIONAL VARIABLES DELIMITED BY COMMA
	RNZ				;ALL DONE IF NOT
	CALL	CHRGTR
	JMP	ERASE
CASDON:
	PUBLIC	POPAHT
POPAHT:	POP	PSW
	POP	H			;GET THE TEXT POINTER
	RET	
	PAGE
;
;TEST FOR A LETTER / CARRY ON=NOT A LETTER
;		     CARRY OFF=A LETTER
;
ISLET:	MOV	A,M
ISLET2:	CPI	'A'
	RC				;IF LESS THAN "A", RETURN EARLY
	CPI	91			;91="Z"+1
	CMC	
	RET	
	SUBTTL	CLEAR
;
; THIS CODE IS FOR THE "CLEAR" COMMAND WITH AN ARGUMENT
; TO CHANGE THE AMOUNT OF STRING SPACE ALLOCATED.
; IF NO FORMULA IS GIVEN THE AMOUNT OF STRING SPACE
; REMAINS UNCHANGED.
;
	PUBLIC	CLEAR
CLEAR:	JZ	CLEARC			;IF NO FORMULA JUST CLEAR
	CPI	54O			;ALLOW NO STRING SPACE
	JZ	CSKPCM
	CALL	INTID2			;GET AN INTEGER INTO [D,E]
	DCX	H
	CALL	CHRGTR			;SEE IF ITS THE END
	JZ	CLEARC
CSKPCM:	CALL	SYNCHR
	DB	54O
	JZ	CLEARC
	XCHG	
	LHLD	TOPMEM			;GET HIGHEST ADDRESS
	XCHG	
	CPI	54O
	JZ	CLEARS			;SHOULD FINISH THERE
	CALL	FRMEVL			;EVALUATE FORMULA
	PUSH	H			;SAVE TEXT POINTER
	CALL	FRQINT			;CONVERT TO INTEGER IN [H,L]
	MOV	A,H
	ORA	L			;Memory size =0?
	JZ	FCERR##			;Yes, error
	XCHG				;VALUE TO [D,E]
	POP	H			;RESTORE TEXT POINTER
CLEARS:	DCX	H			;BACK UP
	CALL	CHRGTR			;GET CHAR
	PUSH	D			;SAVE NEW HIGH MEM
	JZ	CDFSTK			;USE SAME STACK SIZE
	CALL	SYNCHR
	DB	54O
	JZ	CDFSTK
	CALL	INTID2
	DCX	H
	CALL	CHRGTR
	JNZ	SNERR
CLEART:	XTHL				;SAVE TEXT POINTER
	PUSH	H			;SAVE CANDIDATE FOR TOPMEM
	LXI	H,0+(2*NUMLEV)+20	;CHECK STACK SIZE IS REASONABLE
	CALL	DCOMPR
	JNC	OMERR
	POP	H
	CALL	SUBDE			;SUBTRACT [H,L]-[D,E] INTO [D,E]
	JC	OMERR			;WANTED MORE THAN TOTAL!
	PUSH	H			;SAVE MEMSIZ
	LHLD	VARTAB			;TOP LOCATION IN USE
	LXI	B,0+20			;LEAVE BREATHING ROOM
	DAD	B
	CALL	DCOMPR			;ROOM?
	JNC	OMERR			;NO, DON'T EVEN CLEAR
	XCHG				;NEW STACK LOCATION [H,L]
	SHLD	MEMSIZ			;SET UP NEW STACK LOCATION
	POP	H			;GET BACK MEMSIZ
	SHLD	TOPMEM			;SET IT UP, MUST BE OK
	POP	H			;REGAIN THE TEXT POINTER
	JMP	CLEARC			;GO CLEAR
CDFSTK:	PUSH	H			;SAVE TEXT POINTER
	LHLD	TOPMEM			;FIGURE OUT CURRENT STACK SIZE SO
	XCHG				;IT IS SAVED
	LHLD	MEMSIZ
	MOV	A,E
	SUB	L
	MOV	E,A
	MOV	A,D
	SBB	H
	MOV	D,A
	POP	H
	JMP	CLEART

SUBDE:	MOV	A,L
	SUB	E
	MOV	E,A
	MOV	A,H
	SBB	D
	MOV	D,A
	RET	
	PAGE
	SUBTTL	NEXT CODE
;
; A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT:
;
; LOW ADDRESS
;	TOKEN ($FOR IN HIGH BYTE)  1 BYTES
;	A POINTER TO THE LOOP VARIABLE  2 BYTES
;	UNDER ANSI & LENGTH=2, TWO BYTES GIVING TEXT POINTER OF MATCHING "NEXT"
;	A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE
;	UNDER LENGTH=2, A BYTE MINUS FOR INTEGER AND POSITIVE FOR FLOATING "FOR"S
;	THE STEP 4 BYTES
;	THE UPPER VALUE 4 BYTES
;	THE LINE # OF THE "FOR" STATEMENT 2 BYTES
;	A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES
; HIGH ADDRESS
;
; TOTAL 16-19 BYTES
;
	PUBLIC	NEXT
NEXT:
	PUSH	PSW			;SAVE THE CHARACTER CODES
	DB	366Q			;SET [A] NON-ZERO
	PUBLIC	NEXTS
NEXTS:	XRA	A			;FLAG THAT "FOR" IS USING "NEXT"
	STA	NXTFLG
	POP	PSW			;GET BACK THE CHARACTER CODE
	LXI	D,0			;FOR THE "NEXT"
					;STATEMENT WITHOUT ANY ARGS
					;WE CALL FNDFOR WITH [D,E]=0
NEXTC:
	EXTRN	NXTTXT
	SHLD	NXTTXT			;SAVE STARTING TEXT POINTER
	CNZ	PTRGET			;GET A POINTER TO THE
					;LOOP VARIABLE INTO [D,E]
	SHLD	TEMP			;PUT THE TEXT POINTER
					;IN A TEMP LOCATION
					;IN CASE THE LOOP TERMINATES
	CALL	FNDFOR			;TRY TO FIND A FOR ENTRY
					;ON THE STACK WHOSE VARIABLE NAME
					;MATCHES THIS ONES
	JNZ	NFERR			;"NEXT WITHOUT FOR"
	SPHL				;SETUP STACK POINTER BY CHOPPING
					;AT THIS POINT
	PUSH	D			;PUT THE VARIABLE PTR BACK ON
	MOV	E,M			;PICK UP THE CORRECT "NEXT" TEXT POINTER
	INX	H
	MOV	D,M
	INX	H
	PUSH	H			;SAVE THE POINTER INTO THE STACK ENTRY
	LHLD	NXTTXT			;[H,L]=TEXT POINTER AT THE START OF THIS "NEXT"
	CALL	DCOMPR
	JNZ	NFERR			;IF NO MATCH, "NEXT WITHOUT FOR"
	POP	H
	POP	D			;GET BACK THE VARIABLE POINTER
	PUSH	D
	MOV	A,M			;STEP ONTO THE STACK
	PUSH	PSW
	INX	H
	PUSH	D			;PUT THE POINTER TO THE LOOP
					;VARIABLE ONTO THE STACK
	MOV	A,M			;GET FLAG WHETHER THIS IS AN INTEGER "FOR"
	INX	H			;ADVANCE THE "FOR" ENTRY POINTER
	ORA	A			;SET THE MINUS FLAG IF IT'S AN INTEGER "FOR"
	JM	INTNXT			;HANDLE INTEGERS SEPERATELY
	CALL	MOVFM			;STEP VALUE INTO THE FAC
	XTHL				;PUT THE POINTER INTO THE
					;FOR ENTRY ONTO THE STACK
	PUSH	H			;PUT THE POINTER TO THE LOOP
					;VARIABLE BACK ONTO THE STACK
	LDA	NXTFLG			;IS "FOR" USING "NEXT"
	ORA	A
	JNZ	NXTDO			;NO, CONTINUE "NEXT"
	EXTRN	FVALSV
	LXI	H,FVALSV		;FETCH THE INITIAL VALUE INTO THE FAC
	CALL	MOVFM
	XRA	A			;CONTINUE THE "NEXT" WITH INITIAL VALUE
NXTDO:	CNZ	FADDS
	POP	H			;POP OFF THE POINTER TO 
					;THE LOOP VARIABLE
	CALL	MOVMF			;MOV FAC INTO LOOP VARIABLE
	POP	H			;GET THE ENTRY POINTER
	CALL	MOVRM			;GET THE FINAL INTO THE REGISTERS
	PUSH	H			;SAVE THE ENTRY POINTER
	CALL	FCOMP			;COMPARE THE NUMBERS RETURNING 377 IF FAC IS
					;LESS THAN THE REGISTERS,
					;0 IF EQUAL, OTHERWISE 1
	JMP	FINNXT			;SKIP OVER INTEGER CODE
INTNXT:	INX	H			;SKIP THE FOUR DUMMY BYTES
	INX	H
	INX	H
	INX	H
	MOV	C,M			;[B,C]= THE STEP
	INX	H
	MOV	B,M
	INX	H
	XTHL				;SAVE THE ENTRY POINTER ON THE STACK
					;AND SET [H,L]=POINTER TO THE LOOP VARIABLE
	MOV	E,M			;[D,E]=LOOP VARIABLE VALUE
	INX	H
	MOV	D,M
	PUSH	H			;SAVE THE POINTER AT THE LOOP VARIABLE VALUE
	MOV	L,C
	MOV	H,B			;SETUP TO ADD [D,E] TO [H,L]
	LDA	NXTFLG			;SEE IF "FOR" IS USING "NEXT"
	ORA	A
	JNZ	INXTDO			;NO, JUST CONTINUE NEXT
	LHLD	FVALSV			;GET THE INITIAL VALUE
	JMP	IFORIN			;CONTINUE FIRST ITERATION CHECK
INXTDO:	CALL	IADD			;ADD THE STEP TO THE LOOP VARIABLE
	LDA	VALTYP			;SEE IF THERE WAS OVERFLOW
	CPI	4			;TURNED TO SINGLE-PRECISION?
	JZ	OVERR			;INDICE GOT TOO LARGE
IFORIN:	XCHG				;[D,E]=NEW LOOP VARIABLE VALUE
	POP	H			;GET THE POINTER AT THE LOOP VARIABLE
	MOV	M,D			;STORE THE NEW VALUE
	DCX	H
	MOV	M,E
	POP	H			;GET BACK THE POINTER INTO THE "FOR" ENTRY
	PUSH	D			;SAVE THE VALUE OF THE LOOP VARIABLE
	MOV	E,M			;[D,E]=FINAL VALUE
	INX	H
	MOV	D,M
	INX	H
	XTHL				;SAVE THE ENTRY POINTER AGAIN
					;GET THE VALUE OF THE LOOP VARIABLE INTO [H,L]
	CALL	ICOMP			;DO THE COMPARE
FINNXT:
	POP	H			;POP OFF THE "FOR" ENTRY POINTER WHICH IS NOW
					;POINTING PAST THE FINAL VALUE
	POP	B			;GET THE SIGN OF THE INCREMENT
	SUB	B			;SUBTRACT THE INCREMENTS SIGN FROM THAT
					;OF (CURRENT VALUE-FINAL VALUE)
	CALL	MOVRM			;GET LINE # OF "FOR" INTO [D,E]
					;GET TEXT POINTER OF "FOR" INTO [B,C]
	JZ	LOOPDN			;IF SIGN(FINAL-CURRENT)+SIGN(STEP)=0
					;THEN THE LOOP IS FINISHED
	XCHG	
	SHLD	CURLIN			;STORE THE LINE #
	MOV	L,C			;SETUP THE TEXT POINTER
	MOV	H,B
	JMP	NXTCON

LOOPDN:	SPHL				;ELIMINATE THE FOR ENTRY
					;SINCE [H,L] MOVED ALL
					;THE WAY DOWN THE ENTRY
	SHLD	SAVSTK			;UPDATE SAVED STACK
	LHLD	TEMP			;RESTORE THE TEXT POINTER
	MOV	A,M			;IS THERE A COMMA AT THE END
	CPI	44			;IF SO LOOK AT ANOTHER
	JNZ	NEWSTT			;VARIABLE NAME TO "NEXT"
	CALL	CHRGTR			;READ FIRST CHARCTER
	CALL	NEXTC			;DO NEXT, BUT DON'T ALLOW
					;BLANK VARIABLE NAME [D,E]=STK PTR
					;AND WILL NEVER MATCH ANY VARPTR
					;USE CALL TO PUT DUMMY "NEWSTT" ENTRY ON
	PAGE
					;END I8086 CONDITONAL
	END	
                                                                                                              