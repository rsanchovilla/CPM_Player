	SUBTTL	Common file for BASIC interpreter
	.SALL	

CONTO	SET	15			;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	SET	0			;FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2	

	.PRINTX	/EXTENDED/


	.PRINTX	/LPT/

	.PRINTX	/CPM DISK/


	.PRINTX	/Z80/

	.PRINTX	/FAST/

	.PRINTX	/5.0 FEATURES/

	.PRINTX	/ANSI COMPATIBLE/
	ENDIF

CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	SET	80			;TERMINAL LINE LENGTH 
LPTLEN	SET	132
BUFLEN	SET	255			;LONG LINES
NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
					;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	SET	4

STRSIZ	SET	3
NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES

NUMTMP	SET	10

MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
					;NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES
CPMWRM	SET	0			;CP/M WARM BOOT ADDR
CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR
	CSEG	
TRUROM	SET	0
	PAGE
	TITLE	BIPTRG	BASIC Interpreter pointer get routines/WHG/PGA
	SUBTTL	DIMENSION & VARIABLE SEARCHING - PTRGET
	EXTRN	ARYTA2,ARYTAB,BLTU,DIMFLG,ERRBS,ERROR,FAC,FCERR
	EXTRN	FACLO,GETSTK,INTIDX,ISLET,ISLET2,OMERR,REASON,SNERR,STREND
	EXTRN	SUBFLG,TEMP2,TEMP3,UMULT,VALTYP,VARTAB,REDDY,POPHRT,ERRDD,RETVAR
	EXTRN	CHRGTR,DCOMPR,SYNCHR
	EXTRN	GETYPR
	EXTRN	NAMBUF,NAMCNT,NAMTMP
	EXTRN	OPTVAL
	EXTRN	PARM1,PRMFLG,PRMLEN,DEFTBL,NOFUNS
	PUBLIC	PTRGET,BSERR,PTRGT2,DIM,NOARYS
DIMCON:	DCX	H			;SEE IF COMMA ENDED THIS VARIABLE
	CALL	CHRGTR
	RZ				;IF TERMINATOR, GOOD BYE
	CALL	SYNCHR
	DB	44			;MUST BE COMMA
;
; THE "DIM" CODE SETS DIMFLG AND THEN FALLS INTO THE VARIABLE
; SEARCH ROUTINE. THE VARIABLE SEARCH ROUTINE LOOKS AT
; DIMFLG AT THREE DIFFERENT POINTS:
;
;	1) IF AN ENTRY IS FOUND, DIMFLG BEING ON INDICATES
;		A "DOUBLY DIMENSIONED" VARIABLE
;	2) WHEN A NEW ENTRY IS BEING BUILT DIMFLG'S BEING ON
;		INDICATES THE INDICES SHOULD BE USED FOR
;		THE SIZE OF EACH INDICE. OTHERWISE THE DEFAULT
;		OF TEN IS USED.
;	3) WHEN THE BUILD ENTRY CODE FINISHES, ONLY IF DIMFLG IS
;		OFF WILL INDEXING BE DONE
;
DIM:	LXI	B,DIMCON		;PLACE TO COME BACK TO
	PUSH	B
	DB	366Q			;"ORI" NON ZERO THING
					;MUST TURN THE MSB ON
;
; ROUTINE TO READ THE VARIABLE NAME AT THE CURRENT TEXT POSITION
; AND PUT A POINTER TO ITS VALUE IN [D,E]. [H,L] IS UPDATED
; TO POINT TO THE CHARACTER AFTER THE VARIABLE NAME.
; VALTYP IS SETUP. NOTE THAT EVALUATING SUBSCRIPTS IN
; A VARIABLE NAME CAN CAUSE RECURSIVE CALLS TO PTRGET SO AT
; THAT POINT ALL VALUES MUST BE STORED ON THE STACK.
; ON RETURN, [A] DOES NOT REFLECT THE VALUE OF THE TERMINATING CHARACTER
;
PTRGET:	XRA	A			;MAKE [A]=0
	STA	DIMFLG			;FLAG IT AS SUCH
	MOV	C,M			;GET FIRST CHARACTER IN [C]
PTRGT2:	CALL	ISLET			;CHECK FOR LETTER
	JC	SNERR			;MUST HAVE A LETTER
	XRA	A
	MOV	B,A			;ASSUME NO SECOND CHARACTER
	STA	NAMCNT			;ZERO NAMCNT
	INX	H			;INCRMENT TEXT POINTER
	MOV	A,M			;GET CHAR
	CPI	'.'			;IS IT A DOT?
	JC	NOSEC			;TOO SMALL FOR ANYTHING REASONABLE
	JZ	ISSEC			;"." IS VALID VAR CHAR
	CPI	'9'+1			;TOO BIG FOR NUMERIC?
	JNC	PTRGT3			;YES
	CPI	'0'			;IN RIGHT RANGE?
	JNC	ISSEC			;YES, WAS NUMERIC
PTRGT3:	CALL	ISLET2			;SET CARRY IF NOT ALPHABETIC
	JC	NOSEC			;ALLOW ALPHABETICS
ISSEC:	MOV	B,A			;IT IS A NUMBER--SAVE IN B
	PUSH	B			;SAVE [B,C]
	MVI	B,255			;[B] COUNTS THE CHARACTERS PAST #2
	LXI	D,NAMBUF-1		;THE PLACE TO PUT THE CHARACTERS
VMORCH:	ORI	128			;EXTRA CHARACTERS MUST HAVE THE HIGH BIT ON
					;SO ERASE CAN SCAN BACKWARDS OVER THEM
	INR	B			;INCREASE THE CHACRACTER COUNT
	STAX	D			;AND STORE INTO THE BUFFER
	INX	D			;AND UPDATE THE BUFFER POINTER
	INX	H			;INCREMENT TEXT POINTER
	MOV	A,M			;GET CHAR
	CPI	'9'+1			;TOO BIG?
	JNC	VMORC1			;YES
	CPI	'0'			;IN RANGE FOR DIGIT
	JNC	VMORCH			;YES, VALID CHAR
VMORC1:	CALL	ISLET2			;AS ARE ALPHABETICS
	JNC	VMORCH
	CPI	'.'			;DOTS ALSO OK
	JZ	VMORCH			;SO EAT IT
	MOV	A,B			;CHECK FOR MAXIMUM COUNT
	CPI	NAMLEN-1		;LIMITED TO SIZE OF NAMBUF ONLY
	JNC	SNERR			;MUST BE BAD SYNTAX
	POP	B			;GET BACK THE STORED [B,C]
	STA	NAMCNT			;ALWAYS SET UP COUNT OF EXTRAS
	MOV	A,M			;RESTORE TERMINATING CHAR
NOSEC:
	CPI	'%'+1			;NOT A TYPE INDICATOR
	JNC	TABTYP			;THEN DONT CHECK THEM
	LXI	D,HAVTYP		;SAVE JUMPS BY USING RETURN ADDRESS
	PUSH	D
	MVI	D,2			;CHECK FOR INTEGER
	CPI	'%'
	RZ	
	INR	D			;CHECK FOR STRING
	CPI	'$'
	RZ	
	INR	D			;CHECK FOR SINGLE PRECISION
	CPI	'!'
	RZ	
	MVI	D,8			;ASSUME ITS DOUBLE PRECISION
	CPI	'#'			;CHECK THE CHARACTER
	RZ				;WHEN WE MATCH, SETUP VALTYP
	POP	PSW			;POP OFF NON-USED HAVTYP ADDRESS
TABTYP:	MOV	A,C			;GET THE STARTING CHARACTER
	ANI	127			;GET RID OF THE USER-DEFINED
					;FUNCTION BIT IN [C]
	MOV	E,A			;BUILD A TWO BYTE OFFSET
	MVI	D,0
	PUSH	H			;SAVE THE TEXT POINTER
	LXI	H,DEFTBL-'A'		;SEE WHAT THE DEFAULT IS
	DAD	D
	MOV	D,M			;GET THE TYPE OUT OF THE TABLE
	POP	H			;GET BACK THE TEXT POINTER
	DCX	H			;NO MARKING CHARACTER
HAVTYP:	MOV	A,D			;SETUP VALTYP
	STA	VALTYP
	CALL	CHRGTR			;READ PAST TYPE MARKER
	LDA	SUBFLG			;GET FLAG WHETHER TO ALLOW ARRAYS
	DCR	A			;IF SUBFLG=1, "ERASE" HAS CALLED
	JZ	ERSFIN			;PTRGET, AND SPECIAL HANDLING MUST BE DONE
	JP	NOARYS			;NO ARRAYS ALLOWED
	MOV	A,M			;GET CHAR BACK
	SUI	'('			;ARRAY PERHAPS (IF SUBFLG SET NEVER WILL MATCH)
	JZ	ISARY			;IT IS!
	SUI	'['-')'+1		;SEE IF LEFT BRACKET
	JZ	ISARY			;IF SO, OK SUBSCRIPT
NOARYS:	XRA	A			;ALLOW PARENS AGAIN
	STA	SUBFLG			;SAVE IN FLAG LOCATION
	PUSH	H			;SAVE THE TEXT POINTER
	LDA	NOFUNS			;ARE FUNCTIONS ACTIVE?
	ORA	A
	STA	PRMFLG			;INDICATE IF PARM1 NEEDS SEARCHING
	JZ	SNFUNS			;NO FUNCTIONS SO NO SPECIAL SEARCH
	LHLD	PRMLEN			;GET THE SIZE TO SEARCH
	LXI	D,PARM1			;GET THE BASE OF THE SEARCH
	DAD	D			;[H,L]= PLACE TO STOP SEARCHING
	SHLD	ARYTA2			;SET UP STOPPING POINT
	XCHG				;[H,L]=START [D,E]=END
	JMP	LOPFND			;START LOOPING
LOPTOP:	LDAX	D			;GET THE VALTYP OF THIS SIMPLE VARIABLE
	MOV	L,A			;SAVE SO WE KNOW HOW MUCH TO SKIP
	INX	D
	LDAX	D			;[A]=FIRST CHARACTER OF THIS VARIABLE
	INX	D			;POINT TO 2ND CHAR OF VAR NAME
	CMP	C			;SEE IF OUR VARIABLE MATCHES
	JNZ	NOTIT1
	LDA	VALTYP			;GET TYPE WERE LOOKING FOR
	CMP	L			;COMPARE WITH OUR VALTYP
	JNZ	NOTIT1			;NOT RIGHT KIND -- SKIP IT
	LDAX	D			;SEE IF SECOND CHACRACTER MATCHES
	CMP	B
	JZ	FINPTR			;THAT WAS IT, ALL DONE
NOTIT1:	INX	D
NFINPT:	LDAX	D			;GET LENGTH OF VAR NAME IN [A]
SNOMAT:
					;SKIP OVER THE
					;CURRENT VARIABLE SINCE WE DIDN'T MATCH
	MVI	H,0			;[H,L]=NUMBER OF BYTES TO SKIP
	ADD	L			;ADD VALTYPE TO LENGTH OF VAR
	INR	A			;PLUS ONE
	MOV	L,A			;SAVE IN [L] TO MAKE OFFSET
	DAD	D			;ADD ON THE POINTER
LOPFND:	XCHG				;[D,E]=POINTER INTO SIMPLE VARIABLES
	LDA	ARYTA2			;ARE LOW BYTES DIFFERENT
	CMP	E			;TEST
	JNZ	LOPTOP			;YES
	LDA	ARYTA2+1		;ARE HIGH BYTES DIFFERENT
	CMP	D			;THE SAME?
	JNZ	LOPTOP			;NO, MUST BE MORE VARS TO EXAMINE

NOTFNS:	LDA	PRMFLG			;HAS PARM1 BEEN SEARCHED
	ORA	A
	JZ	SMKVAR			;IF SO, CREATE VARIABLE
	XRA	A			;FLAG PARM1 AS SEARCHED
	STA	PRMFLG
SNFUNS:	LHLD	ARYTAB			;STOPPING POINT IS [ARYTA2]
	SHLD	ARYTA2
	LHLD	VARTAB			;SET UP STARTING POINT
	JMP	LOPFND

; THIS IS EXIT FOR VARPTR AND OTHERS
VARNOT:
	MOV	D,A			;ZERO [D,E]
	MOV	E,A
	POP	B			;GET RID OF PUSHED [D,E]
	XTHL				;PUT RETURN ADDRESS BACK ON STACK
	RET				;RETURN FROM PTRGET

SMKVAR:	POP	H			;[H,L]= TEXT POINTER
	XTHL				;[H,L]= RETURN ADDRESS
	PUSH	D			;SAVE CURRENT VARIABLE TABLE POSITION
	EXTRN	VARRET
	LXI	D,VARRET		;ARE WE RETURNING TO VARPTR?
	CALL	DCOMPR			;COMPARE
	JZ	VARNOT			;YES.
	EXTRN	COMPTR,COMPT2		;RETURN HERE IF NOT FOUND
	LXI	D,COMPTR
	CALL	DCOMPR
	JZ	VARNOT
	LXI	D,COMPT2		;2ND ONE
	CALL	DCOMPR
	JZ	VARNOT
	LXI	D,RETVAR		;DID EVAL CALL US?
	CALL	DCOMPR			;IF SO, DON'T MAKE A NEW VARIABLE
	POP	D			;RESTORE THE POSITION
	JZ	FINZER			;MAKE FAC ZERO (ALL TYPES) AND SKIP RETURN
	XTHL				;PUT RETURN ADDRESS BACK
	PUSH	H			;PUT THE TEXT POINTER BACK
	PUSH	B			;SAVE THE LOOKS
	LDA	VALTYP			;GET LENGTH OF SYMBOL TABLE ENTRY
	MOV	B,A			;[B]=VALTYP
	LDA	NAMCNT			;INCLUDE EXTRA CHARACTERS IN SIZE
	ADD	B
	INR	A			;AS WELL AS THE EXTRA CHARACTER COUNT
	MOV	C,A			;[B,C]=LENGTH OF THIS VARIABLE
	PUSH	B			;SAVE THE VALTYP ON THE STACK
	MVI	B,0			;[B]=0
	INX	B			;MAKE THE LENGTH INCLUDE
					;THE LOOKS TOO
	INX	B
	INX	B
					;EVERYTHING UP BY
	LHLD	STREND			;THE CURRENT END OF STORAGE
	PUSH	H			;SAVE THIS #
	DAD	B			;ADD ON THE AMOUNT OF SPACE
					;EXTRA NOW BEING USED
	POP	B			;POP OFF HIGH ADDRESS TO MOVE
	PUSH	H			;SAVE NEW CANDIDATE FOR STREND
	CALL	BLTU			;BLOCK TRANSFER AND MAKE SURE
					;WE ARE NOT OVERFLOWING THE
					;STACK SPACE
	POP	H			;[H,L]=NEW STREND
	SHLD	STREND			;STORE SINCE WAS OK
					;THERE WAS ROOM, AND BLOCK TRANSFER
					;WAS DONE, SO UPDATE POINTERS
	MOV	H,B			;GET BACK [H,L] POINTING AT THE END
	MOV	L,C			;OF THE NEW VARIABLE
	SHLD	ARYTAB			;UPDATE THE ARRAY TABLE POINTER
ZEROER:	DCX	H			;[H,L] IS RETURNED POINTING TO THE
	MVI	M,0			;END OF THE VARIABLE SO WE
	CALL	DCOMPR			;ZERO BACKWARDS TO [D,E] WHICH
	JNZ	ZEROER			;POINTS TO THE START OF THE VARIABLE
	POP	D			;[E]=VALTYP
	MOV	M,D			;VALTYP IS IN HIGH ORDER
	INX	H
	POP	D
	MOV	M,E			;PUT DESCRIPTION
	INX	H
	MOV	M,D			;OF THIS VARIABLE
					;INTO MEMORY
	CALL	NPUTSB			;SAVE THE EXTRA CHARACTERS IN THE NAME
	XCHG				;POINTER AT VARIABLE INTO [D,E]
	INX	D			;POINT AT THE VALUE
	POP	H			;RESTORE THE TEXT POINTER
	RET	
FINPTR:	INX	D			;POINT AT THE EXTRA CHARACTER COUNT
	LDA	NAMCNT			;SEE IF THE EXTRA COUNTS MATCH
	MOV	H,A			;SAVE LENGTH OF NEW VAR
	LDAX	D			;GET LENGTH OF CURRENT VAR
	CMP	H			;ARE THEY THE SAME?
	JNZ	NFINPT			;SKIP EXTRAS AND CONTINUE SEARCH
	ORA	A			;LENGTH ZERO?
	JNZ	NTFPRT			;NO, MORE CHARS TO LOOK AT
	INX	D			;POINT TO VALUE OF VAR
	POP	H			;RESTORE TEXT POINTER
	RET				;ALL DONE WITH THIS VAR
NTFPRT:	XCHG	
	CALL	MATSUB			;SEE IF THE CHARACTERS MATCH
	XCHG				;TABLE POINTER BACK INTO [D,E]
	JNZ	SNOMAT			;IF NOT, CONTINUE SEARCH
	POP	H			;GET BACK THE TEXT POINTER
	RET	
;
; MAKE ALL TYPES ZERO AND SKIP RETURN
;
FINZER:
	STA	FAC			;MAKE SINGLES AND DOUBLES ZERO
	MOV	H,A			;MAKE INTEGERS ZERO
	MOV	L,A
	SHLD	FACLO
	CALL	GETYPR			;SEE IF ITS A STRING
	JNZ	POPHR2			;IF NOT, DONE
	LXI	H,REDDY-1		;MAKE IT A NULL STRING BY
	SHLD	FACLO			;POINTING AT A ZERO
POPHR2:	POP	H			;GET THE TEXT POINTER
	RET				;RETURN FROM EVAL


	PAGE
	SUBTTL	MULTIPLE DIMENSION CODE

;
; FORMAT OF ARRAYS IN CORE
;
; DESCRIPTOR 
;	LOW BYTE = SECOND CHARCTER (200 BIT IS STRING FLAG)
;	HIGH BYTE = FIRST CHARACTER
; LENGTH OF ARRAY IN CORE IN BYTES (DOES NOT INCLUDE DESCRIPTOR)
; NUMBER OF DIMENSIONS 1 BYTE
; FOR EACH DIMENSION STARTING WITH THE FIRST A LIST
; (2 BYTES EACH) OF THE MAX INDICE+1
; THE VALUES
;
ISARY:	PUSH	H			;SAVE DIMFLG AND VALTYP FOR RECURSION
	LHLD	DIMFLG
	XTHL				;TEXT POINTER BACK INTO [H,L]
	MOV	D,A			;SET # DIMENSIONS =0
INDLOP:	PUSH	D			;SAVE NUMBER OF DIMENSIONS
	PUSH	B			;SAVE LOOKS
	LXI	D,NAMCNT		;POINT AT THE AREA TO SAVE
	LDAX	D			;GET LENGTH
	ORA	A			;IS IT ZERO?
	JZ	SHTNAM			;YES, SHORT NAME
	XCHG				;SAVE THE TEXT POINTER IN [D,E]
	ADI	2			;WE WANT SMALLEST INT .GE.(NAMCNT+1)/2
	RAR	
	MOV	C,A			;SEE IF THERE IS ROOM TO SAVE THIS STUFF
	CALL	GETSTK
	MOV	A,C			;RESTORE COUNT OF PUSHES
LPPSNM:	MOV	C,M			;GET VALUES TO PUSH
	INX	H
	MOV	B,M
	INX	H
	PUSH	B			;AND DO THE SAVE
	DCR	A			;[A] TIMES
	JNZ	LPPSNM
	PUSH	H			;SAVE THE ADDRESS TO STORE TO
	LDA	NAMCNT			;SAVE THE NUMBER OF BYTES FOR A COUNT
	PUSH	PSW
	XCHG				;RESTORE THE TEXT POINTER
	CALL	INTIDX			;EVALUATE INDICE INTO [D,E]
	POP	PSW			;COUNT TELLING HOW MUCH TO RESTORE
	SHLD	NAMTMP			;SAVE THE TEXT POINTER
	POP	H			;THE PLACE TO RESTORE TO
	ADI	2			;CALCULATE BYTE POPS AGAIN
	RAR	
LPLNAM:	POP	B
	DCX	H
	MOV	M,B
	DCX	H
	MOV	M,C
	DCR	A			;LOOP [A] TIMES POPING NAME BACK INTO NAMBUF
	JNZ	LPLNAM
	LHLD	NAMTMP
	JMP	LNGNAM			;WAS LONG ONE
SHTNAM:	CALL	INTIDX			;EVALUATE IT
	XRA	A			;MAKE SURE NAMCNT=0
	STA	NAMCNT
LNGNAM:
	LDA	OPTVAL			;SEE WHAT THE OPTION BASE IS
	ORA	A
	JZ	OPTB0			;IF BASE 0 DO NOTHING
	MOV	A,D			;CHECK FOR 0 SUBSCRIPT
	ORA	E			;WHICH IS ILLEGAL IN BASE 1
	DCX	D			;ADJUST SUBSCRIPT
	JZ	BSERR
OPTB0:
	POP	B			;POP OFF THE LOOKS
	POP	PSW			;[A] = NUMBER OF DIMENSIONS SO FAR
	XCHG				;[D,E]=TEXT POINTER
					;[H,L]=INDICE
	XTHL				;PUT THE INDICE ON THE STACK
					;[H,L]=VALTYP & DIMFLG
	PUSH	H			;RESAVE VALTYP AND DIMFLG
	XCHG				;[H,L]=TEXT POINTER
	INR	A			;INCREMENT # OF DIMENSIONS
	MOV	D,A			;[D]=NUMBER OF DIMENSIONS
	MOV	A,M			;GET TERMINATING CHARACTER
	CPI	44			;A COMMA SO MORE INDICES FOLLOW?
	JZ	INDLOP			;IF SO, READ MORE
	CPI	')'			;EXPECTED TERMINATOR?
	JZ	DOCHRT			;DO CHRGET FOR NEXT ONE
	CPI	']'			;BRACKET?
	JNZ	SNERR			;NO, GIVE ERROR
DOCHRT:	CALL	CHRGTR
SUBSOK:	SHLD	TEMP2			;SAVE THE TEXT POINTER
	POP	H			;[H,L]= VALTYP & DIMFLG
	SHLD	DIMFLG			;SAVE VALTYP AND DIMFLG
	MVI	E,0			;WHEN [D,E] IS POPED INTO PSW, WE
					;DON'T WANT THE ZERO FLAG TO BE SET, SO
					;"ERASE" WILL HAVE A UNIQUE CONDITION
	PUSH	D			;SAVE NUMBER OF DIMENSIONS
	PUBLIC	ERSFIN
	DB	21O			;"LXI	D," OVER THE NEXT TWO BYTES
ERSFIN:	PUSH	H			;SAVE THE TEXT POINTER
	PUSH	PSW			;SAVE A DUMMY NUMBER OF DIMENSIONS
					;WITH THE ZERO FLAG SET
;
; AT THIS POINT [B,C]=LOOKS. THE TEXT POINTER IS IN TEMP2.
; THE INDICES ARE ALL ON THE STACK, FOLLOWED BY THE NUMBER OF DIMENSIONS.
;
	LHLD	ARYTAB			;[H,L]=PLACE TO START THE SEARCH
	DB	76O			;"MVI A," AROUND THE NEXT BYTE
LOPFDA:	DAD	D			;SKIP OVER THIS ARRAY SINCE IT'S
					;NOT THE ONE
	XCHG				;[D,E]=CURRENT SEARCH POINT
	LHLD	STREND			;GET THE PLACE TO STOP INTO [H,L]
	XCHG				;[H,L]=SEARCH POINT
	CALL	DCOMPR			;STOPPING TIME?
	JZ	NOTFDD			;YES, COULDN'T FIND THIS ARRAY
	MOV	E,M			;GET VALTYP IN [E]
	INX	H
	MOV	A,M			;GET FIRST CHARACTER
	INX	H
	CMP	C			;SEE IF IT MATCHES
	JNZ	NMARY1			;NOT THIS ONE
	LDA	VALTYP			;GET TYPE OF VAR WERE LOOKING FOR
	CMP	E			;SAME AS THIS ONE?
	JNZ	NMARY1			;NO, SKIP THIS VAR
	MOV	A,M			;GET SECOND CHARACTER
	CMP	B			;ANOTHER MATCH?
	JZ	CMPNAM			;MATCH, CHECK OUT REST OF NAME
NMARY1:	INX	H			;POINT TO SIZE ENTRY
BNAMSZ:	MOV	E,M			;GET VAR NAME LENGTH IN [E]
	INR	E			;ADD ONE TO GET CORRECT LENGTH
	MVI	D,0			;HIGH BYTE OF ZERO
	DAD	D			;ADD OFFSET
CNOMAT:
	MOV	E,M			;[D,E]=LENGTH
	INX	H			;OF THE ARRAY BEING LOOKED AT
	MOV	D,M
	INX	H
	JNZ	LOPFDA			;IF NO MATCH, SKIP THIS ONE
					;AND TRY AGAIN
	LDA	DIMFLG			;SEE IF CALLED BY "DIM"
	ORA	A			;ZERO MEANS NO
	EXTRN	DDERR
	JNZ	DDERR			;PRESERVE [D,E], AND DISPATCH TO
					;"REDIMENSIONED VARIABLE" ERROR
					;IF ITS "DIM" CALLING PTRGET
;
; TEMP2=THE TEXT POINTER
; WE HAVE LOCATED THE VARIABLE WE WERE LOOKING FOR
; AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
; THE INDICES ARE ON THE STACK FOLLOWED BY THE NUMBER OF DIMENSIONS
;
	POP	PSW			;[A]=NUMBER OF DIMENSIONS
	MOV	B,H			;SET [B,C] TO POINT AT NUMBER OF DIMENSIONS
	MOV	C,L
	JZ	POPHRT			;"ERASE" IS DONE AT THIS POINT, SO RETURN
					;TO DO THE ACTUAL ERASURE
	SUB	M			;MAKE SURE THE NUMBER GIVEN NOW AND
					;AND WHEN THE ARRAY WAS SET UP ARE THE
					;SAME
	JZ	GETDEF			;JUMP OFF AND READ
					;THE INDICES....

BSERR:	LXI	D,0+ERRBS		;"SUBSCRIPT OUT OF RANGE"
	JMP	ERROR
CMPNAM:	INX	H			;POINT TO LENGTH OF NAME
	LDA	NAMCNT			;SEE IF COUNT MATCHES COUNT IN COMPLEX TABLE
	CMP	M
	JNZ	BNAMSZ			;BAD NAME SIZE JUST SKIP AND SET NZ CC
	INX	H			;POINT ONE BYTE AFTER LENGTH FIELD
	ORA	A			;LENGTH ZERO?
	JZ	CNOMAT			;THEN FOUND, EXIT
	DCX	H			;MOVE BACK ONE
	CALL	MATSUB			;OTHERWISE TRY TO MATCH CHARACTERS
	JMP	CNOMAT			;USING COMMON SUBROUTINE
;
; HERE WHEN VARIABLE IS NOT FOUND IN THE ARRAY TABLE
;
; BUILDING AN ENTRY:
; 
;	PUT DOWN THE DESCRIPTOR	
;	SETUP NUMER OF DIMENSIONS
;	MAKE SURE THERE IS ROOM FOR THE NEW ENTRY
;	REMEMBER VARPTR
;	TALLY=4 (VALTYP FOR THE EXTENDED)
;	SKIP 2 LOCS FOR LATER FILL IN -- THE SIZE
; LOOP:	GET AN INDICE
;	PUT NUMBER +1 DOWN AT VARPTR AND INCREMENT VARPTR
;	TALLY= TALLY * NUMBER+1
;	DECREMENT NUMBER-DIMS
;	JNZ	LOOP
;	CALL REASON WITH [H,L] REFLECTING LAST LOC OF VARIABLE
;	UPDATE STREND
;	ZERO BACKWARDS
;	MAKE TALLY INCLUDE MAXDIMS
;	PUT DOWN TALLY
;	IF CALLED BY DIMENSION, RETURN
;	OTHERWISE INDEX INTO THE VARIABLE AS IF IT
;	WERE FOUND ON THE INITIAL SEARCH
;
NOTFDD:
	LDA	VALTYP			;GET VALTYP OF NEW VAR
	MOV	M,A			;PUT DOWN THE VARIABLE TYPE
	INX	H
	MOV	E,A
	MVI	D,0			;[D,E]=SIZE OF ONE VALUE (VALTYP)
	POP	PSW			;[A]=NUMBER OF DIMENSIONS
	JZ	PTRRNZ			;CALLED BY CHAIN, JUST RETURN NON-ZERO
	MOV	M,C			;PUT DOWN THE DESCRIPTOR
	INX	H
	MOV	M,B
	CALL	NPUTSB			;STORE THE EXTRA CHARACTERS IN THE TABLE
	INX	H
	MOV	C,A			;[C]=NUMBER OF TWO BYTE ENTRIES NEEDED
					;TO STORE THE SIZE OF EACH DIMENSION
	CALL	GETSTK			;GET SPACE FOR DIMENSION ENTRIES
	INX	H			;SKIP OVER THE SIZE LOCATIONS
	INX	H
	SHLD	TEMP3			;SAVE THE LOCATION TO PUT THE SIZE
					;IN -- POINTS AT THE NUMBER OF DIMENSIONS
	MOV	M,C			;STORE THE NUMBER OF DIMENSIONS
	INX	H
	LDA	DIMFLG			;CALLED BY DIMENSION?
	RAL				;SET CARRY IF SO
	MOV	A,C			;[A]=NUMBER OF DIMENSIONS
LOPPTA:
	JC	POPDIM
	PUSH	PSW
	LDA	OPTVAL			;GET THE OPTION BASE
	XRI	11			;MAP 0 TO 11 AND 1 TO 10
	MOV	C,A			;[B,C]=DEFAULT DIMENSION
	MVI	B,0
	POP	PSW
	JNC	NOTDIM			;DEFAULT DIMENSIONS TO TEN
POPDIM:	POP	B			;POP OFF AN INDICE INTO [B,C]
	INX	B			;ADD ONE TO IT FOR THE ZERO ENTRY
NOTDIM:	MOV	M,C			;PUT THE MAXIMUM DOWN
	PUSH	PSW			;SAVE THE NUMBER OF DIMENSIONS AND
					;DIMFLG (CARRY)
	INX	H
	MOV	M,B
	INX	H
	CALL	UMULT			;MULTIPLY [B,C]=NEWMAX BY CURTOL=[D,E]
	POP	PSW			;GET THE NUMBER OF DIMENSIONS AND
					;DIMFLG (CARRY) BACK
	DCR	A			;DECREMENT THE NUMBER OF DIMENSIONS LEFT
	JNZ	LOPPTA			;HANDLE THE OTHER INDICES
	PUSH	PSW			;SAVE DIMFLG (CARRY)
	MOV	B,D			;[B,C]=SIZE
	MOV	C,E
	XCHG				;[D,E]=START OF VALUES
	DAD	D			;[H,L]=END OF VALUES
	JC	OMERR			;OUT OF MEMORY POINTER BEING GENERATED?
	CALL	REASON			;SEE IF THERE IS ROOM FOR THE VALUES
	SHLD	STREND			;UPDATE THE END OF STORAGE
ZERITA:	DCX	H			;ZERO THE NEW ARRAY
	MVI	M,0
	CALL	DCOMPR			;BACK AT THE BEGINNING?
	JNZ	ZERITA			;NO, ZERO MORE
	INX	B			;ADD ONE TO THE SIZE TO INCLUDE
					;THE BYTE FOR THE NUMBER OF DIMENSIONS
	MOV	D,A			;[D]=ZERO
	LHLD	TEMP3			;GET A POINTER AT THE NUMBER OF DIMENSIONS
	MOV	E,M			;[E]=NUMBER OF DIMENSIONS
	XCHG				;[H,L]=NUMBER OF DIMENSIONS
	DAD	H			;[H,L]=NUMBER OF DIMENSIONS TIMES TWO
	DAD	B			;ADD ON THE SIZE
					;TO GET THE TOTAL NUMBER OF BYTES USED
	XCHG				;[D,E]=TOTAL SIZE
	DCX	H			;BACK UP TO POINT TO LOCATION TO PUT
	DCX	H			;THE SIZE OF THE ARRAY IN BYTES IN.
	MOV	M,E			;PUT DOWN THE SIZE
	INX	H
	MOV	M,D
	INX	H
	POP	PSW			;GET BACK DIMFLG (CARRY) AND SET [A]=0
	JC	FINNOW
;
; AT THIS POINT [H,L] POINTS BEYOND THE SIZE TO THE NUMBER OF DIMENSIONS
; STRATEGY:
;	NUMDIM=NUMBER OF DIMENSIONS
;	CURTOL=0
; INLPNM:GET A NEW INDICE
;	POP NEW MAX INTO CURMAX
;	MAKE SURE INDICE IS NOT TOO BIG
;	MUTLIPLY CURTOL BY CURMAX
;	ADD INDICE TO CURTOL
;	NUMDIM=NUMDIM-1
;	JNZ	INLPNM
;	USE CURTOL*4 (VALTYP FOR EXTENDED) AS OFFSET
;
GETDEF:	MOV	B,A			;[B,C]=CURTOL=ZERO
	MOV	C,A
	MOV	A,M			;[A]=NUMBER OF DIMENSIONS
	INX	H			;POINT PAST THE NUMBER OF DIMENSIONS
	DB	26Q			;"MVI D," AROUND THE NEXT BYTE
INLPNM:	POP	H			;[H,L]= POINTER INTO VARIABLE ENTRY
	MOV	E,M			;[D,E]=MAXIMUM FOR THE CURRENT INDICE
	INX	H
	MOV	D,M
	INX	H
	XTHL				;[H,L]=CURRENT INDICE
					;POINTER INTO THE VARIABLE GOES ON THE STACK
	PUSH	PSW			;SAVE THE NUMBER OF DIMENSIONS
	CALL	DCOMPR			;SEE IF THE CURRENT INDICE IS TOO BIG
	JNC	BSERR			;IF SO "BAD SUBSCRIPT" ERROR
	CALL	UMULT			;CURTOL=CURTOL*CURRENT MAXIMUM
	DAD	D			;ADD THE INDICE TO CURTOL
	POP	PSW			;GET THE NUMBER OF DIMENSIONS IN [A]
	DCR	A			;SEE IF ALL THE INDICES HAVE BEEN PROCESSED
	MOV	B,H			;[B,C]=CURTOL IN CASE WE LOOP BACK
	MOV	C,L
	JNZ	INLPNM			;PROCESS THE REST OF THE INDICES
	LDA	VALTYP			;SEE HOW BIG THE VALUES ARE
					;AND MULTIPLY BY THAT SIZE
	MOV	B,H			;SAVE THE ORIGINAL VALUE FOR MULTIPLYING
	MOV	C,L			;BY THREE
	DAD	H			;MULTIPLY BY TWO AT LEAST
	SUI	4			;FOR INTEGERS AND STRINGS
					;NO MORE MULTIPLYING BY TWO
	JC	SMLVAL
	DAD	H			;NOW MULTIPLIED BY FOUR
	JZ	DONMUL			;IF SINGLE ALL DONE
	DAD	H			;BY EIGHT FOR DOUBLES
SMLVAL:
	ORA	A			;FIX CC'S FOR Z-80
	JPO	DONMUL			;FOR STRINGS
	DAD	B			;ADD IN THE ORIGINAL
DONMUL:
	POP	B			;POP OFF THE ADDRESS OF WHERE THE VALUES
					;BEGIN
	DAD	B			;ADD IT ONTO CURTOL TO GET THE
					;PLACE THE VALUE IS STORED
	XCHG				;RETURN THE POINTER IN [D,E]
FINNOW:	LHLD	TEMP2			;REGET THE TEXT POINTER
	RET	
PTRRNZ:	STC				;RETURN WITH NON-ZERO IN [A]
	SBB	A			;AND CONDITION CODES SET
	POP	H			;RESTORE TEST POINTER
	RET	

;
; LONG VARIABLE NAME SUBROUTINES. AFTER THE NORMAL 2 CHARACTER NAME
; THE COUNT OF ADDITIONAL CHARACTERS IS STORED. FOLLOWING THIS
; COMES THE CHARACTERS IN ORDER WITH THE HIGH BIT TURNED ON SO A BACKWARD
; SCAN IS POSSIBLE
;
	PUBLIC	IADAHL
IADAHL:	MOV	A,M			;GET THE CHARACTER COUNT
	INX	H
ADDAHL:	PUSH	B			;ADD [A] TO [H,L]
	MVI	B,0
	MOV	C,A
	DAD	B
	POP	B			;RESTORE THE SAVED [B,C]
	RET	
NPUTSB:	PUSH	B			;THIS ROUTINE STORE THE "LONG" NAME AT [H,L]
	PUSH	D
	PUSH	PSW
	LXI	D,NAMCNT		;POINT AT DATA TO SAVE
	LDAX	D			;GET THE COUNT
	MOV	B,A
	INR	B			;[B]= NUMBER OF BYTES TO SAVE
SLPLNG:	LDAX	D			;FETCH STORE VALUE
	INX	D
	INX	H			;MOVE UP TO STORE NAME INTO TABLE
	MOV	M,A			;DO THE STORE
	DCR	B			;AND REPEAT [B] TIMES
	JNZ	SLPLNG			;FOR THE COUNT AND DATA
	POP	PSW
	POP	D
	POP	B
	RET	

MATSUB:	PUSH	D			;THIS ROUTINE TRIES TO PERFORM A MATCH
	PUSH	B
	LXI	D,NAMBUF		;POINT AT COUNT AND DATA
	MOV	B,A			;[B]=CHARACTER COUNT
	INX	H			;POINT AT THE DATA
	INR	B			;START OFF LOOP
SLPMAT:	DCR	B			;MATCHED ALL CHARACTERS YET?
	JZ	ISMAT2			;IF SO, ITS A MATCH
	LDAX	D			;GET ANOTHER CHARACTER
	CMP	M			;SEE IF ITS THE SAME
	INX	H			;MOVE FORWARD IN DEFINITION TABLE
	INX	D			;MORE FORWARD IN STORED NAME
	JZ	SLPMAT			;IF MATCH KEEP GOING UNTIL END
	MOV	A,B			;NEED TO ADVANCE BY [B]-1 TO SKIP BAD CHARS
	DCR	A
	CNZ	ADDAHL			;USE THE COMMON SUBROUTINE. [H,L]=[H,L]+[A]
	XRA	A			;SET CC'S NON ZERO FOR NO MATCH
	DCR	A			;AND RETURN [A]=FF
ISMAT2:	POP	B			;RESTORE SAVED REGISTERS
	POP	D
	RET	

	PAGE
	END	
       