	SUBTTL	Common file for BASIC interpreter
	.SALL	

CONTO	SET	15			;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	SET	0			;FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2	

	.PRINTX	/EXTENDED/


	.PRINTX	/LPT/

	.PRINTX	/CPM DISK/


	.PRINTX	/Z80/

	.PRINTX	/FAST/

	.PRINTX	/5.0 FEATURES/

	.PRINTX	/ANSI COMPATIBLE/
	ENDIF

CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	SET	80			;TERMINAL LINE LENGTH 
LPTLEN	SET	132
BUFLEN	SET	255			;LONG LINES
NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
					;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	SET	4

STRSIZ	SET	3
NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES

NUMTMP	SET	10

MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
					;NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES
CPMWRM	SET	0			;CP/M WARM BOOT ADDR
CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR
	CSEG	
TRUROM	SET	0
	PAGE
	TITLE	DSKCOM - - COMMON ROUTINES FOR DISK BASICS

	EXTRN	CLSFIL,CONINT,DATOFS,DERBFN,DERRPE,ERROR,FILOU3,CHRGTR,CURLIN
	EXTRN	INDSKB,INDSKC,NMLOFS,PRGFIL,SCRTCH,SNERR
	EXTRN	FRMEQL,BUF
	EXTRN	STRLT3,DERFOV
	EXTRN	DATOFC,DERBFM,DIRTMP,DOASIG,DOCNVF,DSCTMP,ERRFDR,FCERR
	EXTRN	FILPT1,FILPTR,FIN,FINBCK,FINPRT,FRCSTR,FRESTR,FRETOP
	EXTRN	FRMEVL,GETBYT,GETSPA,GONE,GTBYTC,GTMPRT,INCHRI,LETCON
	EXTRN	LINKER,LIST,LSTFRE,MAIN,MAXFIL,NEWSTT,NMLOFC,OMERR
	EXTRN	PTRFIL,PTRGET,PUTNEW,READY,RUNC
	EXTRN	SCCPTR

	EXTRN	SAVSTK,STRINI,TXTTAB,VALTYP,VARTAB,VMOVFM,VMOVMF,ENDCON
	EXTRN	GETYPR,SYNCHR,DCOMPR
	PUBLIC	CLSALL,FILFRM,FILIDX,FILSCN,FIELD,PRGFLI,FILIND
	PUBLIC	FILINP,FILGET,MKI$,MKS$,MKD$,CVI,CVS,CVD
	PUBLIC	DLINE,PRGFL2,LRUN,LOAD,PRGFIN,MERGE,DIRDO,SAVE,CLOSE
	PUBLIC	OKGETM
	PUBLIC	RSET,LSET
	PUBLIC	BINPSV
	EXTRN	PROSAV,PROLOD
	EXTRN	PROFLG
; REVISION HISTORY
;4/23/78	PGA	ALLOW # ON CLOSE
;
;8/6/79  PGA	IF ^C ON MBASIC FOO, DONT RETURN TO SYSTEM. SEE 'NOTINI'
;6/27/80	PGA	FIX INPUT#1,D# SO IT USES FINDBL INSTEAD OF FIN
;		AND THUS AVOIDS LOSING SIGNIFICANCE.
;
;%
	SUBTTL	FILINP AND FILGET -- SCAN A FILE NUMBER AND SETUP PTRFIL

FILINP:	MVI	C,MD.SQI		;MUST BE SEQUENTIAL INPUT
FILGET:	CPI	'#'			;NUMBER SIGN THERE?
	RNZ				;NO, NOT DISK READER
	PUSH	B			;SAVE EXPECTED MODE
	CALL	FILSCN			;READ AND GET POINTER
	POP	D			;[E]=FILE MODE
	CMP	E			;IS IT RIGHT?
	JZ	GDFILM			;GOOD FILE MODE
	CPI	MD.RND			;ALLOW STUFF WITH RANDOM FILES
	JNZ	DERBFM			;IF NOT, "BAD FILE MODE"
GDFILM:
	CALL	SYNCHR
	DB	44			;GO PAST THE COMMA
FILSET:	XCHG				;[D,E]=TEXT POINTER
	MOV	H,B			;SETUP PTRFIL
	MOV	L,C
	SHLD	PTRFIL
	XCHG				;TEXT POINTER BACK INTO [H,L]
	RET	

	PAGE
	SUBTTL	FILSCN, FILFRM, AND FILIDX
;
; AT THIS ENTRY POINT [H,L] IS ASSUMED TO BE THE TEXT POINTER AND
; A FILE NUMBER IS SCANNED
;
FILSCN:	DCX	H
	CALL	CHRGTR
	CPI	'#'			;MAKE NUMBER SIGN OPTIONAL
	CZ	CHRGTR			;BY SKIPPING IT IF THERE
	CALL	FRMEVL			;READ THE FILE NUMBER INTO THE FAC
;
; AT THIS ENTRY POINT THE FAC HAS THE FILE NUMBER IN IT ALREADY
;
FILFRM:	CALL	CONINT			;GET THE FILE NUMBER INTO [A]
;
; AT THIS POINT IT IS ASSUMED THE FILE NUMBER IS IN [A]
; THE FILE NUMBER IS RETURNED IN [E]
; [D] IS SET TO ZERO. [H,L] IS SAVED.
; [B,C] IS SET TO POINT AT THE FILE DATA BLOCK FOR FILE [E]
; [A] GIVE THE MODE OF THE FILE AND ZERO IS SET  IF THE FILE IS
; MODE ZERO (NOT OPEN).
;
FILIDX:	MOV	E,A			;GET FILE NUMBER INTO [E]
FILID2:	LDA	MAXFIL			;IS THIS FILE # LEGAL?
	CMP	E
	JC	DERBFN			;IF NOT, "BAD FILE NUMBER"
	MVI	D,0			;SETUP DOUBLE-BYTE OFFSET TO GET
					;POINTER TO FILE DATA BLOCK
	PUSH	H			;SAVE [H,L]
	LXI	H,FILPTR		;POINT AT POINTER TABLE
	DAD	D			;ADD ON OFFSET TWICE FOR DOUBLE BYTE
	DAD	D			;ENTRIES
	MOV	C,M			;PICK UP POINTER IN [B,C]
	INX	H
	MOV	B,M
	LDAX	B			;GET MODE OF FILE INTO [A]
	ORA	A			;SET ZERO IF FILE NOT OPEN
	POP	H			;RETRIEVE [H,L]
	RET	

; GETPTR IS CALLED FROM VARPTR(#<EXPRESSION>)
	PUBLIC	GETPTR
GETPTR:	CALL	FILID2			;INDEX INTO FILE DATA BLOCK
	LXI	H,DATOFC		;POINT TO DATA BLOCK
	CPI	MD.RND			;RANDOM FILE?
	JNZ	NTFIVD			;NO, USE NOTRRMAL FOOFFSET
	LXI	H,0+FD.DAT##		;YES
NTFIVD:
	DAD	B			;ADD START OF FILE DATA BLOCK
	XCHG				;RETURN IN [D,E]
	RET	
	PAGE

MKI$:	MVI	A,2			;VALUE TYPE FOR INTEGER AND NUMBER
					;OF CHARACTERS RESULT WILL NEED
	DB	1			;SKIP NEXT TWO BYTES WITH "LXI	B,"
MKS$:	MVI	A,4			;VALUE TYPE OF SINGLE PRECISION
	DB	1			;SKIP NEXT TWO BYTES
MKD$:	MVI	A,8			;VALUE TYPE OF DOUBLE-PRECISION
	PUSH	PSW			;SAVE THE NUMBER OF BYTES OF
					;STRING SPACE WE NEED
	CALL	DOCNVF			;CONVERT FAC TO PROPER TYPE
	POP	PSW			;GET THE NUMBER OF BYTES NEEDED
	CALL	STRINI			;GET A PLACE FOR THE STRING DATA
	LHLD	DSCTMP+1		;POINT TO THE PLACE TO STORE THE DATA
	CALL	VMOVMF			;MOVE THE FAC VALUE INTO THE STRING CREATION
	JMP	FINBCK			;FINISH UP THESE STRING FUNCTIONS

CVI:	MVI	A,1			;SET [A] TO BE VALTYP-1
	DB	1			;SKIP THE NEXT TWO BYTES WITH "LXI B,"
CVS:	MVI	A,3			;ALSO SET [A] TO NUMBER OF CHARACTERS REQUIRED -1
	DB	1			;SKIP THE NEXT TWO BYTES
CVD:	MVI	A,7			;DOUBLE PRECISION VALUE TYPE -1
	PUSH	PSW			;SAVE THE VALTYP
	CALL	FRESTR			;MAKE SURE THE ARGUMENT IS A STRING
					;AND GET A POINTER TO THE DESCRIPTOR
	POP	PSW			;GET BACK NUMBER OF CHARACTERS REQUIRED-1
	CMP	M			;MAKE SURE THE STRING IS LONGER THAN THAT
	JNC	FCERR			;IF NOT, "ILLEGAL FUNCTION CALL"
	INR	A			;[A]=TRUE VALUE TYPE
	INX	H
	MOV	C,M			;[H,L]=POINTER AT STRING DATA
	INX	H			;TO BE MOVED INTO THE FAC
	MOV	H,M
	MOV	L,C
	STA	VALTYP			;SETUP VALUE TYPE FOR MOVE
					;AND FOR IDENTIFICATION
	JMP	VMOVFM			;MOVE IN THE STRING DATA

	PAGE
	SUBTTL	SETUP TO READ A SEQUENTIAL ITEM -- FILIND

FILIND:
	CALL	GETYPR			;SEE IF INPUT IS STRING OR NUMBER
	LXI	B,DOASIG		;RETURN ADDRESS TO SETUP [FAC]
CON1	SET	0+(44*256)+32
	LXI	D,CON1			;SETUP TERMINATORS SPACE AND COMMA
	JNZ	INPDOR			;IF NUMERIC, GO READ THE FILE
	MOV	E,D			;MAKE BOTH TERMINATORS COMMA
	JMP	INPDOR			;GO READ THE FILE
	PAGE
	SUBTTL	LINE INPUT & READ CODE FOR ITEM FETCHING FROM SEQUENTIAL INPUT FILES

DLINE:	CALL	FILINP			;GET FILE NUMBER SET UP
	CALL	PTRGET			;READ STRING TO STORE INTO
	CALL	FRCSTR			;MAKE SURE IT WAS A STRING
	LXI	B,FINPRT		;RESET TO CONSOLE WHEN DONE READING
	PUSH	B			;SAVE ON STACK
	PUSH	D			;SAVE POINTER AT VARIABLE
	LXI	B,LETCON		;GOOD RETURN ADDRESS FOR ASSIGNMENT
	XRA	A			;SET A=0 FOR STRING VALUE TYPE
	MOV	D,A			;ZERO OUT BOTH TERMINATORS
	MOV	E,A
INPDOR:	PUSH	PSW			;SAVE VALUE TYPE
	PUSH	B			;SAVE RETURN ADDRESS
	PUSH	H			;SAVE POINTER AT DATA COMING IN
					;A DUMMY POINTER AT BUFMIN
NOTNWT:	CALL	INDSKC			;READ A CHARACTER
	JC	DERRPE			;READ PAST END ERROR IF EOF
	CPI	' '			;SKIP LEADING SPACES
	JNZ	NOTSPC			;EXCEPT FOR LINE INPUT
	INR	D			;CHECK FOR LINEINPUT
	DCR	D
	JNZ	NOTNWT			;SKIP ANY NUMBER
NOTSPC:	CPI	34			;QUOTED STRING COMING IN?
	JNZ	NOTQTE
	MOV	B,A			;SAVE THE QUOTE
	MOV	A,E			;MUST BE INPUT OF A STRING
	CPI	44			;WHICH HAS [E]=44
	MOV	A,B			;QUOTE BACK INTO [A]
	JNZ	NOTQTE
	MOV	D,B			;TERMINATORS ARE QUOTES ONLY
	MOV	E,B
	CALL	INDSKC			;READ PAST QUOTATION
	JC	QUITSI			;IF EOF, ALL DONE
NOTQTE:
	LXI	H,BUF			;BUFFER FOR DATA
	MVI	B,255			;MAXIMUM NUMBER OF CHARACTERS (255)
LOPCRS:	MOV	C,A			;SAVE CHARACTER IN [C]
	MOV	A,D			;CHECK FOR QUOTED STRING
	CPI	34
	MOV	A,C			;RESTORE CHARACTER
	JZ	NOTQTL			;DON'T IGNORE CR OR STOP ON LF
	CPI	13			;CR?
	PUSH	H			;SAVE DEST PTR. ON STACK
	JZ	ICASLF			;EAT LINE FEED IF ONE
	POP	H			;RESTORE DEST. PTR.
	CPI	10			;LF?
	JNZ	NOTQTL			;NO, TEST OTHER TERMINATORS
	MOV	C,A			;SAVE CURRENT CHAR
	MOV	A,E			;GET TERMINATOR 2
	CPI	54O			;CHECK FOR COMMA (UNQUOTED STRING)
	MOV	A,C			;RESTORE ORIG CHAR
	CNZ	STRCHR			;IF NOT, STORE LF (?)
	CALL	INDSKC			;GET NEXT CHAR
	JC	QUITSI			;IF EOF, ALL DONE.
	CPI	13			;IS IT A CR?
	JNZ	NOTQTL			;IF NOT SEE IF STORE NORMALLY
	MOV	A,E			;GET TERMINATOR
	CPI	' '			;IS IT NUMERIC INPUT?
	JZ	LPCRGT			;IF SO, IGNORE CR, DONT PUT IN BUFFER
	CPI	44			;IS IT NON-QUOTED STRING (TERM=,)
	MVI	A,13			;GET BACK CR.
	JZ	LPCRGT			;IF SO, IGNORE CR.
NOTQTL:	ORA	A			;IS CHAR ZERO
	JZ	LPCRGT			;ALWAYS IGNORE, AS IT IS TERMINATOR
					;FOR STRLIT (SEE QUIT2B)
	CMP	D			;TERMINATOR ONE?
	JZ	QUITSI			;STOP THEN
	CMP	E			;TERMINATOR TWO?
	JZ	QUITSI
	CALL	STRCHR			;SAVE THE CHAR
LPCRGT:	CALL	INDSKC			;READ ANOTHER CHARACTER
	JNC	LOPCRS			;IF NOT, CHECK AS TERMINATOR
QUITSI:	PUSH	H			;SAVE PLACE TO STUFF ZERO
	CPI	34			;STOPPED ON QUOTE?
	JZ	MORSPC			;DON'T SKIP SPACES THEN
					;BUT DO SKIP FOLLOWING COMMA OR
					;CRLF THOUGH
	CPI	' '			;STOPPED ON SPACE?
	JNZ	NOSKCR			;NO, DON'T SKIP SPACES
					;OR ANY FOLLOWING COMMAS OR CRLFS EITHER
MORSPC:	CALL	INDSKC			;READ SPACES
	JC	NOSKCR			;EOF, ALL DONE.
	CPI	' '
	JZ	MORSPC
	CPI	44			;COMMA?
	JZ	NOSKCR			;OK, SKIP IT
	CPI	13			;CARRIAGE RETURN?
	JNZ	BAKUPT			;BACK UP PAST THIS CHARACTER
ICASLF:
	CALL	INDSKC			;READ ANOTHER
	JC	NOSKCR			;EOF, ALL DONE.
	CPI	10			;LINE FEED?
	JZ	NOSKCR			;OK, SKIP IT TOO
BAKUPT:	LHLD	PTRFIL			;GO TO NUMBER OF CHARATERS
	LXI	B,0+NMLOFS
	DAD	B
	INR	M			;BACK UP BY INCREMENTING CHARACTER COUNT
NOSKCR:	POP	H			;GET BACK PLACE TO STORE TERMINATOR
QUIT2B:	MVI	M,0			;STORE THE TERMINATOR
	LXI	H,BUF-1			;ITEM IS NOW STORED AT THIS POINT +1
	MOV	A,E			;WAS IT A NUMERIC INPUT?
	SUI	' '			;IF SO, [E]=" "
	JZ	NUMIMK			;USE FIN TO SCAN IT
	EXTRN	STRLT2
	MOV	B,D			;SET [B]=44 IF SCANNING UNQUOTED STRING
	MVI	D,0
	CALL	STRLT2
	POP	H			;GET BACK [H,L]
	RET				;DO ASSIGNMENT

NUMIMK:	CALL	GETYPR			;GET TYPE OF NUMERIC VARIABLE BEING READ
	PUSH	PSW			;SAVE IT
	CALL	CHRGTR			;READ FIRST CHARACTER
	POP	PSW			;RESTORE TYPE OF VARIABLE
	PUSH	PSW			;SAVE BACK
	CC	FIN			;SINGLE PRECISION INPUT
	POP	PSW			;GET BACK TYPE OF VAR
	EXTRN	FINDBL
	CNC	FINDBL			;DOUBLE PRECISION INPUT
	POP	H			;GET [H,L]
	RET				;DO THE ASSIGNMENT

STRCHR:	ORA	A			;TRYING TO STORE NULL BYTE
	RZ				;RETURN, DONT STORE IT
	MOV	M,A			;STORE THE CHARACTER
	INX	H
	DCR	B			;128 YET?
	RNZ				;MORE SPACE IN BUFFER, RETURN
	POP	B			;GET RID OF SUPERFLUOUS STACK ENTRY
	JMP	QUIT2B			;SPECIAL QUIT

	PAGE
PRGFLI:	MVI	D,MD.SQI		;SEQUENTIAL INPUT MODE
PRGFL2:	XRA	A			;INTERNAL FILE NUMBER IS ALWAYS ZERO
	JMP	PRGFIL			;SCAN FILE NAME AND DISK NUMMER
					;AND DO THE RIGHT THING USING MD.KIL
					;AS A FLAG

LRUN:
LRUN2::	DB	366Q			;SET NON ZERO TO FLAG "RUN" COMMAND
LOAD:	XRA	A			;FLAG ZERO FOR "LOAD"
	PUSH	PSW			;SAVE "RUN"/"LOAD" FLAG
	CALL	PRGFLI			;FIND THAT FILE AND SETUP FOR
					;USING INDSKC SUBROUTINE
	LDA	MAXFIL			;SAVE THE NUMBER OF FILES
	STA	LSTFRE+1		;SINCE WE MAKE IT LOOK LIKE ZERO
					;SO ,R OPTION CAN LEAVE FILES
					;OPEN
	DCX	H			;SEE IF NO RUN OPTION
	CALL	CHRGTR
	JZ	NOTRNL			;NO, JUST LOAD
	CALL	SYNCHR
	DB	44			;GOTTA HAVE A COMMA
	CALL	SYNCHR
	DB	'R'			;ONLY OPTION IS RUN
	JNZ	SNERR			;AND THAT BETTER BE THE END
	POP	PSW			;GET RID OF "RUN"/"LOAD" FLAG
	PUBLIC	CHNENT
CHNENT:
	XRA	A			;SO FILES AREN'T CLOSED
	STA	MAXFIL			;PRETEND THERE AREN'T ANY
	DB	366O			;FLAG RUN WITH NON-ZERO
NOTRNL:	POP	PSW			;FLAG NON-RUN WITH ZERO
	STA	LSTFRE
	LXI	H,DIRTMP
	MVI	M,0
	SHLD	FILPTR			;MESS UP POINTER AT FILE ZERO
	CALL	SCRTCH			;WIPE OUT OLD STUFF
	LDA	LSTFRE+1		;RESTORE MAXFIL
	STA	MAXFIL			;THAT WAS KLUDGED
	LHLD	FILPT1
	SHLD	FILPTR			;RESTORE BACK TO NORMAL
	SHLD	PTRFIL			;PTRFIL GOT ZEROED SO FIX IT TOO
; BELOW IS FIX (TO LABEL NOTINI) SO THAT IF ^C DURING MBASIC FOO, WONT EXIT TO SYSTEM
	LHLD	CURLIN			;GET LINE NUMBER
	INX	H			;SEE IF IN INITIALIZATION
	MOV	A,H
	ANA	L
	INR	A
	JNZ	NOTINI			;NO
	SHLD	CURLIN			;SAVE DIRECT LINE NUMBER
NOTINI:
	CALL	INDSKC			;READ THE FIRST CHARACTER
	JC	MAIN			;ALL DONE IF NOTHING IN FILE
	CPI	254			;IS THIS A PROTECTED FILE?
	JNZ	NTPROL			;NO
	STA	PROFLG			;SET PROTECTED FILE
	JMP	BINLOD			;DO BINARY LOAD
NTPROL:
	INR	A			;IS IT A BINARY FILE?
	JNZ	MAINGO			;NO, SINCE PTRFIL IS NON-ZERO
					;INCHR WILL USE INDSKC INSTEAD OF POLLING
					;THE TERMINAL
					;WHEN EOF IS HIT PTRFIL WILL BE RESTORED
					;AND LSTFRE WILL BE USED AS A FLAG
					;TO INDICATE WHETHER TO RUN THE
					;LOADED PROGRAM
;
; TIME FOR A BINARY LOAD.
; AFTER THE LOAD, THE FILE IS LINKED TOGETHER
; LSTFRE IS USED AS A FLAG WHETHER TO RUN OR NOT
;
BINLOD:	LHLD	TXTTAB			;GET PLACE TO START STORING INTO
LPBLDR:	XCHG				;SEE IF THERE IS ROOM TO SPARE
	LHLD	FRETOP
	LXI	B,0+65536-86
	DAD	B
	CALL	DCOMPR
	XCHG	
	JC	OUTLOD			;ERROR AND WIPE OUT PARTIAL GARBAGE
					;UNLINKED!! NO ZEROES AT THE END!!
	CALL	INDSKB			;READ THE A DATA BYTE
					;THIS IS SEMI-WEAK SINCE MEMORY
					;IS LEFT IN A BAD BAD STATE
					;IF AN I/O ERROR OCCURS
	MOV	M,A			;STORE BYTE
	INX	H			;INCRMENT POINTER
	JNC	LPBLDR			;READ THE NEXT CHAR
	SHLD	VARTAB			;SAVE END TEMP FOR DECODING
	LDA	PROFLG			;IS THIS A PROTECTED FILE?
	ORA	A			;SET CC'S
	CNZ	PROLOD			;TRANSLATE TO GOOD STUFF
	CALL	LINKER			;FIX THE LINKS
	INX	H			;WHEN LINKER RETURNS, [H,L]
	INX	H			;POINTS TO DOUBLE ZERO
	SHLD	VARTAB			;UPDATE [VARTAB]
	LXI	H,MAXFIL		;ONLY CLOSE FILE ZER0
	MOV	A,M
	STA	LSTFRE+1
	MVI	M,0
	CALL	RUNC			;SETUP ARYTAB, STREND
	LDA	LSTFRE+1		;RESTORE NUMBER OF FILES
	STA	MAXFIL
	EXTRN	CHNFLG,CHNRET
	LDA	CHNFLG			;CHAIN IN PROGRESS
	ORA	A			;TEST
	JNZ	CHNRET			;YES, GO BACK TO CHAIN CODE
	LDA	LSTFRE			;RUN OR NOT?
	ORA	A
	JZ	READY
	JMP	NEWSTT

PRGFIN:	CALL	FINPRT			;ZERO PTRFIL
	CALL	CLSFIL			;CLOSE FILE ZERO
	JMP	GTMPRT			;REFETCH TEXT POINTER
OUTLOD::CALL	SCRTCH
	JMP	OMERR
MERGE:	POP	B			;ELIMINATE NEWSTT RETURN
	CALL	PRGFLI			;READ THE NAME AND DISK
	DCX	H			;MUST END THERE
	CALL	CHRGTR
	JZ	OKGETM			;READ THE FILE
	CALL	PRGFIN			;CLOSE OUT TIME
	JMP	SNERR			;AND "SYNTAX ERROR"
OKGETM:	XRA	A			;NO RUN OPTION WITH "MERGE"
	STA	LSTFRE			;SET UP THE FLAG
	CALL	INDSKC			;READ FROM [PTRFIL] FILE
	JC	MAIN			;GO BACK IF EOF
	INR	A			;IS IT A BINARY FILE??
	JZ	DERBFM			;BINARY IS WRONG FILE MODE
MAINGO:	LHLD	PTRFIL			;GET FILE POINTER
	LXI	B,NMLOFC		;POINT TO NUMBER OF CHARS IN BUFFER
	DAD	B			;BY ADDING OFFSET
	INR	M			;BACK UP FILE BY INCREMENTING COUNT
	JMP	MAIN

	PAGE
	SUBTTL	DISPATCH FOR DIRECT STATEMENT
;
; MAKE SURE WE'RE NOT READING A FILE IN
;
DIRDO:
	PUSH	H
	LHLD	PTRFIL
	MOV	A,H
	ORA	L			;IS PTRFIL ZERO SO NOT FILE READING?
	LXI	D,0+ERRFDR		;"DIRECT STATEMENT IN FILE"
	JNZ	ERROR			;NOTE: LXI D, IS USED TO
					;TO MAKE SOURCE CONVERSIONS EASIER
	POP	H			;GET BACK POINTER AT BUFMIN
	JMP	GONE			;EXECUTE DIRECT STATEMENT

	PAGE
	SUBTTL	SAVE COMMAND -- ASCII OR BINARY

SAVE:	MVI	D,MD.SQO		;ELIMINATE EARLIER VERSION
					;AND CREATE EMPTY FILE
	CALL	PRGFL2			;READ FILE NAME AND DISK NUMBER AND
					;LOOK IT UP
	DCX	H
	CALL	CHRGTR			;END OF STATEMENT?
	JZ	BINSAV			;BINARY SAVE!!
	CALL	SYNCHR
	DB	44			;ONLY OPTION IS ",A"
	EXTRN	PROSAV
	CPI	'P'			;PROTECTED SAVE?
	JZ	PROSAV			;DO IT
	CALL	SYNCHR
	DB	'A'			;FOR ASCII SAVE
	JMP	LIST			;USE THE LIST CODE TO DO THE OUTPUT
					;CONTROL-CS ARE NOT ALLOWED
					;AND AT THE END PTRFIL IS ZEROED
BINSAV:
	CALL	SCCPTR			;GET RID OF POINTERS BEFORE SAVING
	EXTRN	PROCHK
	CALL	PROCHK			;DONT ALLOW BINARY SAVES OF PROTECTED PROGRAMS
	MVI	A,255			;ALWAYS START WITH 255
BINPSV:	CALL	FILOU3			;SEND TO FILE
	LHLD	VARTAB			;GET STOP POINT
	XCHG				;SAVE IN [D,E]
	LHLD	TXTTAB			;GET START POINT
BSAVLP:	CALL	DCOMPR			;REACHED THE END?
	JZ	PRGFIN			;REGET TEXT POINTER AND CLOSE FILE 0
	MOV	A,M			;GET LINE DATA
	INX	H			;POINT AT NEXT DATA
	PUSH	D			;SAVE LIMIT
	CALL	FILOU3			;SEND CHAR TO FILE
	POP	D			;RESTORE LIMIT
	JMP	BSAVLP			;CONTINUE WITH LINE DATA

	SUBTTL	DRIVER CODE FOR CLOSE

CLOSE:	LXI	B,CLSFIL		;SERVICE ROUTINE ADDRESS
	LDA	MAXFIL			;HIGHEST POSSIBLE ARGUMENT
					;WHICH MEANS DO ALL POSSIBLE
RTALLR:	JNZ	RTLOOP			;NOT END OF STATEMENT, SO SCAN ARGUMENTS
	PUSH	H			;SAVE THE TEXT POINTER
MRALL:	PUSH	B			;SAVE ROUTINE ADDRESS
	PUSH	PSW			;SAVE CURRENT VALUE
	LXI	D,RETALL		;RETURN ADDRESS
	PUSH	D			;SAVE IT TO COME BACK WITH
	PUSH	B			;DISPATCH TO SERVICE ROUTINE
	RET	
RETALL:	POP	PSW			;GET BACK OLD ARGUMENT
	POP	B			;GET BACK SERVICE ROUTINE ADDRESS
	DCR	A			;DECREMENT ARGUMENT
	JP	MRALL			;LOOP ON MORE VALUES
	POP	H			;GET BACK THE TEXT POINTER
	RET	

RETRTS:	POP	B			;GET BACK SERVICE ROUTINE ADDRESS
	POP	H			;GET BACK THE TEXT POINTER
	MOV	A,M			;SEE IF MORE ARGUMENTS
	CPI	44			;DELIMITED BY COMMA
	RNZ	
	CALL	CHRGTR			;READ FIRST CHARACTER OF FORMULA
RTLOOP:	PUSH	B			;SAVE THE SERVICE ROUTINE ADDRESS
	MOV	A,M			;GET POSSBLE "#"
	CPI	'#'			;IS IT
	CZ	CHRGTR			;SKIP IT, ITS OPTIONAL
	CALL	GETBYT			;READ THE ARGUMENT
	XTHL				;SAVE THE TEXT POINTER ON THE STACK
					;AND SET [H,L]=SERVICE ADDRESS
	PUSH	H			;SAVE THE SERVICE ADDRESS
	LXI	D,RETRTS		;PUT A RETURN ADDRESS ON THE STACK
	PUSH	D
	PCHL				;DISPATCH TO DO THE FUNCTION


CLSALL:	PUSH	D
	PUSH	B			;SAVE [B,C] FOR STKINI
	XRA	A			;MAKE IT CLOSE ALL DISKS
	CALL	CLOSE
	POP	B
	POP	D			;GET BACK [D,E]
	XRA	A			;RETURN WITH [A]=0 AND Z ON
	RET	

	PAGE
	SUBTTL	"FIELD" STATEMENT FOR SETTING UP I/O STRINGS
FIELD:	CALL	FILSCN			;GET DATA BLOCK POINTER IN [B,C]
	JZ	DERBFN			;"BAD FILE NUMBER" IF FILE NOT OPEN
	SUI	MD.RND			;MAKE SURE ITS A RANDOM FILE
	JNZ	DERBFM			;IF NOT, "BAD FILE MODE"
	EXTRN	FD.SIZ,TEMPA,TEMPB,FD.DAT
	XCHG				;SAVE TEXT POINTER
	LXI	H,0+FD.SIZ		;POINT TO RECORD SIZE
	DAD	B
	MOV	A,M			;GET IT
	INX	H
	MOV	H,M
	MOV	L,A
	SHLD	TEMPA			;STORE MAX ALLOWED
	LXI	H,0			;ZERO MAX # OF CHARS
	SHLD	TEMPB
	MOV	A,H			;MAKE [A]=0
	XCHG				;GET BACK TEXT POINTER
	LXI	D,0+FD.DAT		;POINT TO 5.0 FIELD BUFFER
LOPFLD:	XCHG				;SAVE TEXT POINTER IN [D,E]
	DAD	B			;ADD ON DATA POINTER SO [H,L] NOW POINTS
					;AT THE START OF THE DATA
	MOV	B,A			;SETUP COUNT OF CHARACTERS PAST BY
					;IN DATA AREA, SO TOTAL IS NEVER GREATER THAN 128
	XCHG				;TEXT POINTER BACK INTO [H,L]
					;[D,E]=POINTER INTO DATA AREA
	MOV	A,M			;MORE "AS"S TO SCAN?
	CPI	44			;COMMA STARTS THE CLAUSE
	RNZ				;BACK TO NEWSTT IF NOT
	PUSH	D			;SAVE THE POINTER INTO THE DATA BLOCK
	PUSH	B			;SAVE [B]=NUMBER OF CHARACTERS ALLOCATED
	CALL	GTBYTC			;READ NUMBER INTO [A] FROM TEXT
	PUSH	PSW			;SAVE THIS NUMBER
	CALL	SYNCHR
	DB	'A'			;SCAN THE "AS"
	CALL	SYNCHR
	DB	'S'
	CALL	PTRGET			;GET A POINTER AT THE STRING DESCRIPTOR
	CALL	FRCSTR			;INTO [D,E]
	POP	PSW			;GET THE NUMBER OF CHARACTERS
	POP	B			;GET THE NUMBER ALREADY USED
	XTHL				;SAVE THE TEXT POINTER AND
					;[H,L]=POINTER INTO DATA BLOCK
	MOV	C,A			;SAVE # OF CHARACTERS IN [C]
	PUSH	D			;SAVE [D,E]
	PUSH	H			;SAVE [H,L]
	LHLD	TEMPB			;GET TOTAL SO FAR
	MVI	B,0			;ACCUMULATE COUNT
	DAD	B
	SHLD	TEMPB			;SAVE TOTAL AGAIN
	XCHG				;TOTAL TO [D,E]
	LHLD	TEMPA			;GET MAX ALLOWED
	CALL	DCOMPR			;IN RANGE?
	JC	DERFOV			;NO, GIVE ERROR
	POP	H			;RESTORE [H,L]
	POP	D			;RESTORE [D,E]
	XCHG				;[H,L] POINT AT STRING DESCRIPTOR
	MOV	M,C			;STORE THE LENGTH
	INX	H
	MOV	M,E			;STORE THE POINTER INTO THE DATA BLOCK
	INX	H
	MOV	M,D
	POP	H			;GET BACK THE TEXT POINTER
	IFF	DATPSC-256
	JNZ	LOPFLD			;IF TOTAL ADDED UP TO NOT 256, GO BACK FOR MORE
	MOV	A,C			;SEE HOW MUCH WE ADDED
	ORA	A			;TEST
	RNZ	
	ENDIF				;JUST ADDED UP TO 256, GIVE SYNTAX ERROR IF MORE
	JMP	LOPFLD			;CONTINUE SCANNING "AS" CLAUSES IF MORE
	PAGE
	SUBTTL	Random Non-I/O -- LSET/RSET/FIELD

;LSET/RSET stringvar = stringexp
;
; If stringvar points to an I/O buffer, use the string size to
;justify string. If stringvar is a literal, make new var with length
;of literal. If stringvar points to string space, use it. If the
;length of the variable is zero, return the null string. If a copy
;must be created, and stringexp is a temporary, use this space over
;unless length stringvar greater than stringexp.

RSET:	DB	366O			;ORI	<STC>
LSET:	STC				;Set carry if lset
	PUSH	PSW			;Save LSET/RSET flag
	CALL	PTRGET			;Get pointer to stringvar
	CALL	FRCSTR			;Must be a string variable
	PUSH	D			;Save pointer to descriptor
	CALL	FRMEQL			;EAT "=" AND EVALUATE STRINGEXP
	POP	B			; [B,C] = ptr to descr.
	XTHL				;Text ptr on bottom of stack
	PUSH	H			;LSET/RSET flag next
	PUSH	B			;Put descr. ptr back on
	CALL	FRESTR			;Error if not string, free temp.
	MOV	B,M			;Get length of stringexp
	XTHL				; [H,L] = descr. of var,save othr
	MOV	A,M			;Get length of stringvar
	MOV	C,A			;Save in [C]
	PUSH	B			;Save lengths of both
	PUSH	H			;Save descriptor pointer
	PUSH	PSW			;PSW zero if was temp.
	INX	H
	MOV	E,M
	INX	H
	MOV	D,M			;Get ptr to stringvar text
	ORA	A			;stringvar null?
	JZ	RETCUR			;Yes, don't change
	LHLD	TXTTAB
	CALL	DCOMPR			;Stringvar in disk buffer?
	JNC	OLDSTR			;Yes, use it
	LHLD	VARTAB
	CALL	DCOMPR			;stringvar in program(literal)?
	JC	OLDSTR			;No, in string space so use it
;Need to make new string for result since stringvar points to a literal.
;If stringexp was a temporary, it has been freed. If the length of
;stringexp is greater than or equal to the length of stringvar, GETSPA
;can be called and no garbage collection can occur so temp. can be reused.
;If stringvar is greater, must get a temp. to point to stringexp if it
;was a temp. , then call GETSPA which in this case can garbage collect.
	MOV	E,C
	MVI	D,0			;# BYTES TO ALLOCATE FOR RESULT
	EXTRN	STREND
	LHLD	STREND
	DAD	D
	XCHG	
	LHLD	FRETOP
	CALL	DCOMPR			;WILL GETSPA GARBAGE COLLECT?
	JC	MAKDSC			;Yes, better have stringexp temp.
MADESC:	POP	PSW
	MOV	A,C			;Get length of stringvar
	CALL	GETSPA			;Get space for result
	POP	H			;Get stringvar descr.
	POP	B			;Get lengths off stack
	XTHL				;Get what we wanted, stringexp descr.
	PUSH	D
	PUSH	B
	CALL	FRESTR			;Free temp if any
	POP	B
	POP	D
	XTHL	
	PUSH	B			;Restore stack to previous state
	PUSH	H
	INX	H
	MOV	M,E
	INX	H
	MOV	M,D			;Set pointer to stringvar copy
	PUSH	PSW
OLDSTR:	POP	PSW
	POP	H			;Get stringvar descr.
	INX	H
	MOV	E,M
	INX	H
	MOV	D,M			;Get pointer to text area
	POP	B			;Get lengths off stack
	POP	H			;Get pointer to stringexp descr.
	PUSH	D
	INX	H
	MOV	E,M
	INX	H
	MOV	D,M			;Get ptr to stringexp text
	XCHG				;Put pointer in [H,L]
	POP	D
	MOV	A,C			;Get length of field(stringvar)
	CMP	B
	JNC	FILDOK			;Jump if field large enough for result
	MOV	B,A			;Save # of bytes to copy
FILDOK:	SUB	B
	MOV	C,A			;[C] = # blanks to fill
	POP	PSW			;Get LSET/RSET flag
	CNC	BLKFIL			;Fill leading if RSET
	INR	B			;In case zero
COPLOP:	DCR	B			;Decr. # to copy
	JZ	LRSTDN			;Done when all copied
	MOV	A,M			;Get byte from stringexp
	STAX	D			;Copy to stringvar
	INX	H
	INX	D
	JMP	COPLOP

RETCUR:	POP	B
	POP	B
	POP	B
	POP	B
	POP	B			;Get garb off stack
LRSTDN:	CC	BLKFIL			;Fill trailing if LSET
	POP	H			;Restore text pointer
	RET	

BLKFIL:	MVI	A,' '			;Fill with spaces
	INR	C			;In case zero
BLKFL1:	DCR	C			;Decr. # to fill
	RZ				;Return when done
	STAX	D			;Store space
	INX	D
	JMP	BLKFL1

; If stringexp was a temporary, create a new temporary to point to
; stringexp since old one was freed. This must be done since GETSPA
; will be called and garbage collection might occur. If stringexp is
; not a temporary, return.

MAKDSC:	POP	PSW			;Get temp flag
	POP	H
	POP	B
	XTHL				;Dig down to stringexp descr.
	XCHG				;FRETMS wants [D,E]
	JNZ	MAKDS1			;Not a temp, don't reallocate
	PUSH	B
	MOV	A,B
	CALL	STRINI			;Make a temp point to stringexp
	CALL	PUTNEW			;Get a temp to point to it
	POP	B
MAKDS1:	XTHL	
	PUSH	B
	PUSH	H			;Restore stack to previous state
	PUSH	PSW
	JMP	MADESC
	PAGE
	SUBTTL	Program I/O -- Fixed Length INPUT

; Format:
;		stringvar = INPUT$(#bytes[,[#] file#])
;If no file # is given, characters will be read from the user's
; terminal. No echoing will be done and no editing will be allowed
; (i.e. rubout,@,_,^U are just input as characters).

	PUBLIC	FIXINP
FIXINP:	CALL	CHRGTR
	CALL	SYNCHR
	DB	'$'			;STRING FUNCTION
	CALL	SYNCHR
	DB	'('
	CALL	GETBYT			;Get # of bytes to read
	PUSH	D			;Save # of bytes to read
	MOV	A,M
	CPI	54O			;Read from disk file?
	JNZ	REDTTY			;No, from user's terminal
	CALL	CHRGTR
	CALL	FILSCN			;Set up file #
	CPI	MD.SQO			;SEQUENTIAL OUTPUT FILE?
	JZ	DERBFM			;THEN BAD FILE MODE
	CALL	FILSET			;SET UP PTRFIL
	XRA	A			;SET ZERO FOR FLAG
REDTTY:	PUSH	PSW			;NON ZERO SET IF TERMINAL I/O
	CALL	SYNCHR
	DB	')'			;Must have paren
	POP	PSW			;Get flag off stack
	XTHL				;Save text ptr, [L]=# to read
	PUSH	PSW			;Save flag
	MOV	A,L
	ORA	A			;Read no characters?
	JZ	FCERR			;Yes, error
	PUSH	H			;Save #
	CALL	STRINI			;Get space for string
	XCHG	
	POP	B			;[C] = # to read
FIXLOP:	POP	PSW
	PUSH	PSW			;NON-ZERO set if should read from TTY
	JZ	DSKCHR			;Read from disk file
	EXTRN	CHARCG
	CALL	CHARCG			;GET CHAR IF ONE
	JNZ	CHARCW			;WAS ONE
	CALL	INCHRI			;Read a char from terminal
CHARCW:
;Note : will check flag on interrupt ^c
	CPI	3			;Control-C?
	JZ	INTCTC			;Yes, stop
PUTCHR:	MOV	M,A			;Put char into string
	INX	H
	DCR	C			;Read enough yet?
	JNZ	FIXLOP			;No, read more
	POP	PSW			;Get flag off stack
	CALL	FINPRT			;Clear PTRFIL
	JMP	PUTNEW			;Return string as result
INTCTC:	LHLD	SAVSTK			;GET SAVED STACK POINTER
	SPHL				;SET [H,L] TO IT
	JMP	ENDCON			;STOP PROGRAM

DSKCHR:	CALL	INDSKC			;Get char from file
	JC	DERRPE			;If carry, read past EOF
	JMP	PUTCHR			;Put char in string
	END	
                                               