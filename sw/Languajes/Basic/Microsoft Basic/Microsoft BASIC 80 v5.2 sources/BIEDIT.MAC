	SUBTTL	Common file for BASIC interpreter
	.SALL	

CONTO	SET	15			;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	SET	0			;FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2	

	.PRINTX	/EXTENDED/


	.PRINTX	/LPT/

	.PRINTX	/CPM DISK/


	.PRINTX	/Z80/

	.PRINTX	/FAST/

	.PRINTX	/5.0 FEATURES/

	.PRINTX	/ANSI COMPATIBLE/
	ENDIF

CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	SET	80			;TERMINAL LINE LENGTH 
LPTLEN	SET	132
BUFLEN	SET	255			;LONG LINES
NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
					;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	SET	4

STRSIZ	SET	3
NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES

NUMTMP	SET	10

MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
					;NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES
CPMWRM	SET	0			;CP/M WARM BOOT ADDR
CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR
	CSEG	
TRUROM	SET	0
	PAGE
	TITLE	BIEDIT	BASIC Interpreter EDIT routines/PGA etc.
	SUBTTL	EDIT COMMAND
;
;
;[C] CONTAINS COUNT OF CHARACTERS IN LINE
;[B] CONTAINS CURRENT CHARACTER POSITION 0=FIRST IN LINE.
;[D] CONTAINS NUMBER OF TIMES TO REPEAT THIS SUBCOMMAND
;[H,L] POINT TO CURRENT CHARACTER
;
;*
	PUBLIC	ERREDT,EDIT,EDITRT,POPART
	EXTRN	BUF,BUFLIN,CRDO,DOT,EDENT,ERRFLG,FININL,FNDLIN,INCHRI,OUTCH1
	EXTRN	LINPRT,LINSPC,LISPRT,MAKUPS,OUTDO,POPHRT,READY,USERR
	EXTRN	BLTUC,ERRLIN
ERREDT:	STA	ERRFLG			;RESET THE FLAG TO CALL EDIT
	LHLD	ERRLIN			;GET THE LINE NUMBER
	ORA	H			;SEE IF IT WAS DIRECT
	ANA	L
	INR	A			;SET ZERO FLAG ON DIRECT
	XCHG				;LINE NUMBER INTO [D,E]
	RZ				;GO BACK IF DIRECT
	JMP	EREDIT
EDIT:	CALL	LINSPC			;GET THE ARGUMENT LINE NUMBER
	RNZ				;ERROR IF NOT END OF LINE
EREDIT:	POP	H			;GET RID OF NEWSTT ADDRESS
EEDITS:	XCHG				;SAVE CURRENT LINE IN DOT
	SHLD	DOT			;FOR LATER EDIT OR LIST
	XCHG				;GET BACK LINE # IN [H,L]
	CALL	FNDLIN			;FIND THE LINE IN QUESTION
	JNC	USERR			;IF NOT FOUND, UNDEFINED STATEMENT ERROR.
	MOV	H,B			;PONTER TO LINE IS IN [B,C]
	MOV	L,C			;TRANSFER IT TO [H,L]
	INX	H			;PASS OVER POINTER TO NEXT LINE
	INX	H			;LIKE SO.
	MOV	C,M			;GET FIRST BYTE OF LINE #
	INX	H			;MOVE TO 2ND BYTE
	MOV	B,M			;PICK IT UP INTO B
	INX	H			;ADVANCE TO POINT TO FIRST BYTE OF LINE
	PUSH	B			;SAVE LINE # ON STACK
	CALL	BUFLIN			;UNPACK LINE INTO BUF
	PUBLIC	INLED
LLED:	POP	H			;GET BACK LINE #
INLED:	PUSH	H			;SAVE IT BACK ON STACK
	MOV	A,H			;TEST FOR DOUBLE BYTE ZERO
	ANA	L
	INR	A
	MVI	A,'!'			;GET PROMPT FOR DIRECT EDIT
	CZ	OUTDO			;SEND IT
	CNZ	LINPRT			;PRINT LINE # IF NOT INLIN EDIT
	MVI	A,' '			;TYPE A SPACE
	CALL	OUTDO			;...
	LXI	H,BUF			;GET START OF BUF IN [H,L]
	PUSH	H			;SAVE [H,L] WHILE WE CALC LINE LENGTH
	MVI	C,255			;ASSUME 0 CHAR LINE
LENLP:	INR	C			;BUMP COUNT OF CHARS
	MOV	A,M			;GET CHAR FROM LINE
	INX	H			;BUMP POINTER
	ORA	A
	JNZ	LENLP			;IF NOT ZERO (END OF LINE) KEEP COUNTING...
	POP	H			;GET BACK POINTER TO LINE
	MOV	B,A			;SET CURRENT LINE POSIT TO ZERO
DISPED:	MVI	D,0			;ASSUME REPITION COUNT IS ZERO
DISPI:
	CALL	INCHRI			;GET A CHAR FROM USER
	ORA	A			;IGNORE NULLS
	JZ	DISPI
	CALL	MAKUPS			;MAKE UPPER CASE COMMAND
	SUI	'0'			;GET RID OF OFFSET
	JC	NOTDGI			;...
	CPI	10
	JNC	NOTDGI
	MOV	E,A			;SAVE CHAR
	MOV	A,D			;GET ACCUM REPITITION
	RLC				;MULTIPLY BY 2
	RLC				;BY 4
	ADD	D			;AND ADD TO GET 5*D
	RLC				;*2 TO GET 10*D
	ADD	E			;ADD DIGIT
	MOV	D,A			;SAVE BACK NEW ACCUM
	JMP	DISPI			;GET NEXT CHAR

NOTDGI:	PUSH	H			;SAVE TEXT POINTER
	LXI	H,DISPED		;PUT RETURN ADDRESS TO DISPED
	XTHL				;ON THE STACK
	DCR	D			;SEE IF D=0 (REP FACTOR)
	INR	D			;SET CONDITION CODES
	JNZ	NTZERD			;BRANCH AROUND
	INR	D			;MAKE IT 1
NTZERD:
	CPI	8-'0'			;Backspace?
	JZ	BAKED			;HANDLE IT
	CPI	177O-'0'		;DEL?
	JZ	DELED			;BACKSPACE POINTER
	CPI	13-'0'			;CARRIAGE RETURN
	JZ	CRED			;DONE EDITING
	CPI	' '-'0'			;SPACE
	JZ	SPED			;GO TO ROUTINE
	CPI	'A'+40O-'0'		;COMMAND IN LOWER CASE?
	JC	NOTLW4			;NO, SO OK.
	SUI	40O			;CONVERT TO UPPER CASE
NOTLW4:	CPI	'Q'-'0'			;QUIT?
	JZ	QED			;IF SO, QUIT & PRINT "OK" OR RETURN TO INLIN
	CPI	'L'-'0'			;L?
	JZ	LED			;BRANCH
	CPI	'S'-'0'			;S?
	JZ	SED			;SEARCH
	CPI	'I'-'0'			;I?
	JZ	IED			;INSERT
	CPI	'D'-'0'			;D?
	JZ	DED			;DELETE
	CPI	'C'-'0'			;C?
	JZ	CED			;CHANGE
	CPI	'E'-'0'			;END?
	JZ	EED			;(SAME AS <CR> BUT DOESNT PRINT REST)
	CPI	'X'-'0'			;EXTEND?
	JZ	XED			;GO TO END OF LINE & INSERT
	CPI	'K'-'0'			;KILL??
	JZ	KED			;(SAME AS "S" BUT DELETES CHARS)
	CPI	'H'-'0'			;HACK??
	JZ	HED			;HACK OFF THE REST OF THE LINE & INSERT
	CPI	'A'-'0'			;AGAIN??
	MVI	A,7			;GET READY TO TYPE BEL.
	JNZ	OUTDO			;NO MATCH, SEND BEL AND RETURN TO DISPATCHER
	POP	B			;DISPI RETURN ADDRESS
	POP	D			;LINE NUMBER INTO [D,E]
	CALL	CRDO			;TYPE A CARRIAGE RETURN LINE-FEED
	JMP	EEDITS			;RESTART EDITING

SPED:	MOV	A,M			;GET CHAR FROM CURENT POSIT
	ORA	A			;ARE WE AT END OF LINE?
	RZ				;IF SO, RETURN
	INR	B			;BUMP CURRENT POSITION
	CALL	OUTCH1			;TYPE CHARACTER
	INX	H			;MOVE POINTER TO NEXT CHAR
	DCR	D			;TEST IF DONE WITH REPITITIONS
	JNZ	SPED			;REPEAT
	RET				;RETURN TO DISPATCHER

KED:	PUSH	H			;SAVE CURRENT CHAR POSIT
	LXI	H,TYPSLH		;TYPE SLASH WHEN DONE
	XTHL				;PUT IT ON STACK & GET POSIT BACK
	STC				;SET THE CARRY FLAG
SED:	PUSH	PSW			;SAVE CONDITION CODES
	CALL	INCHRI			;GET SEARCH CHAR
	MOV	E,A			;SAVE IT
	POP	PSW
	PUSH	PSW
	CC	TYPSLH			;TYPE BEGINNING SLASH FOR "K"
SRCALP:	MOV	A,M
	ORA	A
	JZ	POPART
	CALL	OUTCH1			;TYPE THE CHAR
	POP	PSW			;GET KILL FLAG
	PUSH	PSW			;SAVE BACK
	CC	DELCHR			;DELETE THE CHAR IF K COMMAND.
	JC	NOTSRC			;AND DONT MOVE POINTER AS DELCHR ALREADY DID
	INX	H
	INR	B			;INCREMENT LINE POSIT
NOTSRC:	MOV	A,M			;ARE WE AT END
	CMP	E			;ARE CURRENT CHAR & SEARCH
	JNZ	SRCALP			;CHAR THE SAME? IF NOT, LOOK MORE
	DCR	D			;LOOK FOR N MATCHES
	JNZ	SRCALP			;IF NOT 0, KEEP LOOKING

POPART:	POP	PSW			;GET RID OF KILL FLAG
	RET				;DONE SEARCHING
LED:	CALL	LISPRT			;TYPE REST OF LINE
	CALL	CRDO			;TYPE CARRIAGE RETURN
	POP	B			;GET RID OF RETURN TO DISPED
	JMP	LLED			;GO TO MAIN CODE

DED:	MOV	A,M			;GET CHAR WHICH WE ARE TRYING TO DELETE
	ORA	A			;IS IT THE END OF LINE MARKER?
	RZ				;DONE IF SO
	MVI	A,'\'			;TYPE BACKSLASH
	CALL	OUTCH1			;LIKE SO
DELLP:	MOV	A,M			;GET CHAR FROM LINE
	ORA	A			;ARE WE AT END?
	JZ	TYPSLH			;TYPE SLASH
	CALL	OUTCH1			;TYPE CHAR WE'RE GOING TO DELETE
	CALL	DELCHR			;DELETE CURRENT CHAR
	DCR	D			;DECREMENT DELETE COUNT
	JNZ	DELLP			;KEEP DOING IT
TYPSLH:
	MVI	A,'\'			;TYPE ENDING SLASH
	CALL	OUTDO			;LIKE SO
	RET	

CED:	MOV	A,M			;ARE WE AT END OF LINE?
	ORA	A			;SEE IF 0
	RZ				;RETURN
CED2:	CALL	INCHRI			;GET CHAR TO REPLACE CHAR
	CPI	32			;IS IT CONTROL CHAR?
	JNC	NOTCCC			;NO
	CPI	10			;IS IT LF?
	JZ	NOTCCC			;YES
	CPI	7			;OR BELL?
	JZ	NOTCCC			;OK
	CPI	9			;OR TAB?
	JZ	NOTCCC			;OK
	MVI	A,7			;GET BELL
	CALL	OUTDO			;SEND IT
	JMP	CED2			;RETRY
NOTCCC:	MOV	M,A			;SAVE IN MEMORY
	CALL	OUTCH1			;ECHO THE CHAR WERE USING TO REPLACE
	INX	H			;BUMP POINTER
	INR	B			;INCREMENT POSITION WITHIN LINE
	DCR	D			;ARE WE DONE CHANGING?
	JNZ	CED			;IF NOT, CHANGE SOME MORE.
	RET				;DONE
HED:	MVI	M,0			;MAKE LINE END AT CURRENT POSITION
	MOV	C,B			;SET UP LINE LENGTH CORRECTLY

XED:	MVI	D,255			;FIND END OF LINE
	CALL	SPED			;BY CALLING SPACER
;NOW FALL INTO INSERT CODE
IED:
	CALL	INCHRI			;GET CHAR TO INSERT

	CPI	177O			;DELETE??
	JZ	TYPARW			;YES, ACT LIKE "_"
	CPI	8			;Backspace?
	JZ	TYPAR1			;Do delete
	CPI	15O			;IS IT A CARRIAGE RETURN?
	JZ	CRED			;DONT INSERT, AND SIMULATE <CR>
	CPI	33O			;IS IT ESCAPE?
	RZ				;IF SO, DONE.
	CPI	8			;BACKSPACE?
	JZ	TYPAR1			;TYPE BACKARROW AND DELETE
	CPI	10			;LINE FEED?
	JZ	NTARRW			;ALLOW IT
	CPI	7			;BELL?
	JZ	NTARRW			;ALLOW IT
	CPI	9			;TAB?
	JZ	NTARRW			;ALLOW IT
	CPI	32			;IS IT ILLEGAL CHAR
	JC	IED			;TOO SMALL
	CPI	'_'			;DELETE PREVIOUS CHAR INSERTED?
	JNZ	NTARRW			;IF NOT, JUMP AROUND NEXT CODE
TYPARW:
	MVI	A,'_'			;TYPE IT
TYPAR1:	DCR	B			;ARE WE AT START OF LINE?
	INR	B			;LETS SEE
	JZ	DINGI			;IF SO, TYPE DING.
	CALL	OUTCH1			;TYPE THE BACK ARROW
	DCX	H			;BACK UP THE POINTER
	DCR	B			;MOVE BACK POSIT IN LINE
	LXI	D,IED			;SET UP RETURN ADDRESS
	PUSH	D			;SAVE IT  ON STACK & FALL THROUGH
; SUBROUTINE TO DELETE CHAR POINTED TO BY [H,L]. CORRECTS C.
DELCHR:	PUSH	H			;SAVE CURRENT POSIT POINTER
	DCR	C			;MAKE LENGTH OF LINE ONE LESS
CMPRSS:	MOV	A,M			;GET CHAR TO DELETE
	ORA	A			;ARE WE AT END OF LINE
	STC				;FLAG THAT DELCHR WAS CALLED (FOR K)
	JZ	POPHRT			;IF SO, DONE COMPRESSING
	INX	H			;POINT TO NEXT BYTE
	MOV	A,M			;PICK IT UP
	DCX	H			;NOW BACK AGAIN
	MOV	M,A			;DEPOSIT IT
	INX	H			;NOW TO NEXT BYTE
	JMP	CMPRSS			;KEEP CRUNCHING
NTARRW:	PUSH	PSW			;SAVE THE CHAR TO BE INSERTED
	MOV	A,C			;GET LENGTH OF LINE
	CPI	BUFLEN			;SEE IF WE ARENT TRYING TO MAKE LINE TOO LONG
	JC	OKINS			;IF LENGTH OK, GO INSERT
	POP	PSW			;GET THE UNLAWFUL CHAR
DINGI:
	MVI	A,7			;TYPE A BELL TO LET USER KNOW
	CALL	OUTDO			;IT ALL OVER
IEDG:	JMP	IED			;HE HAS TO TYPE <ESC> TO GET OUT
OKINS:	SUB	B			;CALC POINTER TO 0 AT END OF LINE
	INR	C			;WE ARE GOING TO HAVE LINE LONGER BY 1
	INR	B			;POSITION MOVES UP ONE ALSO
	PUSH	B			;SAVE [B,C]
	XCHG				;SAVE [D,E] IN [H,L]
	MOV	L,A			;SAVE # OF BYTES TO MOVE IN [L]
	MVI	H,0			;GET SET TO ADD [D,E] TO [H,L]
	DAD	D			;CALC HIGH POINTER
	MOV	B,H			;GET HIGH BYTE TO MOVE POINTER
	MOV	C,L			;IN [B,C]
	INX	H			;ALWAYS MOVE AT LEAST ZERO AT END
	CALL	BLTUC			;MOVE LINE OUT 1 CHAR
	POP	B			;RESTORE [B,C]
	POP	PSW			;GET CHAR BACK
	MOV	M,A			;SAVE IT IN LINE
	CALL	OUTCH1			;TYPE THE CHAR
	INX	H			;POINT TO NEXT CHAR
	JMP	IEDG			;AND GO GET MORE CHARS

BAKED:	MOV	A,B			;ARE WE MOVING BACK PAST THE
	ORA	A			;FIRST CHARACTER
	RZ				;DON'T ALLOW IT
	DCX	H			;MOVE CHAR POINTER BACK
	MVI	A,8
	CALL	OUTCH1			;ECHO IT
	DCR	B			;CHANGE CURRENT POSITION
	DCR	D			;ARE WE DONE MOVING BACK?
	JNZ	DELED			;IF NOT, GO BACK MORE
	RET				;RETURN

DELED:	MOV	A,B			;ARE WE MOVING BACK PAST THE
	ORA	A			;FIRST CHARACTER
	RZ				;DON'T ALLOW IT
	DCR	B			;CHANGE CURRENT POSITION
	DCX	H			;MOVE CHAR POINTER BACK
	MOV	A,M			;GET CURRENT CHAR
	CALL	OUTCH1			;ECHO IT
	DCR	D			;ARE WE DONE MOVING BACK?
	JNZ	DELED			;IF NOT, GO BACK MORE
	RET				;RETURN

CRED:	CALL	LISPRT			;TYPE REST OF LINE
EED:	CALL	CRDO			;TYPE CARRIAGE RETURN
	POP	B			;GET RID OF DISPED ADDRESS
	POP	D			;GET LINE # OFF STACK
	MOV	A,D			;DOUBLE BYTE ZERO.
	ANA	E
	INR	A			;SET ZERO IF [D,E] = ALL ONES.
EDITRT:					;USED BY AUTO CODE
	LXI	H,BUF-1			;START KRUNCHING AT BUF
	RZ				;RETURN TO INLIN IF CALLED FROM THERE
	STC				;FLAG LINE # WAS SEEN TO FOOL INSERT CODE
	PUSH	PSW			;PSW IS ON STACK
	INX	H			;NOW POINT AT BUF.
	JMP	EDENT			;GO TO ENTRY POINT IN MAIN CODE

QED:	POP	B			;GET RID OF DISPED ADDRESS
	POP	D			;GET LINE # OFF STACK
	MOV	A,D			;DOUBLE BYTE ZERO.
	ANA	E
	INR	A			;SET ZERO IF [D,E] = ALL ONES.
	JZ	FININL			;TYPE CR AND STORE ZERO IN BUF.
	JMP	READY			;OTHERWISE CALLED FROM MAIN
	END	
                                                               