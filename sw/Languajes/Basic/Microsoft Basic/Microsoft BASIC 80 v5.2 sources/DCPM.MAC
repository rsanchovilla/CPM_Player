	SUBTTL	Common file for BASIC interpreter
	.SALL	

CONTO	SET	15			;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	SET	0			;FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2	

	.PRINTX	/EXTENDED/


	.PRINTX	/LPT/

	.PRINTX	/CPM DISK/


	.PRINTX	/Z80/

	.PRINTX	/FAST/

	.PRINTX	/5.0 FEATURES/

	.PRINTX	/ANSI COMPATIBLE/
	ENDIF

CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	SET	80			;TERMINAL LINE LENGTH 
LPTLEN	SET	132
BUFLEN	SET	255			;LONG LINES
NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
					;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	SET	4

STRSIZ	SET	3
NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES

NUMTMP	SET	10

MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
					;NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES
CPMWRM	SET	0			;CP/M WARM BOOT ADDR
CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR
	CSEG	
TRUROM	SET	0
	PAGE
	SUBTTL	DISK PARAMETERS AND DOCUMENTATION
	TITLE	Disk code for CPM/ONTEL/MOSTEK/DMC/BEEHIVE: WHG,PGA,MBM


;External symbols


	EXTRN	DERBFM,DERBFN,DERBRN,DERDFL
	EXTRN	DERFAO,DERFNF,DERIOE,DERNMF,DERTMF
	EXTRN	FINPRT,OUTDO,CRDO
	EXTRN	TEMP,STROUT,STRLT3,SNERR,SCRTCH
	EXTRN	FACLO,FOUT,CONINT
	EXTRN	CLSALL,FILFRM,FILIDX,GETBYT,FILSCN


	EXTRN	BUF


	EXTRN	DCOMPR,GETYPR,SYNCHR

	EXTRN	FILNAM
	EXTRN	FILNA2
	EXTRN	DIRTMP
;Internal symbols

	PUBLIC	NTOPNC,FILOUT,FILOU3,INDSKC
	PUBLIC	NMLOFS,NMLOFC,NMLO.C,DATOFS,DATOFC,LOCOFS
	PUBLIC	EOF,CLSFIL,LOC
	PUBLIC	NAME,OPEN,KILL,INDSKB,PRGFIL




;
;
;			Revision history
;			-------- -------
;
;11/7/77		FIXED EOF() CODE TO USE ORNOFS INSTEAD OF NMLOFS, PGA
;12/2/77  (4.41) FIXED RANDOM ACCESS TO CLOSE EXTENTS PGA
;12/17/77	ADDITIONAL CODE TO SUPPORT ONTEL DOS BASIC, P.ZILBER
;12/29/77 (4.42)	FIXED BUG WHERE GET, PUT W/O REC NOT INC CURLOC, PGA
;1/5/78   (4.43) FIXED ANOTHER RANDOM BUG, LINE PRINTER ^C PROB. PGA
;7/23/79		Add Beehive interace and cleanup conditionals
;
;
;
;File information:
;
;	 1	Mode of the file
;F.BLK1	(n)	1st block of space, usually FCB( CPM: 33, ONTEL: 42,
;		MOSTEK: 47 ). Zero for others
;LOCOFS	 2	CURLOC, # of sectors read or writeen for sequential.
;		For random files, it is the last record # +1.
;ORNOFS	 1/2	Seq Input: 	# of bytes in sector when read.
;		Seq Output:	# bytes in output sector( # written )
;		Random:		Set to DATPSC by PUT and GET, sometimes
;				zeroed by OUTSQ2 setup for DSKOUT code.
;NMLOFS	 1/2	Seq Input:	# bytes left in input buffer
;		Seq Output:	Position of imaginary print head
;F.BLK2	(n)	2nd block of space( 6 byte chain links for ONTEL,
;		160 bytes for DMC, 10 bytes for BEEHIV )
;DATOFS	(n)	Sector buffer, Length = DATPSC
;
;Extra information for 5.0 version only:
;
;FD.SIZ	 2	Variable length record size( default = 128 )
;FD.PHY	 2	Current physical record #
;FD.LOG	 2	Current logical record #
;FD.CHG	 1	Future flag for across record PRINTs, etc.
;FD.OPS	 2	Output print position for PRINT, INPUT, WRITE
;FD.DAT	(n)	Data buffer for FIELD, size is (FD.SIZ). FD.MAX is max.
;
;%

;File modes

MD.000	SET	0			;THE MODE NUMBER FOR NO FILE, INTERNAL
					;USE ONLY AS AN ESCAPE FROM OPEN
MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT
					;FILES NEVER WRITTEN INTO A FILE
MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
					;AND PROGRAM FILES

;Disk code configuration switches

SPC1ST	SET	1 OR 0 OR 0 OR 0 OR 0 OR 0;1st block exists
SPC2ND	SET	0 OR 0 OR 0		;2nd block exists
SW2BYT	SET	0 OR 0 OR 0		;2 byte offsets (DATPSC .GT. 255)
SWLOF	SET	1 OR 0 OR 0 OR 0 OR 0 OR 0;There is a LOF function
SWRES	SET	1 OR 0 OR 0		;There is a RESET statement
SWFIL	SET	0 OR 1 OR 0 OR 0 OR 0	;There is a FILES command
SWDSKF	SET	(0 OR 0) AND (0-1)	;There is a DSKF function

; Offsets into file blocks for specific entries

LOCOFS	SET	34+3*1+9*0+14*0-10*0+267*0-30*0;OFFSET TO CURLOC BYTES
ORNOFS	SET	2+LOCOFS		;OFFSET TO NUMBER OF BYTES
					;ORIGINALLY IN THE BUFFER
NMLOFS	SET	1+ORNOFS+0		;OFFSET TO BYTES REMAINING IN THE BUFFER
NMLOFC	SET	0+NMLOFS
					;OR THE PRINT POSITION ON OUTPUT
NMLO.C	SET	0+NMLOFS


DATOFS	SET	1+NMLOFS+0+6*0+288*0+10*0;OFFSET TO BUFFER
DATOFC	SET	0+DATOFS
DBLKSZ	SET	DATOFS+DATPSC
	PUBLIC	DBLK.C
DBLK.C	SET	0+DBLKSZ

Q	SET	DBLKSZ
;DEFINE	ENT(SYM,SIZ),<
;INTERN	SYM
;SYM=Q
;Q=Q+SIZ>

	PUBLIC	FD.SIZ,FD.PHY,FD.LOG,FD.CHG,FD.OPS,FD.DAT
FD.MAX	SET	0			;Size of FIELD buffer

;ENT	FD.SIZ,2		;Variable length record size default 128
FD.SIZ	SET	Q
Q	SET	Q+2
;ENT	FD.PHY,2		;Current physical record #
FD.PHY	SET	Q
Q	SET	Q+2
;ENT	FD.LOG,2		;Current logical record number
FD.LOG	SET	Q
Q	SET	Q+2
;ENT	FD.CHG,1		;Future flag for accross block PRINTs etc.
FD.CHG	SET	Q
Q	SET	Q+1
;ENT	FD.OPS,2		;Output print position for PRINT, INPUT, WRITE
FD.OPS	SET	Q
Q	SET	Q+2
;ENT	FD.DAT,FD.MAX		;Actual FIELD data buffer
FD.DAT	SET	Q
Q	SET	Q+FD.MAX
					;Size is FD.SIZ bytes long

	PUBLIC	FNZBLK
FNZBLK	SET	0+Q

EOFCHR	SET	26+2*0-22*0-23*0	;END OF FILE CHARACTER

	SUBTTL	Operating system calls and other data


	EXTRN	CPMVRN,CPMREA,CPMWRI

; CPM CALL IDENTIFIERS

C.OPEN	SET	15
C.CLOS	SET	16
C.DELE	SET	19
;C.WRIT==21
C.MAKE	SET	22
C.RENA	SET	23
C.BUFF	SET	26			;SET DMA ADDRESS
C.GDRV	SET	25			;GET CURRENTLY SELECTED DRIVE
C.SDRV	SET	14			;SET CURRENTLY SELECTED DRIVE
C.REST	SET	13			;INITIALIZE BDOS
C.SEAR	SET	17			;SEARCH FOR FILE

; OFFSETS INTO CP/M FCB (FILE CONTROL BLOCK)
FCB.FN	SET	1-0			;FILE NAME
FCB.FT	SET	9-0			;EXTENSION
FCB.EX	SET	12+20*0			;FILE EXTENT
FCB.RC	SET	15+23*0			;RECORD COUNT = CURRENT EXTENT SIZE
FCB.NR	SET	32+8*0			;NEXT RECORD NUMBER
FCB.RN	SET	33			;CP/M 2.x Random Record Number





;Special for CP/M testing

	SUBTTL	EOF function

	PUBLIC	EOF
EOF::	CALL	FILFRM			;CONVERT ARGUMENT TO FILE NUMBER
	JZ	DERBFN			;BAD FILE NUMBER - NOT FOUND !!!
					;AND SET [B,C] TO POINT TO FILE DATA BLOCK
	CPI	MD.SQO			;IS IT A SEQUENTIAL OUTPUT FILE?
	JZ	DERBFM			;THEN GIVE BAD FILE MODE
ORNCHK:	LXI	H,0+ORNOFS		;SEE IF ANY BYTES ARRIVED IN THIS BUFFER
	DAD	B
	MOV	A,M			;ZERO IFF IT IS END OF FILE
	ORA	A			;SET CC'S
	JZ	WASEOF			;NO BYTES LEFT
	LDAX	B			;** 5.11 **  GET FILE MODE
	CPI	MD.RND			;IS IT A RANDOM FILE?
	JZ	WASEOF			;** 5.11 **  (A) .NE. 0 - not EOF
	INX	H			;POINT TO NUMBER LEFT IN BUFFER
	MOV	A,M			;GET NUMBER OF BYTES IN BUFFER
	ORA	A			;NON-ZERO?
	JNZ	CHKCTZ			;THEN CHECK FOR CONTROL-Z
	PUSH	B			;SAVE [B,C]
	MOV	H,B			;GET FCB POINTER IN [B,C]
	MOV	L,C
	CALL	READIN			;READ ANOTHER BUFFER
	POP	B			;RESTORE [B,C]
	JMP	ORNCHK			;HAVE NEW BUFFER, USE PREVIOUS PROCEDURE
CHKCTZ:	MVI	A,DATPSC AND 377O	;GET # OF BYTES IN FULL BUFFER
	SUB	M			;SUBTRACT LEFT
	MOV	C,A			;PUT IN [B,C] FOR DAD
	MVI	B,0
	DAD	B			;ADD TO ORNOFS OFFSET
	INX	H			;ADD ONE TO POINT TO BYTE IN BUFFER
	MOV	A,M			;GET BYTE
	SUI	EOFCHR			;IF CONTROL-Z, EOF (CONTROL-\ IS FS)
WASEOF:	SUI	1			;MAP 0 TO -1 AND ALL OTHERS TO 0
	SBB	A
	JMP	CONIA##			;CONVERT TO AN INTEGER AND RETURN

	SUBTTL	OUTSEQ	-- Sequential output for a data block

;
; [B,C] POINTS AT FILE DATA BLOCK
;
	PUBLIC	OUTSEQ
OUTSEQ:	MOV	D,B			;PUT FILE BLOCK OFFSET IN [D,E]
	MOV	E,C
	INX	D			;POINT TO FCB
OUTSQ2:	LXI	H,0+ORNOFS		;POINT TO NUMBER IN BUFFER
	DAD	B			;ADD START OF FILE DATA BLOCK
	PUSH	B			;SAVE FILE DATA POINTER
	XRA	A
	MOV	M,A			;ZERO OUT NUMBER IN DATA BUFFER

;	OUTPUT NEXT RECORD IN FILE
;
;	(A) = 0
;	(HL) points to NMLOFS-1
;	(DE) points to File Data Block + 1 ( FCB if SPC2ND=0)
;	(BC) points to File Data Block

	CALL	SETBUF			;SET BUFFER ADDRESS
	LDA	CPMWRI			;Get write code
	CALL	ACCFIL			;Access file
	CPI	255
	JZ	DERTMF			;Too many files - 5.11
	DCR	A			;ERROR EXTENDING FILE? (1)
	JZ	DERIOE			;YES
	DCR	A			;DISK FULL? (2)
	JNZ	OUTSOK			;NO
	POP	D			;GET BACK FILE POINTER
	XRA	A			;GET ZERO
	STAX	D			;MARK AS CLOSED
	MVI	C,C.CLOS		;CLOSE IT
	INX	D			;POINT TO FCB
	CALL	CPMENT			;CALL CP/M
	JMP	DERDFL			;GIVE "DISK FULL" ERROR MESSAGE
OUTSOK:	INR	A			;TOO MANY FILES?
	JZ	DERTMF			;YES

	POP	B			;GET POINTER AT CURLOC
	LXI	H,0+LOCOFS		;BY ADDING OFFSET TO FILE POINTER
	DAD	B
	MOV	E,M			;INCREMENT IT
	INX	H
	MOV	D,M
	INX	D
	MOV	M,D
	DCX	H
	MOV	M,E
	RET	

	SUBTTL	CLOSE A FILE
; FILE NUMBER IS IN [A]
; ZERO ALL INFORMATION. IF FILE IS OPEN, RAISE ITS DISKS HEAD
; IF FILE IS SEQUENTIAL OUTPUT, SEND FINAL SECTOR OF DATA

	PUBLIC	CLSFIL
CLSFIL:	CALL	FILIDX			;GET POINTER TO DATA
	JZ	NTOPNC			;RETURN IF NOT OPEN
					;SAVE FILE #
	PUSH	B			;SAVE FILE POINTER
	LDAX	B			;GET FILE MODE
	MOV	D,B			;PUT FILE BLOCK OFFSET IN [D,E]
	MOV	E,C
	INX	D			;POINT TO FCB
	PUSH	D			;SAVE [D,E] FOR LATER
	CPI	MD.SQO			;SEQENTIAL OUTPUT?
	JNZ	NOFORC			;NO NEED TO FORCE PARTIAL OUTPUT BUFFER
	LXI	H,CLSFL1		;RETURN HERE
	PUSH	H			;SAVE ON STACK
	PUSH	H			;NEED EXTRA STACK ENTRY
	MOV	H,B			;GET FILE POINTER
	MOV	L,C			;INTO [H,L]
	MVI	A,EOFCHR		;PUT OUT CONTROL-Z (OR FS)
	JMP	FILOU4			;JUMP INTO CHAR OUTPUT CODE

CLSFL1:	LXI	H,0+ORNOFS		;CHARS IN BUFFER
	DAD	B			;TEST
	MOV	A,M			;TEST ORNOFS
	ORA	A
	CNZ	OUTSQ2			;FORCE OUT BUFFER


NOFORC:	POP	D			;GET BACK FCB POINTER

;	CLOSE FILE
;
;	(DE) points to FCB
;	((SP)) points to File Data Block

	CALL	SETBUF			;SET DMA ADDRESS
	MVI	C,C.CLOS		;THE CLOSE
	CALL	CPMENT			;CALL CPM
;*****	NO CHECK FOR ERRORS





	POP	B			;RESTORE FILE POINTER
NTOPNC:	MVI	D,DATOFS		;NUMBER OF BYTES TO ZERO
	XRA	A
MORCZR:	STAX	B
	INX	B
	DCR	D
	JNZ	MORCZR
	RET	

	SUBTTL	LOC (CURRENT LOCATION) AND LOF (LAST RECORD NUMBER)

	PUBLIC	LOC
LOC:	CALL	FILFRM			;CONVERT ARGUMENT AND POINT AT DATA BLOCK
	JZ	DERBFN			;IF NOT OPEN, "BAD FILE NUMBER"
	CPI	MD.RND			;Random mode?
	LXI	H,0+LOCOFS+1		;Assume not
	JNZ	LOC1			;No, use CURLOC
	LXI	H,0+FD.LOG+1		;POINT AT LOGICAL RECORD NUMBER
LOC1:
INTRED:	DAD	B
INTRET:	MOV	A,M
	DCX	H
	MOV	L,M
	JMP	GIVINT##
	PAGE
	PUBLIC	LOF
LOF:	CALL	FILFRM			;CONVERT ARGUMENT AND INDEX
	JZ	DERBFN			;"BAD FILE NUMBER" IF NOT OPEN

;	(BC) points to File Data Block

	LXI	H,0+FCB.RC+1		;Point to record number
	DAD	B
	MOV	A,M			;GET RC
	JMP	SNGFLT##		;FLOAT IT
					;Return with LOF in (HL)
					;SWLOF

	SUBTTL	FILOUT -- PUT A CHARACTER IN AN OUTPUT BUFFER AND OUTPUT IF NECESSARY
;
; CALL AT FILOUT WITH [H,L] TO BE SAVED ON THE STACK
; AND THE CHARACTER IN THE HIGH ORDER BYTE BELOW THE [H,L]
; ON THE STACK. THE CURRENT DATA IS OUTPUT IF THERE ARE 128
; CHARACTER STUFFED INTO THE DATA AREA.
; FILOUT IS NORMALLY CALLED FROM OUTDO (OUTCHR)
;
FILOUT:	POP	H			;GET SAVED [H,L] OFF STACK
	POP	PSW			;GET SAVE CHAR OFF STACK
FILOU3:	PUSH	H			;SAVE THE [H,L]
	PUSH	PSW			;SAVE THE CHARACTER AGAIN
	LHLD	PTRFIL##		;GET THE POINTER TO THE FILE
	MOV	A,M			;WHAT IS THE MODE?
	CPI	MD.SQI			;MUST BE ECHOING OR "EXTRA IGNORED"
					;DURING THE READING OF A FILE
	JZ	POPAHT##		;SO IGNORE THIS OUTCHR
	EXTRN	FILOFV
	CPI	MD.RND			;RANDOM?
	JZ	FILOFV			;YES, FINISH UP IN FIVDK.MAC
	POP	PSW			;TAKE THE CHARACTER OFF
FILOU4:	PUSH	D
	PUSH	B
	MOV	B,H			;SETUP [B,C] FOR OUTSEQ
	MOV	C,L
	PUSH	PSW			;RE-SAVE OUTPUT CHARACTER
	LXI	D,0+ORNOFS		;POINT AT THE NUMBER OF CHARACTERS IN THE
	DAD	D			;BUFFER CURRENTLY
	MOV	A,M
	CPI	DATPSC AND 377O		;IS THE BUFFER FULL?
	PUSH	H			;SAVE POINTER AT CHARACTER COUNT
	CZ	OUTSEQ			;OUTPUT IF FULL
	POP	H			;GET BACK DATA BLOCK POINTER
	INR	M			;INCREMENT THE NUMBER OF CHARACTERS
	MOV	C,M			;FETCH FOR OFFSET INTO DATA
	MVI	B,0
	INX	H			;POINT AT PRINT POSITION
	PUBLIC	FILUPP
FILUPP:
	POP	PSW			;GET THE OUTPUT CHARACTER
	PUSH	PSW			;RESAVE FOR OUTPUT
	MOV	D,M			;[D]=CURRENT POSITION
	CPI	13			;BACK TO ZERO POSITION WITH RETURN?
	MOV	M,B			;ASSUME RESET TO ZERO SINCE [B]=0
	JZ	ISCRDS			;ALL DONE UPDATING POSITION
	ADI	224			;SET CARRY FOR SPACES AND HIGHER
	MOV	A,D			;[A]=CURRENT POSITION
	ADC	B			;ADD ON CARRY SINCE [B]=0
	MOV	M,A			;UPDATE THE POSITION IN THE DATA BLOCK
ISCRDS:	DAD	B
	POP	PSW			;GET THE CHARACTER
	POP	B
	POP	D
	MOV	M,A			;SAVE IT IN THE DATA AREA
	POP	H			;GET BACK SAVED [H,L]
	RET	

	SUBTTL	PUT AND GET STATEMENTS

;	EXTERN	GET,PUT
	PUBLIC	FIVDPT
FIVDPT:
	DCX	D			;MAP RECORD NUMBER 1=0 LOGICAL
	DCX	H
	MOV	M,E
	INX	H
	MOV	M,D			;SETUP CURLOC AGAIN
	INX	H			;POINT TO ORN
	MVI	M,DATPSC AND 377O	;SET NUMBER IN THE BUFFER TO DATSPC
	INX	H
	MVI	M,DATPSC AND 377O
	POP	H			;[H,L]=TEXT POINTER
	XTHL				;SAVE TEXT POINTER, [H,L]=START OF DATA BLOCK
	MOV	B,H
	MOV	C,L

;	RANDOM FILE ACCESS
;
;	(DE) = physical block #
;	(BC) points to File Data Block
;	(HL) points to File Data Block

	PUSH	H			;SAVE DATA BLOCK POINTER
	LDA	CPMVRN			;Get version number
	ORA	A
	JZ	RNDVR1			;Version 1.x

	LXI	H,0+FCB.RN+1		;Offset to random record number
	DAD	B
	MOV	M,E			;Set new random record number
	INX	H
	MOV	M,D
	INX	H
	MVI	M,0
	JMP	RNDDON			;Finished setting record number

RNDVR1:	LXI	H,0+FCB.EX+1		;POINT TO EXTENT
	DAD	B			;ADD START OF FILE CONTROL BLOCK
	MOV	A,E			;GET LOW BYTE OF OFFSET
	RAL				;GET HIGH BIT IN CARRY
	MOV	A,D			;GET HIGH BYTE
	RAL				;ROTATE IN HIGH BYTE OF LOW PART
	MOV	D,M			;PUT ORIGINAL EXTENT IN [D]
	CMP	D			;ARE NEW AND OLD EXTENT THE SAME?
	JZ	SAMEXT			;SAME EXTENT, DONT RE-OPEN
	PUSH	D			;SAVE RECORD NUMBER
	PUSH	PSW			;SAVE NEW EXTENT
	PUSH	H			;SAVE POINTER TO EXTENT
	PUSH	B			;SAVE FILE POINTER
	LXI	D,DIRTMP		;READ DIRECTORY IN HERE FOR OPEN
	MVI	C,C.BUFF		;SET CPM BUFFER ADDRESS
	CALL	CPMENT
	POP	D			;GET CPM FCB POINTER
	PUSH	D			;SAVE BACK
	INX	D			;POINT TO FCB
	MVI	C,C.CLOS		;CLOSE PREVIOUS EXTENT (?!)
	CALL	CPMENT			;CALL CP/M
	POP	D			;GET BACK FCB POINTER
	POP	H			;RESTORE POINTER TO EXTENT FIELD
	POP	PSW			;GET BACK NEW EXTENT
	MOV	M,A			;STORE NEW EXTENT
	PUSH	D
	INX	D			;POINT TO FCB
	MVI	C,C.OPEN		;OPEN NEW EXTENT
	PUSH	D			;SAVE EXTENT POINTER
	CALL	CPMENT			;BY CALLING CP/M
	POP	D			;RESTORE FCB POINTER
	INR	A			;DOES EXTENT EXIST?
	JNZ	RNDOK			;YES
	MVI	C,C.MAKE		;MAKE THE EXTENT EXIST
	CALL	CPMENT			;CALL CP/M
	INR	A			;ROOM IN DIRECTORY?
	JZ	DERTMF			;NO
RNDOK:	POP	B			;RESTORE [B,C]
	POP	D			;RESTORE RECORD NUMBER
SAMEXT:	LXI	H,0+FCB.NR+1		;NEXT RECORD FIELD
	DAD	B			;POINT TO IT
	MOV	A,E			;GET LOW 7 BITS OF RECORD #
	ANI	127
	MOV	M,A			;SET RECORD #

RNDDON:
	POP	H			;[H,L] POINT AT FILE DATA BLOCK

;	(BC) points to File Data Block
;	(HL) points to File Data Block

	LDA	MAXTRK##		;GET FLAG FOR "PUT" OR "GET"
	ORA	A
	JNZ	PUTFIN			;DO THE PUTTING
	CALL	READIN			;PERFORM THE GET
	POP	H			;GET THE TEXT POINTER
	RET	

PUTFIN:
	LXI	H,0+FCB.NR+1		;LOOK AT RECORD #
	DAD	B			;[H,L] POINTS TO IT
	MOV	A,M			;GET IT
	CPI	127			;LAST RECORD IN EXTENT?
	PUSH	PSW			;SAVE INDICATOR
	LXI	D,DIRTMP		;SAVE HERE
	LXI	H,0+DATOFS		;POINT TO DATA
	DAD	B
	PUSH	D			;SAVE DIRTMP POINTER
	PUSH	H			;SAVE DATA POINTER
	CZ	BUFMOV			;NOT LAST EXTENT
	CALL	OUTSEQ			;OUTPUT THE DATA
	POP	D			;RESTORE DATA POINTER
	POP	H			;RESTORE POINTER TO DIRTMP
	POP	PSW			;RESTORE INDICATOR
	CZ	BUFMOV			;MOVE SECTOR
	POP	H			;GET THE TEXT POINTER
	JMP	FINPRT##		;ZERO PTRFIL

BUFMOV:	PUSH	B			;SAVE [B,C]
	MVI	B,DATPSC		;# OF BYTES TO MOVE
BUFSLP:	MOV	A,M			;GET BYTE FROM BUFFER
	INX	H			;BUMP POINTER
	STAX	D			;SAVE IN DIRTMP
	INX	D			;BUMP POINTER
	DCR	B
	JNZ	BUFSLP			;KEEP MOVING BYTES
	POP	B			;RESTORE [B,C]
	RET	

	SUBTTL	INDSKC, FILLSQ, AND READIN -- FOR READING CHARACTERS AND BUFFERS

;
; GET A CHARACTER FROM A SEQUENTIAL FILE IN [PTRFIL]
; ALL REGISTERS EXCEPT [D,E] SMASHED
;
;	'C' set if EOF read
;
INDSKB:	PUSH	B			;SAVE CHAR COUNTER
	PUSH	H			;SAVE [H,L]
INDSK3:	LHLD	PTRFIL##		;GET DATA BLOCK POINTER
	EXTRN	FILIFV
	MOV	A,M			;GET FILE MODE
	CPI	MD.RND			;RANDOM?
	JZ	FILIFV			;DO INPUT
	LXI	B,0+NMLOFS		;SEE HOW MANY CHARACTERS LEFT
	DAD	B
	MOV	A,M			;GET THE NUMBER
	ORA	A
	JZ	FILLSQ			;MUST GO READ SOME MORE -- IF CAN
	DCX	H			;POINT AT ORNOFS
	MOV	A,M			;GET ORIGINAL NUMBER
	INX	H			;POINT AT NUMBER LEFT AGAIN
	DCR	M			;DECREMENT THE NUMBER
	SUB	M			;SUBTRACT TO GIVE OFFSET
	MOV	C,A			;[C]=OFFSET
	DAD	B
	MOV	A,M			;GET THE DATA
	ORA	A			;RESET CARRY FLAG FOR NO EOF
	POP	H			;RESTORE [H,L]
POPBRT:	POP	B			;RESTORE
	RET	

FILLSQ:	DCX	H			;BACK UP POINTER
	MOV	A,M			;TO ORNOFS
	ORA	A			;DID WE HIT EOF ON PREVIOUS READ?
	JZ	FILLS1			;YES
	CALL	READ2			;READ A RECORD
;	ORA	A		;USED TO BE - WAS IT EOF?
	JNZ	INDSK3			;RETURN WITH A CHAR
FILLS1:	STC				;CARRY IS EOF FLAG
	POP	H			;RESTORE [H,L]
	POP	B			;EOF DETECTED
	MVI	A,EOFCHR		;RETURN WITH CHAR=CONTROL-Z (OR =FS)
	RET	

READ2:	LHLD	PTRFIL##		;GET DATA POINTER
READIN:	PUSH	D
	MOV	D,H			;PUT FCB POINTER IN [D,E]
	MOV	E,L
	INX	D
	LXI	B,0+LOCOFS		;POINT TO CURLOC
	DAD	B
	MOV	C,M			;UPDATE [CURLOC]
	INX	H
	MOV	B,M
	INX	B
	DCX	H
	MOV	M,C
	INX	H
	MOV	M,B
	INX	H			;POINT TO NUMBER READ
	INX	H			;POINT TO NMLOFS
	PUSH	H			;SAVE [H,L]
; ZERO OUT THE BUFFER IN CASE NOTHING READ
	MVI	C,DATPSC		;NUMBER OF BYTES/BUFFER
ZRRND:	INX	H			;INCREMENT BUFFER POINTER
	MVI	M,0			;ZERO IT
	DCR	C			;DECREMENT COUNT
	JNZ	ZRRND			;KEEP ZEROING

;	READ SPECIFIED RECORD IN FILE
;
;	(DE) points to FCB
;
;	If SW2BYT = 0,
;		(A) = number of bytes read
;	If SW2BYT = 1,
;		(DE) = number of bytes read
;
;	If EOF, return with (A) or (DE) zero and
;		jump to READI2
;
;	Returns 'Z' set if EOF

	CALL	SETBUF			;SET CPM BUFFER ADDRESS
	LDA	CPMREA			;Get read code
	CALL	ACCFIL			;Access file
	ORA	A			;EOF?
	MVI	A,0			;Return 0 if EOF
	JNZ	READI2			;Assume EOF if error
READI1:	MVI	A,DATPSC		;OTHERWISE, HAVE 128 BYTES
READI2:	POP	H			;POINT BACK TO # READ
	MOV	M,A			;STORE NUMBER READ
	DCX	H			;POINT AT NUMBER ORIGINALLY
	MOV	M,A			;STORE NUMBER READ
	ORA	A			;Test for EOF
	POP	D			;GET [D,E] BACK
	RET	

SETBUF:	PUSH	B			;SAVE [B,C]
	PUSH	D			;SAVE [D,E]
	PUSH	H			;SAVE [H,L]
	LXI	H,0+DATOFS-1		;POINT TO BUFFER
	DAD	D			;ADD
	XCHG				;PUT BUFFER ADDRESS IN [D,E]
	MVI	C,C.BUFF		;SET UP BUFFER ADDRESS
	CALL	CPMENT			;CALL CPM
	POP	H			;RESTORE [H,L]
	POP	D			;RESTORE [D,E]
	POP	B			;RESTORE [B,C]
	RET	

;
INDSKC:
	CALL	INDSKB			;GET CHAR
	RC				;IF EOF, RETURN WITH END OF FILE CHARACTER
	CPI	EOFCHR			;WAS IT A CONTROL-Z (OR FS)?
	STC				;SET CARRY
	CMC				;MAKE SURE CARRY RESET
	RNZ				;NO
	PUSH	B			;SAVE [B,C]
	PUSH	H			;SAVE [H,L]
	LHLD	PTRFIL			;GET POINTER TO FILE DATA BLOCK
	LXI	B,0+ORNOFS		;POINT TO NUMBER ORIGINALLY IN BUFFER
	DAD	B
	MVI	M,0			;FORCE IT TO ZERO
	INX	H			;POINT TO NUMBER IN BUFFER
	MVI	M,0			;FORCE TO ZERO.
	STC				;SET EOF FLAG
	POP	H			;RESTORE [H,L]
	POP	B			;RESTORE [B,C]
	RET	


	SUBTTL	NAMFIL -- SCAN A FILE NAME AND NAME COMMAND

NAMFIL:	CALL	FRMEVL##		;EVALUATE STRING
	PUSH	H			;SAVE TEXT POINTER
	CALL	FRESTR##		;FREE UP THE TEMP
	MOV	A,M			;GET LENGTH OF STRING
	ORA	A			;NULL STRING?
	JZ	DERNMF			;YES, ERROR
	PUSH	PSW			;NO "." SEEN
	INX	H			;PICK UP POINTER TO STRING
	MOV	E,M			;BY GETTING ADDRESS
	INX	H			;OUT OF DESCRIPTOR
	MOV	H,M
	MOV	L,E			;[H,L] POINTS TO STRING
	MOV	E,A			;SAVE LENGTH

;	(HL) points to filename
;	(A) = length
;	(E) = length
;	((SP)) = no carry

	CPI	2			;CAN THERE BE A DEVICE?
	JC	NODEV			;NO, NAME TOO SHORT
	MOV	C,M			;[C]=POSSIBLE DEVICE NAME
	INX	H			;POINT TO NEXT CHAR
	MOV	A,M			;GET IT
	DCR	E			;DECREMENT COUNT FOR DEVICE NAME
	CPI	':'			;COLON FOR DEVICE NAME?
	JZ	CHKFIL			;YES, SO NOW GET FILE NAME
	DCX	H			;BACK UP POINTER BY ONE
	INR	E			;COMPENSATE FOR DCR
NODEV:	DCX	H			;BACK UP POINTER
	INR	E			;INCREMENT CHAR COUNT TO COMPENSATE FOR NEXT DECR
	MVI	C,'A'-1			;USE CURRENTLY SELECTED DRIVE
CHKFIL:	DCR	E			;DECRMENT CHAR COUNT
	JZ	DERNMF			;ERROR IF NO FILENAME
	MOV	A,C			;GET DRIVE #
	SUI	'A'-1			;CONVERT TO LOGICAL NUMBER
	JC	DERNMF			;NOT IN RANGE
	CPI	27			;BIGGER THAN 27
	JNC	DERNMF			;NOT ALLOWED
	LXI	B,FILNAM		;WHERE TO PUT NAME
	STAX	B			;STORE DISK # IN FCB
	INX	B			;POINT TO WHERE FIRST CHAR OF FILE NAME IS STORED
	MVI	D,11-2*0		;LENGTH OF NAME
FILINX:	INX	H			;BUMP POINTER
FILLOP:	DCR	E			;END OF STRING
	JM	FILSPC			;YES, FILL REST OF FIELD WITH BLANKS
	MOV	A,M			;GET CHAR
	CPI	'.'			;EXTENSION?
	JNZ	FILLO1			;NO
FILLO0:	CALL	FILLNM			;YES, FILL NAME WITH BLANKS
	POP	PSW			;RESTORE CC'S
	STC				;FLAG "." SEEN
	PUSH	PSW			;SAVE CC'S BACK
	JMP	FILINX			;YES, IGNORE "."
FILLO1:
	STAX	B			;COPY CHAR
	INX	B
	INX	H
	DCR	D			;DECRMENT POSSIBLE COUNT OF CHARS
	JNZ	FILLOP
GOTNAM:
	XRA	A			;CLEAR EXTENT FIELD
	STA	FILNAM+12
	POP	PSW			;RESTORE CONDITION CODES
	POP	H			;GET BACK TEXT POINTER
	RET	

FILLNM:	MOV	A,D			;GET # OF CHARS
	CPI	11+8*0-2*0		;INITIAL POSITION?
	JZ	DERNMF			;DONT ALLOW NULL FILENAME
	CPI	3			;FILLED FIELD?
	JC	DERNMF			;NO, BUT 2ND "."
	RZ				;YES, BACK TO LOOP
FILLN1:	MVI	A,' '			;FILL WITH SPACE
	STAX	B
	INX	B
	DCR	D
	JMP	FILLNM
FILSPC:	INR	D			;CHARS LEFT IN FILE BUFFER
	DCR	D			;TEST
	JZ	GOTNAM			;NO
FILSP2:	MVI	A,' '			;SPACE
	STAX	B			;STORE
	INX	B
	DCR	D			;FILLED WHOLE FIELD?
	JNZ	FILSP2			;NO, MORE SPACES
	JMP	GOTNAM			;YES, MAKE SURE NAME OK
	PAGE
NAME::
	CALL	NAMFIL			;PICK UP THE OLD NAME TO USE
	PUSH	H			;SAVE THE TEXT POINTER
	LXI	D,DIRTMP		;READ DIRECTORY IN HERE
	MVI	C,C.BUFF		;SET BUFFER ADDRESS
	CALL	CPMENT			;CALL CP/M
	LXI	D,FILNAM		;SEE IF ORIGINAL NAME EXISTS
	MVI	C,C.OPEN		;BY OPENING
	CALL	CPMENT			;CALL CP/M
	INR	A			;DOES IT EXIST?
	JZ	DERFNF			;FILE NOT FOUND
	LXI	H,FILNA2		;SAVE FILE NAME IN FILNA2
	LXI	D,FILNAM
	MVI	B,12+3*0-2*0+2*0+3*0-3*0;SET [C]=MAX FILE NAME LENGTH
NAMRMV:	LDAX	D			;GET BYTE FROM FILE
	MOV	M,A			;SAVE BYTE IN "OLD" FILE NAME
	INX	H			;BUMP POINTERS
	INX	D
	DCR	B
	JNZ	NAMRMV
	POP	H			;GET THE TEXT POINTER BACK
	CALL	SYNCHR
	DB	'A'			;MAKE SURE "AS" IS THERE
	CALL	SYNCHR
	DB	'S'			;
	CALL	NAMFIL			;READ THE NEW NAME
	PUSH	H			;SAVE THE TEXT POINTER
	LDA	FILNAM			;GET DISK # OF FILE NAME
	LXI	H,FILNA2		;POINT TO ORIG FILE
	CMP	M			;COMPARE
	JNZ	FCERR##			;DISKS MUST BE THE SAME
	LXI	D,FILNAM		;SEE IF ORIGINAL NAME EXISTS
	MVI	C,C.OPEN		;BY OPENING
	CALL	CPMENT			;CALL CP/M
	INR	A			;DOES IT EXIST?
	EXTRN	DERFAE
	JNZ	DERFAE			;YES
	MVI	C,C.RENA		;RENAME OPERATION
	LXI	D,FILNA2		;POINT AT OLD NAME FCB
	CALL	CPMENT			;CALL CPM
;	INR	A		;FILE FOUND?
;****DONT CHECK ERROR RETURN, CP/M HAS PROBLEMS****
;	JZ	DERFNF		;NO
	POP	H			;RESTORE TEXT POINTER
	RET	



	SUBTTL	OPEN STATEMENT AND ALL DIRECTORY HANDLING

OPEN::	LXI	B,FINPRT		;ZERO PTRFIL WHEN DONE
	PUSH	B
	CALL	FRMEVL			;READ THE FILE MODE
	PUSH	H			;SAVE THE TEXT POINTER
	CALL	FRESTR			;FREE STRING TEMP & CHECK STRING
	MOV	A,M			;MAKE SURE ITS NOT A NULL STRING
	ORA	A
	JZ	DERBFM			;IF SO, "BAD FILE MODE"
	INX	H
	MOV	C,M			;[B,C] POINT AT MODE CHARACTER
	INX	H
	MOV	B,M
	LDAX	B			;[A]=MODE CHARACTER
	ANI	-1-' '			;FORCE TO UPPER CASE
	MVI	D,MD.SQO		;ASSUME ITS "O"
	CPI	'O'			;IS IT?
	JZ	HAVMOD			;[D] HAS CORRECT MODE
	MVI	D,MD.SQI		;ASSUME SEQUENTIAL
	CPI	'I'			;IS IT?
	JZ	HAVMOD			;[D] SAYS SEQUENTIAL INPUT
	MVI	D,MD.RND		;MUST BE RANDOM
	CPI	'R'
	JNZ	DERBFM			;IF NOT, NO MATCH SO "BAD FILE MODE"
HAVMOD:	POP	H			;GET BACK THE TEXT POINTER
	CALL	SYNCHR
	DB	44			;SKIP COMMA BEFORE FILE NUMBER
	PUSH	D			;SAVE THE FILE MODE
	CPI	'#'			;SKIP A POSSIBLE "#"
	CZ	CHRGTR##
	CALL	GETBYT			;READ THE FILE NUMBER
	CALL	SYNCHR
	DB	44			;SKIP COMMA BEFORE NAME
	MOV	A,E			;[A]=FILE NUMBER
	ORA	A			;MAKE SURE FILE WASN'T ZERO
	JZ	DERBFN			;IF SO, "BAD FILE NUMBER"
	POP	D			;GET BACK FILE MODE
PRGFIL:	MOV	E,A			;SAVE FILE NUMBER IN [E]
	PUSH	D			;SAVE THE MODE IN [D]
					;SINCE PROGRAM FILE [A]=0
	CALL	FILIDX			;[B,C] POINT AT FILE DATA BLOCK
	JNZ	DERFAO			;IF NON ZERO MODE, "FILE ALREADY OPEN"
	POP	D			;[D]=FILE MODE
	MOV	A,D			;FILE MODE TO [A]
	STAX	B			;SAVE IN FILE BLOCK
	PUSH	B			;SAVE POINTER AT FILE DATA BLOCK
	PUSH	D			;SAVE BACK FILE MODE AND NUMBER
	CALL	NAMFIL			;READ THE NAME
	POP	D			;RESTORE FILE NUMBER
	POP	B			;GET BACK FILE DATA BLOCK POINTER
	PUSH	B			;SAVE BACK
	EXTRN	VARECS
	PUSH	PSW			;SAVE EXTENSION FLAG
	LDAX	B			;GET FILE MODE
	CALL	VARECS			;SCAN RECORD LENGTH FIELD
	POP	PSW			;GET BACK EXTENSION FLAG
	EXTRN	TEMP
	SHLD	TEMP			;SAVE THE TEXT POINTER FOR A WHILE
	JC	PRGDOT			;IF "." SEEN, DONT DEFAULT EXTENSION
	MOV	A,E			;GET FILE NUMBER
	ORA	A			;SET CONDITION CODES
	JNZ	PRGDOT			;NOT FILE 0, DONT DEFAULT FILE NAME
	LXI	H,FILNAM+9-0-0-2*0	;POINT TO FIRST CHAR OF EXTENSION
	MOV	A,M			;GET IT
	CPI	' '			;BLANK EXTENSION
	JNZ	PRGDOT			;NON-BLANK EXTENSION, DONT USE DEFAULT
	MVI	M,'B'			;SET DEFAULT EXTENSION
	INX	H
	MVI	M,'A'
	INX	H
	MVI	M,'S'			;SET ".BAS"
					;BASCOM
PRGDOT:	POP	H			;[H,L]=POINTER AT FILE DATA BLOCK
	SHLD	PTRFIL##		;SETUP AS CURRENT FILE
	PUSH	H			;SAVE BACK FILE DATA BLOCK POINTER
	INX	H			;POINT TO FCB ENTRY
	LXI	D,FILNAM		;GET POINTER TO SCANNED FILE NAME
	MVI	C,12+0+0*3+2*0+3*0	;NUMBER OF BYTES TO COPY
OPNLP:	LDAX	D			;GET BYTE FROM FILNAM
	MOV	M,A			;STORE IN FILE DATA BLOCK
	INX	D
	INX	H
	DCR	C			;DECRMENT COUNT OF BYTES TO MOVE
	JNZ	OPNLP			;KEEP LOOPING

;	OPEN FILE
;
;	((SP)) points to File Data Block
;	((SP)+2) contains the file mode - DMC!X3200!R2E

	MVI	M,0			;MAKE SURE EXTENT FIELD IS ZERO
	LXI	D,0+20			;POINT TO NR FIELD
	DAD	D
	MVI	M,0			;SET TO ZERO
	POP	D			;GET POINTER TO FILE DATA BLOCK BACK IN [D]
	PUSH	D			;SAVE AGAIN FOR LATER
	INX	D
	CALL	SETBUF			;SET BUFFER ADDRESS
	POP	H			;GET BACK FILE DATA BLOCK PTR
	PUSH	H			;SAVE BACK
	MOV	A,M			;GET MODE
	CPI	MD.SQO			;SEQENTIAL OUTPUT?
	JNZ	OPNFIL			;NO, DO CPM OPEN CALL
	PUSH	D			;SAVE FCB POINTER
	MVI	C,C.DELE		;DELETE EXISTING OUTPUT FILE, IF ANY
	CALL	CPMENT			;CALL CP/M
	POP	D			;RESTORE FCB POINTER
MAKFIL:	MVI	C,C.MAKE		;CREATE FILE
	CALL	CPMENT			;CALL CPM
	INR	A			;TEST FOR TOO MANY FILES
	JZ	DERTMF			;THAT WAS THE CASE
	JMP	OPNSET			;FINISH SETUP OF FILE DATA BLOCK
OPNFIL:	MVI	C,C.OPEN		;CPM CODE FOR OPEN
	CALL	CPMENT			;CALL CPM
	INR	A			;FILE NOT FOUND
	JNZ	OPNSET			;FOUND
	POP	D			;GET BACK FILE POINTER
	PUSH	D			;SAVE BACK
	LDAX	D			;GET MODE OF FILE
	CPI	MD.RND			;RANDOM?
	JNZ	DERFNF			;NO, SEQENTIAL INPUT, FILE NOT FOUND
	INX	D			;MAKE [D,E]=FCB POINTER
	JMP	MAKFIL			;MAKE FILE

;	((SP)) points to File Data Block
;	((SP)+2) contains the file mode - DMC!X3200!R2E

OPNSET:	POP	D			;POINT TO FILE INFO
	PUSH	D			;SAVE POINTER BACK
	LXI	H,0+LOCOFS		;POINT TO CURLOC
	DAD	D
	XRA	A			;ZERO CURLOC IN CASE THIS FILE
					;WAS JUST KILLED
	MOV	M,A
	INX	H
	MOV	M,A
	INX	H
	MOV	M,A			;ZERO NUMBER OF BYTES IN THE BUFFER
	INX	H
	MOV	M,A			;ZERO PRINT POSITION
	POP	H			;GET POINTER AT MODE
	MOV	A,M			;SEE WHAT HAS TO BE DONE
	CPI	MD.RND			;IS IT RANDOM MODE?
	JZ	RNDFIN			;YES RANDOM FINISH UP
	CPI	MD.SQI			;IF SEQUENTIAL ALL THAT IS LEFT TO DO
	JNZ	GTMPRT##		;FETCH TEXT POINTER AND DONE

;
; FINISH UP SEQUENTIAL INPUT AFTER FINDING FILE
;
	CALL	READ2			;READ FIRST DATA BLOCK
OPN000:
	LHLD	TEMP			;GET BACK THE TEXT POINTER
	RET	

RNDFIN:	LXI	B,0+DATOFS		;NOW ADVANCE POINTER TO DATA
	DAD	B			;BY ADDING PROPER OFFSET
	MVI	C,DATPSC		;# OF BYTES TO ZERO
ZRRNDT:	MOV	M,B
	INX	H
	DCR	C
	JNZ	ZRRNDT
	JMP	GTMPRT			;GET TEXT POINTER

	SUBTTL	SYSTEM (EXIT) COMMAND - RETURN TO CPM (OR EXIT TO OS)

	PUBLIC	SYSTEM
	PUBLIC	SYSTME
SYSTEM:
	RNZ				;SHOULD TERMINATE
	CALL	CLSALL			;CLOSE ALL DATA FILES
SYSTME:	JMP	CPMWRM			;WARM START CP/M
					;BASCOM

	SUBTTL	RESET COMMAND - FORCE DIRECTORY RE-READ ON ALL DISKS

	PUBLIC	RESET
RESET:	RNZ				;SHOULD TERMINATE
	PUSH	H			;SAVE TEXT POINTER
	CALL	CLSALL			;CLOSE ALL FILES
	MVI	C,C.GDRV		;GET DRIVE CURRENTLY SELECTED
	CALL	CPMENT			;GET IT IN [A]
	PUSH	PSW			;SAVE CURRENT DRIVE #
	MVI	C,C.REST		;DO THE RESET CALL
	CALL	CPMENT
	POP	PSW			;GET DRIVE TO SELECT
	MOV	E,A			;INTO [E]
	MVI	C,C.SDRV		;SET DRIVE
	CALL	CPMENT			;CALL CPM
	POP	H			;RESTORE TEXT POINTER
	RET	

	SUBTTL	Kill command

KILL::
	CALL	NAMFIL			;SCAN FILE NAME
	PUSH	H			;SAVE TEXT POINTER
	LXI	D,DIRTMP		;READ DIRECTORY IN HERE
	MVI	C,C.BUFF		;SET BUFFER ADDRESS
	CALL	CPMENT			;FOR CP/M
	LXI	D,FILNAM		;TRY TO OPEN FILE
	PUSH	D			;SAVE FCB POINTER
	MVI	C,C.OPEN
	CALL	CPMENT
	INR	A			;FILE FOUND?
	POP	D			;GET BACK POINTER TO FCB
	PUSH	D			;SAVE BACK
	PUSH	PSW			;SAVE FOUND FLAG
	MVI	C,C.CLOS		;THIS MAY NOT BE NESC.
	CNZ	CPMENT			;CLOSE FILE
	POP	PSW			;RESTORE FOUND INDICATOR
	POP	D			;RESTORE FCB POINTER
	JZ	DERFNF			;YES
	MVI	C,C.DELE		;CODE FOR DELETE
	CALL	CPMENT			;CALL CPM
	POP	H			;GET BACK TEXT POINTER
	RET	

	SUBTTL	FILES COMMAND - LIST THE DIRECTORY

; THIS IS THE FILES[<FILENAME>] COMMAND
; WHICH PRINTS THE FILES WHICH MATCH THE <FILENAME> WILDCARD SPECIFIER
; IF <FILENAME> IS OMITTED, ALL THE FILES ON THE CURRENTLY SELECTED DRIVE
; ARE LISTED
	PUBLIC	FILES
FILES:
	JNZ	FILNB			;FILE NAME WAS SPECIFIED
	PUSH	H			;SAVE TEXT POINTER
	LXI	H,FILNAM		;POINT TO FILE NAME
	MVI	M,0			;SET CURRENT DRIVE
	INX	H			;BUMP POINTER
	MVI	C,11+8*0		;MATCH ALL FILES
	CALL	FILQST			;SET FILE NAME AND EXTENSION TO QUESTION MARKS
	POP	H			;RESTORE TEXT POINTER
FILNB:	CNZ	NAMFIL			;SCAN FILE NAME
	XRA	A			;MAKE SURE EXTENT IS ZERO
	STA	FILNAM+12
	PUSH	H			;SAVE TEXT POINTER
	LXI	H,FILNAM+1		;GET FIRST CHAR OF FILE NAME
	MVI	C,8			;FILL NAME WITH QUESTION MARKS
	CALL	FILQS
	LXI	H,FILNAM+9		;POINT TO EXTENSION
	MVI	C,3			;3 CHARS IN EXTENSION
	CALL	FILQS			;FILL IT WITH QMARKS
	LXI	D,DIRTMP		;SET BUFFER TO 80 HEX
	MVI	C,C.BUFF
	CALL	CPMENT
	LXI	D,FILNAM		;POINT TO FCB
	MVI	C,C.SEAR		;DO INITIAL SEARCH FOR FILE
	CALL	CPMENT			;CALL CP/M
	CPI	255			;FIND FIRST INCARNATION OF FILE
	JZ	DERFNF			;NO
FILNXT:	ANI	3			;MASK OFF LOW TWO BITS
	ADD	A			;MULTIPLY BY 32
	ADD	A
	ADD	A
	ADD	A
	ADD	A
	MOV	C,A			;PUT OFFSET IN [B,C]
	MVI	B,0
	LXI	H,DIRTMP+1		;POINT TO DIRECTORY BUFFER
	DAD	B			;POINT TO FCB ENTRY IN DIRECTORY
	MVI	C,11+5*0+11*0		;CHARS IN NAME
MORNAM:	MOV	A,M			;GET FILE NAME CHAR
	INX	H			;BUMP POINTER
	CALL	OUTDO			;PRINT IT
	MOV	A,C			;GET  CHAR POSIT
	CPI	4+5*0			;ABOUT TO PRINT EXTENSION?
	JNZ	NOTEXT			;NO
	MOV	A,M			;GET FIRST CHAR OF EXTENSION
	CPI	' '			;IF SO, NOT SPACE
	JZ	PRISPA			;PRINT SPACE
	MVI	A,'.'			;PRINT DOT
PRISPA:	CALL	OUTDO
NOTEXT:	DCR	C			;DECREMENT CHAR COUNT
	JNZ	MORNAM			;MORE OF NAME TO PRINT
	LDA	TTYPOS##		;GET CURRENT TTY POSIT
	ADI	13+6*0+9*0+2*0		;SPACE FOR NEXT NAME?
	MOV	D,A			;SAVE IN D
	LDA	LINLEN##		;GET LENGTH OF TERMINAL LINE
	CMP	D			;COMPRE TO CURRENT POSIT
	JC	NWFILN			;NEED TO FORCE CRLF
	MVI	A,' '			;TWO SPACES BETWEEN FILE NAMES
	CALL	OUTDO
	CALL	OUTDO
					;OR THREE
NWFILN:
	CC	CRDO			;TYPE CRLF
	LXI	D,FILNAM		;POINT AT FCB
	MVI	C,C.SEAR+1		;SEARCH FOR NEXT ENTRY
	CALL	CPMENT			;SEARCH FOR NEXT INCARNATION
	CPI	255			;NO MORE?
	JNZ	FILNXT			;MORE.
NWFIL2:
	POP	H			;RESTORE TEXT POINTER
	RET	

FILQS:	MOV	A,M			;GET CHAR
	CPI	'*'			;WILD CARD?
	RNZ				;NO, RETURN
FILQST:	MVI	M,'?'			;STORE QUESTION MARK
	INX	H			;BUMP POINTER
	DCR	C			;DECREMENT COUNT OF QMARKS
	JNZ	FILQST			;KEEP SAVING QMARKS
	RET	
					;Final cr/lf
					;SWFIL

	SUBTTL	DSKF FUNCTION


	SUBTTL	Miscellaneous Operating System I/O

ACCFIL:	PUSH	D			;Save FCB address
	MOV	C,A
	PUSH	B
	CALL	CPMENT
	POP	B
	POP	D
	PUSH	PSW
	LXI	H,0+FCB.RN		;Point to random record number
	DAD	D
	INR	M
	JNZ	ACCFL1
	INX	H
	INR	M
	JNZ	ACCFL1
	INX	H
	INR	M
ACCFL1:	MOV	A,C			;Get back CPM call code
	CPI	34			;Is it random write/
	JNZ	ACCFL2			;NO

	POP	PSW			;Get error code and map into 1.4 errors
	ORA	A
	RZ	
	CPI	5
	JZ	DERTMF			;Too many files
	CPI	3
	MVI	A,1			;Turn into I/O error
	RZ	
	INR	A			;DEFAULT TO DISK SPACE FULL (2)
	RET	

ACCFL2:	POP	PSW
	RET	



	SUBTTL	BASCOM O.S. Dependent Data Areas


	END	

                                                                                       