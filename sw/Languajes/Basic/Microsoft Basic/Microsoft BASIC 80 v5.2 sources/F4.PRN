MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	1
Common file for BASIC interpreter

                                	SUBTTL	Common file for BASIC interpreter
                                	.SALL	
                                
  000F                          CONTO	SET	15			;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
  0000                          DBLTRN	SET	0			;FOR DOUBLE PRECISION TRANSCENDENTALS
                                	IF2	
                                
                                	.PRINTX	/EXTENDED/
                                
                                
                                	.PRINTX	/LPT/
                                
                                	.PRINTX	/CPM DISK/
                                
                                
                                	.PRINTX	/Z80/
                                
                                	.PRINTX	/FAST/
                                
                                	.PRINTX	/5.0 FEATURES/
                                
                                	.PRINTX	/ANSI COMPATIBLE/
                                	ENDIF
                                
  000E                          CLMWID	SET	14			;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
  0080                          DATPSC	SET	128			;NUMBER OF DATA BYTES IN DISK SECTOR
  0050                          LINLN	SET	80			;TERMINAL LINE LENGTH 
  0084                          LPTLEN	SET	132
  00FF                          BUFLEN	SET	255			;LONG LINES
  0028                          NAMLEN	SET	40			;MAXIMUM LENGTH NAME -- 3 TO 127
                                
  001D                          NUMLEV	SET	0*20+19+2*5		;NUMBER OF STACK LEVELS RESERVED
                                					;BY AN EXPLICIT CALL TO GETSTK
                                
  0004                          STRSIZ	SET	4
                                
  0003                          STRSIZ	SET	3
  0003                          NUMTMP	SET	3			;NUMBER OF STRING TEMPORARIES
                                
  000A                          NUMTMP	SET	10
                                
  0003                          MD.RND	SET	3			;THE MODE NUMBER FOR RANDOM FILES
  0001                          MD.SQI	SET	1			;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
                                					;NEVER WRITTEN INTO A FILE
  0002                          MD.SQO	SET	2			;THE MODE FOR SEQUENTIAL OUTPUT FILES
                                					;AND PROGRAM FILES
  0000                          CPMWRM	SET	0			;CP/M WARM BOOT ADDR
  0005                          CPMENT	SET	CPMWRM+5		;CP/M BDOS CALL ADDR
  0000'                         	CSEG	
  0000                          TRUROM	SET	0
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	1-1
Common file for BASIC interpreter

                                
                                	TITLE	MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF
                                	SUBTTL	FLOATING POINT MATH PACKAGE CONFIGURATION
                                
  0024                          CURNCY	SET	44O			;USE DOLLAR SIGN AS DEFAULT
                                
                                	PUBLIC	RND,SIN,FOUT,INPRT,LINPRT
                                	PUBLIC	ZERO,FLOAT,FLOATR,MOVE,FADD,FADDS,FSUB,FMULT,FDIV,FIN
                                	EXTRN	INTXT,SNERR,BSERR,OVERR,MINPLS
                                	PUBLIC	NORMAL,UNPACK
                                	PUBLIC	PUSHF,ABS,INT,QINT,SGN,FCOMP,SIGNC,POPHRT
                                	PUBLIC	SQR
                                	PUBLIC	MOVFM,MOVMF,MOVFR,MOVRF,MOVRM,NEG,INRART,INXHRT
                                	EXTRN	CNSGET
                                	PUBLIC	UMULT,SIGNS
                                	PUBLIC	FPWR,EXP,LOG,COS,TAN,ATN,FONE
                                	PUBLIC	PUFOUT
                                	PUBLIC	VMOVMF,VMOVFM,FRCINT,FRCSNG,FRCDBL,VNEG,IADD
                                	PUBLIC	ISUB,IMULT,ICOMP,INEG,DADD,DSUB,DMULT,DDIV,DCOMP,VINT
                                	PUBLIC	VMOVE,VALINT,VALSNG,FRCSTR,CHKSTR,MAKINT,ISIGN
                                	PUBLIC	DCOMPD,DNORML,DINT
                                	PUBLIC	FDIVT,CONSIH,CONIA,VMOVFA,VMOVAF,GETBCD,VSIGN,VDFACS
                                
                                	PUBLIC	IMOD,IDIV
                                
                                	EXTRN	FANSII,OVERRI,STRPRN,FLGOVC
                                	EXTRN	TTYPOS
                                	EXTRN	DIVMSG,OVRMSG
                                	EXTRN	CALTTY
                                	EXTRN	FAC,FACLO,FBUFFR,MINUTK,PLUSTK,ERROR,FCERR
                                	EXTRN	CHRGTR,OUTDO,DV0ERR,STROUT
                                	PUBLIC	SIGN
                                	PUBLIC	SINCON,ATNCON
                                
                                	EXTRN	GETYPR
                                	EXTRN	DCOMPR,SYNCHR
                                	EXTRN	TMERR
                                	EXTRN	ERRFLG,DFACLO,ARG,ARGLO,VALTYP,TEMP2,TEMP3
                                
                                
                                
                                ;
                                ;	EXTERNAL LOCATIONS USED BY THE MATH-PACKAGE
                                ;	;THE FLOATING ACCUMULATOR
                                ;IFN	LENGTH&2,<
                                ;	BLOCK	1		;[TEMPORARY LEAST SIGNIFICANT BYTE]
                                ;DFACLO:	BLOCK	4>		;[FOUR LOWEST ORDERS FOR DOUBLE PRECISION]
                                ;FACLO:	BLOCK	3		;[LOW ORDER OF MANTISSA (LO)]
                                ;				;[MIDDLE ORDER OF MANTISSA (MO)]
                                ;				;[HIGH ORDER OF MANTISSA (HO)]
                                ;FAC:	BLOCK	2		;[EXPONENT]
                                ;				;[TEMPORARY COMPLEMENT OF SIGN IN MSB]
                                ;IFN	LENGTH&2,<
                                ;	BLOCK	1		;[TEMPORARY LEAST SIGNIFICANT BYTE]
                                ;ARGLO:	BLOCK	7		;[LOCATION OF SECOND ARGUMENT FOR DOUBLE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	1-2
FLOATING POINT MATH PACKAGE CONFIGURATION

                                ;ARG:	BLOCK	1>		; PRECISION]
                                ;FBUFFR:	BLOCK	^D13		;BUFFER FOR FOUT
                                ;IFN	LENGTH&2,<BLOCK	^D<35-13>>
                                ;
                                ;
                                ;THE FLOATING POINT FORMAT IS AS FOLLOWS:
                                ;
                                ;THE SIGN IS THE FIRST BIT OF THE MANTISSA
                                ;THE MANTISSA IS 24 BITS LONG
                                ;THE BINARY POINT IS TO THE LEFT OF THE MSB
                                ;NUMBER = MANTISSA * 2 ^ EXPONENT
                                ;THE MANTISSA IS POSITIVE, WITH A ONE ASSUMED TO BE WHERE THE SIGN BIT IS
                                ;THE SIGN OF THE EXPONENT IS THE FIRST BIT OF THE EXPONENT
                                ;THE EXPONENT IS STORED IN EXCESS 200 I.E. WITH A BIAS OF 200
                                ;SO, THE EXPONENT IS A SIGNED 8-BIT NUMBER WITH 200 ADDED TO IT
                                ;AN EXPONENT OF ZERO MEANS THE NUMBER IS ZERO, THE OTHER BYTES ARE IGNORED
                                ;TO KEEP THE SAME NUMBER IN THE FAC WHILE SHIFTING:
                                ;	TO SHIFT RIGHT,	EXP:=EXP+1
                                ;	TO SHIFT LEFT,	EXP:=EXP-1
                                ;
                                ;SO, IN MEMORY THE NUMBER LOOKS LIKE THIS:
                                ;	[BITS 17-24 OF THE MANTISSA]
                                ;	[BITS 9-16 OF THE MANTISSA]
                                ;	[THE SIGN IN BIT 7, BITS 2-8 OF THE MANTISSA ARE IN BITS 6-0]
                                ;	[THE EXPONENT AS A SIGNED NUMBER + 200]
                                ;(REMEMBER THAT BIT 1 OF THE MANTISSA IS ALWAYS A ONE)
                                ;
                                ;ARITHMETIC ROUTINE CALLING CONVENTIONS:
                                ;
                                ;FOR ONE ARGUMENT FUNCTIONS:
                                ;	THE ARGUMENT IS IN THE FAC, THE RESULT IS LEFT IN THE FAC
                                ;FOR TWO ARGUMENT OPERATIONS:
                                ;	THE FIRST ARGUMENT IS IN B,C,D,E I.E. THE "REGISTERS"
                                ;	THE SECOND ARGUMENT IS IN THE FAC
                                ;	THE RESULT IS LEFT IN THE FAC
                                ;
                                ;THE "S" ENTRY POINTS TO THE TWO ARGUMENT OPERATIONS HAVE (HL) POINTING TO
                                ;THE FIRST ARGUMENT INSTEAD OF THE FIRST ARGUMENT BEING IN THE REGISTERS.
                                ;MOVRM IS CALLED TO GET THE ARGUMENT IN THE REGISTERS.
                                ;THE "T" ENTRY POINTS ASSUME THE FIRST ARGUMENT IS ON THE STACK.
                                ;POPR IS USED TO GET THE ARGUMENT IN THE REGISTERS.
                                ;NOTE: THE "T" ENTRY POINTS SHOULD ALWAYS BE JUMPED TO AND NEVER CALLED
                                ;BECAUSE THE RETURN ADDRESS ON THE STACK WILL BE CONFUSED WITH THE NUMBER.
                                ;
                                ;ON THE STACK, THE TWO LO'S ARE PUSHED ON FIRST AND THEN THE HO AND SIGN.
                                ;THIS IS DONE SO IF A NUMBER IS STORED IN MEMORY, IT CAN BE PUSHED ON THE
                                ;STACK WITH TWO PUSHM'S.  THE LOWER BYTE OF EACH PART IS IN THE LOWER
                                ;MEMORY ADDRESS SO WHEN THE NUMBER IS POPPED INTO THE REGISTERS, THE HIGHER
                                ;ORDER BYTE WILL BE IN THE HIGHER ORDER REGISTER OF THE REGISTER PAIR, I.E.
                                ;THE HIGHER ORDER BYTE WILL BE POPPED INTO B, D OR H.
                                ;%
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	1-3
FLOATING POINT MATH PACKAGE CONFIGURATION

                                
                                
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2
FLOATING POINT ADDITION AND SUBTRACTION

                                	SUBTTL	FLOATING POINT ADDITION AND SUBTRACTION
                                					;ENTRY TO FADD WITH POINTER TO ARG IN (HL)
                                
                                	PUBLIC	FADDH
  0000'   21 10C9'              FADDH:	LXI	H,FHALF			;ENTRY TO ADD 1/2
  0003'   CD 0338'              FADDS:	CALL	MOVRM			;GET ARGUMENT INTO THE REGISTERS
  0006'   C3 000F'              	JMP	FADD			;DO THE ADDITION
                                
                                
                                					;SUBTRACTION	FAC:=ARG-FAC
  0009'   CD 0338'              FSUBS:	CALL	MOVRM			;ENTRY IF POINTER TO ARG IS IN (HL)
  000C'   CD 02F5'              FSUB:	CALL	NEG			;NEGATE SECOND ARGUMENT
                                					;FALL INTO FADD
                                
                                
                                					;ADDITION	FAC:=ARG+FAC
                                					;ALTERS A,B,C,D,E,H,L
                                ;*****************************************************************
                                ;IF INTFSW=1 THE FORMAT OF FLOATING POINT NUMBERS WILL BE:
                                ;REG B:SIGN AND BITS 1-7 OF EXPONENT,REG C:BIT 8 OF EXPONENT
                                ;AND BITS 2-8 OF MANTISSA,REG D:BITS 9-16 OF MANTISSA,
                                ;REG E:BITS 17-24 OF MANTISSA, AND LIKEWISE FOR THE FAC FORMAT
                                ;FURTHERMORE, THE EXPONENT FOR INTEL WILL BE BIAS 177 OCTAL
                                ;******************************************************************
  000F'   78                    FADD:	MOV	A,B			;CHECK IF FIRST ARGUMENT IS ZERO
  0010'   B7                    	ORA	A			;GET EXPONENT
  0011'   C8                    	RZ				;IT IS, RESULT IS NUMBER IN FAC
  0012'   3A 0000*              	LDA	FAC			;GET EXPONENT
  0015'   B7                    	ORA	A			;SEE IF THE NUMBER IS ZERO
  0016'   CA 032A'              	JZ	MOVFR			;IT IS, ANSWER IS IN REGISTERS
                                
                                ;WE WANT TO GET THE SMALLER NUMBER IN THE REGISTERS SO WE CAN SHIFT IT RIGHT
                                ;AND ALIGN THE BINARY POINTS OF THE TWO NUMBERS.  THEN WE CAN JUST ADD OR
                                ;SUBTRACT THEM (DEPENDING ON THEIR SIGNS) BYTEWISE.
  0019'   90                    	SUB	B			;CHECK RELATIVE SIZES
  001A'   D2 0029'              	JNC	FADD1			;IS FAC SMALLER?
  001D'   2F                    	CMA				;YES, NEGATE SHIFT COUNT
  001E'   3C                    	INR	A
  001F'   EB                    	XCHG				;SWITCH FAC AND REGISTERS, SAVE (DE)
  0020'   CD 031A'              	CALL	PUSHF			;PUT FAC ON STACK
  0023'   EB                    	XCHG				;GET (DE) BACK WHERE IT BELONGS
  0024'   CD 032A'              	CALL	MOVFR			;PUT REGISTERS IN THE FAC
  0027'   C1                    	POP	B
  0028'   D1                    	POP	D
                                					;GET THE OLD FAC IN THE REGISTERS
  0029'                         FADD1:
  0029'   FE 19                 	CPI	31O			;ARE WE WITHIN 24 BITS?
  002B'   D0                    	RNC	
  002C'   F5                    	PUSH	PSW			;SAVE SHIFT COUNT
  002D'   CD 0357'              	CALL	UNPACK			;UNPACK THE NUMBERS
  0030'   67                    	MOV	H,A			;SAVE SUBTRACTION FLAG
  0031'   F1                    	POP	PSW			;GET SHIFT COUNT BACK
  0032'   CD 00E9'              	CALL	SHIFTR			;SHIFT REGISTERS RIGHT THE RIGHT AMOUNT
                                
                                ;IF THE NUMBERS HAVE THE SAME SIGN, THEN WE ADD THEM.  IF THE SIGNS ARE
                                ;DIFFERENT, THEN WE HAVE TO SUBTRACT THEM.  WE HAVE TO DO THIS BECAUSE THE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-1
FLOATING POINT ADDITION AND SUBTRACTION

                                ;MANTISSAS ARE POSITIVE.  JUDGING BY THE EXPONENTS, THE LARGER NUMBER IS IN
                                ;THE FAC, SO IF WE SUBTRACT, THE SIGN OF THE RESULT SHOULD BE THE SIGN OF THE
                                ;FAC; HOWEVER, IF THE EXPONENTS ARE THE SAME, THE NUMBER IN THE REGISTERS
                                ;COULD BE BIGGER, SO AFTER WE SUBTRACT THEM, WE HAVE TO CHECK IF THE RESULT
                                ;WAS NEGATIVE.  IF IT WAS, WE NEGATE THE NUMBER IN THE REGISTERS AND
                                ;COMPLEMENT THE SIGN OF THE FAC.  (HERE THE FAC IS UNPACKED)
                                ;IF WE HAVE TO ADD THE NUMBERS, THE SIGN OF THE RESULT IS THE SIGN OF THE
                                ;FAC.  SO, IN EITHER CASE, WHEN WE ARE ALL DONE, THE SIGN OF THE RESULT
                                ;WILL BE THE SIGN OF THE FAC.
  0035'   7C                    	MOV	A,H			;GET SUBTRACTION FLAG
  0036'   B7                    	ORA	A
  0037'   21 0000*              	LXI	H,FACLO			;SET POINTER TO LO'S
  003A'   F2 0050'              	JP	FADD3			;SUBTRACT IF THE SIGNS WERE DIFFERENT
  003D'   CD 00C9'              	CALL	FADDA			;ADD THE NUMBERS
  0040'   D2 00AA'              	JNC	ROUND			;ROUND RESULT IF THERE WAS NO OVERFLOW
                                					;THE MOST IT CAN OVERFLOW IS ONE BIT
  0043'   23                    	INX	H			;THERE WAS OVERFLOW
  0044'   34                    	INR	M			;INCREMENT EXPONENT
  0045'   CA 0B19'              	JZ	OVFIN4
  0048'   2E 01                 	MVI	L,1			;SHIFT RESULT RIGHT ONE, SHIFT CARRY IN
  004A'   CD 0110'              	CALL	SHRADD
  004D'   C3 00AA'              	JMP	ROUND			;ROUND RESULT AND WE ARE DONE
                                					;HERE TO SUBTRACT C,D,E,B FROM ((HL)+0,1,2),0
  0050'   AF                    FADD3:	XRA	A			;SUBTRACT NUMBERS, NEGATE UNDERFLOW BYTE
  0051'   90                    	SUB	B
  0052'   47                    	MOV	B,A			;SAVE IT
  0053'   7E                    	MOV	A,M			;SUBTRACT LOW ORDERS
  0054'   9B                    	SBB	E
  0055'   5F                    	MOV	E,A
  0056'   23                    	INX	H			;UPDATE POINTER TO NEXT BYTE
  0057'   7E                    	MOV	A,M			;SUBTRACT MIDDLE ORDERS
  0058'   9A                    	SBB	D
  0059'   57                    	MOV	D,A
  005A'   23                    	INX	H			;UPDATE POINTER TO HIGH ORDERS
  005B'   7E                    	MOV	A,M			;SUBTRACT HIGH ORDERS
  005C'   99                    	SBB	C
  005D'   4F                    	MOV	C,A
                                					;BECAUSE WE WANT A POSITIVE MANTISSA, CHECK IF WE HAVE TO NEGATE THE
                                					; NUMBER
  005E'   DC 00D5'              FADFLT:	CC	NEGR			;ENTRY FROM FLOATR, INT: NEGATE NUMBER IF IT
                                					; WAS NEGATIVE, FALL INTO NORMALIZE
                                
                                
                                					;NORMALIZE C,D,E,B
                                					;ALTERS A,B,C,D,E,H,L
                                					;HERE WE SHIFT THE MANTISSA LEFT UNTIL THE MSB IS A ONE.
                                					;EXCEPT IN 4K, THE IDEA IS TO SHIFT LEFT BY 8 AS MANY TIMES AS
                                					;POSSIBLE.
  0061'                         NORMAL:
  0061'   68                    	MOV	L,B			;PUT LOWEST 2 BYTES IN (HL)
  0062'   63                    	MOV	H,E
  0063'   AF                    	XRA	A			;ZERO SHIFT COUNT
  0064'   47                    NORM1:	MOV	B,A			;SAVE SHIFT COUNT
  0065'   79                    	MOV	A,C			;DO WE HAVE 1 BYTE OF ZEROS
  0066'   B7                    	ORA	A
  0067'   C2 0095'              	JNZ	NORM3			;NO, SHIFT ONE PLACE AT A TIME
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-2
FLOATING POINT ADDITION AND SUBTRACTION

                                					;THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
  006A'   4A                    	MOV	C,D			;YES, SHIFT OVER 1 BYTE
  006B'   54                    	MOV	D,H
  006C'   65                    	MOV	H,L
  006D'   6F                    	MOV	L,A			;SHIFT IN 8 ZEROS FOR THE LOW ORDER
  006E'   78                    	MOV	A,B			;UPDATE SHIFT COUNT
  006F'   D6 08                 	SUI	10O
  0071'   FE E0                 	CPI	340O			;DID WE SHIFT IN 4 BYTES OF ZEROS?
  0073'   C2 0064'              	JNZ	NORM1			;NO, TRY TO SHIFT OVER 8 MORE
                                					;YES, NUMBER WAS ZERO.  FALL INTO ZERO
                                
                                
                                					;ZERO FAC
                                					;ALTERS A ONLY
                                					;EXITS WITH A=0
                                					;BY OUR FLOATING POINT FORMAT, THE NUMBER IS ZERO IF THE EXPONENT IS
                                					; ZERO
  0076'   AF                    ZERO:	XRA	A			;ZERO A
  0077'   32 0000*              ZERO0:	STA	FAC			;ZERO THE FAC'S EXPONENT, ENTRY IF A=0
  007A'   C9                    	RET				;ALL DONE
                                
                                
  007B'                         NORM2:
  007B'   7C                    	MOV	A,H			;CHECK FOR CASE OF NORMALIZING A SMALL INT
  007C'   B5                    	ORA	L
  007D'   B2                    	ORA	D
  007E'   C2 008D'              	JNZ	NORM2U			;DO USUAL THING
  0081'   79                    	MOV	A,C			;GET BYTE TO SHIFT
  0082'   05                    NORM2F:	DCR	B			;DECRMENT SHIFT COUNT
  0083'   17                    	RAL				;SHIFT LEFT
  0084'   D2 0082'              	JNC	NORM2F			;NORMALIZE LIKE SOB
  0087'   04                    	INR	B			;CORRECT SHIFT COUNT
  0088'   1F                    	RAR				;WE DID IT ONE TOO MANY TIMES
  0089'   4F                    	MOV	C,A			;RESULT TO [C]
  008A'   C3 0098'              	JMP	NORM3A			;ALL DONE
  008D'   05                    NORM2U:	DCR	B			;DECREMENT SHIFT COUNT
  008E'   29                    	DAD	H			;ROTATE (HL) LEFT ONE, SHIFT IN A ZERO
  008F'   7A                    	MOV	A,D			;ROTATE NEXT HIGHER ORDER LEFT ONE
  0090'   17                    	RAL	
  0091'   57                    	MOV	D,A
  0092'   79                    	MOV	A,C			;ROTATE HIGH ORDER LEFT ONE
  0093'   8F                    	ADC	A			;SET CONDITION CODES
  0094'   4F                    	MOV	C,A
  0095'   F2 007B'              NORM3:	JP	NORM2			;WE HAVE MORE NORMALIZATION TO DO
  0098'   78                    NORM3A:	MOV	A,B			;ALL NORMALIZED, GET SHIFT COUNT
  0099'   5C                    	MOV	E,H			;PUT LO'S BACK IN E,B
  009A'   45                    	MOV	B,L
  009B'   B7                    	ORA	A			;CHECK IF WE DID NO SHIFTING
  009C'   CA 00AA'              	JZ	ROUND
  009F'   21 0000*              	LXI	H,FAC			;LOOK AT FAC'S EXPONENT
  00A2'   86                    	ADD	M			;UPDATE EXPONENT
  00A3'   77                    	MOV	M,A
  00A4'   D2 0076'              	JNC	ZERO			;CHECK FOR UNDERFLOW
  00A7'   CA 0076'              	JZ	ZERO			;NUMBER IS ZERO, ALL DONE
                                					;FALL INTO ROUND AND WE ARE DONE
                                
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-3
FLOATING POINT ADDITION AND SUBTRACTION

                                
                                					;ROUND RESULT IN C,D,E,B AND PUT NUMBER IN THE FAC
                                					;ALTERS A,B,C,D,E,H,L
                                					;WE ROUND C,D,E UP OR DOWN DEPENDING UPON THE MSB OF B
  00AA'   78                    ROUND:	MOV	A,B			;SEE IF WE SHOULD ROUND UP
  00AB'   21 0000*              ROUNDB:	LXI	H,FAC			;ENTRY FROM FDIV, GET POINTER TO EXPONENT
                                
                                					;INTEL FLOATING SOFTWARE FLAG
  00AE'   B7                    	ORA	A
  00AF'   FC 00BC'              	CM	ROUNDA			;DO IT IF NECESSARY
  00B2'   46                    	MOV	B,M			;PUT EXPONENT IN B
                                					;HERE WE PACK THE HO AND SIGN
  00B3'   23                    	INX	H			;POINT TO SIGN
  00B4'   7E                    	MOV	A,M			;GET SIGN
  00B5'   E6 80                 	ANI	200O			;GET RID OF UNWANTED BITS
  00B7'   A9                    	XRA	C			;PACK SIGN AND HO
  00B8'   4F                    	MOV	C,A			;SAVE IT IN C
  00B9'   C3 032A'              	JMP	MOVFR			;SAVE NUMBER IN FAC
                                
                                
                                
                                
                                					;SUBROUTNE FOR ROUND:  ADD ONE TO C,D,E
  00BC'   1C                    ROUNDA:	INR	E			;ADD ONE TO THE LOW ORDER, ENTRY FROM QINT
  00BD'   C0                    	RNZ				;ALL DONE IF IT IS NOT ZERO
  00BE'   14                    	INR	D			;ADD ONE TO NEXT HIGHER ORDER
  00BF'   C0                    	RNZ				;ALL DONE IF NO OVERFLOW
  00C0'   0C                    	INR	C			;ADD ONE TO THE HIGHEST ORDER
  00C1'   C0                    	RNZ				;RETURN IF NO OVEFLOW
  00C2'   0E 80                 	MVI	C,200O			;THE NUMBER OVERFLOWED, SET NEW HIGH ORDER
  00C4'   34                    	INR	M			;UPDATE EXPONENT
  00C5'   C0                    	RNZ				;RETURN IF IT DID NOT OVERFLOW
  00C6'   C3 0B18'              	JMP	OVFIN8			;OVERFLOW AND CONTINUE
                                
                                
                                
                                					;ADD (HL)+2,1,0 TO C,D,E
                                					;THIS CODE IS USED BY FADD, FOUT
  00C9'   7E                    FADDA:	MOV	A,M			;GET LOWEST ORDER
  00CA'   83                    	ADD	E			;ADD IN OTHER LOWEST ORDER
  00CB'   5F                    	MOV	E,A			;SAVE IT
  00CC'   23                    	INX	H			;UPDATE POINTER TO NEXT BYTE
  00CD'   7E                    	MOV	A,M			;ADD MIDDLE ORDERS
  00CE'   8A                    	ADC	D
  00CF'   57                    	MOV	D,A
  00D0'   23                    	INX	H			;UPDATE POINTER TO HIGH ORDER
  00D1'   7E                    	MOV	A,M			;ADD HIGH ORDERS
  00D2'   89                    	ADC	C
  00D3'   4F                    	MOV	C,A
  00D4'   C9                    	RET				;ALL DONE
                                
                                
                                					;NEGATE NUMBER IN C,D,E,B
                                					;THIS CODE IS USED BY FADD, QINT
                                					;ALTERS A,B,C,D,E,L
  00D5'   21 0001*              NEGR:	LXI	H,FAC+1			;NEGATE FAC
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-4
FLOATING POINT ADDITION AND SUBTRACTION

  00D8'   7E                    	MOV	A,M			;GET SIGN
  00D9'   2F                    	CMA				;COMPLEMENT IT
  00DA'   77                    	MOV	M,A			;SAVE IT AGAIN
  00DB'   AF                    	XRA	A			;ZERO A
  00DC'   6F                    	MOV	L,A			;SAVE ZERO IN L
  00DD'   90                    	SUB	B			;NEGATE LOWEST ORDER
  00DE'   47                    	MOV	B,A			;SAVE IT
  00DF'   7D                    	MOV	A,L			;GET A ZERO
  00E0'   9B                    	SBB	E			;NEGATE NEXT HIGHEST ORDER
  00E1'   5F                    	MOV	E,A			;SAVE IT
  00E2'   7D                    	MOV	A,L			;GET A ZERO
  00E3'   9A                    	SBB	D			;NEGATE NEXT HIGHEST ORDER
  00E4'   57                    	MOV	D,A			;SAVE IT
  00E5'   7D                    	MOV	A,L			;GET ZERO BACK
  00E6'   99                    	SBB	C			;NEGATE HIGHEST ORDER
  00E7'   4F                    	MOV	C,A			;SAVE IT
  00E8'   C9                    	RET				;ALL DONE
                                
                                
                                					;SHIFT C,D,E RIGHT
                                					;A = SHIFT COUNT
                                					;ALTERS A,B,C,D,E,L
                                					;THE IDEA (EXCEPT IN 4K) IS TO SHIFT RIGHT 8 PLACES AS MANY TIMES AS
                                					; POSSIBLE
  00E9'   06 00                 SHIFTR:	MVI	B,0			;ZERO OVERFLOW BYTE
  00EB'   D6 08                 SHFTR1:	SUI	10O			;CAN WE SHIFT IT 8 RIGHT?
  00ED'   DA 00F8'              	JC	SHFTR2			;NO, SHIFT IT ONE PLACE AT A TIME
                                					;THIS LOOP SPEEDS THINGS UP BY SHIFTING 8 PLACES AT ONE TIME
  00F0'   43                    	MOV	B,E			;SHIFT NUMBER 1 BYTE RIGHT
  00F1'   5A                    	MOV	E,D
  00F2'   51                    	MOV	D,C
  00F3'   0E 00                 	MVI	C,0			;PUT 0 IN HO
  00F5'   C3 00EB'              	JMP	SHFTR1			;TRY TO SHIFT 8 RIGHT AGAIN
  00F8'   C6 09                 SHFTR2:	ADI	11O			;CORRECT SHIFT COUNT
  00FA'   6F                    	MOV	L,A			;SAVE SHIFT COUNT
                                ;TEST FOR CASE (VERY COMMON) WHERE SHIFTING SMALL INTEGER RIGHT.
                                ;THIS HAPPENS IN FOR LOOPS, ETC.
  00FB'   7A                    	MOV	A,D			;SEE IF THREE LOWS ARE ZERO.
  00FC'   B3                    	ORA	E
  00FD'   B0                    	ORA	B
  00FE'   C2 010C'              	JNZ	SHFTR3			;IF SO, DO USUAL.
  0101'   79                    	MOV	A,C			;GET HIGH BYTE TO SHIFT
  0102'   2D                    SHFTRF:	DCR	L			;DONE SHIFTING?
  0103'   C8                    	RZ				;YES, DONE
  0104'   1F                    	RAR				;ROTATE ONE RIGHT
  0105'   4F                    	MOV	C,A			;SAVE RESULT
  0106'   D2 0102'              	JNC	SHFTRF			;ZAP BACK AND DO NEXT ONE IF NONE
  0109'   C3 0112'              	JMP	SHFTC			;CONTINUE SHIFTING
  010C'   AF                    SHFTR3:	XRA	A			;CLEAR CARRY
  010D'   2D                    	DCR	L			;ARE WE DONE SHIFTING?
  010E'   C8                    	RZ				;RETURN IF WE ARE
  010F'   79                    	MOV	A,C			;GET HO
  0110'   1F                    SHRADD:	RAR				;ENTRY FROM FADD, SHIFT IT RIGHT
  0111'   4F                    	MOV	C,A			;SAVE IT
  0112'   7A                    SHFTC:	MOV	A,D			;SHIFT NEXT BYTE RIGHT
  0113'   1F                    	RAR	
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-5
FLOATING POINT ADDITION AND SUBTRACTION

  0114'   57                    	MOV	D,A
  0115'   7B                    	MOV	A,E			;SHIFT LOW ORDER RIGHT
  0116'   1F                    	RAR	
  0117'   5F                    	MOV	E,A
  0118'   78                    	MOV	A,B			;SHIFT OVERFLOW BYTE RIGHT
  0119'   1F                    	RAR	
  011A'   47                    	MOV	B,A
  011B'   C3 010C'              	JMP	SHFTR3			;SEE IF WE ARE DONE
                                
                                
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-6
FLOATING POINT ADDITION AND SUBTRACTION

                                
                                	SUBTTL	NATURAL LOG FUNCTION
                                					;CALCULATION IS BY:
                                					; LN(F*2^N)=(N+LOG2(F))*LN(2)
                                					;AN APPROXIMATION POLYNOMIAL IS USED TO CALCULATE LOG2(F)
                                
                                					;CONSTANTS USED BY LOG
  011E'   00                    FONE:	DB	000			; 1
  011F'   00                    	DB	000
  0120'   00                    	DB	000
  0121'   81                    	DB	201O
  0122'   04                    LOGP:	DB	004			;HART 2524 COEFFICIENTS
  0123'   9A                    	DB	232O			;4.8114746
  0124'   F7                    	DB	367O
  0125'   19                    	DB	031O
  0126'   83                    	DB	203O
  0127'   24                    	DB	044O			;6.105852
  0128'   63                    	DB	143O
  0129'   43                    	DB	103O
  012A'   83                    	DB	203O
  012B'   75                    	DB	165O			;-8.86266
  012C'   CD                    	DB	315O
  012D'   8D                    	DB	215O
  012E'   84                    	DB	204O
  012F'   A9                    	DB	251O			;-2.054667
  0130'   7F                    	DB	177O
  0131'   83                    	DB	203O
  0132'   82                    	DB	202O
  0133'   04                    LOGQ:	DB	004
  0134'   00                    	DB	000			;1.0
  0135'   00                    	DB	000
  0136'   00                    	DB	000
  0137'   81                    	DB	201O
  0138'   E2                    	DB	342O			;6.427842
  0139'   B0                    	DB	260O
  013A'   4D                    	DB	115O
  013B'   83                    	DB	203O
  013C'   0A                    	DB	012O			;4.545171
  013D'   72                    	DB	162O
  013E'   11                    	DB	021O
  013F'   83                    	DB	203O
  0140'   F4                    	DB	364O			;.3535534
  0141'   04                    	DB	004
  0142'   35                    	DB	065O
  0143'   7F                    	DB	177O
                                
  0144'   CD 02C6'              LOG:	CALL	SIGN			;CHECK FOR A NEGATIVE OR ZERO ARGUMENT
  0147'   B7                    	ORA	A			;SET CC'S PROPERLY
  0148'   EA 0000*              	JPE	FCERR			;FAC .LE. 0, BLOW HIM OUT OF THE WATER
                                					;FSIGN ONLY RETURNS 0,1 OR 377 IN A
                                					;THE PARITY WILL BE EVEN IF A HAS 0 OR 377
                                
  014B'   CD 0157'              	CALL	LOG2			;
  014E'   01 8031               	LXI	B,200Q*256+061Q
  0151'   11 7218               	LXI	D,162Q*256+030Q		;GET LN(2)
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-7
NATURAL LOG FUNCTION

  0154'   C3 018A'              	JMP	FMULT			;COMPLETE LOG CALCULATION
  0157'                         LOG2:					;USE HART 2524 CALCULATION
  0157'   CD 0335'              	CALL	MOVRF			;MOVE FAC TO REGISTERS TOO
  015A'   3E 80                 	MVI	A,200O			;
  015C'   32 0000*              	STA	FAC			;ZERO THE EXPONENT
  015F'   A8                    	XRA	B			;REMOVE 200 EXCESS FROM X
  0160'   F5                    	PUSH	PSW			;SAVE EXPONENT
  0161'   CD 031A'              	CALL	PUSHF			;SAVE THE FAC (X)
  0164'   21 0122'              	LXI	H,LOGP			;POINT TO P CONSTANTS
  0167'   CD 1256'              	CALL	POLY			;CALCULATE P(X)
  016A'   C1                    	POP	B			;FETCH X
  016B'   E1                    	POP	H			;PUSHF WOULD ALTER DE
  016C'   CD 031A'              	CALL	PUSHF			;PUSH P(X) ON THE STACK
  016F'   EB                    	XCHG				;GET LOW BYTES OF X TO (DE)
  0170'   CD 032A'              	CALL	MOVFR			;AND MOVE TO FAC
  0173'   21 0133'              	LXI	H,LOGQ			;POINT TO Q COEFFICIENTS
  0176'   CD 1256'              	CALL	POLY			;COMPUTE Q(X)
  0179'   C1                    	POP	B			;FETCH P(X) TO REGISTERS
  017A'   D1                    	POP	D
  017B'   CD 01F0'              	CALL	FDIV			;CALCULATE P(X)/Q(X)
  017E'   F1                    	POP	PSW			;RE-FETCH EXPONENT
  017F'   CD 031A'              	CALL	PUSHF			;SAVE EVALUATION
  0182'   CD 02D5'              	CALL	FLOAT			;FLOAT THE EXPONENT
  0185'   C1                    	POP	B
  0186'   D1                    	POP	D
                                					;GET EVAL. BACK
  0187'   C3 000F'              	JMP	FADD
                                
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-8
NATURAL LOG FUNCTION

                                
                                ;	JMP	FMULT		;MULTIPLY BY LN(2)
                                	SUBTTL	FLOATING MULTIPLICATION AND DIVISION
                                					;MULTIPLICATION		FAC:=ARG*FAC
                                					;ALTERS A,B,C,D,E,H,L
  018A'   CD 02C6'              FMULT:	CALL	SIGN			;CHECK IF FAC IS ZERO
  018D'   C8                    	RZ				;IF IT IS, RESULT IS ZERO
  018E'   2E 00                 	MVI	L,0			;ADD THE TWO EXPONENTS, L IS A FLAG
  0190'   CD 0284'              	CALL	MULDIV			;FIX UP THE EXPONENTS
                                					;SAVE THE NUMBER IN THE REGISTERS SO WE CAN ADD IT FAST
  0193'   79                    	MOV	A,C			;GET HO
  0194'   32 01C3'              	STA	FMULTA+1		;STORE HO OF REGISTERS
  0197'   EB                    	XCHG				;STORE THE TWO LO'S OF THE REGISTERS
  0198'   22 01BE'              	SHLD	FMULTB+1
  019B'   01 0000               	LXI	B,0			;ZERO THE PRODUCT REGISTERS
  019E'   50                    	MOV	D,B
  019F'   58                    	MOV	E,B
  01A0'   21 0061'              	LXI	H,NORMAL
  01A3'   E5                    	PUSH	H			; ON THE STACK
  01A4'   21 01AC'              	LXI	H,FMULT2		;PUT FMULT2 ON THE STACK TWICE, SO AFTER
  01A7'   E5                    	PUSH	H			; WE MULTIPLY BY THE LO BYTE, WE WILL
  01A8'   E5                    	PUSH	H			; MULTIPLY BY THE MO AND HO
  01A9'   21 0000*              	LXI	H,FACLO			;GET ADDRESS OF LO OF FAC
  01AC'   7E                    FMULT2:	MOV	A,M			;GET BYTE TO MULTIPLY BY
  01AD'   23                    	INX	H			;MOVE POINTER TO NEXT BYTE
  01AE'   B7                    	ORA	A
  01AF'   CA 01E0'              	JZ	FMULT3			;ARE WE MULTIPLYING BY ZERO?
  01B2'   E5                    	PUSH	H			;SAVE POINTER
  01B3'   EB                    	XCHG				;GET LO'S IN (HL)
  01B4'   1E 08                 	MVI	E,10O			;SET UP A COUNT
                                
                                ;THE PRODUCT WILL BE FORMED IN C,D,E,B. THIS WILL BE IN C,H,L,B PART OF THE
                                ;TIME IN ORDER TO USE THE "DAD" INSTRUCTION.  AT FMULT2, WE GET THE NEXT
                                ;BYTE OF THE MANTISSA IN THE FAC TO MULTIPLY BY.  ((HL) POINTS TO IT)
                                ;(THE FMULT2 SUBROUTINE PRESERVES (HL))  IN 8K, IF THE BYTE IS ZERO, WE JUST
                                ;SHIFT THE PRODUCT 8 RIGHT.  THIS BYTE IS THEN SHIFTED RIGHT AND SAVED IN D
                                ;(H IN 4K).  THE CARRY DETERMINES IF WE SHOULD ADD IN THE SECOND FACTOR
                                ;IF WE DO, WE ADD IT TO C,H,L.  B IS ONLY USED TO DETERMINE WHICH WAY WE
                                ;ROUND.  WE THEN SHIFT C,H,L,B (C,D,E,B) IN 4K RIGHT ONE TO GET READY FOR THE
                                ;NEXT TIME THROUGH THE LOOP.  NOTE THAT THE CARRY IS SHIFTED INTO THE MSB OF
                                ;C.  E HAS A COUNT (L IN 4K) TO DETERMINE WHEN WE HAVE LOOKED AT ALL THE BITS
                                ;OF D (H IN 4K).
  01B6'   1F                    FMULT4:	RAR				;ROTATE BYTE RIGHT
  01B7'   57                    	MOV	D,A			;SAVE IT
  01B8'   79                    	MOV	A,C			;GET HO
  01B9'   D2 01C4'              	JNC	FMULT5			;DON'T ADD IN NUMBER IF BIT WAS ZERO
  01BC'   D5                    	PUSH	D			;SAVE COUNTERS
  01BD'   11 0000               FMULTB:	LXI	D,0			;GET LO'S OF NUMBER TO ADD, THIS IS SET ABOVE
  01C0'   19                    	DAD	D			;ADD THEM IN
  01C1'   D1                    	POP	D			;GET COUNTERS BACK
  01C2'   CE 00                 FMULTA:	ACI	0			;ADD IN HO, THIS IS SET UP ABOVE
  01C4'   1F                    FMULT5:	RAR				;ROTATE RESULT RIGHT ONE
  01C5'   4F                    	MOV	C,A
  01C6'   7C                    	MOV	A,H			;ROTATE NEXT BYTE
  01C7'   1F                    	RAR	
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-9
FLOATING MULTIPLICATION AND DIVISION

  01C8'   67                    	MOV	H,A
  01C9'   7D                    	MOV	A,L			;ROTATE NEXT LOWER ORDER
  01CA'   1F                    	RAR	
  01CB'   6F                    	MOV	L,A
  01CC'   78                    	MOV	A,B			;ROTATE LO
  01CD'   1F                    	RAR	
  01CE'   47                    	MOV	B,A
  01CF'   E6 10                 	ANI	20O			;SEE IF WE ROTATED THRU ST
  01D1'   CA 01D8'              	JZ	FML5B1			;IF NOT DON'T WORRY
  01D4'   78                    	MOV	A,B			;RE FETCH LO
  01D5'   F6 20                 	ORI	40O			;"OR" IN STICKY
  01D7'   47                    	MOV	B,A			;BACK TO LO
  01D8'                         FML5B1:
  01D8'                         FMLT5B:
  01D8'   1D                    	DCR	E			;ARE WE DONE?
  01D9'   7A                    	MOV	A,D			;GET NUMBER WE ARE MULTIPLYING BY
  01DA'   C2 01B6'              	JNZ	FMULT4			;MULTIPLY AGAIN IF WE ARE NOT DONE
  01DD'   EB                    	XCHG				;GET LO'S IN (DE)
  01DE'   E1                    POPHRT:	POP	H			;GET POINTER TO NUMBER TO MULTIPLY BY
  01DF'   C9                    	RET				;ALL DONE
  01E0'   43                    FMULT3:	MOV	B,E			;MULTIPLY BY ZERO: SHIFT EVERYTHING 8 RIGHT
  01E1'   5A                    	MOV	E,D
  01E2'   51                    	MOV	D,C
  01E3'   4F                    	MOV	C,A			;SHIFT IN 8 ZEROS ON THE LEFT
  01E4'   C9                    	RET				;ALL DONE
                                
                                
                                					;DIVIDE FAC BY 10
                                					;ALTERS A,B,C,D,E,H,L
  01E5'   CD 031A'              DIV10:	CALL	PUSHF			;SAVE NUMBER
  01E8'   21 082F'              	LXI	H,FTEN			;GET POINTER TO THE CONSTANT '10'
  01EB'   CD 0327'              	CALL	MOVFM			;MOVE TEN INTO THE FAC
  01EE'   C1                    FDIVT:	POP	B
  01EF'   D1                    	POP	D
                                					;GET NUMBER BACK IN REGISTERS
                                					;FALL INTO DIVIDE AND WE ARE DONE
                                
                                
                                					;DIVISION	FAC:=ARG/FAC
                                					;ALTERS A,B,C,D,E,H,L
  01F0'   CD 02C6'              FDIV:	CALL	SIGN			;CHECK FOR DIVISION BY ZERO
  01F3'   CA 0B21'              	JZ	INTDV1			;DON'T ALLOW DIVIDE BY ZERO
  01F6'   2E FF                 	MVI	L,377O			;SUBTRACT THE TWO EXPONENTS, L IS A FLAG
  01F8'   CD 0284'              	CALL	MULDIV			;FIX UP THE EXPONENTS AND THINGS
  01FB'   34                    	INR	M
  01FC'   34                    	INR	M
                                					;HERE WE SAVE THE FAC IN MEMORY SO WE CAN SUBTRACT IT FROM THE NUMBER
                                					;IN THE REGISTERS QUICKLY.
  01FD'   2B                    	DCX	H			;POINT TO HO
  01FE'   7E                    	MOV	A,M			;GET HO
  01FF'   32 0221'              	STA	FDIVA+1			;SAVE IT
  0202'   2B                    	DCX	H			;SAVE MIDDLE ORDER
  0203'   7E                    	MOV	A,M
  0204'   32 021D'              	STA	FDIVB+1			;PUT IT WHERE NOTHING WILL HURT IT
  0207'   2B                    	DCX	H			;SAVE LO
  0208'   7E                    	MOV	A,M
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-10
FLOATING MULTIPLICATION AND DIVISION

  0209'   32 0219'              	STA	FDIVC+1
                                
                                ;THE NUMERATOR WILL BE KEPT IN B,H,L.  THE QUOTIENT WILL BE FORMED IN C,D,E.
                                ;TO GET A BIT OF THE QUOTIENT, WE FIRST SAVE B,H,L ON THE STACK, THEN
                                ;SUBTRACT THE DENOMINATOR THAT WE SAVED IN MEMORY.  THE CARRY INDICATES
                                ;WHETHER OR NOT B,H,L WAS BIGGER THAN THE DENOMINATOR.  IF B,H,L WAS BIGGER,
                                ;THE NEXT BIT OF THE QUOTIENT IS A ONE.  TO GET THE OLD B,H,L OFF THE STACK,
                                ;WE POP THEM INTO THE PSW.  IF THE DENOMINATOR WAS BIGGER, THE NEXT BIT OF
                                ;THE QUOTIENT IS ZERO, AND WE GET THE OLD B,H,L BACK BY POPPING IT OFF THE
                                ;STACK.  WE HAVE TO KEEP AN EXTRA BIT OF THE QUOTIENT IN FDIVG+1 IN CASE THE
                                ;DENOMINATOR WAS BIGGER,  THEN B,H,L WILL GET SHIFTED LEFT.  IF THE MSB  OF
                                ;B WAS ONE, IT HAS TO BE STORED SOMEWHERE, SO WE STORE IT IN FDIVG+1.  THEN
                                ;THE NEXT TIME THROUGH THE LOOP B,H,L WILL LOOK BIGGER BECAUSE IT HAS AN
                                ;EXTRA HO BIT IN FDIVG+1. WE ARE DONE DIVIDING WHEN THE MSB OF C IS A ONE.
                                ;THIS OCCURS WHEN WE HAVE CALCULATED 24 BITS OF THE QUOTIENT.  WHEN WE JUMP
                                ;TO ROUND, THE 25TH BIT OF THE QUOTIENT DETERMINES WHETHER WE ROUND OR NOT.
                                ;IT IS IN THE MSB OF A.  IF INITIALLY THE DENOMINATOR IS BIGGER THAN THE
                                ;NUMERATOR, THE FIRST BIT OF THE QUOTIENT WILL BE ZERO.  THIS MEANS WE
                                ;WILL GO THROUGH THE DIVIDE LOOP 26 TIMES, SINCE IT STOPS ON THE 25TH BIT
                                ;AFTER THE FIRST NON-ZERO BIT OF THE QUOTIENT.  SO, THIS QUOTIENT WILL LOOK
                                ;SHIFTED LEFT ONE FROM THE QUOTIENT OF TWO NUMBERS IN WHICH THE NUMERATOR IS
                                ;BIGGER.  THIS CAN ONLY OCCUR ON THE FIRST TIME THROUGH THE LOOP, SO C,D,E
                                ;ARE ALL ZERO.  SO, IF WE FINISH THE LOOP AND C,D,E ARE ALL ZERO, THEN WE
                                ;MUST DECREMENT THE EXPONENT TO CORRECT FOR THIS.
  020C'   41                    	MOV	B,C			;GET NUMBER IN B,H,L
  020D'   EB                    	XCHG	
  020E'   AF                    	XRA	A			;ZERO C,D,E AND HIGHEST ORDER
  020F'   4F                    	MOV	C,A
  0210'   57                    	MOV	D,A
  0211'   5F                    	MOV	E,A
  0212'   32 0224'              	STA	FDIVG+1
  0215'   E5                    FDIV1:	PUSH	H			;SAVE LO'S OF NUMBER
  0216'   C5                    	PUSH	B			;SAVE HO OF NUMBER
  0217'   7D                    	MOV	A,L			;SUBTRACT NUMBER THAT WAS IN FAC
  0218'   D6 00                 FDIVC:	SUI	0			;SUBTRACT LO
  021A'   6F                    	MOV	L,A			;SAVE IT
  021B'   7C                    	MOV	A,H			;SUBTRACT MIDDLE ORDER
  021C'   DE 00                 FDIVB:	SBI	0
  021E'   67                    	MOV	H,A
  021F'   78                    	MOV	A,B			;SUBTRACT HO
  0220'   DE 00                 FDIVA:	SBI	0
  0222'   47                    	MOV	B,A
  0223'   3E 00                 FDIVG:	MVI	A,0			;GET HIGHEST ORDER
                                					;WE COULD DO THIS WITH NO CODE IN RAM, BUT
                                					; IT WOULD BE MUCH SLOWER.
  0225'   DE 00                 	SBI	0			;SUBTRACT THE CARRY FROM IT
  0227'   3F                    	CMC				;SET CARRY TO CORESPOND TO NEXT QUOTIENT BIT
  0228'   D2 0232'              	JNC	FDIV2			;GET OLD NUMBER BACK IF WE SUBTRACTED TOO MUCH
  022B'   32 0224'              	STA	FDIVG+1			;UPDATE HIGHEST ORDER
  022E'   F1                    	POP	PSW			;THE SUBTRACTION WAS GOOD
  022F'   F1                    	POP	PSW			;GET PREVIOUS NUMBER OFF STACK
  0230'   37                    	STC				;NEXT BIT IN QUOTIENT IS A ONE
  0231'   D2                    	DB	322O			;"JNC" AROUND NEXT 2 BYTES
  0232'   C1                    FDIV2:	POP	B			;WE SUBTRACTED TOO MUCH
  0233'   E1                    	POP	H			;GET OLD NUMBER BACK
  0234'   79                    	MOV	A,C			;ARE WE DONE?
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-11
FLOATING MULTIPLICATION AND DIVISION

  0235'   3C                    	INR	A			;SET SIGN FLAG WITHOUT AFFECTING CARRY
  0236'   3D                    	DCR	A
  0237'   1F                    	RAR				;PUT CARRY IN MSB
  0238'   F2 0250'              	JP	DIV2A			;NOT READY TO ROUND YET
  023B'   17                    	RAL				;BIT BACK TO CARRY
  023C'   3A 0224'              	LDA	FDIVG+1			;FETCH EXTRA BIT
  023F'   1F                    	RAR				;BOTH NOW IN A
  0240'   E6 C0                 	ANI	300O			;CLEAR SUPERFLUOUS BITS
  0242'   F5                    	PUSH	PSW			;SAVE FOR LATER
  0243'   78                    	MOV	A,B			;FETCH HO OF REMAINDER
  0244'   B4                    	ORA	H			;FETCH HO
  0245'   B5                    	ORA	L			;SEE IF OTHER REMAINDER BITS
                                					;AND IF SO SET ST
  0246'   CA 024B'              	JZ	DIV2AA			;IF NOT IGNORE
  0249'   3E 20                 	MVI	A,40O			;ST BIT
  024B'   E1                    DIV2AA:	POP	H			;AND THE REST OF REMAINDER
  024C'   B4                    	ORA	H			;"OR" IN REST
  024D'   C3 00AB'              	JMP	ROUNDB			;USE REMAINDER
  0250'                         DIV2A:
  0250'   17                    	RAL				;WE AREN'T, GET OLD CARRY BACK
  0251'   7B                    	MOV	A,E			;ROTATE EVERYTHING LEFT ONE
  0252'   17                    	RAL				;ROTATE NEXT BIT OF QUOTIENT IN
  0253'   5F                    	MOV	E,A
  0254'   7A                    	MOV	A,D
  0255'   17                    	RAL	
  0256'   57                    	MOV	D,A
  0257'   79                    	MOV	A,C
  0258'   17                    	RAL	
  0259'   4F                    	MOV	C,A
  025A'   29                    	DAD	H			;ROTATE A ZERO INTO RIGHT END OF NUMBER
  025B'   78                    	MOV	A,B			;THE HO BYTE, FINALLY!
  025C'   17                    FDIV2A:	RAL	
  025D'   47                    	MOV	B,A
  025E'   3A 0224'              FDIV2B:	LDA	FDIVG+1			;ROTATE THE HIGHEST ORDER
  0261'   17                    	RAL	
  0262'   32 0224'              	STA	FDIVG+1
  0265'   79                    	MOV	A,C			;ADD ONE TO EXPONENT IF THE FIRST SUBTRACTION
  0266'   B2                    	ORA	D			; DID NOT WORK
  0267'   B3                    	ORA	E
  0268'   C2 0215'              	JNZ	FDIV1			;THIS ISN'T THE CASE
  026B'   E5                    	PUSH	H			;SAVE PART OF NUMBER
  026C'   21 0000*              	LXI	H,FAC			;GET POINTER TO FAC
  026F'   35                    	DCR	M			;DECREMENT EXPONENT
  0270'   E1                    	POP	H			;GET NUMBER BACK
  0271'   C2 0215'              	JNZ	FDIV1			;DIVIDE MORE IF NO OVERFLOW OCCURED
  0274'   C3 0076'              	JMP	ZERO			;UNDERFLOW!!
                                
                                
                                					;CHECK SPECIAL CASES AND ADD EXPONENTS FOR FMULT, FDIV
                                					;ALTERS A,B,H,L
  0277'   3E FF                 MULDVS:	MVI	A,377O			;ENTRY FROM DDIV, SUBTRACT EXPONENTS
  0279'   2E                    	DB	056O			;"MVI	L" AROUND NEXT BYTE
  027A'   AF                    MULDVA:	XRA	A			;ENTRY FROM DMULT, ADD EXPONENTS
  027B'   21 FFFF*              	LXI	H,ARG-1			;GET POINTER TO SIGN AND HO OF ARG
  027E'   4E                    	MOV	C,M			;GET HO AND SIGN FOR UNPACKING
  027F'   23                    	INX	H			;INCREMENT POINTER TO EXPONENT
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-12
FLOATING MULTIPLICATION AND DIVISION

  0280'   AE                    	XRA	M			;GET EXPONENT
  0281'   47                    	MOV	B,A			;SAVE IT IN B FOR BELOW
  0282'   2E 00                 	MVI	L,0			;SET FLAG TO ADD THE EXPONENTS BELOW
  0284'   78                    MULDIV:	MOV	A,B			;IS NUMBER IN REGISTERS ZERO?
  0285'   B7                    	ORA	A
  0286'   CA 02A8'              	JZ	MULDV2			;IT IS, ZERO FAC AND WE ARE DONE
  0289'   7D                    	MOV	A,L			;GET ADD OR SUBTRACT FLAG
  028A'   21 0000*              	LXI	H,FAC			;GET POINTER TO EXPONENT
  028D'   AE                    	XRA	M			;GET EXPONENT
  028E'   80                    	ADD	B			;ADD IN REGISTER EXPONENT
  028F'   47                    	MOV	B,A			;SAVE IT
  0290'   1F                    	RAR				;CHECK FOR OVERFLOW
  0291'   A8                    	XRA	B			;OVERFLOW IF SIGN IS THE SAME AS CARRY
  0292'   78                    	MOV	A,B			;GET SUM
  0293'   F2 02A7'              	JP	MULDV1			;WE HAVE OVERFLOW!!
  0296'   C6 80                 	ADI	200O			;PUT EXPONENT IN EXCESS 200
  0298'   77                    	MOV	M,A			;SAVE IT IN THE FAC
  0299'   CA 01DE'              	JZ	POPHRT			;WE HAVE UNDEFLOW!! RETURN.
  029C'   CD 0357'              	CALL	UNPACK			;UNPACK THE ARGUMENTS
  029F'   77                    	MOV	M,A			;SAVE THE NEW SIGN
  02A0'   2B                    DCXHRT:	DCX	H			;POINT TO EXPONENT
  02A1'   C9                    	RET				;ALL DONE, LEAVE HO IN A
  02A2'   CD 02C6'              MLDVEX:	CALL	SIGN			;ENTRY FROM EXP, PICK UNDERFLOW IF NEGATIVE
  02A5'   2F                    	CMA				;PICK OVERFLOW IF POSITIVE
  02A6'   E1                    	POP	H			;DON'T SCREW UP STACK
  02A7'   B7                    MULDV1:	ORA	A			;IS ERROR OVERFLOW OR UNDEFLOW?
  02A8'   E1                    MULDV2:	POP	H			;GET OLD RETURN ADDRESS OFF STACK
                                
                                
                                
  02A9'   F2 0076'              	JP	ZERO
  02AC'   C3 0AF1'              	JMP	OVFIN2
                                
                                
                                					;MULTIPLY FAC BY 10
                                					;ALTERS A,B,C,D,E,H,L
  02AF'   CD 0335'              MUL10:	CALL	MOVRF			;GET NUMBER IN REGISTERS
  02B2'   78                    	MOV	A,B			;GET EXPONENT
  02B3'   B7                    	ORA	A			;RESULT IS ZERO IF ARG IS ZERO
  02B4'   C8                    	RZ				;IT IS
  02B5'   C6 02                 	ADI	2			;MULTIPLY BY 4 BY ADDING 2 TO EXPONENT
  02B7'   DA 0B11'              	JC	OVFIN3
  02BA'   47                    	MOV	B,A			;RESTORE EXPONENT
  02BB'   CD 000F'              	CALL	FADD			;ADD IN ORIGINAL NUMBER TO GET 5 TIMES IT
  02BE'   21 0000*              	LXI	H,FAC			;ADD 1 TO EXPONENT TO MULTIPLY NUMBER BY
  02C1'   34                    	INR	M			; 2 TO GET 10 TIMES ORIGINAL NUMBER
  02C2'   C0                    	RNZ				;ALL DONE IF NO OVERFLOW
  02C3'   C3 0B11'              	JMP	OVFIN3
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-13
FLOATING MULTIPLICATION AND DIVISION

                                
                                	SUBTTL	SIGN, SGN, FLOAT, NEG AND ABS
                                					;PUT SIGN OF FAC IN A
                                					;ALTERS A ONLY
                                					;LEAVES FAC ALONE
                                					;NOTE: TO TAKE ADVANTAGE OF THE RST INSTRUCTIONS TO SAVE BYTES,
                                					;FSIGN IS DEFINED TO BE AN RST.  "FSIGN" IS EQUIVALENT TO "CALL	SIGN"
                                					;THE FIRST FEW INSTRUCTIONS OF SIGN (THE ONES BEFORE SIGNC) ARE DONE
                                					;IN THE 8 BYTES AT THE RST LOCATION.
                                
                                					;INTEL FLOATING SOFTWARE FLAG
                                
                                					;FSIGN IS USUALLY AN RST
  02C6'   3A 0000*              SIGN:	LDA	FAC			;CHECK IF THE NUMBER IS ZERO
  02C9'   B7                    	ORA	A
  02CA'   C8                    	RZ				;IT IS, A IS ZERO
  02CB'   3A FFFF*              SIGNC:	LDA	FAC-1			;GET SIGN OF FAC, IT IS NON-ZERO
  02CE'   FE                    	DB	376O			;"CPI" AROUND NEXT BYTE
  02CF'   2F                    FCOMPS:	CMA				;ENTRY FROM FCOMP, COMPLEMENT SIGN
  02D0'   17                    ICOMPS:	RAL				;ENTRY FROM ICOMP, PUT SIGN BIT IN CARRY
  02D1'   9F                    SIGNS:	SBB	A			;A=0 IF CARRY WAS 0, A=377 IF CARRY WAS 1
  02D2'   C0                    	RNZ				;RETURN IF NUMBER WAS NEGATIVE
  02D3'   3C                    INRART:	INR	A			;PUT ONE IN A IF NUMBER WAS POSITIVE
  02D4'   C9                    	RET				;ALL DONE
                                
                                
                                					;SGN FUNCTION
                                					;ALTERS A,B,C,D,E,H,L
                                					;FALL INTO FLOAT
                                
                                
                                					;FLOAT THE SIGNED INTEGER IN A
                                					;ALTERS A,B,C,D,E,H,L
                                
                                					;USE MICROSOFT FORMAT IF NOT INTEL
  02D5'   06 88                 FLOAT:	MVI	B,210O			;SET EXPONENT CORRECTLY
  02D7'   11 0000               	LXI	D,0			;ZERO D,E
                                					;FALL INTO FLOATR
                                
                                
                                					;FLOAT THE SIGNED NUMBER IN B,A,D,E
                                					;ALTERS A,B,C,D,E,H,L
  02DA'   21 0000*              FLOATR:	LXI	H,FAC			;GET POINTER TO FAC
  02DD'   4F                    	MOV	C,A			;PUT HO IN C
  02DE'   70                    	MOV	M,B			;PUT EXPONENT IN THE FAC
  02DF'   06 00                 	MVI	B,0			;ZERO OVERFLOW BYTE
  02E1'   23                    	INX	H			;POINT TO SIGN
  02E2'   36 80                 	MVI	M,200O			;ASSUME A POSITIVE NUMBER
  02E4'   17                    	RAL				;PUT SIGN IN CARRY
  02E5'   C3 005E'              	JMP	FADFLT			;GO AND FLOAT THE NUMBER
                                
                                
                                					;FALL INTO NEG
                                
                                
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-14
SIGN, SGN, FLOAT, NEG AND ABS

                                ;
                                ;	;GET THE VALTYP AND SET CONDITION CODES AS FOLLOWS:
                                ;;CONDITION CODE		TRUE SET	FALSE SET
                                ;;SIGN			INT=2		STR,SNG,DBL
                                ;;ZERO			STR=3		INT,SNG,DBL
                                ;;ODD PARITY		SNG=4		INT,STR,DBL
                                ;;NO CARRY		DBL=10		INT,STR,SNG
                                ;GETYPE:	LDA	VALTYP		;GET THE VALTYP
                                ;	CPI	10		;SET CARRY CORRECTLY
                                ;	DCR	A		;SET THE OTHER CONDITION CODES CORRECTLY
                                ;	DCR	A		; WITHOUT AFFECTING CARRY
                                ;	DCR	A
                                ;	RET	*			;ALL DONE
                                
                                
                                					;ABSOLUTE VALUE OF FAC
                                					;ALTERS A,B,C,D,E,H,L
  02E8'   CD 0307'              ABS:	CALL	VSIGN			;GET THE SIGN OF THE FAC IN A
  02EB'   F0                    	RP				;IF IT IS POSITIVE, WE ARE DONE
                                
                                
                                					;NEGATE ANY TYPE VALUE IN THE FAC
                                					;ALTERS A,B,C,D,E,H,L
  02EC'   CD 0000*              VNEG:	CALL	GETYPR			;SEE WHAT KIND OF NUMBER WE HAVE
  02EF'   FA 0679'              	JM	INEG			;WE HAVE AN INTEGER, NEGATE IT THAT WAY
  02F2'   CA 0000*              	JZ	TMERR			;BLOW UP ON STRINGS
                                					;FALL INTO NEG TO NEGATE A SNG OR DBL
                                
                                
                                					;NEGATE NUMBER IN THE FAC
                                					;ALTERS A,H,L
                                					;NOTE: THE NUMBER MUST BE PACKED
                                
                                					;IF INTFSW=0 DO NOT USE INTEL FORMAT
  02F5'   21 FFFF*              NEG:	LXI	H,FAC-1			;GET POINTER TO SIGN
  02F8'   7E                    	MOV	A,M			;GET SIGN
  02F9'   EE 80                 	XRI	200O			;COMPLEMENT SIGN BIT
  02FB'   77                    	MOV	M,A			;SAVE IT
  02FC'   C9                    	RET				;ALL DONE
                                
                                
                                					;SGN FUNCTION
                                					;ALTERS A,H,L
  02FD'   CD 0307'              SGN:	CALL	VSIGN			;GET THE SIGN OF THE FAC IN A
                                					;ENTRY TO CONVERT A SIGNED NUMBER IN A TO AN INTEGER
  0300'   6F                    CONIA:	MOV	L,A			;PUT IT IN THE LO POSITION
  0301'   17                    	RAL				;EXTEND THE SIGN TO THE HO
  0302'   9F                    	SBB	A
  0303'   67                    	MOV	H,A
  0304'   C3 045D'              	JMP	MAKINT			;RETURN THE RESULT AND SET VALTYP
                                
                                
                                					;GET THE SIGN OF THE VALUE IN THE FAC IN A
                                					;ALTERS A,H,L
  0307'   CD 0000*              VSIGN:	CALL	GETYPR			;SEE WHAT KIND OF A NUMBER WE HAVE
  030A'   CA 0000*              	JZ	TMERR			;BLOW UP ON STRINGS
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-15
SIGN, SGN, FLOAT, NEG AND ABS

  030D'   F2 02C6'              	JP	SIGN			;SINGLE AND DOUBLE PREC. WORK THE SAME
  0310'   2A 0000*              	LHLD	FACLO			;GET THE INTEGER ARGUMENT
                                
                                					;ENTRY TO FIND THE SIGN OF (HL)
                                					;ALTERS A ONLY
  0313'   7C                    ISIGN:	MOV	A,H			;GET ITS SIGN
  0314'   B5                    	ORA	L			;CHECK IF THE NUMBER IS ZERO
  0315'   C8                    	RZ				;IT IS, WE ARE DONE
  0316'   7C                    	MOV	A,H			;IT ISN'T, SIGN IS THE SIGN OF H
  0317'   C3 02D0'              	JMP	ICOMPS			;GO SET A CORRECTLY
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-16
SIGN, SGN, FLOAT, NEG AND ABS

                                
                                	SUBTTL	FLOATING POINT MOVEMENT ROUTINES
                                					;PUT FAC ON STACK
                                					;ALTERS D,E
  031A'   EB                    PUSHF:	XCHG				;SAVE (HL)
  031B'   2A 0000*              	LHLD	FACLO			;GET LO'S
  031E'   E3                    	XTHL				;SWITCH LO'S AND RET ADDR
  031F'   E5                    	PUSH	H			;PUT RET ADDR BACK ON STACK
  0320'   2A FFFF*              	LHLD	FAC-1			;GET HO'S
  0323'   E3                    	XTHL				;SWITCH HO'S AND RET ADDR
  0324'   E5                    	PUSH	H			;PUT RET ADDR BACK ON STACK
  0325'   EB                    	XCHG				;GET OLD (HL) BACK
  0326'   C9                    	RET				;ALL DONE
                                
                                
                                					;MOVE NUMBER FROM MEMORY [(HL)] TO FAC
                                					;ALTERS B,C,D,E,H,L
                                					;AT EXIT NUMBER IS IN B,C,D,E
                                					;AT EXIT (HL):=(HL)+4
  0327'   CD 0338'              MOVFM:	CALL	MOVRM			;GET NUMBER IN REGISTERS
                                					;FALL INTO MOVFR AND PUT IT IN FAC
                                
                                
                                					;MOVE REGISTERS (B,C,D,E) TO FAC
                                					;ALTERS D,E
  032A'   EB                    MOVFR:	XCHG				;GET LO'S IN (HL)
  032B'   22 0000*              	SHLD	FACLO			;PUT THEM WHERE THEY BELONG
  032E'   60                    	MOV	H,B			;GET HO'S IN (HL)
  032F'   69                    	MOV	L,C
  0330'   22 FFFF*              	SHLD	FAC-1			;PUT HO'S WHERE THEY BELONG
  0333'   EB                    	XCHG				;GET OLD (HL) BACK
  0334'   C9                    	RET				;ALL DONE
                                
                                
                                					;MOVE FAC TO REGISTERS (B,C,D,E)
                                					;ALTERS B,C,D,E,H,L
  0335'   21 0000*              MOVRF:	LXI	H,FACLO			;GET POINTER TO FAC
                                					;FALL INTO MOVRM
                                
                                
                                					;GET NUMBER IN REGISTERS (B,C,D,E) FROM MEMORY [(HL)]
                                					;ALTERS B,C,D,E,H,L
                                					;AT EXIT (HL):=(HL)+4
  0338'   5E                    MOVRM:	MOV	E,M			;GET LO
  0339'   23                    	INX	H			;POINT TO MO
  033A'   56                    GETBCD:	MOV	D,M			;GET MO, ENTRY FOR BILL
  033B'   23                    	INX	H			;POINT TO HO
  033C'   4E                    	MOV	C,M			;GET HO
  033D'   23                    	INX	H			;POINT TO EXPONENT
  033E'   46                    	MOV	B,M			;GET EXPONENT
  033F'   23                    INXHRT:	INX	H			;INC POINTER TO BEGINNING OF NEXT NUMBER
  0340'   C9                    	RET				;ALL DONE
                                
                                
                                					;MOVE NUMBER FROM FAC TO MEMORY [(HL)]
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-17
FLOATING POINT MOVEMENT ROUTINES

                                					;ALTERS A,B,D,E,H,L
  0341'   11 0000*              MOVMF:	LXI	D,FACLO			;GET POINTER TO FAC
                                					;FALL INTO MOVE
                                
                                
                                					;MOVE NUMBER FROM (DE) TO (HL)
                                					;ALTERS A,B,D,E,H,L
                                					;EXITS WITH (DE):=(DE)+4, (HL):=(HL)+4
  0344'   06 04                 MOVE:	MVI	B,4			;SET COUNTER
  0346'   C3 034E'              	JMP	MOVE1			;CONTINUE WITH THE MOVE
                                
                                
                                					;MOVE ANY TYPE VALUE (AS INDICATED BY VALTYP) FROM (DE) TO (HL)
                                					;ALTERS A,B,D,E,H,L
  0349'   EB                    MOVVFM:	XCHG				;ENTRY TO SWITCH (DE) AND (HL)
  034A'   3A 0000*              VMOVE:	LDA	VALTYP			;GET THE LENGTH OF THE NUMBER
  034D'   47                    	MOV	B,A			;SAVE IT AWAY
                                	PUBLIC	MOVE1
  034E'   1A                    MOVE1:	LDAX	D			;GET WORD, ENTRY FROM VMOVMF
  034F'   77                    	MOV	M,A			;PUT IT WHERE IT BELONGS
  0350'   13                    	INX	D			;INCREMENT POINTERS TO NEXT WORD
  0351'   23                    	INX	H
  0352'   05                    	DCR	B
  0353'   C2 034E'              	JNZ	MOVE1
  0356'   C9                    	RET	
                                
                                
                                					;UNPACK THE FAC AND THE REGISTERS
                                					;ALTERS A,C,H,L
                                					;WHEN THE NUMBER IN THE FAC IS UNACKED, THE ASSUMED ONE IN THE
                                					;MANTISSA IS RESTORED, AND THE COMPLEMENT OF THE SIGN IS PLACED
                                					;IN FAC+1
                                
                                					;INTEL FLOATING SOFTWARE FLAG
  0357'   21 FFFF*              UNPACK:	LXI	H,FAC-1			;POINT TO HO AND SIGN
  035A'   7E                    	MOV	A,M			;GET HO AND SIGN
  035B'   07                    	RLC				;DUPLICATE THE SIGN IN CARRY AND THE LSB
  035C'   37                    	STC				;RESTORE THE HIDDEN ONE
  035D'   1F                    	RAR				;RESTORE THE NUMBER IN A
  035E'   77                    	MOV	M,A			;SAVE HO
  035F'   3F                    	CMC				;GET THE COMPLEMENT OF THE SIGN
  0360'   1F                    	RAR				;GET IT IN THE SIGN BIT
  0361'   23                    	INX	H			;POINT TO TEMPORARY SIGN BYTE
  0362'   23                    	INX	H
  0363'   77                    	MOV	M,A			;SAVE COMPLEMENT OF SIGN
  0364'   79                    	MOV	A,C			;GET HO AND SIGN OF THE REGISTERS
  0365'   07                    	RLC				;DUPLICATE THE SIGN IN CARRY AND THE LSB
  0366'   37                    	STC				;RESTORE THE HIDDEN ONE
  0367'   1F                    	RAR				;RESTORE THE HO IN A
  0368'   4F                    	MOV	C,A			;SAVE THE HO
  0369'   1F                    	RAR				;GET THE SIGN BACK
  036A'   AE                    	XRA	M			;COMPARE SIGN OF FAC AND SIGN OF REGISTERS
  036B'   C9                    	RET				;ALL DONE
                                
                                
                                					;MOVE ANY TYPE VALUE FROM MEMORY [(HL)] TO FAC
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-18
FLOATING POINT MOVEMENT ROUTINES

                                					;ALTERS A,B,D,E,H,L
  036C'   21 0000*              VMOVFA:	LXI	H,ARGLO			;ENTRY FROM DADD, MOVE ARG TO FAC
  036F'   11 0349'              VMOVFM:	LXI	D,MOVVFM		;GET ADDRESS OF LOCATION THAT DOES
  0372'   C3 037B'              	JMP	VMVVFM			; AN "XCHG" AND FALLS INTO MOVE1
                                
                                
                                					;MOVE ANY TYPE VALUE FROM FAC TO MEMORY [(HL)]
                                					;ALTERS A,B,D,E,H,L
  0375'   21 0000*              VMOVAF:	LXI	H,ARGLO			;ENTRY FROM FIN, DMUL10, DDIV10
                                					;MOVE FAC TO ARG
  0378'   11 034A'              VMOVMF:	LXI	D,VMOVE			;GET ADDRESS OF MOVE SUBROUTINE
  037B'   D5                    VMVVFM:	PUSH	D			;SHOVE IT ON THE STACK
  037C'   11 0000*              VDFACS:	LXI	D,FACLO			;GET FIRST ADDRESS FOR INT, STR, SNG
  037F'   CD 0000*              	CALL	GETYPR			;GET THE VALUE TYPE
  0382'   D8                    	RC				;GO MOVE IT IF WE DO NOT HAVE A DBL
  0383'   11 0000*              	LXI	D,DFACLO		;WE DO, GET LO ADDR OF THE DBL NUMBER
  0386'   C9                    	RET				;GO DO THE MOVE
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-19
FLOATING POINT MOVEMENT ROUTINES

                                
                                	SUBTTL	COMPARE TWO NUMBERS
                                					;COMPARE TWO SINGLE PRECISION NUMBERS
                                					;A=1 IF ARG .LT. FAC
                                					;A=0 IF ARG=FAC
                                					;A=-1 IF ARG .GT. FAC
                                					;DOREL DEPENDS UPON THE FACT THAT FCOMP RETURNS WITH CARRY ON
                                					; IFF A HAS 377
                                					;ALTERS A,H,L
  0387'   78                    FCOMP:	MOV	A,B			;CHECK IF ARG IS ZERO
  0388'   B7                    	ORA	A
  0389'   CA 02C6'              	JZ	SIGN
  038C'   21 02CF'              	LXI	H,FCOMPS		;WE JUMP TO FCOMPS WHEN WE ARE DONE
  038F'   E5                    	PUSH	H			;PUT THE ADDRESS ON THE STACK
  0390'   CD 02C6'              	CALL	SIGN			;CHECK IF FAC IS ZERO
  0393'   79                    	MOV	A,C			;IF IT IS, RESULT IS MINUS THE SIGN OF ARG
  0394'   C8                    	RZ				;IT IS
  0395'   21 FFFF*              	LXI	H,FAC-1			;POINT TO SIGN OF FAC
  0398'   AE                    	XRA	M			;SEE IF THE SIGNS ARE THE SAME
  0399'   79                    	MOV	A,C			;IF THEY ARE DIFFERENT, RESULT IS SIGN OF ARG
  039A'   F8                    	RM				;THEY ARE DIFFERENT
  039B'   CD 03A1'              	CALL	FCOMP2			;CHECK THE REST OF THE NUMBER
  039E'   1F                    FCOMPD:	RAR				;NUMBERS ARE DIFFERENT, CHANGE SIGN IF
  039F'   A9                    	XRA	C			; BOTH NUMBERS ARE NEGATIVE
  03A0'   C9                    	RET				;GO SET UP A
                                
  03A1'   23                    FCOMP2:	INX	H			;POINT TO EXPONENT
  03A2'   78                    	MOV	A,B			;GET EXPONENT OF ARG
  03A3'   BE                    	CMP	M			;COMPARE THE TWO
  03A4'   C0                    	RNZ				;NUMBERS ARE DIFFERENT
  03A5'   2B                    	DCX	H			;POINT TO HO
  03A6'   79                    	MOV	A,C			;GET HO OF ARG
  03A7'   BE                    	CMP	M			;COMPARE WITH HO OF FAC
  03A8'   C0                    	RNZ				;THEY ARE DIFFERENT
  03A9'   2B                    	DCX	H			;POINT TO MO OF FAC
  03AA'   7A                    	MOV	A,D			;GET MO OF ARG
  03AB'   BE                    	CMP	M			;COMPARE WITH MO OF FAC
  03AC'   C0                    	RNZ				;THE NUMBERS ARE DIFFERENT
  03AD'   2B                    	DCX	H			;POINT TO LO OF FAC
  03AE'   7B                    	MOV	A,E			;GET LO OF ARG
  03AF'   96                    	SUB	M			;SUBTRACT LO OF FAC
  03B0'   C0                    	RNZ				;NUMBERS ARE DIFFERENT
  03B1'   E1                    	POP	H			;NUMBERS ARE THE SAME, DON'T SCREW UP STACK
  03B2'   E1                    	POP	H
  03B3'   C9                    	RET				;ALL DONE
                                
                                
                                					;COMPARE TWO INTEGERS
                                					;A=1 IF (DE) .LT. (HL)
                                					;A=0 IF (DE)=(HL)
                                					;A=-1 IF (DE) .GT. (HL)
                                					;ALTERS A ONLY
  03B4'   7A                    ICOMP:	MOV	A,D			;ARE THE SIGNS THE SAME?
  03B5'   AC                    	XRA	H
  03B6'   7C                    	MOV	A,H			;IF NOT, ANSWER IS THE SIGN OF (HL)
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-20
COMPARE TWO NUMBERS

  03B7'   FA 02D0'              	JM	ICOMPS			;THEY ARE DIFFERENT
  03BA'   BA                    	CMP	D			;THEY ARE THE SAME, COMPARE THE HO'S
  03BB'   C2 02D1'              	JNZ	SIGNS			;GO SET UP A
  03BE'   7D                    	MOV	A,L			;COMPARE THE LO'S
  03BF'   93                    	SUB	E
  03C0'   C2 02D1'              	JNZ	SIGNS			;GO SET UP A
  03C3'   C9                    	RET				;ALL DONE, THEY ARE THE SAME
                                
                                
                                					;COMPARE TWO DOUBLE PRECISION NUMBERS
                                					;A=1 IF ARG .LT. FAC
                                					;A=0 IF ARG=FAC
                                					;A=-1 IF ARG .GT. FAC
                                					;ALTERS A,B,C,D,E,H,L
  03C4'   21 0000*              DCOMPD:	LXI	H,ARGLO			;ENTRY WITH POINTER TO ARG IN (DE)
  03C7'   CD 034A'              	CALL	VMOVE			;MOVE THE ARGUMENT INTO ARG
                                	PUBLIC	XDCOMP
  03CA'   11 0000*              XDCOMP:	LXI	D,ARG			;GET POINTER TO ARG
  03CD'   1A                    	LDAX	D			;SEE IF ARG=0
  03CE'   B7                    	ORA	A
  03CF'   CA 02C6'              	JZ	SIGN			;ARG=0, GO SET UP A
  03D2'   21 02CF'              	LXI	H,FCOMPS		;PUSH FCOMPS ON STACK SO WE WILL RETURN TO
  03D5'   E5                    	PUSH	H			; TO IT AND SET UP A
  03D6'   CD 02C6'              	CALL	SIGN			;SEE IF FAC=0
  03D9'   1B                    	DCX	D			;POINT TO SIGN OF ARGUMENT
  03DA'   1A                    	LDAX	D			;GET SIGN OF ARG
  03DB'   4F                    	MOV	C,A			;SAVE IT FOR LATER
  03DC'   C8                    	RZ				;FAC=0, SIGN OF RESULT IS SIGN OF ARG
  03DD'   21 FFFF*              	LXI	H,FAC-1			;POINT TO SIGN OF FAC
  03E0'   AE                    	XRA	M			;SEE IF THE SIGNS ARE THE SAME
  03E1'   79                    	MOV	A,C			;IF THEY ARE, GET THE SIGN OF THE NUMBERS
  03E2'   F8                    	RM				;THE SIGNS ARE DIFFERENT, GO SET A
  03E3'   13                    	INX	D			;POINT BACK TO EXPONENT OF ARG
  03E4'   23                    	INX	H			;POINT TO EXPONENT OF FAC
  03E5'   06 08                 	MVI	B,10O			;SET UP A COUNT
  03E7'   1A                    DCOMP1:	LDAX	D			;GET A BYTE FROM ARG
  03E8'   96                    	SUB	M			;COMPARE IT WITH THE FAC
  03E9'   C2 039E'              	JNZ	FCOMPD			;THEY ARE DIFFERENT, GO SET UP A
  03EC'   1B                    	DCX	D			;THEY ARE THE SAME, EXAMINE THE NEXT LOWER
  03ED'   2B                    	DCX	H			; ORDER BYTES
  03EE'   05                    	DCR	B			;ARE WE DONE?
  03EF'   C2 03E7'              	JNZ	DCOMP1			;NO, COMPARE THE NEXT BYTES
  03F2'   C1                    	POP	B			;THEY ARE THE SAME, GET FCOMPS OFF STACK
  03F3'   C9                    	RET				;ALL DONE
                                
                                
                                					;COMPARE TWO DOUBLE PRECISION NUMBERS
                                					;A=1 IF ARG .GT. FAC
                                					;A=0 IF ARG=FAC
                                					;A=-1 IF ARG .LT. FAC
                                					;NOTE:	THIS IS THE REVERSE OF ICOMP, FCOMP AND XDCOMP
                                					;ALTERS A,B,C,D,E,H,L
  03F4'   CD 03CA'              DCOMP:	CALL	XDCOMP			;COMPARE THE TWO NUMBERS
  03F7'   C2 02CF'              	JNZ	FCOMPS			;NEGATE THE ANSWER, MAKE SURE THE CARRY COMES
  03FA'   C9                    	RET				; OUT CORRECT FOR DOCMP
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-21
COMPARE TWO NUMBERS

                                
                                	SUBTTL	CONVERSION ROUTINES BETWEEN INTEGER, SINGLE AND DOUBLE PRECISION
                                					;FORCE THE FAC TO BE AN INTEGER
                                					;ALTERS A,B,C,D,E,H,L
  03FB'   CD 0000*              FRCINT:	CALL	GETYPR			;SEE WHAT WE HAVE
  03FE'   2A 0000*              	LHLD	FACLO			;GET FACLO+0,1 IN CASE WE HAVE AN INTEGER
  0401'   F8                    	RM				;WE HAVE AN INTEGER, ALL DONE
  0402'   CA 0000*              	JZ	TMERR			;WE HAVE A STRING, THAT IS A "NO-NO"
  0405'   E2 041A'              	JPO	FRCIN2			;GO DO S.P.
  0408'   CD 0375'              FDBINT:	CALL	VMOVAF			;ADD D.P. .5
  040B'   21 10C5'              	LXI	H,DHALF			;
  040E'   CD 036F'              	CALL	VMOVFM
  0411'   CD 06A7'              	CALL	DADD			;
  0414'   CD 047F'              FRDBIN:	CALL	CONSD
  0417'   C3 041D'              	JMP	FRCIN3
  041A'   CD 0000'              FRCIN2:	CALL	FADDH
  041D'   3A FFFF*              FRCIN3:	LDA	FAC-1			;GET SIGN BYTE
  0420'   B7                    	ORA	A			;SET CONDITION CODES CORRECTLY
  0421'   F5                    	PUSH	PSW
  0422'   E6 7F                 	ANI	177O			;CLEAR SIGN
  0424'   32 FFFF*              	STA	FAC-1			;MAKE FAC POSITIVE
  0427'   3A 0000*              	LDA	FAC			;GET EXPONENT
  042A'   FE 90                 	CPI	220O			;SEE IF TOO LARGE
  042C'   D2 0000*              	JNC	OVERR			;
  042F'   CD 04C3'              	CALL	QINT			;CONVERT TO INTEGER
  0432'   3A 0000*              	LDA	FAC
  0435'   B7                    	ORA	A
  0436'   C2 043E'              	JNZ	FRCIAA
  0439'   F1                    	POP	PSW			;
  043A'   EB                    	XCHG	
  043B'   C3 0443'              	JMP	FRCI3A
  043E'                         FRCIAA:
  043E'   F1                    	POP	PSW			;
  043F'   EB                    	XCHG				;MOVE INTEGER TO (HL)
  0440'   F2 0449'              	JP	FRCIN4
  0443'   7C                    FRCI3A:	MOV	A,H
  0444'   2F                    	CMA	
  0445'   67                    	MOV	H,A			;COMPLEMENT (HL)
  0446'   7D                    	MOV	A,L
  0447'   2F                    	CMA	
  0448'   6F                    	MOV	L,A			;
  0449'   C3 045D'              FRCIN4:	JMP	MAKINT
  044C'   21 0000*              	LXI	H,OVERR			;PUT OVERR ON THE STACK SO WE WILL GET ERROR
  044F'   E5                    	PUSH	H			; IF NUMBER IS TOO BIG
                                					;FALL INTO CONIS
                                
                                
                                					;CONVERT SINGLE PRECISION NUMBER TO INTEGER
                                					;ALTERS A,B,C,D,E,H,L
                                	PUBLIC	CONIS
  0450'   3A 0000*              CONIS:	LDA	FAC			;GET THE EXPONENT
  0453'   FE 90                 	CPI	220O			;SEE IF IT IS TOO BIG
  0455'   D2 0466'              	JNC	CONIS2			;IT IS, BUT IT MIGHT BE -32768
  0458'   CD 04C3'              	CALL	QINT			;IT ISN'T, CONVERT IT TO AN INTEGER
  045B'   EB                    	XCHG				;PUT IT IN (HL)
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-22
CONVERSION ROUTINES BETWEEN INTEGER, SINGLE AND DOUBLE PREC

                                					;ENTRY FROM IADD
  045C'   D1                    CONIS1:	POP	D			;GET ERROR ADDRESS OFF STACK
                                
                                					;PUT (HL) IN FACLO, SET VALTYP TO INT
                                					;ALTERS A ONLY
  045D'   22 0000*              MAKINT:	SHLD	FACLO			;STORE THE NUMBER IN FACLO
  0460'   3E 02                 VALINT:	MVI	A,2			;SET VALTYP TO "INTEGER"
  0462'   32 0000*              CONISD:	STA	VALTYP			;ENTRY FROM CONDS
  0465'   C9                    	RET				;ALL DONE
                                
  0466'   01 9080               CONIS2:	LXI	B,220Q*256+200Q
  0469'   11 0000               	LXI	D,000Q*256+000Q		;CHECK IF NUMBER IS -32768, ENTRY FROM FIN
  046C'   CD 0387'              	CALL	FCOMP
  046F'   C0                    	RNZ				;ERROR:  IT CAN'T BE CONVERTED TO AN INTEGER
  0470'   61                    	MOV	H,C			;IT IS -32768, PUT IT IN (HL)
                                
  0471'   6A                    	MOV	L,D
  0472'   C3 045C'              	JMP	CONIS1			;STORE IT IN THE FAC AND SET VALTYP
                                
                                
                                					;FORCE THE FAC TO BE A SINGLE PRECISION NUMBER
                                					;ALTERS A,B,C,D,E,H,L
  0475'   CD 0000*              FRCSNG:	CALL	GETYPR			;SEE WHAT KIND OF NUMBER WE HAVE
  0478'   E0                    	RPO				;WE ALREADY HAVE A SNG, ALL DONE
  0479'   FA 0492'              	JM	CONSI			;WE HAVE AN INTEGER, CONVERT IT
  047C'   CA 0000*              	JZ	TMERR			;STRINGS!! -- ERROR!!
                                					;DBL PREC -- FALL INTO CONSD
                                
                                
                                					;CONVERT DOUBLE PRECISION NUMBER TO A SINGLE PRECISON ONE
                                					;ALTERS A,B,C,D,E,H,L
                                	PUBLIC	CONSD
  047F'   CD 0335'              CONSD:	CALL	MOVRF			;GET THE HO'S IN THE REGISTERS
  0482'   CD 04B7'              	CALL	VALSNG			;SET VALTYP TO "SINGLE PRECISON"
  0485'   78                    	MOV	A,B			;CHECK IF THE NUMBER IS ZERO
  0486'   B7                    	ORA	A
  0487'   C8                    	RZ				;IF IT IS, WE ARE DONE
  0488'   CD 0357'              	CALL	UNPACK			;UNPACK THE NUMBER
  048B'   21 FFFF*              	LXI	H,FACLO-1		;GET FIRST BYTE BELOW A SNG NUMBER
  048E'   46                    	MOV	B,M			;PUT IT IN B FOR ROUND
  048F'   C3 00AA'              	JMP	ROUND			;ROUND THE DBL NUMBER UP AND WE ARE DONE
                                
                                
                                					;CONVERT AN INTEGER TO A SINGLE PRECISION NUMBER
                                					;ALTERS A,B,C,D,E,H,L
                                	PUBLIC	CONSI
  0492'   2A 0000*              CONSI:	LHLD	FACLO			;GET THE INTEGER
  0495'   CD 04B7'              CONSIH:	CALL	VALSNG			;SET VALTYP TO "SINGLE PRECISION"
  0498'   7C                    	MOV	A,H			;SET UP REGISTERS FOR FLOATR
  0499'   55                    	MOV	D,L
  049A'   1E 00                 	MVI	E,0
  049C'   06 90                 	MVI	B,220O
  049E'   C3 02DA'              	JMP	FLOATR			;GO FLOAT THE NUMBER
                                
                                
                                					;FORCE THE FAC TO BE A DOUBLE PRECISION NUMBER
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-23
CONVERSION ROUTINES BETWEEN INTEGER, SINGLE AND DOUBLE PREC

                                					;ALTERS A,B,C,D,E,H,L
  04A1'   CD 0000*              FRCDBL:	CALL	GETYPR			;SEE WHAT KIND OF NUMBER WE HAVE
  04A4'   D0                    	RNC				;WE ALREADY HAVE A DBL, WE ARE DONE
  04A5'   CA 0000*              	JZ	TMERR			;GIVE AN ERROR IF WE HAVE A STRING
  04A8'   FC 0492'              	CM	CONSI			;CONVERT TO SNG IF WE HAVE AN INT
                                					;FALL INTO CONDS AND CONVERT TO DBL
                                
                                
                                					;CONVERT A SINGLE PRECISION NUMBER TO A DOUBLE PRECISION ONE
                                					;ALTERS A,H,L
                                	PUBLIC	CONDS
  04AB'   21 0000               CONDS:	LXI	H,0			;ZERO H,L
  04AE'   22 0000*              	SHLD	DFACLO			;CLEAR THE FOUR LOWER BYTES IN THE DOUBLE
  04B1'   22 0002*              	SHLD	DFACLO+2		; PRECISION NUMBER
  04B4'   3E 08                 VALDBL:	MVI	A,10O			;SET VALTYP TO "DOUBLE PRECISION"
  04B6'   01                    	DB	001			;"LXI	B" OVER THE NEXT 2 BYTES
  04B7'   3E 04                 VALSNG:	MVI	A,4			;SET VALTYP TO "SINGLE PRECISION"
  04B9'   C3 0462'              	JMP	CONISD			;GO TO IT
                                
                                
                                					;FORCE THE FAC TO BE A STRING
                                					;ALTERS A ONLY
  04BC'                         CHKSTR:
  04BC'   CD 0000*              FRCSTR:	CALL	GETYPR			;SEE WHAT KIND OF VALUE WE HAVE
  04BF'   C8                    	RZ				;WE HAVE A STRING, EVERYTHING IS OK
  04C0'   C3 0000*              	JMP	TMERR			;WE DON'T HAVE A STRING, FALL INTO TMERR
                                
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-24
CONVERSION ROUTINES BETWEEN INTEGER, SINGLE AND DOUBLE PREC

                                
                                	SUBTTL	GREATEST INTEGER FUNCTION
                                					;QUICK GREATEST INTEGER FUNCTION
                                					;LEAVES INT(FAC) IN C,D,E (SIGNED)
                                					;ASSUMES FAC .LT. 2^23 = 8388608
                                					;ASSUMES THE EXPONENT OF FAC IS IN A
                                					;ALTERS A,B,C,D,E
  04C3'   47                    QINT:	MOV	B,A			;ZERO B,C,D,E IN CASE THE NUMBER IS ZERO
  04C4'   4F                    	MOV	C,A
  04C5'   57                    	MOV	D,A
  04C6'   5F                    	MOV	E,A
  04C7'   B7                    	ORA	A			;SET CONDITION CODES
  04C8'   C8                    	RZ				;IT IS ZERO, WE ARE DONE
                                
                                ;THE HARD CASE IN QINT IS NEGATIVE NON-INTEGERS.  TO HANDLE THIS, IF THE
                                ;NUMBER IS NEGATIVE, WE REGARD THE 3-BYTE MANTISSA AS A 3-BYTE INTEGER AND
                                ;SUBTARCT ONE.  THEN ALL THE FRACTIONAL BITS ARE SHIFTED OUT BY SHIFTING THE
                                ;MANTISSA RIGHT.  THEN, IF THE NUMBER WAS NEGATIVE, WE ADD ONE.  SO, IF WE
                                ;HAD A NEGATIVE INTEGER, ALL THE BITS TO THE RIGHT OF THE BINARY POINT WERE
                                ;ZERO.  SO THE NET EFFECT IS WE HAVE THE ORIGINAL NUMBER IN C,D,E.  IF THE
                                ;NUMBER WAS A NEGATIVE NON-INTEGER, THERE IS AT LEAST ONE NON-ZERO BIT TO THE
                                ;RIGHT OF THE BINARY POINT.  SO THE NET EFFECT IS THAT WE GET THE ABSOLUTE
                                ;VALUE OF INT(FAC) IN C,D,E.  C,D,E IS THEN NEGATED IF THE ORIGINAL NUMBER WAS
                                ;NEGATIVE SO THE RESULT WILL BE SIGNED.
  04C9'   E5                    	PUSH	H			;SAVE (HL)
  04CA'   CD 0335'              	CALL	MOVRF			;GET NUMBER IN THE REGISTERS
  04CD'   CD 0357'              	CALL	UNPACK			;UNPACK THE NUMBER
  04D0'   AE                    	XRA	M			;GET SIGN OF NUMBER
  04D1'   67                    	MOV	H,A			;DON'T LOSE IT
  04D2'   FC 04E7'              	CM	QINTA			;SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
  04D5'   3E 98                 	MVI	A,230O			;SEE HOW MANY WE HAVE TO SHIFT TO CHANGE
  04D7'   90                    	SUB	B			; NUMBER TO AN INTEGER
  04D8'   CD 00E9'              	CALL	SHIFTR			;SHIFT NUMBER TO GET RID OF FRACTIONAL BITS
  04DB'   7C                    	MOV	A,H			;GET SIGN
  04DC'   17                    	RAL				;PUT SIGN IN CARRY SO IT WILL NOT BE CHANGED
  04DD'   DC 00BC'              	CC	ROUNDA			;IF NUMBER WAS NEGATIVE, ADD ONE
  04E0'   06 00                 	MVI	B,0			;FORGET THE BITS WE SHIFTED OUT
  04E2'   DC 00D5'              	CC	NEGR			;NEGATE NUMBER IF IT WAS NEGATIVE BECAUSE WE
                                					; WANT A SIGNED MANTISSA
  04E5'   E1                    	POP	H			;GET OLD (HL) BACK
  04E6'   C9                    	RET				;ALL DONE
                                
  04E7'   1B                    QINTA:	DCX	D			;SUBTRACT ONE FROM C,D,E
  04E8'   7A                    	MOV	A,D			;WE HAVE TO SUBTRACT ONE FROM C IF
  04E9'   A3                    	ANA	E			; D AND E ARE BOTH ALL ONES
  04EA'   3C                    	INR	A			;SEE IF BOTH WERE -1
  04EB'   C0                    	RNZ				;THEY WERE NOT, WE ARE DONE
                                	PUBLIC	DCXBRT
  04EC'   0B                    DCXBRT:	DCX	B			;THIS IS FOR BILL.  C WILL NEVER BE ZERO
                                					; (THE MSB WILL ALWAYS BE ONE) SO "DCX	B"
                                					; AND "DCR	C" ARE FUNCTIONALLY EQUIVALENT
  04ED'   C9                    	RET				;ALL DONE
                                					; THIS IS THE FIX (X) FUNCTION. IT RETURNS
                                					; FIX(X)=SGN(X)*INT(ABS(X))
                                	PUBLIC	FIXER
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-25
GREATEST INTEGER FUNCTION

  04EE'   CD 0000*              FIXER:	CALL	GETYPR			;GET VALTYPE OF ARG
  04F1'   F8                    	RM				;INT, DONE
  04F2'   CD 02C6'              	CALL	SIGN			;GET SIGN
  04F5'   F2 0501'              	JP	VINT			;IF POSITIVE, JUST CALL REGULAR INT CODE
  04F8'   CD 02F5'              	CALL	NEG			;NEGATE IT
  04FB'   CD 0501'              	CALL	VINT			;GET THE INTEGER OF IT
  04FE'   C3 02EC'              	JMP	VNEG			;NOW RE-NEGATE IT
                                
                                					;GREATEST INTEGER FUNCTION
                                					;ALTERS A,B,C,D,E,H,L
  0501'   CD 0000*              VINT:	CALL	GETYPR			;SEE WHAT TYPE OF A NUMBER WE HAVE
  0504'   F8                    	RM				;IT IS AN INTEGER, ALL DONE
  0505'   D2 0527'              	JNC	DINT			;CONVERT THE DOUBLE PRECISION NUMBER
  0508'   CA 0000*              	JZ	TMERR			;BLOW UP ON STRINGS
  050B'   CD 0450'              	CALL	CONIS			;TRY TO CONVERT THE NUMBER TO AN INTEGER
                                					;IF WE CAN'T, WE WILL RETURN HERE TO GIVE A
                                					; SINGLE PRECISION RESULT
  050E'   21 0000*              INT:	LXI	H,FAC			;GET EXPONENT
  0511'   7E                    	MOV	A,M
  0512'   FE 98                 	CPI	230O			;SEE IF NUMBER HAS ANY FRACTIONAL BITS
                                
                                					;THE ONLY GUY WHO NEEDS THIS DOESN'T CARE
  0514'   3A 0000*              	LDA	FACLO			; ABOUT THE SIGN
  0517'   D0                    	RNC				;IT DOES NOT
  0518'   7E                    	MOV	A,M			;GET EXPONENT BACK
  0519'   CD 04C3'              	CALL	QINT			;IT DOES, SHIFT THEM OUT
  051C'   36 98                 	MVI	M,230O			;CHANGE EXPONENT SO IT WILL BE CORRECT
                                					;NOTE:QINT UNPACKED THE NUMBER!!!!
                                					; AFTER NORMALIZATION
  051E'   7B                    	MOV	A,E			;GET LO
  051F'   F5                    	PUSH	PSW			;SAVE IT
  0520'   79                    	MOV	A,C			;NEGATE NUMBER IF IT IS NEGATIVE
  0521'   17                    	RAL				;PUT SIGN IN CARRY
  0522'   CD 005E'              	CALL	FADFLT			;REFLOAT NUMBER
  0525'   F1                    	POP	PSW			;GET LO BACK
  0526'   C9                    	RET				;ALL DONE
                                
                                
                                					;GREATEST INTEGER FUNCTION FOR DOUBLE PRECISION NUMBERS
                                					;ALTERS A,B,C,D,E,H,L
  0527'   21 0000*              DINT:	LXI	H,FAC			;GET POINTER TO FAC
  052A'   7E                    	MOV	A,M			;GET EXPONENT
  052B'   FE 90                 	CPI	220O			;CAN WE CONVERT IT TO AN INTEGER?
  052D'   C2 054B'              DIN00:	JNZ	DINT2			;CHECK FOR -32768
  0530'   4F                    	MOV	C,A			;SAVE EXPONENT IN C
  0531'   2B                    	DCX	H			;GET POINTER TO SIGN AND HO
  0532'   7E                    	MOV	A,M			;GET SIGN AND HO
  0533'   EE 80                 	XRI	200O			;CHECK IF IT IS 200
  0535'   06 06                 	MVI	B,6			;SET UP A COUNT TO CHECK IF THE REST OF
  0537'   2B                    DINT1:	DCX	H			; THE NUMBER IS ZERO, POINT TO NEXT BYTE
  0538'   B6                    	ORA	M			;IF ANY BITS ARE NON-ZERO, A WILL BE NON-ZERO
  0539'   05                    	DCR	B			;ARE WE DONE?
  053A'   C2 0537'              	JNZ	DINT1			;NO, CHECK THE NEXT LOWER ORDER BYTE
  053D'   B7                    	ORA	A			;IS A NOW ZERO?
  053E'   21 8000               	LXI	H,200O*400O+0		;GET -32768 JUST IN CASE
  0541'   C2 054A'              	JNZ	DIN05
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-26
GREATEST INTEGER FUNCTION

  0544'   CD 045D'              	CALL	MAKINT			;A IS ZERO SO WE HAVE -32768
  0547'   C3 04A1'              	JMP	FRCDBL			;FORCE BACK TO DOUBLE
  054A'   79                    DIN05:	MOV	A,C			;GET EXPONENT
                                	PUBLIC	DINT2
  054B'   B7                    DINT2:	ORA	A			;CHECK FOR ZERO VALUE
  054C'   C8                    	RZ				;***FIX 5.11***^1 -- ALALOW 0 IN DINT
  054D'   FE B8                 	CPI	270O			;ARE THERE ANY FRACTIONAL BITS?
  054F'   D0                    	RNC				;NO, THE NUMBER IS ALREADY AN INTEGER
                                
                                	PUBLIC	DINTFO
  0550'   F5                    DINTFO:	PUSH	PSW			;ENTRY FROM FOUT, CARRY IS ZERO IF WE COME
                                					; HERE FROM FOUT
  0551'   CD 0335'              	CALL	MOVRF			;GET HO'S OF NUMBER IN REGISTERS FOR UNPACKING
  0554'   CD 0357'              	CALL	UNPACK			;UNPACK IT
  0557'   AE                    	XRA	M			;GET ITS SIGN BACK
  0558'   2B                    	DCX	H			;SET THE EXPONENT TO NORMALIZE CORRECTLY
  0559'   36 B8                 	MVI	M,270O
  055B'   F5                    	PUSH	PSW			;SAVE THE SIGN
  055C'   2B                    	DCX	H
  055D'   71                    	MOV	M,C			;GET UNPACKED HIGH BYTE
  055E'   FC 057B'              	CM	DINTA			;SUBTRACT 1 FROM LO IF NUMBER IS NEGATIVE
  0561'   3A FFFF*              	LDA	FAC-1			;FETCH NEW HIGH MANTISSA BYTE
  0564'   4F                    	MOV	C,A			;AND PUT IN C
  0565'   21 FFFF*              	LXI	H,FAC-1			;POINT TO THE HO OF THE FAC
  0568'   3E B8                 	MVI	A,270O			;GET HOW MANY BITS WE HAVE TO SHIFT OUT
  056A'   90                    	SUB	B
  056B'   CD 07A6'              	CALL	DSHFTR			;SHIFT THEM OUT!!
  056E'   F1                    	POP	PSW			;GET THE SIGN BACK
  056F'   FC 075E'              	CM	DROUNA			;IF NUMBER WAS NEGATIVE, ADD ONE
  0572'   AF                    	XRA	A			;PUT A ZERO IN THE EXTRA LO BYTE SO WHEN
  0573'   32 FFFF*              	STA	DFACLO-1		; WE NORMALIZE, WE WILL SHIFT IN ZEROS
  0576'   F1                    	POP	PSW			;IF WE WERE CALLED FROM FOUT, DON'T NORMALIZE,
  0577'   D0                    	RNC				; JUST RETURN
  0578'   C3 0712'              	JMP	DNORML			;RE-FLOAT THE INTEGER
                                
  057B'   21 0000*              DINTA:	LXI	H,DFACLO		;SUBTRACT ONE FROM FAC, GET POINTER TO LO
  057E'   7E                    DINTA1:	MOV	A,M			;GET A BYTE OF FAC
  057F'   35                    	DCR	M			;SUBTRACT ONE FROM IT
  0580'   B7                    	ORA	A			;CONTINUE ONLY IF THE BYTE USED TO BE ZERO
  0581'   23                    	INX	H			;INCREMENT POINTER TO NEXT BYTE
  0582'   CA 057E'              	JZ	DINTA1			;CONTINUE IF NECESSARY
  0585'   C9                    	RET				;ALL DONE
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-27
GREATEST INTEGER FUNCTION

                                
                                	SUBTTL	INTEGER ARITHMETIC ROUTINES
                                					;INTEGER MULTIPLY FOR MULTIPLY DIMENSIONED ARRAYS
                                					; (DE):=(BC)*(DE)
                                					;OVERFLOW CAUSES A BS ERROR
                                					;ALTERS A,B,C,D,E
  0586'   E5                    UMULT:	PUSH	H			;SAVE [H,L]
  0587'   21 0000               	LXI	H,0			;ZERO PRODUCT REGISTERS
  058A'   78                    	MOV	A,B			;CHECK IF (BC) IS ZERO
  058B'   B1                    	ORA	C			;IF SO, JUST RETURN, (HL) IS ALREADY ZERO
  058C'   CA 05A3'              	JZ	MULRET			;THIS IS DONE FOR SPEED
  058F'   3E 10                 	MVI	A,20O			;SET UP A COUNT
  0591'   29                    UMULT1:	DAD	H			;ROTATE (HL) LEFT ONE
  0592'   DA 0000*              	JC	BSERR			;CHECK FOR OVERFLOW, IF SO,
  0595'   EB                    	XCHG				; BAD SUBSCRIPT (BS) ERROR
  0596'   29                    	DAD	H			;ROTATE (DE) LEFT ONE
  0597'   EB                    	XCHG	
  0598'   D2 059F'              	JNC	UMULT2			;ADD IN (BC) IF HO WAS 1
  059B'   09                    	DAD	B
  059C'   DA 0000*              	JC	BSERR			;CHECK FOR OVERFLOW
  059F'   3D                    UMULT2:	DCR	A			;SEE IF DONE
  05A0'   C2 0591'              	JNZ	UMULT1
  05A3'   EB                    MULRET:	XCHG				;RETURN THE RESULT IN [D,E]
  05A4'   E1                    	POP	H			;GET BACK THE SAVED [H,L]
  05A5'   C9                    	RET	
                                
                                
                                ;
                                ;	INTEGER ARITHMETIC CONVENTIONS
                                ;
                                ;INTEGER VARIABLES ARE 2 BYTE, SIGNED NUMBERS
                                ;	THE LO BYTE COMES FIRST IN MEMORY
                                ;
                                ;CALLING CONVENTIONS:
                                ;FOR ONE ARGUMENT FUNCTIONS:
                                ;	THE ARGUMENT IS IN (HL), THE RESULT IS LEFT IN (HL)
                                ;FOR TWO ARGUMENT OPERATIONS:
                                ;	THE FIRST ARGUMENT IS IN (DE)
                                ;	THE SECOND ARGUMENT IS IN (HL)
                                ;	THE RESULT IS LEFT IN THE FAC AND IF NO OVERFLOW, (HL)
                                ;IF OVERFLOW OCCURS, THE ARGUMENTS ARE CONVERTED TO SINGLE PRECISION
                                ;WHEN INTEGERS ARE STORED IN THE FAC, THEY ARE STORED AT FACLO+0,1
                                ;VALTYP(INTEGER)=2
                                ;%
                                
                                
                                					;INTEGER SUBTRTACTION	(HL):=(DE)-(HL)
                                					;ALTERS A,B,C,D,E,H,L
  05A6'   7C                    ISUB:	MOV	A,H			;EXTEND THE SIGN OF (HL) TO B
  05A7'   17                    	RAL				;GET SIGN IN CARRY
  05A8'   9F                    	SBB	A
  05A9'   47                    	MOV	B,A
  05AA'   CD 066F'              	CALL	INEGHL			;NEGATE (HL)
  05AD'   79                    	MOV	A,C			;GET A ZERO
  05AE'   98                    	SBB	B			;NEGATE SIGN
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-28
INTEGER ARITHMETIC ROUTINES

  05AF'   C3 05B5'              	JMP	IADDS			;GO ADD THE NUMBERS
                                
                                
                                					;INTEGER ADDITION	(HL):=(DE)+(HL)
                                					;ALTERS A,B,C,D,E,H,L
  05B2'   7C                    IADD:	MOV	A,H			;EXTEND THE SIGN OF (HL) TO B
  05B3'   17                    	RAL				;GET SIGN IN CARRY
  05B4'   9F                    	SBB	A
  05B5'   47                    IADDS:	MOV	B,A			;SAVE THE SIGN
  05B6'   E5                    	PUSH	H			;SAVE THE SECOND ARGUMENT IN CASE OF OVERFLOW
  05B7'   7A                    	MOV	A,D			;EXTEND THE SIGN OF (DE) TO A
  05B8'   17                    	RAL				;GET SIGN IN CARRY
  05B9'   9F                    	SBB	A
  05BA'   19                    	DAD	D			;ADD THE TWO LO'S
  05BB'   88                    	ADC	B			;ADD THE EXTRA HO
  05BC'   0F                    	RRC				;IF THE LSB OF A IS DIFFERENT FROM THE MSB OF
  05BD'   AC                    	XRA	H			; H, THEN OVERFLOW OCCURED
  05BE'   F2 045C'              	JP	CONIS1			;NO OVERFLOW, GET OLD (HL) OFF STACK AND WE
                                					; ARE DONE, SAVE (HL) IN THE FAC ALSO
  05C1'   C5                    	PUSH	B			;OVERFLOW -- SAVE EXTENDED SIGN OF (HL)
  05C2'   EB                    	XCHG				;GET (DE) IN (HL)
  05C3'   CD 0495'              	CALL	CONSIH			;FLOAT IT
  05C6'   F1                    	POP	PSW			;GET SIGN OF (HL) IN A
  05C7'   E1                    	POP	H			;GET OLD (HL) BACK
  05C8'   CD 031A'              	CALL	PUSHF			;PUT FIRST ARGUMENT ON STACK
  05CB'   EB                    	XCHG				;PUT SECOND ARGUMENT IN (DE) FOR FLOATR
  05CC'   CD 0689'              	CALL	INEGAD			;FLOAT IT
  05CF'   C3 0AD3'              	JMP	FADDT			;ADD THE TWO NUMBERS USING SINGLE PRECISION
                                
                                
                                					;INTEGER MULTIPLICATION		(HL):=(DE)*(HL)
                                					;ALTERS A,B,C,D,E,H,L
  05D2'   7C                    IMULT:	MOV	A,H			;CHECK (HL) IF IS ZERO, IF SO
  05D3'   B5                    	ORA	L			; JUST RETURN.  THIS IS FOR SPEED.
  05D4'   CA 045D'              	JZ	MAKINT			;UPDATE FACLO TO BE ZERO AND RETURN
  05D7'   E5                    	PUSH	H			;SAVE SECOND ARGUMENT IN CASE OF OVERFLOW
  05D8'   D5                    	PUSH	D			;SAVE FIRST ARGUMENT
  05D9'   CD 0663'              	CALL	IMULDV			;FIX UP THE SIGNS
  05DC'   C5                    	PUSH	B			;SAVE THE SIGN OF THE RESULT
  05DD'   44                    	MOV	B,H			;COPY SECOND ARGUMENT INTO (BC)
  05DE'   4D                    	MOV	C,L
  05DF'   21 0000               	LXI	H,0			;ZERO (HL), THAT IS WHERE THE PRODUCT GOES
  05E2'   3E 10                 	MVI	A,20O			;SET UP A COUNT
  05E4'   29                    IMULT1:	DAD	H			;ROTATE PRODUCT LEFT ONE
  05E5'   DA 060A'              	JC	IMULT5			;CHECK FOR OVERLFOW
  05E8'   EB                    	XCHG				;ROTATE FIRST ARGUMENT LEFT ONE TO SEE IF
  05E9'   29                    	DAD	H			; WE ADD IN (BC) OR NOT
  05EA'   EB                    	XCHG	
  05EB'   D2 05F2'              	JNC	IMULT2			;DON'T ADD IN ANYTHING
  05EE'   09                    	DAD	B			;ADD IN (BC)
  05EF'   DA 060A'              	JC	IMULT5			;CHECK FOR OVERLFOW
  05F2'   3D                    IMULT2:	DCR	A			;ARE WE DONE?
  05F3'   C2 05E4'              	JNZ	IMULT1			;NO, DO IT AGAIN
  05F6'   C1                    	POP	B			;WE ARE DONE, GET SIGN OF RESULT
  05F7'   D1                    	POP	D			;GET ORIGINAL FIRST ARGUMENT
  05F8'   7C                    IMLDIV:	MOV	A,H			;ENTRY FROM IDIV, IS RESULT .GE. 32768?
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-29
INTEGER ARITHMETIC ROUTINES

  05F9'   B7                    	ORA	A
  05FA'   FA 0602'              	JM	IMULT3			;IT IS, CHECK FOR SPECIAL CASE OF -32768
  05FD'   D1                    	POP	D			;RESULT IS OK, GET SECOND ARGUMENT OFF STACK
  05FE'   78                    	MOV	A,B			;GET THE SIGN OF RESULT IN A
  05FF'   C3 066B'              	JMP	INEGA			;NEGATE THE RESULT IF NECESSARY
  0602'   EE 80                 IMULT3:	XRI	200O			;IS RESULT 32768?
  0604'   B5                    	ORA	L			;NOTE: IF WE GET HERE FROM IDIV, THE RESULT
  0605'   CA 061B'              	JZ	IMULT4			; MUST BE 32768, IT CANNOT BE GREATER
  0608'   EB                    	XCHG				;IT IS .GT. 32768, WE HAVE OVERFLOW
  0609'   01                    	DB	001			;"LXI	B" OVER NEXT 2 BYTES
  060A'   C1                    IMULT5:	POP	B			;GET SIGN OF RESULT OFF STACK
  060B'   E1                    	POP	H			;GET THE ORIGINAL FIRST ARGUMENT
  060C'   CD 0495'              	CALL	CONSIH			;FLOAT IT
  060F'   E1                    	POP	H			;GET THE ORIGINAL SECOND ARGUMENT
  0610'   CD 031A'              	CALL	PUSHF			;SAVE FLOATED FIRST ARUMENT
  0613'   CD 0495'              	CALL	CONSIH			;FLOAT SECOND ARGUMENT
  0616'   C1                    FMULTT:	POP	B
  0617'   D1                    	POP	D
                                					;GET FIRST ARGUMENT OFF STACK, ENTRY FROM POLYX
  0618'   C3 018A'              	JMP	FMULT			;MULTIPLY THE ARGUMENTS USING SINGLE PRECISION
  061B'   78                    IMULT4:	MOV	A,B			;IS RESULT +32768 OR -32768?
  061C'   B7                    	ORA	A			;GET ITS SIGN
  061D'   C1                    	POP	B			;DISCARD ORIGINAL SECOND ARGUMENT
  061E'   FA 045D'              	JM	MAKINT			;THE RESULT SHOULD BE NEGATIVE, IT IS OK
  0621'   D5                    	PUSH	D			;IT IS POSITIVE, SAVE REMAINDER FOR MOD
  0622'   CD 0495'              	CALL	CONSIH			;FLOAT -32768
  0625'   D1                    	POP	D			;GET MOD'S REMAINDER BACK
  0626'   C3 02F5'              	JMP	NEG			;NEGATE -32768 TO GET 32768, WE ARE DONE
                                
                                
                                					;INTEGER DIVISION	(HL):=(DE)/(HL)
                                					;REMAINDER IS IN (DE), QUOTIENT IN (HL)
                                					;ALTERS A,B,C,D,E,H,L
  0629'   7C                    IDIV:	MOV	A,H			;CHECK FOR DIVISION BY ZERO
  062A'   B5                    	ORA	L
  062B'   CA 0000*              	JZ	DV0ERR			;WE HAVE DIVISION BY ZERO!!
  062E'   CD 0663'              	CALL	IMULDV			;FIX UP THE SIGNS
  0631'   C5                    	PUSH	B			;SAVE THE SIGN OF THE RESULT
  0632'   EB                    	XCHG				;GET DENOMINATOR IN (HL)
  0633'   CD 066F'              	CALL	INEGHL			;NEGATE IT
  0636'   44                    	MOV	B,H			;SAVE NEGATED DENOMINATOR IN (BC)
  0637'   4D                    	MOV	C,L
  0638'   21 0000               	LXI	H,0			;ZERO WHERE WE DO THE SUBTRACTION
  063B'   3E 11                 	MVI	A,21O			;SET UP A COUNT
  063D'   F5                    	PUSH	PSW			;SAVE IT
  063E'   B7                    	ORA	A			;CLEAR CARRY 
  063F'   C3 064C'              	JMP	IDIV3			;GO DIVIDE
  0642'   F5                    IDIV1:	PUSH	PSW			;SAVE COUNT
  0643'   E5                    	PUSH	H			;SAVE (HL) I.E. CURRENT NUMERATOR
  0644'   09                    	DAD	B			;SUBTRACT DENOMINATOR
  0645'   D2 064B'              	JNC	IDIV2			;WE SUBTRACTED TOO MUCH, GET OLD (HL) BACK
  0648'   F1                    	POP	PSW			;THE SUBTRACTION WAS GOOD, DISCARD OLD (HL)
  0649'   37                    	STC				;NEXT BIT IN QUOTIENT IS A ONE
  064A'   3E                    	DB	076O			;"MVI	A" OVER NEXT BYTE
  064B'   E1                    IDIV2:	POP	H			;IGNORE THE SUBTRACTION, WE COULDN'T DO IT
  064C'   7B                    IDIV3:	MOV	A,E			;SHIFT IN THE NEXT QUOTIENT BIT
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-30
INTEGER ARITHMETIC ROUTINES

  064D'   17                    	RAL	
  064E'   5F                    	MOV	E,A
  064F'   7A                    	MOV	A,D			;SHIFT THE HO
  0650'   17                    	RAL	
  0651'   57                    	MOV	D,A
  0652'   7D                    	MOV	A,L			;SHIFT IN THE NEXT BIT OF THE NUMERATOR
  0653'   17                    	RAL	
  0654'   6F                    	MOV	L,A
  0655'   7C                    	MOV	A,H			;DO THE HO
  0656'   17                    	RAL	
  0657'   67                    	MOV	H,A			;SAVE THE HO
  0658'   F1                    	POP	PSW			;GET COUNT BACK
  0659'   3D                    	DCR	A			;ARE WE DONE?
  065A'   C2 0642'              	JNZ	IDIV1			;NO, DIVIDE AGAIN
  065D'   EB                    	XCHG				;GET QUOTIENT IN (HL), REMAINDER IN (DE)
  065E'   C1                    	POP	B			;GET SIGN OF RESULT
  065F'   D5                    	PUSH	D			;SAVE REMAINDER SO STACK WILL BE ALRIGHT
  0660'   C3 05F8'              	JMP	IMLDIV			;CHECK FOR SPECIAL CASE OF 32768
                                
                                
                                					;GET READY TO MULTIPLY OR DIVIDE
                                					;ALTERS A,B,C,D,E,H,L
  0663'   7C                    IMULDV:	MOV	A,H			;GET SIGN OF RESULT
  0664'   AA                    	XRA	D
  0665'   47                    	MOV	B,A			;SAVE IT IN B
  0666'   CD 066A'              	CALL	INEGH			;NEGATE SECOND ARGUMENT IF NECESARY
  0669'   EB                    	XCHG				;PUT (DE) IN (HL), FALL IN AND NEGATE FIRST
                                					; ARGUMENT IF NECESSARY
                                
                                
                                					;NEGATE H,L
                                					;ALTERS A,C,H,L
  066A'   7C                    INEGH:	MOV	A,H			;GET SIGN OF (HL)
  066B'   B7                    INEGA:	ORA	A			;SET CONDITION CODES
  066C'   F2 045D'              	JP	MAKINT			;WE DON'T HAVE TO NEGATE, IT IS POSITIVE
                                					;SAVE THE RESULT IN THE FAC FOR WHEN
                                					; OPERATORS RETURN THROUGH HERE
  066F'   AF                    INEGHL:	XRA	A			;CLEAR A
  0670'   4F                    	MOV	C,A			;STORE A ZERO (WE USE THIS METHOD FOR ISUB)
  0671'   95                    	SUB	L			;NEGATE LO
  0672'   6F                    	MOV	L,A			;SAVE IT
  0673'   79                    	MOV	A,C			;GET A ZERO BACK
  0674'   9C                    	SBB	H			;NEGATE HO
  0675'   67                    	MOV	H,A			;SAVE IT
  0676'   C3 045D'              	JMP	MAKINT			;ALL DONE, SAVE THE RESULT IN THE FAC
                                					; FOR WHEN OPERATORS RETURN THROUGH HERE
                                
                                
                                					;INTEGER NEGATION
                                					;ALTERS A,B,C,D,E,H,L
  0679'   2A 0000*              INEG:	LHLD	FACLO			;GET THE INTEGER
  067C'   CD 066F'              	CALL	INEGHL			;NEGATE IT
  067F'   7C                    	MOV	A,H			;GET THE HIGH ORDER
  0680'   EE 80                 	XRI	200O			;CHECK FOR SPECIAL CASE OF 32768
  0682'   B5                    	ORA	L
  0683'   C0                    	RNZ				;IT DID NOT OCCUR, EVERYTHING IS FINE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-31
INTEGER ARITHMETIC ROUTINES

                                	PUBLIC	INEG2
  0684'   EB                    INEG2:	XCHG				;WE HAVE IT, FLOAT 32768
  0685'   CD 04B7'              	CALL	VALSNG			;CHANGE VALTYP TO "SINGLE PRECISION"
  0688'   AF                    	XRA	A			;GET A ZERO FOR THE HIGH ORDER
  0689'   06 98                 INEGAD:	MVI	B,230O			;ENTRY FROM IADD, SET EXPONENT
  068B'   C3 02DA'              	JMP	FLOATR			;GO FLOAT THE NUMBER
                                
                                
                                					;MOD OPERATOR
                                					;(HL):=(DE)-(DE)/(HL)*(HL),  (DE)=QUOTIENT
                                					;ALTERS A,B,C,D,E,H,L
  068E'   D5                    IMOD:	PUSH	D			;SAVE (DE) FOR ITS SIGN
  068F'   CD 0629'              	CALL	IDIV			;DIVIDE AND GET THE REMAINDER
  0692'   AF                    	XRA	A			;TURNOFF THE CARRY AND TRANFER
  0693'   82                    	ADD	D			;THE REMAINDER*2 WHICH IS IN [D,E]
  0694'   1F                    	RAR				;TO [H,L] DIVIDING BY TWO
  0695'   67                    	MOV	H,A
  0696'   7B                    	MOV	A,E
  0697'   1F                    	RAR	
  0698'   6F                    	MOV	L,A			; ***WHG01*** FIX TO MOD OPERATOR
  0699'   CD 0460'              	CALL	VALINT			;SET VALTYP TO "INTEGER" IN CASE RESULT OF
                                					; THE DIVISION WAS 32768
  069C'   F1                    	POP	PSW			;GET THE SIGN OF THE REMAINDER BACK
  069D'   C3 066B'              	JMP	INEGA			;NEGATE THE REMAINDER IF NECESSARY
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	2-32
INTEGER ARITHMETIC ROUTINES

                                
                                
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3
DOUBLE PRECISION ARITHMETIC ROUTINES

                                	SUBTTL	DOUBLE PRECISION ARITHMETIC ROUTINES
                                ;
                                ;	DOUBLE PRECISION ARITHMETIC CONVENTIONS
                                ;
                                ;DOUBLE PRECISION NUMBERS ARE 8 BYTE QUANTITIES
                                ;THE LAST 4 BYTES IN MEMORY ARE IN THE SAME FORMAT AS SINGLE PRECISION NUMBERS
                                ;THE FIRST 4 BYTES ARE 32 MORE LOW ORDER BITS OF PRECISION
                                ;THE LOWEST ORDER BYTE COMES FIRST IN MEMORY
                                ;
                                ;CALLING CONVENTIONS:
                                ;FOR ONE ARGUMENT FUNCTIONS:
                                ;	THE ARGUMENT IS IN THE FAC, THE RESULT IS LEFT IN THE FAC
                                ;FOR TWO ARGUMENT OPERATIONS:
                                ;	THE FIRST ARGUMENT IS IN THE FAC
                                ;	THE SECOND ARGUMENT IS IN ARG-7,6,5,4,3,2,1,0  (NOTE: ARGLO=ARG-7)
                                ;	THE RESULT IS LEFT IN THE FAC
                                ;NOTE:	THIS ORDER IS REVERSED FROM INT AND SNG
                                ;VALTYP(DOUBLE PRECISION)=10 OCTAL
                                ;%
                                
                                
                                					;DOUBLE PRECISION SUBTRACTION	FAC:=FAC-ARG
                                					;ALTERS ALL REGISTERS
  06A0'   21 FFFF*              DSUB:	LXI	H,ARG-1			;NEGATE THE SECOND ARGUMENT
  06A3'   7E                    	MOV	A,M			;GET THE HO AND SIGN
  06A4'   EE 80                 	XRI	200O			;COMPLEMNT THE SIGN
  06A6'   77                    	MOV	M,A			;PUT IT BACK
                                					;FALL INTO DADD
                                
                                
                                					;DOUBLE PRECISION ADDITION	FAC:=FAC+ARG
                                					;ALTERS ALL REGISTERS
  06A7'   21 0000*              DADD:	LXI	H,ARG			;GET  POINTER TO EXPONENT OF FIRST ARGUMENT
  06AA'   7E                    	MOV	A,M			;CHECK IF IT IS ZERO
  06AB'   B7                    	ORA	A
  06AC'   C8                    	RZ				;IT IS, RESULT IS ALREADY IN FAC
  06AD'   47                    	MOV	B,A			;SAVE EXPONENT FOR UNPACKING
  06AE'   2B                    	DCX	H			;POINT TO HO AND SIGN
  06AF'   4E                    	MOV	C,M			;GET HO AND SIGN FOR UNPACKING
  06B0'   11 0000*              	LXI	D,FAC			;GET POINTER TO EXPONENT OF SECOND ARGUMENT
  06B3'   1A                    	LDAX	D			;GET EXPONENT
  06B4'   B7                    	ORA	A			;SEE IF IT IS ZERO
  06B5'   CA 036C'              	JZ	VMOVFA			;IT IS, MOVE ARG TO FAC AND WE ARE DONE
  06B8'   90                    	SUB	B			;SUBTRACT EXPONENTS TO GET SHIFT COUNT
  06B9'   D2 06D3'              	JNC	DADD2			;PUT THE SMALLER NUMBER IN FAC
  06BC'   2F                    	CMA				;NEGATE SHIFT COUNT
  06BD'   3C                    	INR	A
  06BE'   F5                    	PUSH	PSW			;SAVE SHIFT COUNT
  06BF'   0E 08                 	MVI	C,10O			;SWITCH FAC AND ARG, SET UP A COUNT
  06C1'   23                    	INX	H			;POINT TO ARG
  06C2'   E5                    	PUSH	H			;SAVE POINTER TO ARG
  06C3'   1A                    DADD1:	LDAX	D			;GET A BYTE OF THE FAC
  06C4'   46                    	MOV	B,M			;GET A BYTE OF ARG
  06C5'   77                    	MOV	M,A			;PUT THE FAC BYTE IN ARG
  06C6'   78                    	MOV	A,B			;PUT THE ARG BYTE IN A
  06C7'   12                    	STAX	D			;PUT THE ARG BYTE IN FAC
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-1
DOUBLE PRECISION ARITHMETIC ROUTINES

  06C8'   1B                    	DCX	D			;POINT TO THE NEXT LO BYTE OF FAC
  06C9'   2B                    	DCX	H			;POINT TO THE NEXT LO BYTE OF ARG
  06CA'   0D                    	DCR	C			;ARE WE DONE?
  06CB'   C2 06C3'              	JNZ	DADD1			;NO, DO THE NEXT LO BYTE
  06CE'   E1                    	POP	H			;GET THE HO BACK
  06CF'   46                    	MOV	B,M			;GET THE EXPONENT
  06D0'   2B                    	DCX	H			;POINT TO THE HO AND SIGN
  06D1'   4E                    	MOV	C,M			;GET HO AND SIGN FOR UNPACKING
  06D2'   F1                    	POP	PSW			;GET THE SHIFT COUNT BACK
  06D3'   FE 39                 DADD2:	CPI	71O			;ARE WE WITHIN 56 BITS?
  06D5'   D0                    	RNC				;NO, ALL DONE
  06D6'   F5                    	PUSH	PSW			;SAVE SHIFT COUNT
  06D7'   CD 0357'              	CALL	UNPACK			;UNPACK THE NUMBERS
  06DA'   21 FFFF*              	LXI	H,ARGLO-1		;POINT TO ARGLO-1
  06DD'   47                    	MOV	B,A			;SAVE SUBTRACTION FLAG
  06DE'   3E 00                 	MVI	A,0			;
  06E0'   77                    	MOV	M,A			;CLEAR TEMPORARY LEAST SIG BYTE
  06E1'   32 FFFF*              	STA	DFACLO-1		;CLEAR EXTRA BYTE
  06E4'   F1                    	POP	PSW			;GET SHIFT COUNT
  06E5'   21 FFFF*              	LXI	H,ARG-1			;POINT TO THE HO OF ARG
  06E8'   CD 07A6'              	CALL	DSHFTR			;SHIFT ARG RIGHT THE RIGHT NUMBER OF TIMES
  06EB'   3A FFFF*              	LDA	ARGLO-1			;TRANSFER OVERFLOW BYTE
  06EE'   32 FFFF*              	STA	DFACLO-1		;FROM ARG TO FAC
  06F1'   78                    	MOV	A,B
  06F2'   B7                    	ORA	A			;GET SUBTRACTION FLAG
  06F3'   F2 0707'              	JP	DADD3			;SUBTRACT NUMBERS IF THEIR SIGNS ARE DIFFERENT
  06F6'   CD 077B'              	CALL	DADDAA			;SIGNS ARE THE SAME, ADD THE NUMBERS
  06F9'   D2 074C'              	JNC	DROUND			;ROUND THE RESULT IF NO CARRY
  06FC'   EB                    	XCHG				;GET POINTER TO FAC IN (HL)
  06FD'   34                    	INR	M			;ADD 1 TO EXPONENT
  06FE'   CA 0B19'              	JZ	OVFIN4
  0701'   CD 07D2'              	CALL	DSHFRB			;SHIFT NUMBER RIGHT ONE, SHIFT IN CARRY
  0704'   C3 074C'              	JMP	DROUND			;ROUND THE RESULT
  0707'                         DADD3:
  0707'   3E                    	DB	076O			;"MVI	A", SUBTRACT THE NUMBERS
  0708'   9E                    	SBB	M			;GET THE SUBTRACT INSTRUCTION IN A
  0709'   CD 077D'              	CALL	DADDA			;SUBTRACT THE NUMBERS
  070C'   21 0001*              	LXI	H,FAC+1			;FIX [H,L] TO POINT TO SIGN FOR DNEGR
  070F'   DC 0793'              	CC	DNEGR			;NEGATE THE RESULT IF IT WAS NEGATIVE
                                					;FALL INTO DNORML
                                
                                
                                					;NORMALIZE FAC
                                					;ALTERS A,B,C,D,H,L
  0712'   AF                    DNORML:	XRA	A			;CLEAR SHIFT COUNT
  0713'   47                    DNORM1:	MOV	B,A			;SAVE SHIFT COUNT
  0714'   3A FFFF*              	LDA	FAC-1			;GET HO
  0717'   B7                    	ORA	A			;SEE IF WE CAN SHIFT 8 LEFT
  0718'   C2 073B'              	JNZ	DNORM5			;WE CAN'T, SEE IF NUMBER IS NORMALIZED
  071B'   21 FFFF*              	LXI	H,DFACLO-1		;WE CAN, GET POINTER TO LO
  071E'   0E 08                 	MVI	C,10O			;SET UP A COUNT
  0720'   56                    DNORM2:	MOV	D,M			;GET A BYTE OF FAC
  0721'   77                    	MOV	M,A			;PUT IN BYTE FROM LAST LOCATION, THE FIRST
                                					; TIME THROUGH A IS ZERO
  0722'   7A                    	MOV	A,D			;PUT THE CURRENT BYTE IN A FOR NEXT TIME
  0723'   23                    	INX	H			;INCREMENT POINTER TO NEXT HIGHER ORDER
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-2
DOUBLE PRECISION ARITHMETIC ROUTINES

  0724'   0D                    	DCR	C			;ARE WE DONE?
  0725'   C2 0720'              	JNZ	DNORM2			;NO, DO THE NEXT BYTE
  0728'   78                    	MOV	A,B			;SUBTRACT 8 FROM SHIFT COUNT
  0729'   D6 08                 	SUI	10O
  072B'   FE C0                 	CPI	300O			;HAVE WE SHIFTED ALL BYTES TO ZERO?
  072D'   C2 0713'              	JNZ	DNORM1			;NO, TRY TO SHIFT 8 MORE
  0730'   C3 0076'              	JMP	ZERO			;YES, THE NUMBER IS ZERO
  0733'   05                    DNORM3:	DCR	B			;DECREMENT SHIFT COUNT
  0734'   21 FFFF*              	LXI	H,DFACLO-1		;GET POINTER TO LO
  0737'   CD 07DA'              	CALL	DSHFLC			;SHIFT THE FAC LEFT
  073A'   B7                    	ORA	A			;SEE IF NUMBER IS NORMALIZED
  073B'   F2 0733'              DNORM5:	JP	DNORM3			;SHIFT FAC LEFT ONE IF IT IS NOT NORMALIZED
  073E'   78                    	MOV	A,B			;GET THE SHIFT COUNT
  073F'   B7                    	ORA	A			;SEE IF NO SHIFTING WAS DONE
  0740'   CA 074C'              	JZ	DROUND			;NONE WAS, PROCEED TO ROUND THE NUMBER
  0743'   21 0000*              	LXI	H,FAC			;GET POINTER TO EXPONENT
  0746'   86                    	ADD	M			;UPDATE IT
  0747'   77                    	MOV	M,A			;SAVE UPDATED EXPONENT
  0748'   D2 0076'              	JNC	ZERO			;UNDERFLOW, THE RESULT IS ZERO
  074B'   C8                    	RZ				;RESULT IS ALREADY ZERO, WE ARE DONE
                                					;FALL INTO DROUND AND ROUND THE RESULT
                                
                                
                                					;ROUND FAC
                                					;ALTERS A,B,H,L
  074C'   3A FFFF*              DROUND:	LDA	DFACLO-1		;GET EXTRA BYTE TO SEE IF WE HAVE TO ROUND
  074F'   B7                    DROUNB:	ORA	A			;ENTRY FROM DDIV
  0750'   FC 075E'              	CM	DROUNA			;ROUND UP IF NECESSARY
  0753'   21 0001*              	LXI	H,FAC+1			;GET POINTER TO UNPACKED SIGN
  0756'   7E                    	MOV	A,M			;GET SIGN
  0757'   E6 80                 	ANI	200O			;ISOLATE SIGN BIT
  0759'   2B                    	DCX	H			;POINT TO HO
  075A'   2B                    	DCX	H
  075B'   AE                    	XRA	M			;PACK SIGN AND HO
  075C'   77                    	MOV	M,A			;PUT PACKED SIGN AND HO IN FAC
  075D'   C9                    	RET				;WE ARE DONE
                                
                                
                                
                                					;SUBROUTINE FOR ROUND: ADD ONE TO FAC
  075E'   21 0000*              DROUNA:	LXI	H,DFACLO		;GET POINTER TO LO, ENTRY FROM DINT
  0761'   06 07                 	MVI	B,7			;SET UP A COUNT
  0763'   34                    DRONA1:	INR	M			;INCREMENT A BYTE
  0764'   C0                    	RNZ				;RETURN IF THERE WAS NO CARRY
  0765'   23                    	INX	H			;INCREMENT POINTER TO NEXT HIGHER ORDER
  0766'   05                    	DCR	B			;HAVE WE INCREMENTED ALL BYTES
  0767'   C2 0763'              	JNZ	DRONA1			;NO, TRY THE NEXT ONE
  076A'   34                    	INR	M			;YES, INCREMENT THE EXPONENT
  076B'   CA 0B19'              	JZ	OVFIN4
  076E'   2B                    	DCX	H			;THE NUMBER OVERFLOWED ITS EXPONENT
  076F'   36 80                 	MVI	M,200O			;PUT 200 IN HO
  0771'   C9                    	RET				;ALL DONE
                                
                                
                                					;ADD OR SUBTRACT 2 DBL QUANTITIES
                                					;ALTERS A,C,D,E,H,L
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-3
DOUBLE PRECISION ARITHMETIC ROUTINES

  0772'   11 001B*              DADDD:	LXI	D,FBUFFR+27		;ENTRY FROM DDIV
  0775'   21 0000*              	LXI	H,ARGLO			;ADD OR SUBTRACT FBUFFR+^D27 AND ARG
  0778'   C3 0783'              	JMP	DADDS			;DO THE OPERATION
                                
  077B'   3E                    DADDAA:	DB	076O			;"MVI	A", ENTRY FROM DADD, DMULT
  077C'   8E                    	ADC	M			;SETUP ADD INSTRUCTION FOR LOOP
  077D'   21 0000*              DADDA:	LXI	H,ARGLO			;GET POINTER TO ARG, ENTRY FROM DADD
  0780'   11 0000*              DADDFO:	LXI	D,DFACLO		;GET POINTER TO FAC, ENTRY FROM FOUT
  0783'   0E 07                 DADDS:	MVI	C,7			;SET UP A COUNT
  0785'                         DADDS1:
  0785'   32 078A'              	STA	DADDOP			;STORE THE ADD OR SUBTRACT INSTRUCTION
  0788'   AF                    	XRA	A			;CLEAR CARRY
  0789'   1A                    DADDL:	LDAX	D			;GET A BYTE FROM RESULT NUMBER
  078A'   8E                    DADDOP:	ADC	M			;THIS IS EITHER "ADC	M" OR "SBB	M"
  078B'   12                    	STAX	D			;SAVE THE CHANGED BYTE
  078C'   13                    	INX	D			;INCREMENT POINTERS TO NEXT HIGHER ORDER BYTE
  078D'   23                    	INX	H
  078E'   0D                    	DCR	C			;ARE WE DONE?
  078F'   C2 0789'              	JNZ	DADDL			;NO, DO THE NEXT HIGHER ORDER BYTE
  0792'   C9                    	RET				;ALL DONE
                                
                                
                                
                                
                                					;NEGATE SIGNED NUMBER IN FAC
                                					;THIS IS USED BY DADD, DINT
                                					;ALTERS A,B,C,H,L
  0793'   7E                    DNEGR:	MOV	A,M			;COMPLEMENT SIGN OF FAC
  0794'   2F                    	CMA				;USE THE UNPACKED SIGN BYTE
  0795'   77                    	MOV	M,A			;SAVE THE NEW SIGN
  0796'   21 FFFF*              	LXI	H,DFACLO-1		;GET POINTER TO LO
  0799'   06 08                 	MVI	B,10O			;SET UP A COUNT
  079B'   AF                    	XRA	A			;CLEAR CARRY AND GET A ZERO
  079C'   4F                    	MOV	C,A			;SAVE ZERO IN C
  079D'   79                    DNEGR1:	MOV	A,C			;GET A ZERO
  079E'   9E                    	SBB	M			;NEGATE THE BYTE OF FAC
  079F'   77                    	MOV	M,A			;UPDATE FAC
  07A0'   23                    	INX	H			;INCREMENT POINTER TO NEXT HIGHER ORDER BYTE
  07A1'   05                    	DCR	B			;ARE WE DONE?
  07A2'   C2 079D'              	JNZ	DNEGR1			;NO, NEGATE THE NEXT BYTE
  07A5'   C9                    	RET				;ALL DONE
                                
                                
                                					;SHIFT DBL FAC RIGHT ONE
                                					;A = SHIFT COUNT
                                					;ALTERS A,C,D,E,H,L
  07A6'   71                    DSHFTR:	MOV	M,C			;PUT THE UNPACKED HO BACK
  07A7'   E5                    	PUSH	H			;SAVE POINTER TO WHAT TO SHIFT
  07A8'   D6 08                 DSHFR1:	SUI	10O			;SEE IF WE CAN SHIFT 8 RIGHT
  07AA'   DA 07BD'              	JC	DSHFR3			;WE CAN'T, CHECK IF WE ARE DONE
  07AD'   E1                    	POP	H			;GET POINTER BACK
  07AE'   E5                    DSHFRM:	PUSH	H			;ENTRY FROM DMULT, SAVE POINTER TO HO
  07AF'   11 0800               	LXI	D,10O*400O+0		;SHIFT A ZERO INTO THE HO, SET UP A COUNT
  07B2'   4E                    DSHFR2:	MOV	C,M			;SAVE A BYTE OF FAC
  07B3'   73                    	MOV	M,E			;PUT THE LAST BYTE IN ITS PLACE
  07B4'   59                    	MOV	E,C			;SET UP E FOR NEXT TIME THROUGH THE LOOP
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-4
DOUBLE PRECISION ARITHMETIC ROUTINES

  07B5'   2B                    	DCX	H			;POINT TO NEXT LOWER ORDER BYTE
  07B6'   15                    	DCR	D			;ARE WE DONE?
  07B7'   C2 07B2'              	JNZ	DSHFR2			;NO, DO THE NEXT BYTE
  07BA'   C3 07A8'              	JMP	DSHFR1			;YES, SEE IF WE CAN SHIFT OVER 8 MORE
  07BD'   C6 09                 DSHFR3:	ADI	11O			;CORRECT SHIFT COUNT
  07BF'   57                    	MOV	D,A			;SAVE SHIFT COUNT IN D
  07C0'   AF                    DSHFR4:	XRA	A			;CLEAR CARRY
  07C1'   E1                    	POP	H			;GET POINTER TO HO
  07C2'   15                    	DCR	D			;ARE WE DONE?
  07C3'   C8                    	RZ				;YES
  07C4'   E5                    DSHFRA:	PUSH	H			;NO, SAVE POINTER TO LO, ENTRY FROM DADD, DMULT
  07C5'   1E 08                 	MVI	E,10O			;SET UP A COUNT, ROTATE FAC ONE LEFT
  07C7'   7E                    DSHFR5:	MOV	A,M			;GET A BYTE OF THE FAC
  07C8'   1F                    	RAR				;ROTATE IT LEFT
  07C9'   77                    	MOV	M,A			;PUT THE UPDATED BYTE BACK
  07CA'   2B                    	DCX	H			;DECREMENT POINTER TO NEXT LOWER ORDER BYTE
  07CB'   1D                    	DCR	E			;ARE WE DONE?
  07CC'   C2 07C7'              	JNZ	DSHFR5			;NO, ROTATE THE NEXT LOWER ORDER BYTE
  07CF'   C3 07C0'              	JMP	DSHFR4			;YES, SEE IF WE ARE DONE SHIFTING
                                
                                					;ENTRY TO DSHFTR FROM DADD, DMULT
  07D2'   21 FFFF*              DSHFRB:	LXI	H,FAC-1			;GET POINTER TO HO OF FAC
  07D5'   16 01                 	MVI	D,1			;SHIFT RIGHT ONCE
  07D7'   C3 07C4'              	JMP	DSHFRA			;GO DO IT
                                
                                
                                					;ROTATE FAC LEFT ONE
                                					;ALTERS A,C,H,L
  07DA'   0E 08                 DSHFLC:	MVI	C,10O			;SET UP A COUNT
  07DC'   7E                    DSHFTL:	MOV	A,M			;
  07DD'   17                    	RAL				;ROTATE IT LEFT ONE
  07DE'   77                    	MOV	M,A			;UPDATE BYTE IN FAC
  07DF'   23                    	INX	H			;INCREMENT POINTER TO NEXT HIGHER ORDER BYTE
  07E0'   0D                    	DCR	C			;ARE WE DONE?
  07E1'   C2 07DC'              	JNZ	DSHFTL
  07E4'   C9                    	RET				;ALL DONE
                                
                                
                                					;DOUBLE PRECISION MULTIPLICATION	FAC:=FAC*ARG
                                					;ALTERS ALL REGISTERS
  07E5'   CD 02C6'              DMULT:	CALL	SIGN			;CHECK IF WE ARE MULTIPLYING BY ZERO
  07E8'   C8                    	RZ				;YES, ALL DONE, THE FAC IS ZERO
  07E9'   3A 0000*              	LDA	ARG			;MUST SEE IF ARG IS ZERO
  07EC'   B7                    	ORA	A
  07ED'   CA 0076'              	JZ	ZERO			;RETURN ZERO
                                
  07F0'   CD 027A'              	CALL	MULDVA			;ADD EXPONENTS AND TAKE CARE OF SIGNS
  07F3'   CD 0922'              	CALL	DMULDV			;ZERO FAC AND PUT FAC IN FBUFFR
  07F6'   71                    	MOV	M,C			;PUT UNPACKED HO IN ARG
  07F7'   13                    	INX	D			;GET POINTER TO LO OF ARG
  07F8'   06 07                 	MVI	B,7			;SET UP A COUNT
  07FA'   1A                    DMULT2:	LDAX	D			;GET THE BYTE OF ARG TO MULTIPLY BY
  07FB'   13                    	INX	D			;INCREMENT POINTER TO NEXT HIGHER BYTE
  07FC'   B7                    	ORA	A			;CHECK IF WE ARE MULTIPLYING BY ZERO
  07FD'   D5                    	PUSH	D			;SAVE POINTER TO ARG
  07FE'   CA 081A'              	JZ	DMULT5			;WE ARE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-5
DOUBLE PRECISION ARITHMETIC ROUTINES

  0801'   0E 08                 	MVI	C,10O			;SET UP A COUNT
  0803'   C5                    DMULT3:	PUSH	B			;SAVE COUNTERS
  0804'   1F                    	RAR				;ROTATE MULTIPLIER RIGHT
  0805'   47                    	MOV	B,A			;SAVE IT
  0806'   DC 077B'              	CC	DADDAA			;ADD IN OLD FAC IF BIT OF MULTIPIER WAS ONE
  0809'   CD 07D2'              	CALL	DSHFRB			;ROTATE PRODUCT RIGHT ONE
  080C'   78                    	MOV	A,B			;GET MULTIPLIER IN A
  080D'   C1                    	POP	B			;GET COUNTERS BACK
  080E'   0D                    	DCR	C			;ARE WE DONE WITH THIS BYTE OF ARG?
  080F'   C2 0803'              	JNZ	DMULT3			;NO, MULTIPLY BY THE NEXT BIT OF THE MULTIPLIER
  0812'   D1                    DMULT4:	POP	D			;YES, GET POINTER INTO ARG BACK
  0813'   05                    	DCR	B			;ARE WE DONE?
  0814'   C2 07FA'              	JNZ	DMULT2			;NO, MULTIPLY BY NEXT HIGHER ORDER BY OF ARG
                                					;POINT IS TO RIGHT OF UNDERSTOOD ONE
  0817'   C3 0712'              	JMP	DNORML			;ALL DONE, NORMALIZE AND ROUND RESULT
  081A'   21 FFFF*              DMULT5:	LXI	H,FAC-1			;GET POINTER TO HO OF FAC
  081D'   CD 07AE'              	CALL	DSHFRM			;SHIFT PRODUCT RIGHT ONE BYTE, WE ARE
  0820'   C3 0812'              	JMP	DMULT4			; MULTIPLYIING BY ZERO
                                
                                					;CONSTANT FOR DIV10, DDIV10
  0823'   CD                    TENTH:	DB	315O
  0824'   CC                    	DB	314O
  0825'   CC                    	DB	314O
  0826'   CC                    	DB	314O
  0827'   CC                    	DB	314O
  0828'   CC                    	DB	314O
  0829'   4C                    	DB	114O
  082A'   7D                    	DB	175O
  082B'   00                    DTEN:	DB	000			; 10D0
  082C'   00                    	DB	000
  082D'   00                    	DB	000
  082E'   00                    	DB	000
  082F'   00                    FTEN:	DB	000			; 10.0
  0830'   00                    	DB	000
  0831'   20                    	DB	040O
  0832'   84                    	DB	204O
                                
                                					;DOUBLE PRECISION DIVIDE FAC BY 10
                                					;ALTERS ALL REGISTERS
  0833'                         DDIV10:					;DOUBLE PRECISION DIVIDE FAC BY 10
                                					;(FAC)=(FAC)*3/4*16/15*1/8
  0833'   3A 0000*              	LDA	FAC			;MUST ASSURE OURSELVES WE CAN DO
  0836'   FE 41                 	CPI	101O			;65 EXPONENT DECREMENTS W/O 
  0838'   D2 0847'              	JNC	DD04			;REACHING ZERO
  083B'   11 0823'              	LXI	D,TENTH			;POINT TO .1D0
  083E'   21 0000*              	LXI	H,ARGLO			;POINT TO ARG
  0841'   CD 034A'              	CALL	VMOVE
  0844'   C3 07E5'              	JMP	DMULT
  0847'                         DD04:
  0847'   3A FFFF*              	LDA	FAC-1			;NEGATIVE NO?
  084A'   B7                    	ORA	A
  084B'   F2 0857'              	JP	DD05
  084E'   E6 7F                 	ANI	177O			;WANT ONLY POS. NOS.
  0850'   32 FFFF*              	STA	FAC-1
  0853'   21 02F5'              	LXI	H,NEG
  0856'   E5                    	PUSH	H			;WILL NEGATE WHEN FINISHED
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-6
DOUBLE PRECISION ARITHMETIC ROUTINES

  0857'                         DD05:
  0857'   CD 0893'              	CALL	$DECF1			;DIVIDE FAC BY 2
  085A'   11 0000*              	LXI	D,DFACLO
  085D'   21 0000*              	LXI	H,ARGLO
  0860'   CD 034A'              	CALL	VMOVE
  0863'   CD 0893'              	CALL	$DECF1			;DIVIDE FAC BY 2
  0866'   CD 06A7'              	CALL	DADD			;(FAC)=(FAC)+(ARG)
  0869'   11 0000*              	LXI	D,DFACLO
  086C'   21 0000*              	LXI	H,ARGLO
  086F'   CD 034A'              	CALL	VMOVE			;(ARG)=(FAC)
  0872'   3E 0F                 	MVI	A,15
  0874'   F5                    DD10:	PUSH	PSW			;SAVE LOOP COUNTER
  0875'   CD 089B'              	CALL	$DECA4			;(ARG)=(ARG)/16
  0878'   CD 08A7'              	CALL	$PSARG			;PUSH ARG ON THE STACK
  087B'   CD 06A7'              	CALL	DADD			;(FAC)=(FAC)+(ARG)
  087E'   21 FFFF*              	LXI	H,ARG-1
  0881'   CD 08B8'              	CALL	$PPARG			;POP ARG OFF THE STACK
  0884'   F1                    	POP	PSW			;FETCH LOOP COUNTER
  0885'   3D                    	DCR	A
  0886'   C2 0874'              	JNZ	DD10
  0889'   CD 0893'              	CALL	$DECF1
  088C'   CD 0893'              	CALL	$DECF1
  088F'   CD 0893'              	CALL	$DECF1
  0892'   C9                    	RET	
  0893'   21 0000*              $DECF1:	LXI	H,FAC
  0896'   35                    	DCR	M			;(FAC)=(FAC)/2
  0897'   C0                    	RNZ	
  0898'   C3 0076'              	JMP	ZERO			;UNDERFLOW
  089B'                         $DECA4:					;(ARG)=(ARG)/16
  089B'   21 0000*              	LXI	H,ARG
  089E'   3E 04                 	MVI	A,4
  08A0'   35                    DC4:	DCR	M
  08A1'   C8                    	RZ	
  08A2'   3D                    	DCR	A
  08A3'   C2 08A0'              	JNZ	DC4
  08A6'   C9                    	RET	
  08A7'                         $PSARG:					;PUSH DOUBLE PRECISION ARG ON THE STACK
  08A7'   D1                    	POP	D			;GET OUR RETURN ADDRESS OFF THE STACK
  08A8'   3E 04                 	MVI	A,4
  08AA'   21 0000*              	LXI	H,ARGLO
  08AD'   4E                    PSA10:	MOV	C,M			;FETCH BYTE
  08AE'   23                    	INX	H
  08AF'   46                    	MOV	B,M
  08B0'   23                    	INX	H
  08B1'   C5                    	PUSH	B
  08B2'   3D                    	DCR	A			;THROUGH?
  08B3'   C2 08AD'              	JNZ	PSA10
  08B6'   D5                    	PUSH	D
  08B7'   C9                    	RET	
  08B8'                         $PPARG:					;POP ARG OFF THE STACK
  08B8'   D1                    	POP	D			;GET OUR RETURN ADDRESS OFF THE STACK
  08B9'   3E 04                 	MVI	A,4
  08BB'   21 0000*              	LXI	H,ARG
  08BE'   C1                    PPA10:	POP	B
  08BF'   70                    	MOV	M,B
  08C0'   2B                    	DCX	H
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-7
DOUBLE PRECISION ARITHMETIC ROUTINES

  08C1'   71                    	MOV	M,C
  08C2'   2B                    	DCX	H
  08C3'   3D                    	DCR	A
  08C4'   C2 08BE'              	JNZ	PPA10
  08C7'   D5                    	PUSH	D
  08C8'   C9                    	RET	
                                					;DOUBLE PRECISION DIVISION	FAC:=FAC/ARG
                                					;ALTERS ALL REGISTERS
  08C9'   3A 0000*              DDIV:	LDA	ARG			;CHECK FOR DIVISION BY ZERO
  08CC'   B7                    	ORA	A			;GET THE EXPONENT OF ARG
  08CD'   CA 0B25'              	JZ	INTDV0
  08D0'   3A 0000*              	LDA	FAC			;IF FAC=0 THEN ANS IS ZERO
  08D3'   B7                    	ORA	A
  08D4'   CA 0076'              	JZ	ZERO
  08D7'   CD 0277'              	CALL	MULDVS			;SUBTRACT EXPONENTS AND CHECK SIGNS
  08DA'   34                    	INR	M			;MULDIV DIFFERENT FOR TRUANS=0
  08DB'   34                    	INR	M			;MUST CORRECT FOR INCORRECT EXP CALC
  08DC'   CA 0B19'              	JZ	OVFIN4
  08DF'   CD 0922'              	CALL	DMULDV			;ZERO FAC AND PUT FAC IN FBUFFR
  08E2'   21 0022*              	LXI	H,FBUFFR+34		;GET POINTER TO THE EXTRA HO BYTE WE WILL USE
  08E5'   71                    	MOV	M,C			;ZERO IT
  08E6'   41                    	MOV	B,C			;ZERO FLAG TO SEE WHEN WE START DIVIDING
  08E7'                         DDIV1:
  08E7'   3E                    	DB	076O			;"MVI	A", SUBTRACT ARG FROM FBUFFR
  08E8'   9E                    	SBB	M			;GET SUBTRACT INSTRUCTION
  08E9'   CD 0772'              	CALL	DADDD			;DO THE SUBTRACTION
  08EC'   1A                    	LDAX	D			;SUBTRACT FROM EXTRA HO BYTE
  08ED'   99                    	SBB	C			;HERE C=0
  08EE'   3F                    	CMC				;CARRY=1 IF SUBTRACTION WAS GOOD
  08EF'   DA 08F9'              	JC	DDIV2			;WAS IT OK?
  08F2'   3E                    	DB	076O			;"MVI	A"  NO, ADD FBUFFR BACK IN
  08F3'   8E                    	ADC	M			;GET ADD INSTRUCTION
  08F4'   CD 0772'              	CALL	DADDD			;DO THE ADDITION
  08F7'   AF                    	XRA	A			;CLEAR CARRY
  08F8'   DA                    	DB	332O			;"JC" OVER NEXT TWO BYTES
  08F9'   12                    DDIV2:	STAX	D			;STORE THE NEW HIGHEST ORDER BYTE
  08FA'   04                    	INR	B			;INCREMENT FLAG TO SHOW WE COULD DIVIDE
  08FB'   3A FFFF*              	LDA	FAC-1			;CHECK IF WE ARE DONE DIVIDING
  08FE'   3C                    	INR	A			;SET SIGN FLAG WITHOUT AFFECTING CARRY
  08FF'   3D                    	DCR	A
  0900'   1F                    	RAR				;PUT CARRY IN MSB FOR DROUND
  0901'   FA 074F'              	JM	DROUNB			;WE ARE DONE, WE HAVE 57 BITS OF ACCURACY
  0904'   17                    	RAL				;GET OLD CARRY BACK WHERE IT BELONGS
  0905'   21 0000*              	LXI	H,DFACLO		;GET POINTER TO LO OF FAC
  0908'   0E 07                 	MVI	C,7			;SET UP A COUNT, SHIFT FAC LEFT ONE
  090A'   CD 07DC'              	CALL	DSHFTL			;SHIFT IN THE NEXT BIT IN THE QUOTIENT
  090D'   21 001B*              	LXI	H,FBUFFR+27		;GET POINTER TO LO IN FBUFFR
  0910'   CD 07DA'              	CALL	DSHFLC			;SHIFT DIVIDEND ONE LEFT
  0913'   78                    	MOV	A,B			;IS THIS THE FIRST TIME AND WAS THE
  0914'   B7                    	ORA	A			; SUBTRACTION NOT GOOD? (B WILL GET
  0915'   C2 08E7'              	JNZ	DDIV1			; CHANGED ON THE FIRST OR SECOND SUBTRACTION)
  0918'   21 0000*              	LXI	H,FAC			;YES, SUBTRACT ONE FROM EXPONENT TO CORRECT
  091B'   35                    	DCR	M			; SCALING
  091C'   C2 08E7'              	JNZ	DDIV1			;CONTINUE DIVIDING IF NO UNDERFLOW
  091F'   C3 0076'              	JMP	ZERO			;UNDERFLOW
                                
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-8
DOUBLE PRECISION ARITHMETIC ROUTINES

                                
                                					;TRANSFER FAC TO FBUFFR FOR DMULT AND DDIV
                                					;ALTERS A,B,C,D,E,H,L
  0922'                         DMULDV:
  0922'   79                    	MOV	A,C			;PUT UNPACKED HO BACK IN ARG
  0923'   32 FFFF*              	STA	ARG-1
  0926'   2B                    	DCX	H			;POINT TO HO OF FAC
  0927'   11 0021*              	LXI	D,FBUFFR+33		;POINT TO END OF FBUFFR
  092A'   01 0700               	LXI	B,7*400O+0		;SET UP A COUNT
                                					;TO FBUFFR
  092D'   7E                    DMLDV1:	MOV	A,M			;GET A BYTE FROM FAC
  092E'   12                    	STAX	D			;PUT IT IN FBUFFR
  092F'   71                    	MOV	M,C			;PUT A ZERO IN FAC
  0930'   1B                    	DCX	D			;POINT TO NEXT BYTE IN FBUFFR
  0931'   2B                    	DCX	H			;POINT TO NEXT LOWER ORDER BYTE IN FAC
  0932'   05                    	DCR	B			;ARE WE DONE?
  0933'   C2 092D'              	JNZ	DMLDV1			;NO, TRANSFER THE NEXT BYTE
  0936'   C9                    	RET				;ALL DONE
                                
                                
                                
                                					;DOUBLE PRECISION MULTIPLY THE FAC BY 10
                                					;ALTERS ALL REGISTERS
  0937'   CD 0375'              DMUL10:	CALL	VMOVAF			;SAVE THE FAC IN ARG
                                					;VMOVAF EXITS WITH (DE)=FAC+1
  093A'   EB                    	XCHG				;GET THE POINTER INTO THE FAC IN (HL)
  093B'   2B                    	DCX	H			;POINT TO THE EXPONENT
  093C'   7E                    	MOV	A,M			;GET THE EXPONENT
  093D'   B7                    	ORA	A			;IS THE NUMBER ZERO?
  093E'   C8                    	RZ				;YES, ALL DONE
  093F'   C6 02                 	ADI	2			;MULTIPLY FAC BY 4 BY ADDING 2 TO THE EXPONENT
  0941'   DA 0B19'              	JC	OVFIN4
  0944'   77                    	MOV	M,A			;SAVE THE NEW EXPONENT
  0945'   E5                    	PUSH	H			;SAVE POINTER TO FAC
  0946'   CD 06A7'              	CALL	DADD			;ADD IN THE ORIGINAL FAC TO GET 5 TIMES  FAC
  0949'   E1                    	POP	H			;GET THE POINTER TO FAC BACK
  094A'   34                    	INR	M			;ADD ONE TO EXPONENT TO GET 10 TIMES FAC
  094B'   C0                    	RNZ				;ALL DONE IF OVERFLOW DID NOT OCCUR
  094C'   C3 0B19'              	JMP	OVFIN4
                                					;MULTIPLY FAC BY 10
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-9
DOUBLE PRECISION ARITHMETIC ROUTINES

                                
                                	SUBTTL	FLOATING POINT INPUT ROUTINE
                                					;ALTERS ALL REGISTERS
                                					;THE NUMBER IS LEFT IN FAC
                                					;AT ENTRY, (HL) POINTS TO THE FIRST CHARACTER IN A TEXT BUFFER.
                                					;THE FIRST CHARACTER IS ALSO IN A.  WE PACK THE DIGITS INTO THE FAC
                                					;AS AN INTEGER AND KEEP TRACK OF WHERE THE DECIMAL POINT IS.
                                					;C IS 377 IF WE HAVE NOT SEEN A DECIMAL POINT, 0 IF WE HAVE.
                                					;B IS THE NUMBER OF DIGITS AFTER THE DECIMAL POINT.
                                					;AT THE END, B AND THE EXPONENT (IN E) ARE USED TO DETERMINE HOW MANY
                                					;TIMES WE MULTIPLY OR DIVIDE BY TEN TO GET THE CORRECT NUMBER.
                                	PUBLIC	FINDBL
  094F'   CD 0076'              FINDBL:	CALL	ZERO			;ZERO THE FAC
  0952'   CD 04B4'              	CALL	VALDBL			;FORCE TO DOUBLE PRECISION
  0955'   F6                    	DB	366O			;"ORI" OVER "XRA A" SO FRCINT IS NOT CALLED
  0956'                         FIN:
  0956'   AF                    	XRA	A			;FORCE CALL TO FRCINT
                                	EXTRN	FINOVC
  0957'   01 0000*              	LXI	B,FINOVC		;WHEN DONE STORE OVERFLOW FLAG
  095A'   C5                    	PUSH	B			;INTO STROVC AND GO TO NORMAL OVERFLOW MODE
  095B'   F5                    	PUSH	PSW			;SET UP ONCE ONLY OVERFLOW MODE
  095C'   3E 01                 	MVI	A,1
  095E'   32 0000*              	STA	FLGOVC
  0961'   F1                    	POP	PSW
  0962'   EB                    FINCHR:	XCHG				;SAVE THE TEXT POINTER IN (DE)
  0963'   01 00FF               	LXI	B,377O+0		;CLEAR FLAGS:  B=DECIMAL PLACE COUNT
                                					;C="." FLAG
  0966'   60                    	MOV	H,B			;ZERO (HL)
  0967'   68                    	MOV	L,B
  0968'   CC 045D'              	CZ	MAKINT			;ZERO FAC, SET VALTYP TO "INTEGER"
  096B'   EB                    	XCHG				;GET THE TEXT POINTER BACK IN (HL) AND 
                                					; ZEROS IN (DE)
  096C'   7E                    	MOV	A,M			;RESTORE CHAR FROM MEMORY
  096D'   FE 26                 	CPI	'&'
                                	EXTRN	OCTCNS
  096F'   CA 0000*              	JZ	OCTCNS
                                					;RESTORE [A]
                                					;IF WE ARE CALLED BY VAL OR INPUT OR READ, THE SIGNS MAY NOT BE CRUNCHED
  0972'   FE 2D                 	CPI	'-'			;SEE IF NUMBER IS NEGATIVE
  0974'   F5                    	PUSH	PSW			;SAVE SIGN
  0975'   CA 097E'              	JZ	FIN1			;IGNORE MINUS SIGN
  0978'   FE 2B                 	CPI	'+'			;IGNORE A LEADING SIGN
  097A'   CA 097E'              	JZ	FIN1
  097D'   2B                    	DCX	H			;SET CHARACTER POINTER BACK ONE
  097E'                         FIN1:
                                					;HERE TO CHECK FOR A DIGIT, A DECIMAL POINT, "E" OR "D"
  097E'   CD 0000*              FINC:	CALL	CHRGTR			;GET THE NEXT CHARACTER OF THE NUMBER
  0981'   DA 0A65'              	JC	FINDIG			;WE HAVE A DIGIT
  0984'   FE 2E                 	CPI	'.'			;CHECK FOR A DECIMAL POINT
  0986'   CA 0A0B'              	JZ	FINDP			;WE HAVE ONE, I GUESS
  0989'   FE 65                 	CPI	145O			;LOWER CASE "E"
  098B'   CA 0990'              	JZ	FINC1
  098E'   FE 45                 	CPI	'E'			;CHECK FOR A SINGLE PRECISION EXPONENT
  0990'                         FINC1:
  0990'   C2 09BA'              	JNZ	NOTE			;NO
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-10
FLOATING POINT INPUT ROUTINE

  0993'   E5                    	PUSH	H			;SAVE TEXT PTR
  0994'   CD 0000*              	CALL	CHRGTR			;GET NEXT CHAR
  0997'   FE 6C                 	CPI	'L'+40O			;SEE IF LOWER CASE "L"
  0999'   CA 09A8'              	JZ	WUZELS			;IF SO POSSIBLE ELSE
  099C'   FE 4C                 	CPI	'L'			;IS THIS REALLY AN "ELSE"?
  099E'   CA 09A8'              	JZ	WUZELS			;WAS ELSE
  09A1'   FE 71                 	CPI	'Q'+40O			;SEE IF LOWER CASE "Q"
  09A3'   CA 09A8'              	JZ	WUZELS			;IF SO POSSIBLE "EQV"
  09A6'   FE 51                 	CPI	'Q'			;POSSIBLE "EQV"
  09A8'   E1                    WUZELS:	POP	H			;RESTORE [H,L]
  09A9'   CA 09B9'              	JZ	WUZ			;IT WAS JUMP!
  09AC'   3A 0000*              	LDA	VALTYP			;IF DOUBLE DON'T DOWNGRADE TO SINGLE
  09AF'   FE 08                 	CPI	10O			;SET CONDITION CODES
  09B1'   CA 09D3'              	JZ	FINEX1
  09B4'   3E 00                 	MVI	A,0			;MAKE A=0 SO NUMBER IS A SINGLE
  09B6'   C3 09D3'              	JMP	FINEX1
  09B9'                         WUZ:
  09B9'   7E                    	MOV	A,M			;RESTORE ORIGINAL CHAR
  09BA'                         NOTE:
  09BA'   FE 25                 	CPI	'%'			;TRAILING % (RSTS-11 COMPATIBILITY)
  09BC'   CA 0A18'              	JZ	FININT			;MUST BE INTEGER.
  09BF'   FE 23                 	CPI	'#'			;FORCE DOUBLE PRECISION?
  09C1'   CA 0A29'              	JZ	FINDBF			;YES, FORCE IT & FINISH UP.
  09C4'   FE 21                 	CPI	'!'			;FORCE SINGLE PREC.
  09C6'   CA 0A2A'              	JZ	FINSNF
  09C9'   FE 64                 	CPI	144O			;LOWER CASE "D"
  09CB'   CA 09D3'              	JZ	FINEX1
  09CE'   FE 44                 	CPI	'D'			;CHECK FOR A DOUBLE PRECISION EXPONENT
  09D0'   C2 09EA'              	JNZ	FINE			;WE DON'T HAVE ONE, THE NUMBER IS FINISHED
  09D3'   B7                    FINEX1:	ORA	A			;DOUBLE PRECISION NUMBER -- TURN OFF ZERO FLAG
  09D4'   CD 0A33'              FINEX:	CALL	FINFRC			;FORCE THE FAC TO BE SNG OR DBL
  09D7'   CD 0000*              	CALL	CHRGTR			;GET THE FIRST CHARACTER OF THE EXPONENT
  09DA'   CD 0000*              	CALL	MINPLS			;EAT SIGN OF EXPONENT
                                					;HERE TO GET THE NEXT DIGIT OF THE EXPONENT
  09DD'   CD 0000*              FINEC:	CALL	CHRGTR			;GET THE NEXT CHARATER
  09E0'   DA 0AD8'              	JC	FINEDG			;PACK THE NEXT DIGIT INTO THE EXPONENT
  09E3'   14                    	INR	D			;IT WAS NOT A DIGIT, PUT THE CORRECT SIGN ON
  09E4'   C2 09EA'              	JNZ	FINE			; THE EXPONENT, IT IS POSITIVE
  09E7'   AF                    	XRA	A			;THE EXPONENT IS NEGATIVE
  09E8'   93                    	SUB	E			;NEGATE IT
  09E9'   5F                    	MOV	E,A			;SAVE IT AGAIN
                                					;HERE TO FINISH UP THE NUMBER
  09EA'   E5                    FINE:	PUSH	H			;SAVE THE TEXT POINTER
  09EB'   7B                    	MOV	A,E			;FIND OUT HOW MANY TIMES WE HAVE TO MULTIPLY
  09EC'   90                    	SUB	B			; OR DIVIDE BY TEN
  09ED'   5F                    	MOV	E,A			;SAVE NEW EXPONENT IN E
                                					;HERE TO MULTIPLY OR DIVIDE BY TEN THE CORRECT NUMBER OF TIMES
                                					;IF THE NUMBER IS AN INT, A IS 0 HERE.
  09EE'   F4 0A42'              FINE2:	CP	FINMUL			;MULTIPLY IF WE HAVE TO
  09F1'   FC 0A52'              	CM	FINDIV			;DIVIDE IF WE HAVE TO
  09F4'   C2 09EE'              	JNZ	FINE2			;MULTIPLY OR DIVIDE AGAIN IF WE ARE NOT DONE
                                					;HERE TO PUT THE CORRECT SIGN ON THE NUMBER
  09F7'   E1                    	POP	H			;GET THE TEXT POINTER
  09F8'   F1                    	POP	PSW			;GET THE SIGN
  09F9'   E5                    	PUSH	H			;SAVE THE TEXT POINTER AGAIN
  09FA'   CC 02EC'              	CZ	VNEG			;NEGATE IF NECESSARY
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-11
FLOATING POINT INPUT ROUTINE

  09FD'   E1                    FINE2C:	POP	H			;GET THE TEXT POINTER IN (HL)
  09FE'   CD 0000*              	CALL	GETYPR			;WE WANT -32768 TO BE AN INT, BUT UNTIL NOW
                                					; IT WOULD BE A SNG
  0A01'   E8                    	RPE				;IT IS NOT SNG, SO IT IS NOT -32768
  0A02'   E5                    	PUSH	H			;WE HAVE A SNG, SAVE TEXT POINTER
  0A03'   21 01DE'              	LXI	H,POPHRT		;GET ADDRESS THAT POP'S H OFF STACK BECAUSE
  0A06'   E5                    	PUSH	H			; CONIS2 DOES FUNNY THINGS WITH THE STACK
  0A07'   CD 0466'              	CALL	CONIS2			;CHECK IF WE HAVE -32768
  0A0A'   C9                    	RET				;WE DON'T, POPHRT IS STILL ON THE STACK SO
                                					; WE CAN JUST RETURN
                                
                                					;HERE TO CHECK IF WE HAVE SEEN 2 DECIMAL POINTS AND SET THE DECIMAL
                                					; POINT FLAG
  0A0B'   CD 0000*              FINDP:	CALL	GETYPR			;SET CARRY IF WE DON'T HAVE A DOUBLE
  0A0E'   0C                    	INR	C			;SET THE FLAG
  0A0F'   C2 09EA'              	JNZ	FINE			;WE HAD 2 DECIMAL POINTS, NOW WE ARE DONE
  0A12'   DC 0A33'              	CC	FINFRC			;THIS IS THE FIRST ONE, CONVERT FAC TO SNG
                                					; IF WE DON'T ALREADY HAVE A DOUBLE
  0A15'   C3 097E'              	JMP	FINC			;CONTINUE LOOKING FOR DIGITS
                                
  0A18'   CD 0000*              FININT:	CALL	CHRGTR
  0A1B'   F1                    	POP	PSW			;GET SIGN OFF THE STACK
  0A1C'   E5                    	PUSH	H			;SAVE TEXT POINTER
  0A1D'   21 01DE'              	LXI	H,POPHRT		;ADDRESS POP (HL) AND RETURN
  0A20'   E5                    	PUSH	H			;
  0A21'   21 03FB'              	LXI	H,FRCINT		;ADDRESS TO FORCE INTEGER
  0A24'   E5                    	PUSH	H			;WILL WANT TO FORCE ONCE D.P. DONE
  0A25'   F5                    	PUSH	PSW			;PUT SIGN BACK ON THE STACK
  0A26'   C3 09EA'              	JMP	FINE			;ALL DONE
  0A29'   B7                    FINDBF:	ORA	A			;SET NON-ZERO TO FORCE DOUBLE PREC
  0A2A'   CD 0A33'              FINSNF:	CALL	FINFRC			;FORCE THE TYPE
  0A2D'   CD 0000*              	CALL	CHRGTR			;READ AFTER TERMINATOR
  0A30'   C3 09EA'              	JMP	FINE			;ALL DONE
                                
                                					;FORCE THE FAC TO BE SNG OR DBL
                                					;IF THE ZERO FLAG IS ON, THEN FORCE THE FAC TO BE SNG
                                					;IF THE ZERO FLAG IS OFF, FORCE THE FAC TO BE DBL
  0A33'   E5                    FINFRC:	PUSH	H			;SAVE TEXT POINTER
  0A34'   D5                    	PUSH	D			;SAVE EXPONENT INFORMATION
  0A35'   C5                    	PUSH	B			;SAVE DECIMAL POINT INFORMATION
  0A36'   F5                    	PUSH	PSW			;SAVE WHAT WE WANT THE FAC TO BE
  0A37'   CC 0475'              	CZ	FRCSNG			;CONVERT TO SNG IF WE HAVE TO
  0A3A'   F1                    	POP	PSW			;GET TYPE FLAG BACK
  0A3B'   C4 04A1'              	CNZ	FRCDBL			;CONVERT TO DBL IF WE HAVE TO
  0A3E'   C1                    	POP	B			;GET DECIMAL POINT INFORMATION BACK
  0A3F'   D1                    	POP	D			;GET EXPONENT INFORMATION BACK
  0A40'   E1                    	POP	H			;GET TEXT POINTER BACK
  0A41'   C9                    	RET				;ALL DONE
                                
                                					;THIS SUBROUTINE MULIPLIES BY TEN ONCE.
                                					;IT IS A SUBROUTINE BECAUSE IT SAVES BYTES WHEN WE CHECK IF A IS ZERO
                                					;ALTERS ALL REGISTERS
  0A42'   C8                    FINMUL:	RZ				;RETURN IF EXPONENT IS ZERO, ENTRY FROM FOUT
  0A43'   F5                    FINMLT:	PUSH	PSW			;SAVE EXPONENT, ENTRY FROM FOUT
  0A44'   CD 0000*              	CALL	GETYPR			;SEE WHAT KIND OF NUMBER WE HAVE
  0A47'   F5                    	PUSH	PSW			;SAVE THE TYPE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-12
FLOATING POINT INPUT ROUTINE

  0A48'   E4 02AF'              	CPO	MUL10			;WE HAVE A SNG, MULTIPLY BY 10.0
  0A4B'   F1                    	POP	PSW			;GET THE TYPE BACK
  0A4C'   EC 0937'              	CPE	DMUL10			;WE HAVE A DBL, MULTIPLY BY 10D0
  0A4F'   F1                    	POP	PSW			;GET EXPONENT
  0A50'   3D                    DCRART:	DCR	A			;DECREASE IT
  0A51'   C9                    	RET				;ALL DONE
                                
                                					;THIS SUBROUTINE DIVIDES BY TEN ONCE.
                                					;IT IS USED BY FIN, FOUT
                                					;ALTERS A,B,C
  0A52'   D5                    FINDIV:	PUSH	D			;SAVE D,E
  0A53'   E5                    	PUSH	H			;SAVE H,L
  0A54'   F5                    	PUSH	PSW			;WE HAVE TO DIVIDE -- SAVE COUNT
  0A55'   CD 0000*              	CALL	GETYPR			;SEE WHAT KIND OF NUMBER WE HAVE
  0A58'   F5                    	PUSH	PSW			;SAVE THE TYPE
  0A59'   E4 01E5'              	CPO	DIV10			;WE HAVE A SNG NUMBER
  0A5C'   F1                    	POP	PSW			;GET THE TYPE BACK
  0A5D'   EC 0833'              	CPE	DDIV10			;WE HAVE A DBL NUMBER
  0A60'   F1                    	POP	PSW			;GET COUNT BACK
  0A61'   E1                    	POP	H			;GET H,L BACK
  0A62'   D1                    	POP	D			;GET D,E BACK
  0A63'   3C                    	INR	A			;UPDATE IT
  0A64'   C9                    	RET	
                                
                                					;HERE TO PACK THE NEXT DIGIT OF THE NUMBER INTO THE FAC
                                					;WE MULTIPLY THE FAC BY TEN AND ADD IN THE NEXT DIGIT
  0A65'                         FINDIG:
  0A65'   D5                    	PUSH	D			;SAVE EXPONENT INFORMATION
  0A66'   78                    	MOV	A,B			;INCREMENT DECIMAL PLACE COUNT IF WE ARE
  0A67'   89                    	ADC	C			; PAST THE DECIMAL POINT
  0A68'   47                    	MOV	B,A
  0A69'   C5                    	PUSH	B			;SAVE DECIMAL POINT INFORMATION
  0A6A'   E5                    	PUSH	H			;SAVE TEXT POINTER
  0A6B'   7E                    	MOV	A,M			;GET THE DIGIT
  0A6C'   D6 30                 	SUI	'0'			;CONVERT IT TO ASCII
  0A6E'   F5                    	PUSH	PSW			;SAVE THE DIGIT
  0A6F'   CD 0000*              	CALL	GETYPR			;SEE WHAT KIND OF A NUMBER WE HAVE
  0A72'   F2 0A9E'              	JP	FINDGV			;WE DO NOT HAVE AN INTEGER
                                					;HERE TO PACK THE NEXT DIGIT OF AN INTEGER
  0A75'   2A 0000*              	LHLD	FACLO			;WE HAVE AN INTEGER, GET IT IN (HL)
  0A78'   11 0CCD               	LXI	D,3277+0		;SEE IF WE WILL OVERFLOW
  0A7B'   CD 0000*              	CALL	DCOMPR			;COMPAR RETURNS WITH CARRY ON IF
  0A7E'   D2 0A9A'              	JNC	FINDG2			; (HL) .LT. (DE), SO THE NUMBER IS TOO BIG
  0A81'   54                    	MOV	D,H			;COPY (HL) INTO (DE)
  0A82'   5D                    	MOV	E,L
  0A83'   29                    	DAD	H			;MULTIPLY (HL) BY 2
  0A84'   29                    	DAD	H			;MULTIPLY (HL) BY 2, (HL) NOW IS 4*(DE)
  0A85'   19                    	DAD	D			;ADD IN OLD (HL) TO GET 5*(DE)
  0A86'   29                    	DAD	H			;MULTIPLY BY 2 TO GET TEN TIMES THE OLD (HL)
  0A87'   F1                    	POP	PSW			;GET THE DIGIT
  0A88'   4F                    	MOV	C,A			;SAVE IT SO WE CAN USE DAD, B IS ALREADY ZERO
  0A89'   09                    	DAD	B			;ADD IN THE NEXT DIGIT
  0A8A'   7C                    	MOV	A,H			;CHECK FOR OVERFLOW
  0A8B'   B7                    	ORA	A			;OVERFLOW OCCURED IF THE MSB IS ON
  0A8C'   FA 0A98'              	JM	FINDG1			;WE HAVE OVERFLOW!!
  0A8F'   22 0000*              	SHLD	FACLO			;EVERYTHING IS FINE, STORE THE NEW NUMBER
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-13
FLOATING POINT INPUT ROUTINE

  0A92'   E1                    FINDGE:	POP	H			;ALL DONE, GET TEXT POINTER BACK
  0A93'   C1                    	POP	B			;GET DECIMAL POINT INFORMATION BACK
  0A94'   D1                    	POP	D			;GET EXPONENT INFORMATION BACK
  0A95'   C3 097E'              	JMP	FINC			;GET THE NEXT CHARACTER
                                					;HERE TO HANDLE 32768, 32769
  0A98'   79                    FINDG1:	MOV	A,C			;GET THE DIGIT
  0A99'   F5                    	PUSH	PSW			;PUT IT BACK ON THE STACK
                                					;HERE TO CONVERT THE INTEGER DIGITS TO SINGLE PRECISION DIGITS
  0A9A'   CD 0492'              FINDG2:	CALL	CONSI			;CONVERT THE INTEGER TO SINGLE PRECISION
  0A9D'   37                    	STC				;DO NOT TAKE THE FOLLOWING JUMP
                                					;HERE TO DECIDE IF WE HAVE A SINGLE OR DOUBLE PRECISION NUMBER
  0A9E'   D2 0ABA'              FINDGV:	JNC	FINDGD			;FALL THROUGH IF VALTYP WAS 4 I.E. SNG PREC
  0AA1'   01 9474               	LXI	B,224Q*256+164Q
  0AA4'   11 2400               	LXI	D,044Q*256+000Q		;GET 1000000, DO WE HAVE 7 DIGITS ALREADY?
  0AA7'   CD 0387'              	CALL	FCOMP			;IF SO, FAC .GE. 1000000
  0AAA'   F2 0AB7'              	JP	FINDG3			;WE DO, CONVERT TO DOUBLE PRECISION
  0AAD'   CD 02AF'              	CALL	MUL10			;MULTIPLY THE OLD NUMBER BY TEN
  0AB0'   F1                    	POP	PSW			;GET THE NEXT DIGIT
  0AB1'   CD 0ACD'              	CALL	FINLOG			;PACK IT INTO THE FAC
  0AB4'   C3 0A92'              	JMP	FINDGE			;GET FLAGS OFF STACK AND WE ARE DONE
                                					;HERE TO CONVERT A 7 DIGIT SINGLE PRECISION NUMBER TO DOUBLE PRECISION
  0AB7'   CD 04AB'              FINDG3:	CALL	CONDS			;CONVERT SINGLE TO DOUBLE PRECISION
                                					;HERE TO PACK IN THE NEXT DIGIT OF A DOUBLE PRECISION NUMBER
  0ABA'   CD 0937'              FINDGD:	CALL	DMUL10			;MULTIPLY THE FAC BY 10
  0ABD'   CD 0375'              	CALL	VMOVAF			;SAVE THE FAC IN ARG
  0AC0'   F1                    	POP	PSW			;GET THE NEXT DIGIT
  0AC1'   CD 02D5'              	CALL	FLOAT			;CONVERT THE DIGIT TO SINGLE PRECISION
  0AC4'   CD 04AB'              	CALL	CONDS			;NOW, CONVERT THE DIGIT TO DOUBLE PRECISION
  0AC7'   CD 06A7'              	CALL	DADD			;ADD IN THE DIGIT
  0ACA'   C3 0A92'              	JMP	FINDGE			;GET THE FLAGS OFF THE STACK AND WE ARE DONE
                                
                                					;SUBROUTINE FOR FIN, LOG
  0ACD'   CD 031A'              FINLOG:	CALL	PUSHF			;SAVE FAC ON STACK
  0AD0'   CD 02D5'              	CALL	FLOAT			;CONVERT A TO A FLOATING POINT NUMBER
  0AD3'   C1                    FADDT:	POP	B
  0AD4'   D1                    	POP	D
                                					;GET PREVIOUS NUMBER OFF STACK
  0AD5'   C3 000F'              	JMP	FADD			;ADD IT IN
                                
                                					;HERE WE PACK IN THE NEXT DIGIT OF THE EXPONENT
                                					;WE MUTIPLY THE OLD EXPONENT BY TEN AND ADD IN THE NEXT DIGIT
                                					;NOTE: EXPONENT OVERFLOW IS NOT CHECKED FOR
  0AD8'   7B                    FINEDG:	MOV	A,E			;EXPONENT DIGIT -- MULTIPLY EXPONENT BY 10
  0AD9'   FE 0A                 	CPI	12O			;CHECK THAT THE EXPONENT DOES NOT OVERFLOW
                                					;IF IT DID, E COULD GET GARBAGE IN IT.
  0ADB'   D2 0AE7'              	JNC	FINEDO			;WE ALREADY HAVE TWO DIGITS
  0ADE'   07                    	RLC				;FIRST BY 4
  0ADF'   07                    	RLC	
  0AE0'   83                    	ADD	E			;ADD 1 TO MAKE 5
  0AE1'   07                    	RLC				;NOW DOUBLE TO GET 10
  0AE2'   86                    	ADD	M			;ADD IT IN
  0AE3'   D6 30                 	SUI	'0'			;SUBTRACT OFF ASCII CODE, THE RESULT IS
                                					; POSITIVE ON LENGTH=2 BECAUSE OF THE
                                					; ABOVE CHECK
  0AE5'   5F                    	MOV	E,A			;STORE EXPONENT
  0AE6'   FA                    	DB	372O			;"JM" OVER THE NEXT 2 BYTES
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-14
FLOATING POINT INPUT ROUTINE

  0AE7'   1E 7F                 FINEDO:	MVI	E,127			;AN EXPONENT LIKE THIS WILL SAFELY CAUSE
                                					; OVERFLOW OR UNDERFLOW
  0AE9'   C3 09DD'              	JMP	FINEC			;CONTINUE
  0AEC'   B7                    OVFIN1:	ORA	A			;CLEAR CARRY
  0AED'   C3 0B4E'              	JMP	OVFINT			;GO PRINT OVERFLOW
  0AF0'   F1                    OVFIN9:	POP	PSW			;GET STACK RIGHT
  0AF1'   E5                    OVFIN2:	PUSH	H			;
  0AF2'   21 FFFF*              	LXI	H,FAC-1			;POINT (HL) TO SIGN BYTE
  0AF5'   CD 0000*              	CALL	GETYPR
  0AF8'   E2 0B01'              	JPO	OVF2A			;SP PROCEED AS NORMAL
  0AFB'   3A FFFF*              	LDA	ARG-1
  0AFE'   C3 0B02'              	JMP	OVF2B
  0B01'                         OVF2A:
  0B01'   79                    	MOV	A,C
  0B02'                         OVF2B:
  0B02'   AE                    	XRA	M			;SIGN IN HIGH BIT OF (A)
  0B03'   17                    	RAL				;SIGN IN CARRY
  0B04'   E1                    	POP	H			;
  0B05'   C3 0B4E'              	JMP	OVFINT
  0B08'   3A 0001*              OVF2C:	LDA	FAC+1			;THIS ENTRY IS USED BY CONSD
  0B0B'   C3 0B1D'              	JMP	OVFI4B			;WHEN D.P. EXP TOO LARGE FOR S.P.
  0B0E'   F1                    OVFIN5:	POP	PSW			;NEED TO DO 3 POP'S THEN OVERFLOW
  0B0F'   F1                    OVFIN6:	POP	PSW
  0B10'   F1                    OVFIN7:	POP	PSW
  0B11'   3A FFFF*              OVFIN3:	LDA	FAC-1
  0B14'   17                    	RAL	
  0B15'   C3 0B4E'              	JMP	OVFINT
  0B18'   F1                    OVFIN8:	POP	PSW			;DO A POP THEN FALL INTO OVFIN4
  0B19'   3A 0001*              OVFIN4:	LDA	FAC+1			;GET SIGN BYTE
  0B1C'   2F                    	CMA				;SIGN WAS STORED COMPLEMENTED
  0B1D'   17                    OVFI4B:	RAL				;SIGN TO CARRY
  0B1E'   C3 0B4E'              	JMP	OVFINT
  0B21'   79                    INTDV1:	MOV	A,C
  0B22'   C3 0B47'              	JMP	INTDV2			;
  0B25'   E5                    INTDV0:	PUSH	H			;GET ARG SIGN BYTE
  0B26'   D5                    	PUSH	D			;
  0B27'   21 0000*              	LXI	H,DFACLO
  0B2A'   11 0BCA'              	LXI	D,INFM			;ALL ONE'S
  0B2D'   CD 0344'              	CALL	MOVE
  0B30'   3A 0BCA'              	LDA	INFM			;377
  0B33'   32 0002*              	STA	DFACLO+2		;(PREVIOUSLY 177)
  0B36'   CD 0000*              	CALL	GETYPR
  0B39'   E2 0B42'              	JPO	INDV0A			;NOT D.P. LOAD ARG SIGN
  0B3C'   3A FFFF*              	LDA	FAC-1
  0B3F'   C3 0B45'              	JMP	INDV0B
  0B42'                         INDV0A:
  0B42'   3A FFFF*              	LDA	ARG-1
  0B45'   D1                    INDV0B:	POP	D
  0B46'   E1                    	POP	H
  0B47'   17                    INTDV2:	RAL				;TO CARRY
  0B48'   21 0000*              	LXI	H,DIVMSG		;GET MESSAGE ADDRESS
  0B4B'   22 0000*              	SHLD	OVERRI			;STORE SO OVFINT WILL PICK UP
  0B4E'                         OVFINT:					;ANSI OVERFLOW ROUTINE
  0B4E'   E5                    	PUSH	H
  0B4F'   C5                    	PUSH	B
  0B50'   D5                    	PUSH	D
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-15
FLOATING POINT INPUT ROUTINE

  0B51'   F5                    	PUSH	PSW			;SAVE MACHINE STATUS
  0B52'   F5                    	PUSH	PSW			;AGAIN
                                	EXTRN	ONELIN			;
  0B53'   2A 0000*              	LHLD	ONELIN			;TRAPPING ERRORS?
  0B56'   7C                    	MOV	A,H
  0B57'   B5                    	ORA	L
  0B58'   C2 0B7F'              	JNZ	OVFPRT			;JUMP PRINT IF TRAPPING
                                					;OTHERWISE +INFINITY
  0B5B'   3A 0000*              	LDA	FLGOVC			;PRINT INDICATOR FLAG
  0B5E'   B7                    	ORA	A			;PRINT IF 0,1;SET TO 2 IF 1
  0B5F'   CA 0B6C'              	JZ	OV1A			;GO PRINT
  0B62'   FE 01                 	CPI	1
  0B64'   C2 0B7F'              	JNZ	OV1B
  0B67'   3E 02                 	MVI	A,2
  0B69'   32 0000*              	STA	FLGOVC
  0B6C'                         OV1A:
  0B6C'   2A 0000*              	LHLD	OVERRI			;ADDRESS OF OVERFLOW MESSAGE
  0B6F'   CD 0000*              	CALL	STRPRN			;PRINT
  0B72'   32 0000*              	STA	TTYPOS			;SET TTY POSITION TO CHAR 0
                                					;SET TTY POSITION TO CHAR 0
  0B75'   3E 0D                 	MVI	A,15O
  0B77'   CD 0000*              	CALL	CALTTY
  0B7A'   3E 0A                 	MVI	A,12O
  0B7C'   CD 0000*              	CALL	CALTTY			;CARRIAGE RETURN,LINE FEED
  0B7F'                         OV1B:
  0B7F'   F1                    OVFPRT:	POP	PSW			;GET PLUS,MINUS INDICATION BACK
  0B80'   21 0000*              	LXI	H,FACLO			;MUST NOW PUT RIGHT INFINITY
                                					;INTO THE FAC
  0B83'   11 0BC6'              	LXI	D,INFP
  0B86'   D2 0B8C'              	JNC	OVFINA
  0B89'   11 0BCA'              	LXI	D,INFM			;MINUS INFINITY
  0B8C'   CD 0344'              OVFINA:	CALL	MOVE			;MOVE INTO FAC
  0B8F'   CD 0000*              	CALL	GETYPR
  0B92'   E2 0B9E'              	JPO	OVFINB			;SP ALL OK
  0B95'   21 0000*              	LXI	H,DFACLO
  0B98'   11 0BCA'              	LXI	D,INFM			;ALL ONES
  0B9B'   CD 0344'              	CALL	MOVE
  0B9E'                         OVFINB:
  0B9E'   2A 0000*              	LHLD	ONELIN			;TRAPPING ERRORS?
  0BA1'   7C                    	MOV	A,H
  0BA2'   B5                    	ORA	L
  0BA3'   CA 0BBB'              	JZ	NOODTP			;JUMP IF NOT TRAPPING
  0BA6'   2A 0000*              	LHLD	OVERRI
  0BA9'   11 0000*              	LXI	D,OVRMSG
  0BAC'   CD 0000*              	CALL	DCOMPR
  0BAF'   21 0000*              	LXI	H,OVRMSG
  0BB2'   22 0000*              	SHLD	OVERRI
  0BB5'   CA 0000*              	JZ	OVERR
  0BB8'   C3 0000*              	JMP	DV0ERR
  0BBB'                         NOODTP:
  0BBB'   F1                    	POP	PSW			;
  0BBC'   21 0000*              	LXI	H,OVRMSG		;PUT "OVRMSG" ADDRESS IN OVERRI
  0BBF'   22 0000*              	SHLD	OVERRI			;IN CASE THIS WAS A DIV BY 0
  0BC2'   D1                    	POP	D
  0BC3'   C1                    	POP	B
  0BC4'   E1                    	POP	H			;ALL RESTORED 
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-16
FLOATING POINT INPUT ROUTINE

  0BC5'   C9                    	RET				;CONTINUE PROCESSING
  0BC6'   FF                    INFP:	DB	377O
  0BC7'   FF                    	DB	377O
  0BC8'   7F                    	DB	177O
  0BC9'   FF                    	DB	377O
  0BCA'   FF                    INFM:	DB	377O
  0BCB'   FF                    	DB	377O
  0BCC'   FF                    	DB	377O
  0BCD'   FF                    	DB	377O
                                
                                
                                
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-17
FLOATING POINT INPUT ROUTINE

                                
                                	SUBTTL	FLOATING POINT OUTPUT ROUTINE
                                					;ENTRY TO LINPRT
  0BCE'   E5                    INPRT:	PUSH	H			;SAVE LINE NUMBER
  0BCF'   21 0000*              	LXI	H,INTXT			;PRINT MESSAGE
  0BD2'   CD 0000*              	CALL	STROUT
  0BD5'   E1                    	POP	H			;FALL INTO LINPRT
                                
                                
                                					;PRINT THE 2 BYTE NUMBER IN H,L
                                					;ALTERS ALL REGISTERS
  0BD6'                         LINPRT:
  0BD6'   01 0000*              	LXI	B,STROUI
  0BD9'   C5                    	PUSH	B
                                	PUBLIC	LINOUT
  0BDA'   CD 045D'              LINOUT:	CALL	MAKINT			;PUT THE LINE NUMBER IN THE FAC AS AN INTEGER
  0BDD'   AF                    	XRA	A			;SET FORMAT TO FREE FORMAT
  0BDE'   CD 0C6E'              	CALL	FOUINI			;SET UP THE SIGN
  0BE1'   B6                    	ORA	M			;TURN OFF THE ZERO FLAG
  0BE2'   C3 0C02'              	JMP	FOUT2			;CONVERT THE NUMBER INTO DIGITS
                                	EXTRN	STROUI
                                
                                					;FLOATING OUTPUT OF FAC
                                					;ALTERS ALL REGISTERS
                                					;THE ORIGINAL CONTENTS OF THE FAC IS LOST
                                ;
                                ;	OUTPUT THE VALUE IN THE FAC ACCORDING TO THE FORMAT SPECIFICATIONS
                                ;	IN A,B,C
                                ;	ALL REGISTERS ARE ALTERED
                                ;	THE ORIGINAL CONTENTS OF THE FAC IS LOST
                                ;
                                ;	THE FORMAT IS SPECIFIED IN A, B AND C AS FOLLOWS:
                                ;	THE BITS OF A MEAN THE FOLLOWING:
                                ;BIT 7	0 MEANS FREE FORMAT OUTPUT, I.E. THE OTHER BITS OF A MUST BE ZERO,
                                ;	TRAILING ZEROS ARE SUPPRESSED, A NUMBER IS PRINTED IN FIXED OR FLOATING
                                ;	POINT NOTATION ACCORDING TO ITS MAGNITUDE, THE NUMBER IS LEFT
                                ;	JUSTIFIED IN ITS FIELD, B AND C ARE IGNORED.
                                ;	1 MEANS FIXED FORMAT OUTPUT, I.E. THE OTHER BITS OF A ARE CHECKED FOR
                                ;	FORMATTING INFORMATION, THE NUMBER IS RIGHT JUSTIFIED IN ITS FIELD,
                                ;	TRAILING ZEROS ARE NOT SUPPRESSED.  THIS IS USED FOR PRINT USING.
                                ;BIT 6	1 MEANS GROUP THE DIGITS IN THE INTEGER PART OF THE NUMBER INTO GROUPS
                                ;	OF THREE AND SEPARATE THE GROUPS BY COMMAS
                                ;	0 MEANS DON'T PRINT THE NUMBER WITH COMMAS
                                ;BIT 5	1 MEANS FILL THE LEADING SPACES IN THE FIELD WITH ASTERISKS ("*")
                                ;BIT 4	1 MEANS OUTPUT THE NUMBER WITH A FLOATING DOLLAR SIGN ("$")
                                ;BIT 3	1 MEANS PRINT THE SIGN OF A POSITIVE NUMBER AS A PLUS SIGN ("+")
                                ;	INSTEAD OF A SPACE
                                ;BIT 2	1 MEANS PRINT THE SIGN OF THE NUMBER AFTER THE NUMBER
                                ;BIT 1	UNUSED
                                ;BIT 0	1 MEANS PRINT THE NUMBER IN FLOATING POINT NOTATION I.E. "E NOTATION"
                                ;	IF THIS BIT IS ON, THE COMMA SPECIFICATION (BIT 6) IS IGNORED.
                                ;	0 MEANS PRINT THE NUMBER IN FIXED POINT NOTATION.  NUMBERS .GE. 1E16
                                ;	CANNOT BE PRINTED IN FIXED POINT NOTATION.
                                ;
                                ;	B AND C TELL HOW BIG THE FIELD IS:
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-18
FLOATING POINT OUTPUT ROUTINE

                                ;B   =	THE NUMBER OF PLACES IN THE FIELD TO THE LEFT OF THE DECIMAL POINT
                                ;	(B DOES NOT INCLUDE THE DECIMAL POINT)
                                ;C   =	THE NUMBER OF PLACES IN THE FIELD TO THE RIGHT OF THE DECIMAL POINT
                                ;	(C INCLUDES THE DECIMAL POINT)
                                ;	B AND C DO NOT INCLUDE THE 4 POSITIONS FOR THE EXPONENT IF BIT 0 IS ON
                                ;	FOUT ASSUMES B+C .LE. 24 (DECIMAL)
                                ;	IF THE NUMBER IS TOO BIG TO FIT IN THE FIELD, A PERCENT SIGN ("%") IS
                                ;	PRINTED AND THE FIELD IS EXTENDED TO HOLD THE NUMBER.
                                ;&
                                
                                
                                					;ENTRY TO PRINT THE FAC IN FREE FORMAT
  0BE5'   AF                    FOUT:	XRA	A			;SET FORMAT FLAGS TO FREE FORMATED OUTPUT
                                					;ENTRY TO PRINT THE FAC USING THE FORMAT SPECIFICATIONS IN A, B AND C
  0BE6'   CD 0C6E'              PUFOUT:	CALL	FOUINI			;SAVE THE FORMAT SPECIFICATION IN A AND PUT
                                					;A SPACE FOR POSITIVE NUMBERS IN THE BUFFER
  0BE9'   E6 08                 	ANI	10O			;CHECK IF POSITIVE NUMBERS GET A PLUS SIGN
  0BEB'   CA 0BF0'              	JZ	FOUT1			;THEY DON'T
  0BEE'   36 2B                 	MVI	M,'+'			;THEY DO, PUT IN A PLUS SIGN
  0BF0'   EB                    FOUT1:	XCHG				;SAVE BUFFER POINTER
  0BF1'   CD 0307'              	CALL	VSIGN			;GET THE SIGN OF THE FAC
  0BF4'   EB                    	XCHG				;PUT THE BUFFER POINTER BACK IN (HL)
  0BF5'   F2 0C02'              	JP	FOUT2			;IF WE HAVE A NEGATIVE NUMBER, NEGATE IT
  0BF8'   36 2D                 	MVI	M,'-'			; AND PUT A MINUS SIGN IN THE BUFFER
  0BFA'   C5                    	PUSH	B			;SAVE THE FIELD LENGTH SPECIFICATION
  0BFB'   E5                    	PUSH	H			;SAVE THE BUFFER POINTER
  0BFC'   CD 02EC'              	CALL	VNEG			;NEGATE THE NUMBER
  0BFF'   E1                    	POP	H			;GET THE BUFFER POINTER BACK
  0C00'   C1                    	POP	B			;GET THE FIELD LENGTH SPECIFICATIONS BACK
  0C01'   B4                    	ORA	H			;TURN OFF THE ZERO FLAG, THIS DEPENDS ON THE
                                					; FACT THAT FBUFFR IS NEVER ON PAGE 0.
  0C02'   23                    FOUT2:	INX	H			;POINT TO WHERE THE NEXT CHARACTER GOES
  0C03'   36 30                 	MVI	M,'0'			;PUT A ZERO IN THE BUFFER IN CASE THE NUMBER
                                					; IS ZERO (IN FREE FORMAT) OR TO RESERVE SPACE
                                					; FOR A FLOATING DOLLAR SIGN (FIXED FORMAT)
  0C05'   3A 0000*              	LDA	TEMP3			;GET THE FORMAT SPECIFICATION
  0C08'   57                    	MOV	D,A			;SAVE IT FOR LATER
  0C09'   17                    	RAL				;PUT THE FREE FORMAT OR NOT BIT IN THE CARRY
  0C0A'   3A 0000*              	LDA	VALTYP			;GET THE VALTYP, VNEG COULD HAVE CHANGED THIS
                                					; SINCE -32768 IS INT AND 32768 IS SNG.
  0C0D'   DA 0D93'              	JC	FOUTFX			;THE MAN WANTS FIXED FORMATED OUTPUT
                                					;HERE TO PRINT NUMBERS IN FREE FORMAT
  0C10'   CA 0D8B'              	JZ	FOUTZR			;IF THE NUMBER IS ZERO, FINISH IT UP
  0C13'   FE 04                 	CPI	4			;DECIDE WHAT KIND OF A VALUE WE HAVE
  0C15'   D2 0C77'              	JNC	FOUFRV			;WE HAVE A SNG OR DBL
                                					;HERE TO PRINT AN INTEGER IN FREE FORMAT
  0C18'   01 0000               	LXI	B,0			;SET THE DECIMAL POINT COUNT AND COMMA COUNT
                                					; TO ZERO
  0C1B'   CD 1076'              	CALL	FOUTCI			;CONVERT THE INTEGER TO DECIMAL
                                					;FALL INTO FOUTZS AND ZERO SUPPRESS THE THING
                                
                                
                                					;ZERO SUPPRESS THE DIGITS IN FBUFFR
                                					;ASTERISK FILL AND ZERO SUPPRESS IF NECESSARY
                                					;SET UP B AND CONDITION CODES IF WE HAVE A TRAILING SIGN
  0C1E'   21 0001*              FOUTZS:	LXI	H,FBUFFR+1		;GET POINTER TO THE SIGN
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-19
FLOATING POINT OUTPUT ROUTINE

  0C21'   46                    	MOV	B,M			;SAVE THE SIGN IN B
  0C22'   0E 20                 	MVI	C,' '			;DEFAULT FILL CHARACTER TO A SPACE
  0C24'   3A 0000*              	LDA	TEMP3			;GET FORMAT SPECS TO SEE IF WE HAVE TO
  0C27'   5F                    	MOV	E,A			; ASTERISK FILL.  SAVE IT
  0C28'   E6 20                 	ANI	40O
  0C2A'   CA 0C3B'              	JZ	FOTZS1			;WE DON'T
  0C2D'   78                    	MOV	A,B			;WE DO, SEE IF THE SIGN WAS A SPACE
  0C2E'   B9                    	CMP	C			;ZERO FLAG IS SET IF IT WAS
  0C2F'   0E 2A                 	MVI	C,'*'			;SET FILL CHARACTER TO AN ASTERISK
  0C31'   C2 0C3B'              	JNZ	FOTZS1			;SET THE SIGN TO AN ASTERISK IF IT WAS A SPACE
  0C34'   7B                    	MOV	A,E			;GET FORMAT SPECS AGAIN
  0C35'   E6 04                 	ANI	4			;SEE IF SIGN IS TRAILING
  0C37'   C2 0C3B'              	JNZ	FOTZS1			;IF SO DON'T ASTERISK FILL
  0C3A'   41                    	MOV	B,C			;B HAS THE SIGN, C THE FILL CHARACTER
  0C3B'   71                    FOTZS1:	MOV	M,C			;FILL IN THE ZERO OR THE SIGN
  0C3C'   CD 0000*              	CALL	CHRGTR			;GET THE NEXT CHARACTER IN THE BUFFER
                                					;SINCE THERE ARE NO SPACES, "CHRGET" IS
                                					; EQUIVALENT TO "INX	H"/"MOV	A,M"
  0C3F'   CA 0C5B'              	JZ	FOTZS4			;IF WE SEE A REAL ZERO, IT IS THE END OF
                                					; THE NUMBER, AND WE MUST BACK UP AND PUT
                                					; IN A ZERO.  CHRGET SETS THE ZERO FLAG ON
                                					; REAL ZEROS OR COLONS, BUT WE WON'T SEE
                                					; ANY COLONS IN THIS BUFFER.
  0C42'   FE 45                 	CPI	'E'			;BACK UP AND PUT IN A ZERO IF WE SEE
  0C44'   CA 0C5B'              	JZ	FOTZS4			;AN "E" OR A "D" SO WE CAN PRINT 0 IN
  0C47'   FE 44                 	CPI	'D'			;FLOATING POINT NOTATION WITH THE C FORMAT ZERO
  0C49'   CA 0C5B'              	JZ	FOTZS4
  0C4C'   FE 30                 	CPI	'0'			;DO WE HAVE A ZERO?
  0C4E'   CA 0C3B'              	JZ	FOTZS1			;YES, SUPPRESS IT
  0C51'   FE 2C                 	CPI	54O			;54=","  DO WE HAVE A COMMA?
  0C53'   CA 0C3B'              	JZ	FOTZS1			;YES, SUPPRESS IT
  0C56'   FE 2E                 	CPI	'.'			;ARE WE AT THE DECIMAL POINT?
  0C58'   C2 0C5E'              	JNZ	FOTZS2			;NO, I GUESS NOT
  0C5B'   2B                    FOTZS4:	DCX	H			;YES, BACK UP AND PUT A ZERO BEFORE IT
  0C5C'   36 30                 	MVI	M,'0'
  0C5E'   7B                    FOTZS2:	MOV	A,E			;GET THE FORMAT SPECS TO CHECK FOR A FLOATING
  0C5F'   E6 10                 	ANI	20O			; DOLLAR SIGN
  0C61'   CA 0C67'              	JZ	FOTZS3			;WE DON'T HAVE ONE
  0C64'   2B                    	DCX	H			;WE HAVE ONE, BACK UP AND PUT IN THE DOLLAR
  0C65'   36 24                 	MVI	M,CURNCY		; SIGN
  0C67'   7B                    FOTZS3:	MOV	A,E			;DO WE HAVE A TRAILING SIGN?
  0C68'   E6 04                 	ANI	4
  0C6A'   C0                    	RNZ				;YES, RETURN; NOTE THE NON-ZERO FLAG IS SET
  0C6B'   2B                    	DCX	H			;NO, BACK UP ONE AND PUT THE SIGN BACK IN
  0C6C'   70                    	MOV	M,B			;PUT IN THE SIGN
  0C6D'   C9                    	RET				;ALL DONE
                                
                                
                                					;HERE TO INITIALLY SET UP THE FORMAT SPECS AND PUT IN A SPACE FOR THE
                                					;SIGN OF A POSITIVE NUMBER
  0C6E'   32 0000*              FOUINI:	STA	TEMP3			;SAVE THE FORMAT SPECIFICATION
  0C71'   21 0001*              	LXI	H,FBUFFR+1		;GET A POINTER INTO FBUFFR
                                					;WE START AT FBUFFR+1 IN CASE THE NUMBER WILL
                                					; OVERFLOW ITS FIELD, THEN THERE IS ROOM IN
                                					; FBUFFR FOR THE PERCENT SIGN.
  0C74'   36 20                 	MVI	M,' '			;PUT IN A SPACE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-20
FLOATING POINT OUTPUT ROUTINE

  0C76'   C9                    	RET				;ALL DONE
                                
                                
                                					;HERE TO PRINT A SNG OR DBL IN FREE FORMAT
  0C77'                         FOUFRV:
                                					;THE FOLLOWING CODE DOWN TO FOUFRF: IS ADDED TO ADDRESS THE
                                					;ANSI STANDARD OF PRINTING NUMBERS IN FIXED FORMAT RATHER THAN
                                					;SCIENTIFIC NOTATION IF THEY CAN BE AS ACCURATELY RPRESENTED
                                					;IN FIXED FORMAT
                                
  0C77'   CD 031A'              	CALL	PUSHF			;SAVE IN CASE NEEDED FOR 2ED PASS
  0C7A'   EB                    	XCHG				;SAVE BUFFER POINTER IN (HL)
  0C7B'   2A 0000*              	LHLD	DFACLO
  0C7E'   E5                    	PUSH	H			;SAVE FOR D.P.
  0C7F'   2A 0002*              	LHLD	DFACLO+2		;
  0C82'   E5                    	PUSH	H			;
  0C83'   EB                    	XCHG				;BUFFER POINTER BACK TO (HL)
  0C84'   F5                    	PUSH	PSW			;SAVE IN CASE NEEDED FOR SECOND PASS
  0C85'   AF                    	XRA	A			;(A)=0
  0C86'   32 0000*              	STA	FANSII			;INITIALIZE FANSII FLAG
  0C89'   F1                    	POP	PSW			;GET PSW RIGHT
  0C8A'   F5                    	PUSH	PSW			;SAVE PSW
  0C8B'   CD 0D22'              	CALL	FOUFRF			;FORMAT NUMBER
  0C8E'   06 45                 	MVI	B,'E'			;WILL SEARCH FOR SCIENTIFIC NOTN.
  0C90'   0E 00                 	MVI	C,0			;DIGIT COUNTER
  0C92'                         FU1:					;GET ORIGINAL FBUFFER POINTER
  0C92'   E5                    	PUSH	H			;SAVE IN CASE WE NEED TO LOOK FOR "D"
  0C93'   7E                    	MOV	A,M			;FETCH UP FIRST CHARACTER
  0C94'   B8                    FU2:	CMP	B			;SCIENTIFIC NOTATION?
  0C95'   CA 0CC3'              	JZ	FU4			;IF SO, JUMP
  0C98'   FE 3A                 	CPI	72O			;IF CARRY NOT SET NOT A DIGIT
  0C9A'   D2 0CA3'              	JNC	FU2A
  0C9D'   FE 30                 	CPI	60O			;IF CARRY SET NOT A DIGIT
  0C9F'   DA 0CA3'              	JC	FU2A
  0CA2'   0C                    	INR	C			;INCREMENTED DIGITS TO PRINT
  0CA3'   23                    FU2A:	INX	H			;POINT TO NEXT BUFFER CHARACTER
  0CA4'   7E                    	MOV	A,M			;FETCH NEXT CHARACTER
  0CA5'   B7                    	ORA	A			;0(BINARY) AT THE END OF CHARACTERS
  0CA6'   C2 0C94'              	JNZ	FU2			;CONTINUE SEARCH IF NOT AT END
  0CA9'   3E 44                 	MVI	A,'D'			;NOW TO CHECK TO SEE IF SEARCHED FOR D
  0CAB'   B8                    	CMP	B
  0CAC'   47                    	MOV	B,A			;IN CASE NOT YET SEARCHED FOR
  0CAD'   E1                    	POP	H			;NOW TO CHECK FOR "D"
  0CAE'   0E 00                 	MVI	C,0			;ZERO DIGIT COUNT
  0CB0'   C2 0C92'              	JNZ	FU1			;GO SEARCH FOR "D" IF NOT DONE SO
  0CB3'   F1                    FU3:	POP	PSW			;POP	ORIGINAL PSW
  0CB4'   C1                    	POP	B
  0CB5'   D1                    	POP	D
                                					;GET DFACLO-DFACLO+3
  0CB6'   EB                    	XCHG				;(DE)=BUF PTR,(HL)=DFACLO
  0CB7'   22 0000*              	SHLD	DFACLO			;
  0CBA'   60                    	MOV	H,B
  0CBB'   69                    	MOV	L,C
  0CBC'   22 0002*              	SHLD	DFACLO+2
  0CBF'   EB                    	XCHG	
  0CC0'   C1                    	POP	B
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-21
FLOATING POINT OUTPUT ROUTINE

  0CC1'   D1                    	POP	D
                                					;GET ORIG FAC OFF STACK
  0CC2'   C9                    	RET				;COMPLETE
  0CC3'                         FU4:					;PRINT IS IN SCIENTIFIC NOTATION , IS THIS BEST?
  0CC3'   C5                    	PUSH	B			;SAVE TYPE,DIGIT COUNT
  0CC4'   06 00                 	MVI	B,0			;EXPONENT VALUE (IN BINARY)
  0CC6'   23                    	INX	H			;POINT TO NEXT CHARACTER OF EXP.
  0CC7'   7E                    	MOV	A,M			;FETCH NEXT CHARACTER OF EXPONENT
  0CC8'   FE 2B                 FU5:	CPI	'+'			;IS EXPONENT POSITIVE?
  0CCA'   CA 0D0A'              	JZ	FU8			;IF SO NO BETTER PRINTOUT
  0CCD'   FE 2D                 	CPI	'-'			;MUST BE NEGATIVE!
  0CCF'   CA 0CE1'              	JZ	FU5A			;MUST PROCESS THE DIGITS
  0CD2'   D6 30                 	SUI	'0'			;SUBTRACT OUT ASCII BIAS
  0CD4'   4F                    	MOV	C,A			;DIGIT TO C
  0CD5'   78                    	MOV	A,B			;FETCH OLD DIGIT
  0CD6'   87                    	ADD	A			;*2
  0CD7'   87                    	ADD	A			;*4
  0CD8'   80                    	ADD	B			;*5
  0CD9'   87                    	ADD	A			;*10
  0CDA'   81                    	ADD	C			;ADD IN NEW DIGIT
  0CDB'   47                    	MOV	B,A			;BACK OUT TO EXPONENT ACCUMULATOR
  0CDC'   FE 10                 	CPI	20O			;16 D.P. DIGITS FOR MICROSOFT FORMAT
  0CDE'   D2 0D0A'              	JNC	FU8			;IF SO STOP TRYING
  0CE1'   23                    FU5A:	INX	H			;POINT TO NEXT CHARACTER 
  0CE2'   7E                    	MOV	A,M			;FETCH UP
  0CE3'   B7                    	ORA	A			;BINARY ZERO AT END
  0CE4'   C2 0CC8'              	JNZ	FU5			;CONTINUE IF NOT AT END
  0CE7'   60                    	MOV	H,B			;SAVE EXPONENT
  0CE8'   C1                    	POP	B			;FETCH TYPE, DIGIT COUNT
  0CE9'   78                    	MOV	A,B			;DETERMINE TYPE
  0CEA'   FE 45                 	CPI	'E'			;SINGLE PRECISION?
  0CEC'   C2 0CFF'              	JNZ	FU7			;NO -GO PROCESS AS DOUBLE PRECISION
  0CEF'   79                    	MOV	A,C			;DIGIT COUNT
  0CF0'   84                    	ADD	H			;ADD EXPONENT VALUE
  0CF1'   FE 09                 	CPI	11O
  0CF3'   E1                    	POP	H			;POP	OLD BUFFER POINTER
  0CF4'   D2 0CB3'              	JNC	FU3			;CAN'T DO BETTER
  0CF7'   3E 80                 FU6:	MVI	A,200O			;
  0CF9'   32 0000*              	STA	FANSII			;
  0CFC'   C3 0D0F'              	JMP	FU9			;DO FIXED POINT PRINTOUT
  0CFF'   7C                    FU7:	MOV	A,H			;SAVE EXPONENT
  0D00'   81                    	ADD	C			;TOTAL DIGITS NECESSARY
  0D01'   FE 12                 	CPI	22O			;MUST PRODUCE CARRY TO USE FIXED POINT
  0D03'   E1                    	POP	H			;GET STACK RIGHT
  0D04'   D2 0CB3'              	JNC	FU3
  0D07'   C3 0CF7'              	JMP	FU6			;GO  RINT IN FIXED POINT
  0D0A'   C1                    FU8:	POP	B			;
  0D0B'   E1                    	POP	H			;GET ORIGINAL BUFFER PTR BACK
  0D0C'   C3 0CB3'              	JMP	FU3			;
  0D0F'   F1                    FU9:	POP	PSW			;GET ORIGINAL PSW OFF STACK
  0D10'   C1                    	POP	B
  0D11'   D1                    	POP	D
                                					;GET DFACLO-DFACLO+3
  0D12'   EB                    	XCHG				;(DE)=BUFFER PTR,(HL)=DFACLO
  0D13'   22 0000*              	SHLD	DFACLO			;
  0D16'   60                    	MOV	H,B
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-22
FLOATING POINT OUTPUT ROUTINE

  0D17'   69                    	MOV	L,C
  0D18'   22 0002*              	SHLD	DFACLO+2
  0D1B'   EB                    	XCHG	
  0D1C'   C1                    	POP	B
  0D1D'   D1                    	POP	D
                                					;GET ORIGINAL FAC BACK
  0D1E'   CD 032A'              	CALL	MOVFR			;MOVE TO FAC
  0D21'   23                    	INX	H			;BECAUSE WHEN WE ORIGINALLY ENTERED
                                					;FOUFRV THE (HL) POINTED TO A CHAR.
                                					;PAST THE SIGN AND THE PASS THROUGH
                                					;THIS CODE LEAVES (HL) POINTING TO
                                					;THE SIGN. (HL) MUST POINT PAST SIGN!
  0D22'                         FOUFRF:					;
  0D22'   FE 05                 	CPI	5			;SET CC'S FOR Z80
  0D24'   E5                    	PUSH	H			;SAVE THE BUFFER POINTER
  0D25'   DE 00                 	SBI	0			;MAP 4 TO 6 AND 10 TO 20
  0D27'   17                    	RAL				;THIS CALCULATES HOW MANY DIGITS WE WILL
  0D28'   57                    	MOV	D,A			; PRINT
  0D29'   14                    	INR	D
  0D2A'   CD 0F18'              	CALL	FOUTNV			;NORMALIZE THE FAC SO ALL SIGNIFICANT DIGITS
                                					; ARE IN THE INTEGER PART
  0D2D'   01 0300               	LXI	B,3*400O+0		;B = DECIMAL POINT COUNT
                                					;C = COMMA COUNT
                                					;SET COMMA COUNT TO ZERO AND DECIMAL POINT
                                					; COUNT FOR E NOTATION
                                
  0D30'   F5                    	PUSH	PSW			;SAVE FOR NORMAL CASE
  0D31'   3A 0000*              	LDA	FANSII			;SEE IF FORCED FIXED OUTPUT
  0D34'   B7                    	ORA	A			;SET CONDITION CODES CORRECTLY
  0D35'   F2 0D3D'              	JP	FOFV5A			;DO NORMAL THING
  0D38'   F1                    	POP	PSW			;
  0D39'   82                    	ADD	D
  0D3A'   C3 0D47'              	JMP	FOUFV6			;FIXED OUTPUT
  0D3D'   F1                    FOFV5A:	POP	PSW			;NORMAL ROUTE
  0D3E'   82                    	ADD	D			;SEE IF NUMBER SHOULD BE PRINTED IN E NOTATION
  0D3F'   FA 0D4B'              	JM	FOFRS1			;IT SHOULD, IT IS .LT. .01
  0D42'   14                    	INR	D			;CHECK IF IT IS TOO BIG
  0D43'   BA                    	CMP	D
  0D44'   D2 0D4B'              	JNC	FOFRS1			;IT IS TOO BIG, IT IS .GT. 10^D-1
  0D47'   3C                    FOUFV6:	INR	A			;IT IS OK FOR FIXED POINT NOTATION
  0D48'   47                    	MOV	B,A			;SET DECIMAL POINT COUNT
  0D49'   3E 02                 	MVI	A,2			;SET FIXED POINT FLAG, THE EXPONENT IS ZERO
                                					; IF WE ARE USING FIXED POINT NOTATION
  0D4B'   D6 02                 FOFRS1:	SUI	2			;E NOTATION: ADD D-2 TO ORIGINAL EXPONENT
                                					;RESTORE EXP IF NOT D.P.
  0D4D'   E1                    	POP	H			;GET THE BUFFER POINTER BACK
  0D4E'   F5                    	PUSH	PSW			;SAVE THE EXPONENT FOR LATER
  0D4F'   CD 0FB7'              	CALL	FOUTAN			;.01 .LE. NUMBER .LT. .1?
  0D52'   36 30                 	MVI	M,'0'			;YES, PUT ".0" IN BUFFER
  0D54'   CC 033F'              	CZ	INXHRT
  0D57'   CD 0FDE'              	CALL	FOUTCV			;CONVERT THE NUMBER TO DECIMAL DIGITS
                                					;HERE TO SUPPRESS THE TRAILING ZEROS
  0D5A'   2B                    FOFRS2:	DCX	H			;MOVE BACK TO THE LAST CHARACTER
  0D5B'   7E                    	MOV	A,M			;GET IT AND SEE IF IT WAS ZERO
  0D5C'   FE 30                 	CPI	'0'
  0D5E'   CA 0D5A'              	JZ	FOFRS2			;IT WAS, CONTINUE SUPPRESSING
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-23
FLOATING POINT OUTPUT ROUTINE

  0D61'   FE 2E                 	CPI	'.'			;HAVE WE SUPPRESSED ALL THE FRACTIONAL DIGITS?
  0D63'   C4 033F'              	CNZ	INXHRT			;YES, IGNORE THE DECIMAL POINT ALSO
  0D66'   F1                    	POP	PSW			;GET THE EXPONENT BACK
  0D67'   CA 0D8C'              	JZ	FOUTDN			;WE ARE DONE IF WE ARE IN FIXED POINT NOTATION
                                					;FALL IN AND PUT THE EXPONENT IN THE BUFFER
                                
                                
                                					;HERE TO PUT THE EXPONENT AND "E" OR "D" IN THE BUFFER
                                					;THE EXPONENT IS IN A, THE CONDITION CODES ARE ASSUMED TO BE SET
                                					;CORRECTLY.
  0D6A'   F5                    FOFLDN:	PUSH	PSW			;SAVE THE EXPONENT
  0D6B'   CD 0000*              	CALL	GETYPR			;SET CARRY FOR SINGLE PRECISION
  0D6E'   3E 22                 	MVI	A,42O			;[A]="D"/2
  0D70'   8F                    	ADC	A			;MULTIPLY BY 2 AND ADD CARRY
  0D71'   77                    	MOV	M,A			;SAVE IT IN THE BUFFER
  0D72'   23                    	INX	H			;INCREMENT THE BUFFER POINTER
                                					;PUT IN THE SIGN OF THE EXPONENT
  0D73'   F1                    	POP	PSW			;GET THE EXPONENT BACK
  0D74'   36 2B                 	MVI	M,'+'			;A PLUS IF POSITIVE
  0D76'   F2 0D7D'              	JP	FOUCE1
  0D79'   36 2D                 	MVI	M,'-'			;A MINUS IF NEGATIVE
  0D7B'   2F                    	CMA				;NEGATE EXPONENT
  0D7C'   3C                    	INR	A
                                					;CALCULATE THE TWO DIGIT EXPONENT
  0D7D'   06 2F                 FOUCE1:	MVI	B,'0'-1			;INITIALIZE TEN'S DIGIT COUNT
  0D7F'   04                    FOUCE2:	INR	B			;INCREMENT DIGIT
  0D80'   D6 0A                 	SUI	12O			;SUBTRACT TEN
  0D82'   D2 0D7F'              	JNC	FOUCE2			;DO IT AGAIN IF RESULT WAS POSITIVE
  0D85'   C6 3A                 	ADI	'0'+12O			;ADD BACK IN TEN AND CONVERT TO ASCII
                                					;PUT THE EXPONENT IN THE BUFFER
  0D87'   23                    	INX	H
  0D88'   70                    	MOV	M,B			;PUT TEN'S DIGIT OF EXPONENT IN BUFFER
  0D89'   23                    	INX	H			;WHEN WE JUMP TO HERE, A IS ZERO
  0D8A'   77                    	MOV	M,A			;PUT ONE'S DIGIT IN BUFFER
  0D8B'   23                    FOUTZR:	INX	H			;INCREMENT POINTER, HERE TO FINISH UP
                                					; PRINTING A FREE FORMAT ZERO
  0D8C'   36 00                 FOUTDN:	MVI	M,0			;PUT A ZERO AT THE END OF THE NUMBER
  0D8E'   EB                    	XCHG				;SAVE THE POINTER TO THE END OF THE NUMBER
                                					; IN (DE) FOR FFXFLV
  0D8F'   21 0001*              	LXI	H,FBUFFR+1		;GET A POINTER TO THE BEGINNING
  0D92'   C9                    	RET				;ALL DONE
                                
                                
                                
                                
                                					;HERE TO PRINT A NUMBER IN FIXED FORMAT
  0D93'   23                    FOUTFX:	INX	H			;MOVE PAST THE ZERO FOR THE DOLLAR SIGN
  0D94'   C5                    	PUSH	B			;SAVE THE FIELD LENGTH SPECIFICATIONS
  0D95'   FE 04                 	CPI	4			;CHECK WHAT KIND OF VALUE WE HAVE
  0D97'   7A                    	MOV	A,D			;GET THE FORMAT SPECS
  0D98'   D2 0E0D'              	JNC	FOUFXV			;WE HAVE A SNG OR A DBL
                                					;HERE TO PRINT AN INTEGER IN FIXED FORMAT
  0D9B'   1F                    	RAR				;CHECK IF WE HAVE TO PRINT IT IN FLOATING
  0D9C'   DA 0EAA'              	JC	FFXIFL			; POINT NOTATION
                                					;HERE TO PRINT AN INTEGER IN FIXED FORMAT-FIXED POINT NOTATION
  0D9F'   01 0603               	LXI	B,6*400O+3+0		;SET DECIMAL POINT COUNT TO 6 AND
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-24
FLOATING POINT OUTPUT ROUTINE

                                					; COMMA COUNT TO 3
  0DA2'   CD 0FAF'              	CALL	FOUICC			;CHECK IF WE DON'T HAVE TO USE THE COMMAS
  0DA5'   D1                    	POP	D			;GET THE FIELD LENGTHS
  0DA6'   7A                    	MOV	A,D			;SEE IF WE HAVE TO PRINT EXTRA SPACES BECAUSE
  0DA7'   D6 05                 	SUI	5			; THE FIELD IS TOO BIG
  0DA9'   F4 0F8B'              	CP	FOTZER			;WE DO, PUT IN ZEROS, THEY WILL LATER BE
                                					; CONVERTED TO SPACES OR ASTERISKS BY FOUTZS
  0DAC'   CD 1076'              	CALL	FOUTCI			;CONVERT THE NUMBER TO DECIMAL DIGITS
  0DAF'   7B                    FOUTTD:	MOV	A,E			;DO WE NEED A DECIMAL POINT?
  0DB0'   B7                    	ORA	A
  0DB1'   CC 02A0'              	CZ	DCXHRT			;WE DON'T, BACKSPACE OVER IT.
  0DB4'   3D                    	DCR	A			;GET HOW MANY TRAILING ZEROS TO PRINT
  0DB5'   F4 0F8B'              	CP	FOTZER			;PRINT THEM
                                					;IF WE DO HAVE DECIMAL PLACES, FILL THEM UP
                                					; WITH ZEROS
                                					;FALL IN AND FINISH UP THE NUMBER
                                
                                
                                					;HERE TO FINISH UP A FIXED FORMAT NUMBER
  0DB8'   E5                    FOUTTS:	PUSH	H			;SAVE BUFFER POINTER
  0DB9'   CD 0C1E'              	CALL	FOUTZS			;ZERO SUPPRESS THE NUMBER
  0DBC'   E1                    	POP	H			;GET THE BUFFER POINTER BACK
  0DBD'   CA 0DC2'              	JZ	FFXIX1			;CHECK IF WE HAVE A TRAILING SIGN
  0DC0'   70                    	MOV	M,B			;WE DO, PUT THE SIGN IN THE BUFFER
  0DC1'   23                    	INX	H			;INCREMENT THE BUFFER POINTER
  0DC2'   36 00                 FFXIX1:	MVI	M,0			;PUT A ZERO AT THE END OF THE NUMBER
                                
                                
                                					;HERE TO CHECK IF A FIXED FORMAT-FIXED POINT NUMBER OVERFLOWED ITS
                                					;FIELD LENGTH
                                					;D = THE B IN THE FORMAT SPECIFICATION
                                					;THIS ASSUMES THE LOCATION OF THE DECIMAL POINT IS IN TEMP2
  0DC4'   21 0000*              	LXI	H,FBUFFR		;GET A POINTER TO THE BEGINNING
  0DC7'   23                    FOUBE1:	INX	H			;INCREMENT POINTER TO THE NEXT CHARACTER
  0DC8'   3A 0000*              FOUBE5:	LDA	TEMP2			;GET THE LOCATION OF THE DECIMAL POINT
                                					;SINCE FBUFFR IS ONLY 35 (DECIMAL) LONG, WE
                                					; ONLY HAVE TO LOOK AT THE LOW ORDER TO SEE
                                					; IF THE FIELD IS BIG ENOUGH
  0DCB'   95                    	SUB	L			;FIGURE OUT HOW MUCH SPACE WE ARE TAKING
  0DCC'   92                    	SUB	D			;IS THIS THE RIGHT AMOUNT OF SPACE TO TAKE?
  0DCD'   C8                    	RZ				;YES, WE ARE DONE, RETURN FROM FOUT
  0DCE'   7E                    	MOV	A,M			;NO, WE MUST HAVE TOO MUCH SINCE WE STARTED
                                					; CHECKING FROM THE BEGINNING OF THE BUFFER
                                					; AND THE FIELD MUST BE SMALL ENOUGH TO FIT IN
                                					; THE BUFFER.  GET THE NEXT CHARACTER IN
                                					; THE BUFFER.
  0DCF'   FE 20                 	CPI	' '			;IF IT IS A SPACE OR AN ASTERISK, WE CAN
  0DD1'   CA 0DC7'              	JZ	FOUBE1			; IGNORE IT AND MAKE THE FIELD SHORTER WITH
  0DD4'   FE 2A                 	CPI	'*'			; NO ILL EFFECTS
  0DD6'   CA 0DC7'              	JZ	FOUBE1
  0DD9'   2B                    	DCX	H			;MOVE THE POINTER BACK ONE TO READ THE
                                					; CHARACTER WITH CHRGET
  0DDA'   E5                    	PUSH	H			;SAVE THE POINTER
                                
                                					;HERE WE SEE IF WE CAN IGNORE THE LEADING ZERO BEFORE A DECIMAL POINT.
                                					;THIS OCCURS IF WE SEE THE FOLLOWING: (IN ORDER)
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-25
FLOATING POINT OUTPUT ROUTINE

                                					;	+,-	A SIGN (EITHER "-" OR "+")	[OPTIONAL]
                                					;	$	A DOLLAR SIGN			[OPTIONAL]
                                					;	0	A ZERO				[MANDATORY]
                                					;	.	A DECIMAL POINT			[MANDATORY]
                                					;	0-9	ANOTHER DIGIT			[MANDATORY]
                                					;IF YOU SEE A LEADING ZERO, IT MUST BE THE ONE BEFORE A DECIMAL POINT
                                					;OR ELSE FOUTZS WOULD HAVE SUPPRESSED IT, SO WE CAN JUST "INX	H"
                                					;OVER THE CHARACTER FOLLOWING THE ZERO, AND NOT CHECK FOR THE
                                					;DECIMAL POINT EXPLICITLY.
  0DDB'   F5                    FOUBE2:	PUSH	PSW			;PUT THE LAST CHARACTER ON THE STACK.  THE
                                					; ZERO FLAG IS SET.  THE FIRST TIME THE ZERO
                                					; ZERO FLAG IS NOT SET.
  0DDC'   01 0DDB'              	LXI	B,FOUBE2		;GET ADDRESS WE GO TO IF WE SEE A CHARACTER
  0DDF'   C5                    	PUSH	B			; WE ARE LOOKING FOR
  0DE0'   CD 0000*              	CALL	CHRGTR			;GET THE NEXT CHARACTER
  0DE3'   FE 2D                 	CPI	'-'			;SAVE IT AND GET THE NEXT CHARACTER IF IT IS
  0DE5'   C8                    	RZ				; A MINUS SIGN, A PLUS SIGN OR A DOLLAR SIGN
  0DE6'   FE 2B                 	CPI	'+'
  0DE8'   C8                    	RZ	
  0DE9'   FE 24                 	CPI	CURNCY
  0DEB'   C8                    	RZ	
  0DEC'   C1                    	POP	B			;IT ISN'T, GET THE ADDRESS OFF THE STACK
  0DED'   FE 30                 	CPI	'0'			;IS IT A ZERO?
  0DEF'   C2 0E05'              	JNZ	FOUBE4			;NO, WE CAN NOT GET RID OF ANOTHER CHARACTER
  0DF2'   23                    	INX	H			;SKIP OVER THE DECIMAL POINT
  0DF3'   CD 0000*              	CALL	CHRGTR			;GET THE NEXT CHARACTER
  0DF6'   D2 0E05'              	JNC	FOUBE4			;IT IS NOT A DIGIT, WE CAN'T SHORTEN THE FIELD
  0DF9'   2B                    	DCX	H			;WE CAN!!!  POINT TO THE DECIMAL POINT
  0DFA'   01                    	DB	001			;"LXI	B" OVER THE NEXT 2 BYTES
  0DFB'   2B                    FOUBE3:	DCX	H			;POINT BACK ONE CHARACTER
  0DFC'   77                    	MOV	M,A			;PUT THE CHARACTER BACK
                                
                                					;IF WE CAN GET RID OF THE ZERO, WE PUT THE CHARACTERS ON THE STACK
                                					;BACK INTO THE BUFFER ONE POSITION IN FRONT OF WHERE THEY ORIGINALLY
                                					;WERE.  NOTE THAT THE MAXIMUM NUMBER OF STACK LEVELS THIS USES IS
                                					;THREE -- ONE FOR THE LAST ENTRY FLAG, ONE FOR A POSSIBLE SIGN,
                                					;AND ONE FOR A POSSIBLE DOLLAR SIGN.  WE DON'T HAVE TO WORRY ABOUT
                                					;THE FIRST CHARACTER BEING IN THE BUFFER TWICE BECAUSE THE POINTER
                                					;WHEN FOUT EXITS WILL BE POINTING TO THE SECOND OCCURANCE.
  0DFD'   F1                    	POP	PSW			;GET THE CHARACTER OFF THE STACK
  0DFE'   CA 0DFB'              	JZ	FOUBE3			;PUT IT BACK IN THE BUFFER IF IT IS NOT THE
                                					; LAST ONE
  0E01'   C1                    	POP	B			;GET THE BUFFER POINTER OFF THE STACK
  0E02'   C3 0DC8'              	JMP	FOUBE5			;SEE IF THE FIELD IS NOW SMALL ENOUGH
                                					;HERE IF THE NUMBER IS TOO BIG FOR THE FIELD
  0E05'   F1                    FOUBE4:	POP	PSW			;GET THE CHARACTERS OFF THE STACK
  0E06'   CA 0E05'              	JZ	FOUBE4			;LEAVE THE NUMBER IN THE BUFFER ALONE
  0E09'   E1                    	POP	H			;GET THE POINTER TO THE BEGINNING OF THE
                                					; NUMBER MINUS 1
  0E0A'   36 25                 	MVI	M,'%'			;PUT IN A PERCENT SIGN TO INDICATE THE NUMBER
                                					; WAS TOO LARGE FOR THE FIELD
  0E0C'   C9                    	RET				;ALL DONE -- RETURN FROM FOUT
                                
                                
                                					;HERE TO PRINT A SNG OR DBL IN FIXED FORMAT
  0E0D'   E5                    FOUFXV:	PUSH	H			;SAVE THE BUFFER POINTER
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-26
FLOATING POINT OUTPUT ROUTINE

  0E0E'   1F                    	RAR				;GET FIXED OR FLOATING NOTATION FLAG IN CARRY
  0E0F'   DA 0EB1'              	JC	FFXFLV			;PRINT THE NUMBER IN E-NOTATION
  0E12'   CA 0E29'              	JZ	FFXSFX			;WE HAVE A SNG
                                					;HERE TO PRINT A DBL IN FIXED FORMAT--FIXED POINT NOTATION
  0E15'   11 10CD'              	LXI	D,FFXDXM		;GET POINTER TO 1D16
  0E18'   CD 03C4'              	CALL	DCOMPD			;WE CAN'T PRINT A NUMBER .GE. 10^16 IN FIXED
                                					; POINT NOTATION
  0E1B'   16 10                 	MVI	D,20O			;SET D = NUMBER OF DIGITS TO PRINT FOR A DBL
  0E1D'   FA 0E37'              	JM	FFXSDC			;IF THE FAC WAS SMALL ENOUGH, GO PRINT IT
                                					;HERE TO PRINT IN FREE FORMAT WITH A PERCENT SIGN A NUMBER .GE. 10^16
  0E20'   E1                    FFXSDO:	POP	H			;GET THE BUFFER POINTER OFF THE STACK
  0E21'   C1                    	POP	B			;GET THE FIELD SPECIFICATION OFF THE STACK
  0E22'   CD 0BE5'              	CALL	FOUT			;PRINT THE NUMBER IN FREE FORMAT
  0E25'   2B                    	DCX	H			;POINT TO IN FRONT OF THE NUMBER
  0E26'   36 25                 	MVI	M,'%'			;PUT IN THE PERCENT SIGN
  0E28'   C9                    	RET				;ALL DONE--RETURN FROM FOUT
                                
                                					;HERE TO PRINT A SNG IN FIXED FORMAT--FIXED POINT NOTATION
  0E29'   01 B60E               FFXSFX:	LXI	B,266Q*256+016Q
  0E2C'   11 1BCA               	LXI	D,033Q*256+312Q		;GET 1E16, CHECK IF THE NUMBER IS TOO BIG
  0E2F'   CD 0387'              	CALL	FCOMP
  0E32'   F2 0E20'              	JP	FFXSDO			;IT IS, PRINT IT IN FREE FORMAT WITH A % SIGN
  0E35'   16 06                 	MVI	D,6			;D = NUMBER OF DIGITS TO PRINT IN A SNG
                                
                                					;HERE TO ACTUALLY PRINT A SNG OR DBL IN FIXED FORMAT
  0E37'   CD 02C6'              FFXSDC:	CALL	SIGN			;SEE IF WE HAVE ZERO
  0E3A'   C4 0F18'              	CNZ	FOUTNV			;IF NOT, NORMALIZE THE NUMBER SO ALL DIGITS TO
                                					; BE PRINTED ARE IN THE INTEGER PART
  0E3D'   E1                    	POP	H			;GET THE BUFFER POINTER
  0E3E'   C1                    	POP	B			;GET THE FIELD LENGTH SPECS
  0E3F'   FA 0E5C'              	JM	FFXXVS			;DO DIFFERENT STUFF IF EXPONENT IS NEGATIVE
                                					;HERE TO PRINT A NUMBER WITH NO FRACTIONAL DIGITS
  0E42'   C5                    FFXSD2:	PUSH	B			;SAVE THE FIELD LENGTH SPECS AGAIN
  0E43'   5F                    	MOV	E,A			;SAVE THE EXPONENT IN E
  0E44'   78                    	MOV	A,B			;WE HAVE TO PRINT LEADING ZEROS IF THE FIELD
  0E45'   92                    	SUB	D			; HAS MORE CHARACTERS THAN THERE ARE DIGITS
  0E46'   93                    	SUB	E			; IN THE NUMBER.
                                					;IF WE ARE USING COMMAS, A MAY BE TOO BIG.
                                					;THIS DOESN'T MATTER BECAUSE FOUTTS WILL FIND
                                					; THE CORRECT BEGINNING.  THERE IS ROOM IN
                                					; FBUFFR BECAUSE THE MAXIMUM VALUE B CAN BE IS
                                					; 24 (DECIMAL) SO D+C .LE. 16 (DECIMAL)  SINCE
                                					; FAC .LT. 10^16.
                                					;SO WE NEED 8 MORE BYTES FOR ZEROS.  4 COME
                                					; SINCE WE WILL NOT NEED TO PRINT AN EXPONENT.
                                					; FBUFFR ALSO CONTAINS AN EXTRA 4 BYTES FOR
                                					; THIS CASE.
                                					;(IT WOULD TAKE MORE THAN 4 BYTES TO CHECK FOR
                                					; THIS.)
  0E47'   F4 0F8B'              	CP	FOTZER			;FOUTZS WILL LATER SUPPRESS THEM
  0E4A'   CD 0FA2'              	CALL	FOUTCD			;SETUP DECIMAL POINT AND COMMA COUNT
  0E4D'   CD 0FDE'              	CALL	FOUTCV			;CONVERT THE NUMBER TO DECIMAL DIGITS
  0E50'   B3                    	ORA	E			;PUT IN DIGITS AFTER THE NUMBER IF IT
                                					; IS BIG ENOUGH, HERE A=0
  0E51'   C4 0F9B'              	CNZ	FOTZEC			;THERE CAN BE COMMAS IN THESE ZEROS
  0E54'   B3                    	ORA	E			;MAKE SURE WE GET A DECIMAL POINT FOR FOUTTS
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-27
FLOATING POINT OUTPUT ROUTINE

  0E55'   C4 0FCA'              	CNZ	FOUTED
  0E58'   D1                    	POP	D			;GET THE FIELD LENGTH SPECS
  0E59'   C3 0DAF'              	JMP	FOUTTD			;GO CHECK THE SIZE, ZERO SUPPRESS, ETC. AND
                                					; FINISH THE NUMBER
                                
                                					;HERE TO PRINT A SNG OR DBL THAT HAS FRACTIONAL DIGITS
  0E5C'   5F                    FFXXVS:	MOV	E,A			;SAVE THE EXPONENT
  0E5D'   79                    	MOV	A,C			;DIVIDE BY TEN THE RIGHT NUMBER OF TIMES SO
  0E5E'   B7                    	ORA	A			; THE RESULT WILL BE ROUNDED CORRECTLY AND
  0E5F'   C4 0A50'              	CNZ	DCRART			; HAVE THE CORRECT NUMBER OF SIGNIFICANT
  0E62'   83                    	ADD	E			; DIGITS
  0E63'   FA 0E67'              FFXXS2:	JM	FFXXV8			;FOR LATER CALCULATIONS, WE WANT A ZERO IF THE
  0E66'   AF                    	XRA	A			; RESULT WAS NOT NEGATIVE
  0E67'   C5                    FFXXV8:	PUSH	B			;SAVE THE FIELD SPECS
  0E68'   F5                    	PUSH	PSW			;SAVE THIS NUMBER FOR LATER
  0E69'   FC 0A52'              FFXXV2:	CM	FINDIV			;THIS IS THE DIVIDE LOOP
  0E6C'   FA 0E69'              	JM	FFXXV2
  0E6F'   C1                    	POP	B			;GET THE NUMBER WE SAVED BACK IN B
  0E70'   7B                    	MOV	A,E			;WE HAVE TWO CASES DEPENDING ON WHETHER THE
  0E71'   90                    	SUB	B			; THE NUMBER HAS INTEGER DIGITS OR NOT
  0E72'   C1                    	POP	B			;GET THE FILED SPECS BACK
  0E73'   5F                    	MOV	E,A			;SAVE HOW MANY DECIMAL PLACES BEFORE THE
  0E74'   82                    	ADD	D			; THE NUMBER ENDS
  0E75'   78                    FFXXS4:	MOV	A,B			;GET THE "B" FIELD SPEC
  0E76'   FA 0E85'              	JM	FFXXV3
                                					;HERE TO PRINT NUMBERS WITH INTEGER DIGITS
  0E79'   92                    	SUB	D			;PRINT SOME LEADING ZEROS IF THE FIELD IS
  0E7A'   93                    	SUB	E			; BIGGER THAN THE NUMBER OF DIGITS WE WILL
  0E7B'   F4 0F8B'              FFXXS6:	CP	FOTZER			; PRINT
  0E7E'   C5                    	PUSH	B			;SAVE FIELD SPEC
  0E7F'   CD 0FA2'              	CALL	FOUTCD			;SET UP DECIMAL POINT AND COMMA COUNT
  0E82'   C3 0E96'              	JMP	FFXXV6			;CONVERT THE DIGITS AND DO THE TRIMMING UP
                                
                                					;HERE TO PRINT A NUMBER WITHOUT INTEGER DIGITS
  0E85'   CD 0F8B'              FFXXV3:	CALL	FOTZER			;PUT ALL ZEROS BEFORE THE DECIMAL POINT
  0E88'   79                    	MOV	A,C			;SAVE C
  0E89'   CD 0FCE'              	CALL	FOUTDP			;PUT IN A DECIMAL POINT
  0E8C'   4F                    	MOV	C,A			;RESTORE C
  0E8D'   AF                    	XRA	A			;DECIDE HOW MANY ZEROS TO PRINT BETWEEN THE
  0E8E'   92                    	SUB	D			; DECIMAL POINT AND THE FIRST DIGIT WE WILL
  0E8F'   93                    	SUB	E			; PRINT.
  0E90'   CD 0F8B'              	CALL	FOTZER			;PRINT THE ZEROS
  0E93'   C5                    	PUSH	B			;SAVE EXPONENT AND THE "C" IN THE FIELD SPEC
  0E94'   47                    	MOV	B,A			;ZERO THE DECIMAL PLACE COUNT
  0E95'   4F                    	MOV	C,A			;ZERO THE COMMA COUNT
  0E96'   CD 0FDE'              FFXXV6:	CALL	FOUTCV			;CONVERT THE NUMBER TO DECIMAL DIGITS
  0E99'   C1                    	POP	B			;GET THE FIELD SPECS BACK
  0E9A'   B1                    	ORA	C			;CHECK IF WE HAVE TO PRINT ANY ZEROS AFTER
                                					; THE LAST DIGIT
  0E9B'   C2 0EA1'              	JNZ	FFXXV7			;CHECK IF THERE WERE ANY DECIMAL PLACES AT ALL
                                					;E CAN NEVER BE 200, (IT IS NEGATIVE) SO IF
                                					; A=0 HERE, THERE IS NO WAY WE WILL CALL FOTZER 
  0E9E'   2A 0000*              	LHLD	TEMP2			;THE END OF THE NUMBER IS WHERE THE DP IS
  0EA1'   83                    FFXXV7:	ADD	E			;PRINT SOME MORE TRAILING ZEROS
  0EA2'   3D                    	DCR	A
  0EA3'   F4 0F8B'              	CP	FOTZER
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-28
FLOATING POINT OUTPUT ROUTINE

  0EA6'   50                    	MOV	D,B			;GET THE "B" FIELD SPEC IN D FOR FOUTTS
  0EA7'   C3 0DB8'              	JMP	FOUTTS			;FINISH UP THE NUMBER
                                
                                
                                					;HERE TO PRINT AN INTEGER IN FIXED FORMAT--FLOATING POINT NOTATION
  0EAA'   E5                    FFXIFL:	PUSH	H			;SAVE THE BUFFER POINTER
  0EAB'   D5                    	PUSH	D			;SAVE THE FORMAT SPECS
  0EAC'   CD 0492'              	CALL	CONSI			;CONVERT THE INTEGER TO A SNG
  0EAF'   D1                    	POP	D			;GET THE FORMAT SPECS BACK
  0EB0'   AF                    	XRA	A			;SET FLAGS TO PRINT THE NUMBER AS A SNG
                                					;FALL INTO FFXFLV
                                
                                
                                					;HERE TO PRINT A SNG OR DBL IN FIXED FORMAT-FLOTATING POINT NOTATION
  0EB1'   CA 0EB7'              FFXFLV:	JZ	FFXSFL			;IF WE HAVE A SNG, SET THE RIGHT FLAGS
  0EB4'   1E 10                 	MVI	E,20O			;WE HAVE A DBL, GET HOW MANY DIGITS WE HAVE
  0EB6'   01                    	DB	001			;"LXI	B" OVER THE NEXT TWO BYTES
  0EB7'   1E 06                 FFXSFL:	MVI	E,6			;WE HAVE A SNG, GET HOW MANY DIGITS WE PRINT
  0EB9'   CD 02C6'              	CALL	SIGN			;SEE IF WE HAVE ZERO
  0EBC'   37                    FFXS03:	STC				;SET CARRY TO DETERMINE IF WE ARE PRINTING
                                					;ZERO. NOTE: THIS DEPENDS ON THE FACT THAT
                                					;FOUTNV EXITS WITH CARRY OFF
  0EBD'   C4 0F18'              	CNZ	FOUTNV			;IF NOT, NORMALIZE THE NUMBER SO ALL DIGITS TO
                                					; BE PRINTED ARE IN THE INTEGER PART
  0EC0'   E1                    	POP	H			;GET THE BUFFER POINTER BACK
  0EC1'   C1                    	POP	B			;GET THE FIELD LENGTH SPECS
  0EC2'   F5                    	PUSH	PSW			;SAVE THE EXPONENT
  0EC3'   79                    	MOV	A,C			;CALCULATE HOW MANY SIGNIFICANT DIGITS WE MUST
  0EC4'   B7                    	ORA	A			; PRINT
  0EC5'   F5                    	PUSH	PSW			;SAVE THE "C" FIELD SPEC FOR LATER
  0EC6'   C4 0A50'              	CNZ	DCRART
  0EC9'   80                    	ADD	B
  0ECA'   4F                    	MOV	C,A
  0ECB'   7A                    	MOV	A,D			;GET THE "A" FIELD SPEC
  0ECC'   E6 04                 	ANI	4			;SEE IF THE SIGN IS A TRAILING SIGN
  0ECE'   FE 01                 	CPI	1			;SET CARRY IF A IS ZERO
  0ED0'   9F                    	SBB	A			;SET D=0 IF WE HAVE A TRAILING SIGN,
  0ED1'   57                    	MOV	D,A			; D=377 IF WE DO NOT
  0ED2'   81                    	ADD	C
  0ED3'   4F                    	MOV	C,A			;SET C=NUMBER OF SIGNIFICANT DIGITS TO PRINT
  0ED4'   93                    	SUB	E			;IF WE HAVE LESS THAN E, THEN WE MUST GET RID
  0ED5'   F5                    	PUSH	PSW			;SAVE COMPARISON # OF SIG DIGITS AND THE
                                					;# OF DIGITS WE WILL PRINT
  0ED6'   C5                    	PUSH	B			;SAVE THE "B" FIELD SPEC AND # OF SIG DIGITS
  0ED7'   FC 0A52'              FFXLV1:	CM	FINDIV			; OF SOME BY DIVIDING BY TEN AND ROUNDING
  0EDA'   FA 0ED7'              	JM	FFXLV1
  0EDD'   C1                    	POP	B			;GET "B" FIELD SPEC AND # OF SIG DIGITS BACK
  0EDE'   F1                    	POP	PSW			;GET # OF TRAILING ZEROS TO PRINT
  0EDF'   C5                    	PUSH	B			;SAVE THE "B" FIELD SPEC AND # OF SIG DIGITS
  0EE0'   F5                    	PUSH	PSW			;SAVE # OF TRAILING ZEROS TO PRINT
  0EE1'   FA 0EE5'              	JM	FFXLV3			;TAKE INTO ACCOUNT DIGITS THAT WERE
  0EE4'   AF                    	XRA	A			;DIVIDED OFF AT FFXLV1
  0EE5'   2F                    FFXLV3:	CMA	
  0EE6'   3C                    	INR	A
  0EE7'   80                    	ADD	B			;SET THE DECIMAL PLACE COUNT
  0EE8'   3C                    	INR	A
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-29
FLOATING POINT OUTPUT ROUTINE

  0EE9'   82                    	ADD	D			;TAKE INTO ACCOUNT IF THE SIGN IS TRAILING
  0EEA'   47                    	MOV	B,A			; OR NOT
  0EEB'   0E 00                 	MVI	C,0			;SET COMMA COUNT TO ZERO, THE COMMA SPEC IS
                                					; IGNORED.
  0EED'   CD 0FDE'              	CALL	FOUTCV			;CONVERT THE NUMBER TO DECIMAL DIGITS
  0EF0'   F1                    	POP	PSW			;GET NUMBER TRAILING ZEROS TO PRINT
                                					;IF THE FIELD LENGTH IS LONGER THAN THE # OF DIGITS
                                					;WE CAN PRINT
  0EF1'   F4 0F94'              	CP	FOTZNC			;THE DECIMAL POINT COULD COME OUT IN HERE
  0EF4'   CD 0FCA'              	CALL	FOUTED			;IN CASE D.P. IS LAST ON LIST
  0EF7'   C1                    	POP	B			;GET # OF SIG DIGITS AND "B" FIELD SPAC BACK
  0EF8'   F1                    	POP	PSW			;GET THE "C" FIELD SPEC BACK
  0EF9'   C2 0F08'              	JNZ	FFXLV4			;IF NON-ZERO PROCEED
  0EFC'   CD 02A0'              	CALL	DCXHRT			;SEE IF D.P. THERE
  0EFF'   7E                    	MOV	A,M			;FETCH TO MAKE SURE D.P.
  0F00'   FE 2E                 	CPI	'.'			;IF NOT MUST BE ZERO
  0F02'   C4 033F'              	CNZ	INXHRT			;IF NOT MUST LEAVE AS IS
  0F05'   22 0000*              	SHLD	TEMP2			;NEED D.P. LOCATION IN TEMP2
  0F08'                         FFXLV4:					; SO IGNORE IT.
  0F08'   F1                    	POP	PSW			;GET THE EXPONENT BACK
  0F09'   DA 0F0F'              	JC	FFXLV2			;EXPONENT=0 IF THE NUMBER IS ZERO
  0F0C'   83                    	ADD	E			;SCALE IT CORRECTLY
  0F0D'   90                    	SUB	B
  0F0E'   92                    	SUB	D
  0F0F'   C5                    FFXLV2:	PUSH	B			;SAVE THE "B" FIELD SPEC
  0F10'   CD 0D6A'              	CALL	FOFLDN			;PUT THE EXPONENT IN THE BUFFER
  0F13'   EB                    	XCHG				;GET THE POINTER TO THE END IN (HL)
                                					; IN CASE WE HAVE A TRAILING SIGN
  0F14'   D1                    	POP	D			;GET THE "B" FIELD SPEC IN D, PUT ON A
  0F15'   C3 0DB8'              	JMP	FOUTTS			; POSSIBLE TRAILING SIGN AND WE ARE DONE
                                
                                
                                					;NORMALIZE THE NUMBER IN THE FAC SO ALL THE DIGITS ARE IN THE INTEGER
                                					;PART.  RETURN THE BASE 10 EXPONENT IN A
                                					;D,E ARE LEFT UNALTERED
  0F18'   D5                    FOUTNV:	PUSH	D			;SAVE (DE)
  0F19'   AF                    	XRA	A			;ZERO THE EXPONENT
  0F1A'   F5                    	PUSH	PSW			;SAVE IT
  0F1B'   CD 0000*              	CALL	GETYPR			;GET TYPE OF NUMBER TO BE PRINTED
  0F1E'   E2 0F3C'              	JPO	FOUNDB			;NOT DOUBLE, DO NORMAL THING
  0F21'   3A 0000*              FORBIG:	LDA	FAC			;GET EXPONENT
  0F24'   FE 91                 	CPI	221O			;IS IT .LT.1D5?
  0F26'   D2 0F3C'              	JNC	FOUNDB			;NO, DONT MULTPLY
  0F29'   11 10AD'              	LXI	D,TENTEN		;MULTIPLY BY 1D10
  0F2C'   21 0000*              	LXI	H,ARGLO			;MOVE INTO ARG
  0F2F'   CD 034A'              	CALL	VMOVE			;PUT IN ARG
  0F32'   CD 07E5'              	CALL	DMULT			;MULTIPLY BY IT
  0F35'   F1                    	POP	PSW			;GET ORIG EXPONENT OFF STACK
  0F36'   D6 0A                 	SUI	10			;GET PROPER OFFSET FOR EXPONENT
  0F38'   F5                    	PUSH	PSW			;SAVE EXPONENT BACK
  0F39'   C3 0F21'              	JMP	FORBIG			;FORCE IT BIGGER IF POSSIBLE
  0F3C'   CD 0F6E'              FOUNDB:	CALL	FOUNVC			;IS THE FAC TOO BIG OR TOO SMALL?
  0F3F'   CD 0000*              FOUNV1:	CALL	GETYPR			;SEE WHAT KIND OF VALUE WE HAVE SO WE
                                					; CAN SEE IF THE FAC IS BIG ENOUGH
  0F42'   EA 0F51'              	JPE	FOUNV4			;WE HAVE A DBL
  0F45'   01 9143               	LXI	B,221Q*256+103Q
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-30
FLOATING POINT OUTPUT ROUTINE

  0F48'   11 4FF9               	LXI	D,117Q*256+371Q		;GET 99999.95 TO SEE IF THE FAC IS BIG
  0F4B'   CD 0387'              	CALL	FCOMP			; ENOUGH YET
  0F4E'   C3 0F57'              	JMP	FOUNV5			;GO DO THE CHECK
  0F51'   11 10B5'              FOUNV4:	LXI	D,FOUTDL		;GET POINTER TO 999,999,999,999,999.5
  0F54'   CD 03C4'              	CALL	DCOMPD			;SEE IF THE NUMBER IS STILL TOO SMALL
  0F57'   F2 0F6A'              FOUNV5:	JP	FOUNV3			;IT ISN'T ANY MORE, WE ARE DONE
  0F5A'   F1                    	POP	PSW			;IT IS, MULTIPLY BY TEN
  0F5B'   CD 0A43'              	CALL	FINMLT
  0F5E'   F5                    	PUSH	PSW			;SAVE THE EXPONENT AGAIN
  0F5F'   C3 0F3F'              	JMP	FOUNV1			;NOW SEE IF IT IS BIG ENOUGH
  0F62'   F1                    FOUNV2:	POP	PSW			;THE FAC IS TOO BIG, GET THE EXPONENT
  0F63'   CD 0A52'              	CALL	FINDIV			;DIVIDE IT BY TEN
  0F66'   F5                    	PUSH	PSW			;SAVE THE EXPONENT AGAIN
  0F67'   CD 0F6E'              	CALL	FOUNVC			;SEE IF THE FAC IS SMALL ENOUGH
  0F6A'   F1                    FOUNV3:	POP	PSW			;WE ARE DONE, GET THE EXPONENT BACK
  0F6B'   B7                    	ORA	A			;CLEAR CARRY
  0F6C'   D1                    	POP	D			;GET (DE) BACK
  0F6D'   C9                    	RET				;ALL DONE
                                
                                					;HERE TO SEE IF THE FAC IS SMALL ENOUGH YET
  0F6E'   CD 0000*              FOUNVC:	CALL	GETYPR			;SEE WHAT TYPE NUMBER WE HAVE
  0F71'   EA 0F80'              	JPE	FONVC1			;WE HAVE A DBL
  0F74'   01 9474               	LXI	B,224Q*256+164Q
  0F77'   11 23F8               	LXI	D,043Q*256+370Q		;GET 999999.5 TO SEE IF THE FAC IS TOO BIG
  0F7A'   CD 0387'              	CALL	FCOMP
  0F7D'   C3 0F86'              	JMP	FONVC2			;GO DO THE CHECK
  0F80'   11 10BD'              FONVC1:	LXI	D,FOUTDU		;GET POINTER TO 9,999,999,999,999,999.5
  0F83'   CD 03C4'              	CALL	DCOMPD			;SEE IF THE NUMBER IS TOO BIG
  0F86'   E1                    FONVC2:	POP	H			;GET THE RETURN ADDRESS OFF THE STACK
  0F87'   F2 0F62'              	JP	FOUNV2			;THE NUMBER IS TOO BIG, DIVIDE IT BY TEN
  0F8A'   E9                    	PCHL				;IT ISN'T TOO BIG, JUST RETURN
                                
                                
                                					;HERE TO PUT SOME ZEROS IN THE BUFFER
                                					;THE COUNT IS IN A, IT CAN BE ZERO, BUT THE ZERO FLAG MUST BE SET
                                					;ONLY (HL) AND A ARE ALTERED
                                					;WE EXIT WITH A=0
  0F8B'   B7                    FOTZER:	ORA	A			;THIS IS BECAUSE FFXXV3 CALL US WITH THE
                                					; CONDITION CODES NOT SET UP
  0F8C'   C8                    FOTZR1:	RZ				;RETURN IF WE ARE DONE
  0F8D'   3D                    	DCR	A			;WE ARE NOT DONE, SO DECREMENT THE COUNT
  0F8E'   36 30                 	MVI	M,'0'			;PUT A ZERO IN THE BUFFER
  0F90'   23                    	INX	H			;UPDATE THE BUFFER POINTER
  0F91'   C3 0F8C'              	JMP	FOTZR1			;GO SEE IF WE ARE NOW DONE
                                
                                
                                					;HERE TO PUT ZEROS IN THE BUFFER WITH COMMAS OR A DECIMAL POINT IN THE
                                					;MIDDLE.  THE COUNT IS IN A, IT CAN BE ZERO, BUT THE ZERO FLAG MUST BE
                                					;SET.  B THE DECIMAL POINT COUNT AND C THE COMMA COUNT ARE UPDATED
                                					;A,B,C,H,L ARE ALTERED
  0F94'   C2 0F9B'              FOTZNC:	JNZ	FOTZEC			;ENTRY AFTER A "CALL FOUTCV"
  0F97'   C8                    FOTZRC:	RZ				;RETURN IF WE ARE DONE
  0F98'   CD 0FCA'              	CALL	FOUTED			;SEE IF WE HAVE TO PUT A COMMA OR A DECIMAL
                                					; POINT BEFORE THIS ZERO
  0F9B'   36 30                 FOTZEC:	MVI	M,'0'			;PUT A ZERO IN THE BUFFER
  0F9D'   23                    	INX	H			;UPDATE THE BUFFER POINTER
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-31
FLOATING POINT OUTPUT ROUTINE

  0F9E'   3D                    	DCR	A			;DECREMENT THE ZERO COUNT
  0F9F'   C3 0F97'              	JMP	FOTZRC			;GO BACK AND SEE IF WE ARE DONE
                                
                                
                                					;HERE TO PUT A POSSIBLE COMMA COUNT IN C, AND ZERO C IF WE ARE NOT
                                					;USING THE COMMA SPECIFICATION
  0FA2'   7B                    FOUTCD:	MOV	A,E			;SETUP DECIMAL POINT COUNT
  0FA3'   82                    	ADD	D
  0FA4'   3C                    	INR	A
  0FA5'   47                    	MOV	B,A
  0FA6'   3C                    	INR	A			;SETUP COMMA COUNT
  0FA7'   D6 03                 FOTCD1:	SUI	3			;REDUCE [A] MOD 3
  0FA9'   D2 0FA7'              	JNC	FOTCD1
  0FAC'   C6 05                 	ADI	5			;ADD 3 BACK IN AND ADD 2 MORE FOR
                                					;SCALING
  0FAE'   4F                    FOUTCC:	MOV	C,A			;SAVE A POSSIBLE COMMA COUNT
  0FAF'   3A 0000*              FOUICC:	LDA	TEMP3			;GET THE FORMAT SPECS
  0FB2'   E6 40                 	ANI	100O			;LOOK AT THE COMMA BIT
  0FB4'   C0                    	RNZ				;WE ARE USING COMMAS, JUST RETURN
  0FB5'   4F                    	MOV	C,A			;WE AREN'T, ZERO THE COMMA COUNT
  0FB6'   C9                    	RET				;ALL DONE
                                
                                
                                					;HERE TO PUT DECIMAL POINTS AND COMMAS IN THEIR CORRECT PLACES
                                					;THIS SUBROUTINE SHOULD BE CALLED BEFORE THE NEXT DIGIT IS PUT IN THE
                                					;BUFFER.  B=THE DECIMAL POINT COUNT, C=THE COMMA COUNT
                                					;THE COUNTS TELL HOW MANY MORE DIGITS HAVE TO GO IN BEFORE THE COMMA
                                					;OR DECIMAL POINT GO IN.  THE COMMA OR DECIMAL POINT THEN GOES BEFORE 
                                					;THE LAST DIGIT IN THE COUNT.  FOR EXAMPLE, IF THE DECIMAL POINT SHOULD
                                					;COME AFTER THE FIRST DIGIT, THE DECIMAL POINT COUNT SHOULD BE 2.
  0FB7'                         FOUTAN:					;SAVE FOR LATER
  0FB7'   05                    	DCR	B			;
  0FB8'   F2 0FCB'              	JP	FOUTE1			;PROCESS AS NORMAL
  0FBB'   22 0000*              	SHLD	TEMP2			;SAVE LOCATION OF DECIMAL POINT
  0FBE'   36 2E                 	MVI	M,'.'			;PUT IN D.P.
  0FC0'   23                    FOUTD1:	INX	H			;POINT TO NEXT BUFFER POSTION
  0FC1'   36 30                 	MVI	M,'0'
  0FC3'   04                    	INR	B			;
  0FC4'   C2 0FC0'              	JNZ	FOUTD1
  0FC7'   23                    	INX	H			;POINT TO NEXT AVAILABLE BUFFER LOCATION
  0FC8'   48                    	MOV	C,B
  0FC9'   C9                    	RET	
  0FCA'   05                    FOUTED:	DCR	B			;TIME FOR D.P.?
  0FCB'                         FOUTE1:					;
  0FCB'   C2 0FD6'              	JNZ	FOUED1			;NO, CHECK FOR THE COMMA
                                					;ENTRY TO PUT A DECIMAL POINT IN THE BUFFER
  0FCE'   36 2E                 FOUTDP:	MVI	M,'.'			;YES, PUT THE DECIMAL POINT IN
  0FD0'   22 0000*              	SHLD	TEMP2			;SAVE THE LOCATION OF THE DECIMAL POINT
  0FD3'   23                    	INX	H			;INCREMENT THE BUFFER POINTER
  0FD4'   48                    	MOV	C,B			;PUT ZERO IN C SO WE WON"T PRINT ANY COMMAS
  0FD5'   C9                    	RET				; AFTER THE DECIMAL POINT.  ALL DONE
                                					;HERE TO SEE IF IT IS TIME TO PRINT A COMMA
  0FD6'   0D                    FOUED1:	DCR	C			;IS IT TIME?
  0FD7'   C0                    	RNZ				;NOPE, WE CAN RETURN
  0FD8'   36 2C                 	MVI	M,54O			;","=54, YES, PUT A COMMA IN THE BUFFER
  0FDA'   23                    	INX	H			;INCREMENT THE BUFFER POINTER
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-32
FLOATING POINT OUTPUT ROUTINE

  0FDB'   0E 03                 	MVI	C,3			;RESET THE COMMA COUNT SO WE WILL PRINT A
  0FDD'   C9                    	RET				; COMMA AFTER THREE MORE DIGITS.  ALL DONE
                                
                                
                                					;HERE TO CONVERT A SNG OR DBL NUMBER THAT HAS BEEN NORMALIZED TO
                                					;DECIMAL DIGITS.  THE DECIMAL POINT COUNT AND COMMA COUNT ARE IN B AND
                                					;C RESPECTIVELY.  (HL) POINTS TO WHERE THE FIRST DIGIT WILL GO.
                                					;THIS EXITS WITH A=0.  (DE) IS LEFT UNALTERED.
  0FDE'   D5                    FOUTCV:	PUSH	D			;SAVE (DE)
  0FDF'   CD 0000*              	CALL	GETYPR			;SEE WHAT KIND OF A NUMBER WE HAVE
  0FE2'   E2 102D'              	JPO	FOUTCS			;WE HAVE A SNG
                                					;HERE TO CONVERT A DOUBLE PRECISION NUMBER TO DECIMAL DIGITS
  0FE5'   C5                    	PUSH	B			;SAVE THE DECIMAL POINT AND COMMA COUNTS
  0FE6'   E5                    	PUSH	H			;SAVE THE BUFFER POINTER
  0FE7'   CD 0375'              	CALL	VMOVAF			;MOVE THE FAC INTO ARG
  0FEA'   21 10C5'              	LXI	H,DHALF			;GET POINTER TO .5D0
  0FED'   CD 036F'              	CALL	VMOVFM			;MOVE THE CONSTANT INTO THE FAC
  0FF0'   CD 06A7'              	CALL	DADD			;ADD .5 TO THE ORIGINAL NUMBER TO ROUND IT
  0FF3'   AF                    	XRA	A			;CLEAR THE CARRY
  0FF4'   CD 0550'              	CALL	DINTFO			;TAKE THE INTEGER PART OF THE NUMBER
                                					;THE NUMBER IS NOT NORMALIZED AFTERWARDS
  0FF7'   E1                    	POP	H			;GET THE BUFFER POINTER BACK
  0FF8'   C1                    	POP	B			;GET THE COMMA AND DECIMAL POINT COUNTS BACK
  0FF9'   11 10D5'              	LXI	D,FODTBL		;GET A POINTER TO THE DBL POWER OF TEN TABLE
  0FFC'   3E 0A                 	MVI	A,12O			;CONVERT TEN DIGITS, THE OTHERS WILL BE
                                					; CONVERTED AS SNG'S AND INT'S
                                					;BECAUSE WE BRACKETED THE NUMBER A
                                					;POWER OF TEN LESS IN MAGNITUDE AND
                                					;SINGLE PRECISION CONVERSION CAN HANDLE
                                					;A MAGNITUDE OF TEN LARGER
                                					;HERE TO CONVERT THE NEXT DIGIT
  0FFE'   CD 0FCA'              FOUCD1:	CALL	FOUTED			;SEE IF WE HAVE TO PUT IN A DP OR COMMA
  1001'   C5                    	PUSH	B			;SAVE DP AND COMMA INFORMATION
  1002'   F5                    	PUSH	PSW			;SAVE DIGIT COUNT
  1003'   E5                    	PUSH	H			;SAVE BUFFER POINTER
  1004'   D5                    	PUSH	D			;SAVE POWER OF TEN POINTER
                                					;HERE TO DIVIDE FOR THE NEXT DIGIT
  1005'   06 2F                 	MVI	B,'0'-1			;SET UP THE COUNT FOR THE DIGIT
  1007'   04                    FOUCD2:	INR	B			;INCREMENT THE DIGIT COUNT
  1008'   E1                    	POP	H			;GET THE POINTER TO THE POWER OF TEN
  1009'   E5                    	PUSH	H			;SAVE IT AGAIN
  100A'   3E                    	DB	076O			;"MVI	A", GET THE INSTRUCTION TO SUBTRACT
  100B'   9E                    	SBB	M			; THE POWER OF TEN
  100C'   CD 0780'              	CALL	DADDFO			;GO SUBTRACT THEM
  100F'   D2 1007'              	JNC	FOUCD2			;IF THE NUMBER WAS NOT LESS THAN THE POWER OF
                                					; TEN, SUBTRACT AGAIN
  1012'   E1                    	POP	H			;WE ARE DONE SUBTRACTING, BUT WE DID IT ONCE
                                					; TOO OFTEN, SO ADD BACK IN THE POWER OF TEN
                                					;GET THE POINTER TO THE POWER OF TEN
  1013'   3E                    	DB	076O			;"MVI	A", GET THE INSTRUCTION TO ADD THE
  1014'   8E                    	ADC	M			; POWER OF TEN AND THE NUMBER
  1015'   CD 0780'              	CALL	DADDFO			;ADD THE TWO NUMBERS
  1018'   EB                    	XCHG				;PUT THE POWER OF TEN POINTER IN (DE).  IT IS
                                					; UPDATED FOR THE NEXT POWER OF TEN
  1019'   E1                    	POP	H			;GET THE BUFFER POINTER BACK
  101A'   70                    	MOV	M,B			;PUT THE DIGIT INTO THE BUFFER
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-33
FLOATING POINT OUTPUT ROUTINE

  101B'   23                    	INX	H			;INCREMENT THE BUFFER POINTER
  101C'   F1                    	POP	PSW			;GET THE DIGIT COUNT BACK
  101D'   C1                    	POP	B			;GET THE DECIMAL POINT AND COMMA COUNTS
  101E'   3D                    	DCR	A			;HAVE WE PRINTED THE LAST DIGIT?
  101F'   C2 0FFE'              	JNZ	FOUCD1			;NO, GO DO THE NEXT ONE
  1022'   C5                    	PUSH	B			;YES, CONVERT REMAINING DIGITS USING SINGLE
  1023'   E5                    	PUSH	H			; PRECISION, THIS IS FASTER, MOVE THE NUMBER
  1024'   21 0000*              	LXI	H,DFACLO		; THAT IS LEFT INTO THE SNG FAC
  1027'   CD 0327'              	CALL	MOVFM
  102A'   C3 103A'              	JMP	FOUCDC			;GO TO IT!!
                                
                                					;HERE TO CONVERT A SINGLE PRECISION NUMBER TO DECIMAL DIGITS
  102D'   C5                    FOUTCS:	PUSH	B			;SAVE THE DECIMAL POINT AND COMMA COUNTS
  102E'   E5                    	PUSH	H			;SAVE THE BUFFER POINTER
  102F'   CD 0000'              	CALL	FADDH			;ROUND NUMBER TO NEAREST INTEGER
  1032'   3E 01                 	MVI	A,1			;MAKE A NON-ZERO, SINCE NUMBER IS POSITIVE
                                					; AND NON-ZERO, ROUND WILL EXIT WITH THE HO
                                					; IN A, SO THE MSB WILL ALWAYS BE ZERO AND
                                					; ADDING ONE WILL NEVER CAUSE A TO BE ZERO
  1034'   CD 04C3'              	CALL	QINT			;GET INTEGER PART IN C,D,E
  1037'   CD 032A'              	CALL	MOVFR			;SAVE NUMBER IN FAC
  103A'   E1                    FOUCDC:	POP	H			;GET THE BUFFER POINTER BACK
  103B'   C1                    	POP	B			;GET THE DECIMAL POINT AND COMMA COUNTS BACK
  103C'   AF                    	XRA	A			;CLEAR CARRY, THE CARRY IS OUR FLAG TO
                                					; CALCULATE TWO DIGITS
  103D'   11 111B'              	LXI	D,FOSTBL		;GET POINTER TO POWER OF TEN TABLE
                                					;HERE TO CALCULATE THE NEXT DIGIT OF THE NUMBER
  1040'   3F                    FOUCS1:	CMC				;COMPLEMENT FLAG THAT TELLS WHEN WE ARE DONE
  1041'   CD 0FCA'              	CALL	FOUTED			;SEE IF A COMMA OR DP GOES BEFORE THIS DIGIT
  1044'   C5                    	PUSH	B			;SAVE COMMA AND DECIMAL POINT INFORMATION
  1045'   F5                    	PUSH	PSW			;SAVE CARRY I.E. DIGIT COUNT
  1046'   E5                    	PUSH	H			;SAVE CHARACTER POINTER
  1047'   D5                    	PUSH	D			;SAVE POWER OF TEN POINTER
  1048'   CD 0335'              	CALL	MOVRF			;GET NUMBER IN C,D,E
  104B'   E1                    	POP	H			;GET POWER OF TEN POINTER
  104C'   06 2F                 	MVI	B,'0'-1			;B = NEXT DIGIT TO BE PRINTED
  104E'   04                    FOUCS2:	INR	B			;ADD ONE TO DIGIT
  104F'   7B                    	MOV	A,E			;SUBTRACT LO
  1050'   96                    	SUB	M
  1051'   5F                    	MOV	E,A
  1052'   23                    	INX	H			;POINT TO NEXT BYTE OF POWER OF TEN
  1053'   7A                    	MOV	A,D			;SUBTRACT MO
  1054'   9E                    	SBB	M
  1055'   57                    	MOV	D,A
  1056'   23                    	INX	H
  1057'   79                    	MOV	A,C			;SUBTRACT HO
  1058'   9E                    	SBB	M
  1059'   4F                    	MOV	C,A
  105A'   2B                    	DCX	H			;POINT TO BEGINNING OF POWER OF TEN
  105B'   2B                    	DCX	H
  105C'   D2 104E'              	JNC	FOUCS2			;SUBTRACT AGAIN IF RESULT WAS POSITIVE
  105F'   CD 00C9'              	CALL	FADDA			;IT WASN'T, ADD POWER OF TEN BACK IN
  1062'   23                    	INX	H			;INCREMENT POINTER TO NEXT POWER OF TEN
  1063'   CD 032A'              	CALL	MOVFR			;SAVE C,D,E IN FAC
  1066'   EB                    	XCHG				;GET POWER OF TEN POINTER IN (DE)
  1067'   E1                    	POP	H			;GET BUFFER POINTER
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-34
FLOATING POINT OUTPUT ROUTINE

  1068'   70                    	MOV	M,B			;PUT CHARACTER IN BUFFER
  1069'   23                    	INX	H			;INCREMENT BUFFER POINTER
  106A'   F1                    	POP	PSW			;GET DIGIT COUNT (THE CARRY) BACK
  106B'   C1                    	POP	B			;GET COMMA AND DP INFORMATION BACK
  106C'   DA 1040'              	JC	FOUCS1			;CALCULATE NEXT DIGIT IF WE HAVE NOT DONE 2
  106F'   13                    	INX	D			;WE HAVE, INCREMENT POINTER TO CORRECT PLACE
  1070'   13                    	INX	D			; IN THE INTEGER POWER OF TEN TABLE
  1071'   3E 04                 	MVI	A,4			;GET THE DIGIT COUNT
  1073'   C3 107C'              	JMP	FOUCI1			;COMPUTE THE REST OF THE DIGITS LIKE INTEGERS
                                					;NOTE THAT THE CARRY IS OFF
                                
                                					;HERE TO CONVERT AN INTEGER INTO DECIMAL DIGITS
                                					;THIS EXITS WITH A=0.  (DE) IS LEFT UNALTERED.
  1076'   D5                    FOUTCI:	PUSH	D			;SAVE (DE)
  1077'   11 1121'              	LXI	D,FOITBL		;GET POINTER TO THE INTEGER POWER OF TEN TABLE
  107A'   3E 05                 	MVI	A,5			;SET UP A DIGIT COUNT, WE HAVE TO CALCULATE 5
                                					; DIGITS BECAUSE THE MAX POS INTEGER IS 32768
                                					;HERE TO CALCULATE EACH DIGIT
  107C'   CD 0FCA'              FOUCI1:	CALL	FOUTED			;SEE IF A COMMA OR DP GOES BEFORE THE DIGIT
  107F'   C5                    	PUSH	B			;SAVE COMMA AND DECIMAL POINT INFORMATION
  1080'   F5                    	PUSH	PSW			;SAVE DIGIT COUNT
  1081'   E5                    	PUSH	H			;SAVE BUFFER POINTER
  1082'   EB                    	XCHG				;GET THE POWER OF TEN POINTER IN (HL)
  1083'   4E                    	MOV	C,M			;PUT THE POWER OF TEN ON THE STACK
  1084'   23                    	INX	H
  1085'   46                    	MOV	B,M
  1086'   C5                    	PUSH	B
  1087'   23                    	INX	H			;INCREMENT THE PWR OF TEN PTR TO NEXT POWER
  1088'   E3                    	XTHL				;GET THE POWER OF TEN IN (HL) AND PUT THE
                                					; POINTER ON THE STACK
  1089'   EB                    	XCHG				;PUT THE POWER OF TEN IN (DE)
  108A'   2A 0000*              	LHLD	FACLO			;GET THE INTEGER IN (HL)
  108D'   06 2F                 	MVI	B,'0'-1			;SET UP THE DIGIT COUNT, B=DIGIT TO BE PRINTED
  108F'   04                    FOUCI2:	INR	B			;INCREMENT THE DIGIT COUNT
  1090'   7D                    	MOV	A,L			;SUBTRACT (DE) FROM (HL)
  1091'   93                    	SUB	E			;SUBTRACT THE LOW ORDERS
  1092'   6F                    	MOV	L,A			;SAVE THE NEW RESULT
  1093'   7C                    	MOV	A,H			;SUBTRACT THE HIGH ORDERS
  1094'   9A                    	SBB	D
  1095'   67                    	MOV	H,A			;SAVE THE NEW HIGH ORDER
  1096'   D2 108F'              	JNC	FOUCI2			;IF (HL) WAS .GE. (DE) THEN SUBTRACT AGAIN
  1099'   19                    	DAD	D			;WE ARE DONE, BUT WE SUBTRACTED (DE) ONCE TOO
                                					; OFTEN, SO ADD IT BACK IN
  109A'   22 0000*              	SHLD	FACLO			;SAVE IN THE FAC WHAT IS LEFT
  109D'   D1                    	POP	D			;GET THE POWER OF TEN POINTER BACK
  109E'   E1                    	POP	H			;GET THE BUFFER POINTER BACK
  109F'   70                    	MOV	M,B			;PUT THE NEW DIGIT IN THE BUFFER
  10A0'   23                    	INX	H			;INCREMENT THE BUFFER POINTER TO NEXT DIGIT
  10A1'   F1                    	POP	PSW			;GET THE DIGIT COUNT BACK
  10A2'   C1                    	POP	B			;GET THE COMMA AND DP INFORMATION BACK
  10A3'   3D                    	DCR	A			;WAS THAT THE LAST DIGIT?
  10A4'   C2 107C'              	JNZ	FOUCI1			;NO, GO DO THE NEXT ONE
  10A7'   CD 0FCA'              	CALL	FOUTED			;YES, SEE IF A DP GOES AFTER THE LAST DIGIT
  10AA'   77                    	MOV	M,A			;PUT A ZERO AT THE END OF THE NUMBER, BUT
                                					; DON'T INCREMENT (HL) SINCE AN EXPONENT OR A
                                					; TRAILING SIGN MAY BE COMMING
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-35
FLOATING POINT OUTPUT ROUTINE

  10AB'   D1                    	POP	D			;GET (DE) BACK
  10AC'   C9                    	RET				;ALL DONE, RETURN WITH A=0
                                
                                
                                					;CONSTANTS USED BY FOUT
  10AD'   00                    TENTEN:	DB	0			;10000000000
  10AE'   00                    	DB	0
  10AF'   00                    	DB	0
  10B0'   00                    	DB	0
  10B1'   F9                    	DB	371O
  10B2'   02                    	DB	2
  10B3'   15                    	DB	25O
  10B4'   A2                    	DB	242O
  10B5'   E1                    FOUTDL:	DB	341O			; 999,999,999,999,999.5
  10B6'   FF                    	DB	377O
  10B7'   9F                    	DB	237O
  10B8'   31                    	DB	061O
  10B9'   A9                    	DB	251O
  10BA'   5F                    	DB	137O
  10BB'   63                    	DB	143O
  10BC'   B2                    	DB	262O
  10BD'   FE                    FOUTDU:	DB	376O			; 9,999,999,999,999,999.5
  10BE'   FF                    	DB	377O
  10BF'   03                    	DB	003
  10C0'   BF                    	DB	277O
  10C1'   C9                    	DB	311O
  10C2'   1B                    	DB	033O
  10C3'   0E                    	DB	016O
  10C4'   B6                    	DB	266O
  10C5'   00                    DHALF:	DB	000			; .5D0
  10C6'   00                    	DB	000
  10C7'   00                    	DB	000
  10C8'   00                    	DB	000
  10C9'   00                    FHALF:	DB	000			; .5E0
  10CA'   00                    	DB	000
  10CB'   00                    	DB	000
  10CC'   80                    	DB	200O
  10CD'   00                    FFXDXM:	DB	000			; 1D16
  10CE'   00                    	DB	000
  10CF'   04                    	DB	004
  10D0'   BF                    	DB	277O
  10D1'   C9                    	DB	311O
  10D2'   1B                    	DB	033O
  10D3'   0E                    	DB	016O
  10D4'   B6                    	DB	266O
                                					;DOUBLE PRECISION POWER OF TEN TABLE
  10D5'   00                    FODTBL:	DB	000			; 1D15
  10D6'   80                    	DB	200O
  10D7'   C6                    	DB	306O
  10D8'   A4                    	DB	244O
  10D9'   7E                    	DB	176O
  10DA'   8D                    	DB	215O
  10DB'   03                    	DB	003
  10DC'   00                    	DB	000			; 1D14
  10DD'   40                    	DB	100O
  10DE'   7A                    	DB	172O
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-36
FLOATING POINT OUTPUT ROUTINE

  10DF'   10                    	DB	020O
  10E0'   F3                    	DB	363O
  10E1'   5A                    	DB	132O
  10E2'   00                    	DB	000
  10E3'   00                    	DB	000			; 1D13
  10E4'   A0                    	DB	240O
  10E5'   72                    	DB	162O
  10E6'   4E                    	DB	116O
  10E7'   18                    	DB	030O
  10E8'   09                    	DB	011O
  10E9'   00                    	DB	000
  10EA'   00                    	DB	000			; 1D12
  10EB'   10                    	DB	020O
  10EC'   A5                    	DB	245O
  10ED'   D4                    	DB	324O
  10EE'   E8                    	DB	350O
  10EF'   00                    	DB	000
  10F0'   00                    	DB	000
  10F1'   00                    	DB	000			; 1D11
  10F2'   E8                    	DB	350O
  10F3'   76                    	DB	166O
  10F4'   48                    	DB	110O
  10F5'   17                    	DB	027O
  10F6'   00                    	DB	000
  10F7'   00                    	DB	000
  10F8'   00                    	DB	000			; 1D10
  10F9'   E4                    	DB	344O
  10FA'   0B                    	DB	013O
  10FB'   54                    	DB	124O
  10FC'   02                    	DB	002
  10FD'   00                    	DB	000
  10FE'   00                    	DB	000
  10FF'   00                    	DB	000			; 1D9
  1100'   CA                    	DB	312O
  1101'   9A                    	DB	232O
  1102'   3B                    	DB	073O
  1103'   00                    	DB	000
  1104'   00                    	DB	000
  1105'   00                    	DB	000
  1106'   00                    	DB	000			; 1D8
  1107'   E1                    	DB	341O
  1108'   F5                    	DB	365O
  1109'   05                    	DB	005
  110A'   00                    	DB	000
  110B'   00                    	DB	000
  110C'   00                    	DB	000
  110D'   80                    	DB	200O			; 1D7
  110E'   96                    	DB	226O
  110F'   98                    	DB	230O
  1110'   00                    	DB	000
  1111'   00                    	DB	000
  1112'   00                    	DB	000
  1113'   00                    	DB	000
  1114'   40                    	DB	100O			; 1D6
  1115'   42                    	DB	102O
  1116'   0F                    	DB	017O
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-37
FLOATING POINT OUTPUT ROUTINE

  1117'   00                    	DB	000
  1118'   00                    	DB	000
  1119'   00                    	DB	000
  111A'   00                    	DB	000
                                					;SINGLE PRECISION POWER OF TEN TABLE
  111B'   A0                    FOSTBL:	DB	240O			; 1E5
  111C'   86                    	DB	206O
  111D'   01                    	DB	001
  111E'   10                    	DB	020O			; 1E4
  111F'   27                    	DB	047O
  1120'   00                    	DB	000
                                					;INTEGER POWER OF TEN TABLE
  1121'   10                    FOITBL:	DB	020O			; 10000
  1122'   27                    	DB	047O
  1123'   E8                    	DB	350O			; 1000
  1124'   03                    	DB	003
  1125'   64                    	DB	144O			; 100
  1126'   00                    	DB	000
  1127'   0A                    	DB	012O			; 10
  1128'   00                    	DB	000
  1129'   01                    	DB	001			; 1
  112A'   00                    	DB	000
                                ;
                                ; OUTPUT ROUTINES FOR OCTAL AND HEX NUMBERS
                                ;
                                	PUBLIC	FOUTO,FOUTH
  112B'   AF                    FOUTO:	XRA	A			;MAKE A=0, SET ZERO
  112C'   47                    	MOV	B,A			;SAVE IN [B]
  112D'   C2                    	DB	302O			;"JNZ" AROUND NEXT TWO BYTES
  112E'   06 01                 FOUTH:	MVI	B,1			;SET HEX FLAG
  1130'   C5                    	PUSH	B			;SAVE HEX/OCTAL FLAG
                                	EXTRN	FRQINT
  1131'   CD 0000*              	CALL	FRQINT			;GET DOUBLE BYTE INT IN [H,L]
  1134'   C1                    	POP	B			;GET BACK HEX/OCTAL FLAG
  1135'   11 0000*              	LXI	D,FBUFFR		;POINTER TO OUTPUT BUFFER IN [D,E]
  1138'   D5                    	PUSH	D			;SAVE SO WE CAN RETURN IT LATER
  1139'   AF                    	XRA	A			;GET SET TO HAVE FIRST DIGIT FOR OCTAL
  113A'   12                    	STAX	D			;CLEAR DIGIT SEEN FLAG
  113B'   05                    	DCR	B			;SEE IF OCTAL
  113C'   04                    	INR	B			;IF SO, ZERO SET
  113D'   0E 06                 	MVI	C,6			;SIX DIGITS FOR OCTAL
  113F'   CA 114A'              	JZ	OCTONE			;DO FIRST OCTAL DIGIT
  1142'   0E 04                 	MVI	C,4			;FOUR DIGIT FOR HEX
                                
  1144'   29                    OUTHLP:	DAD	H			;SHIFT LEFT ONE BIT
  1145'   8F                    	ADC	A			;ADD IN THE SHIFTED BIT
  1146'   29                    OUTOLP:	DAD	H			;SHIFT LEFT ONE BIT
  1147'   8F                    	ADC	A
  1148'   29                    	DAD	H
  1149'   8F                    	ADC	A
  114A'   29                    OCTONE:	DAD	H			;ENTER HERE FOR FIRST OCTAL DIGIT
  114B'   8F                    	ADC	A
  114C'   B7                    	ORA	A			;SEE IF WE GOT A ZERO DIGIT
  114D'   C2 115B'              	JNZ	MAKDIG			;NO, MAKE A DIGIT
  1150'   79                    	MOV	A,C			;GET DIGIT COUNTER
  1151'   3D                    	DCR	A			;WAS IT GOING TO GO TO ZERO (LAST DIG?)
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-38
FLOATING POINT OUTPUT ROUTINE

  1152'   CA 115B'              	JZ	MAKDIG			;IF SO, FORCE ONE ZERO DIGIT
  1155'   1A                    	LDAX	D			;HAVE WE PRINTED A NON-ZERO DIGIT?
  1156'   B7                    	ORA	A			;SET CC'S
  1157'   CA 1167'              	JZ	NOLEAD			;NO, DONT PRINT THIS LEADING ZERO
  115A'   AF                    	XRA	A			;GET ZERO
  115B'   C6 30                 MAKDIG:	ADI	'0'			;MAKE NUMERIC DIGIT
  115D'   FE 3A                 	CPI	'9'+1			;IS IT A BIG HEX DIGIT? (A-F)
  115F'   DA 1164'              	JC	NOTHAL			;NO, DONT ADD OFFSET
  1162'   C6 07                 	ADI	'A'-'9'-1		;ADD OFFSET
  1164'   12                    NOTHAL:	STAX	D			;SAVE DIGIT IN FBUFFR
  1165'   13                    	INX	D			;BUMP POINTER
  1166'   12                    	STAX	D			;SAVE HERE TO FLAG PRINTED SIG. DIG.
  1167'   AF                    NOLEAD:	XRA	A			;MAKE A ZERO
  1168'   0D                    	DCR	C			;ALL DONE PRINTING?
  1169'   CA 1174'              	JZ	FINOHO			;YES, RETURN
  116C'   05                    	DCR	B			;SEE IF HEX OR OCTAL
  116D'   04                    	INR	B			;TEST
  116E'   CA 1146'              	JZ	OUTOLP			;WAS OCTAL
  1171'   C3 1144'              	JMP	OUTHLP			;WAS HEX
                                
  1174'   12                    FINOHO:	STAX	D			;STORE FINAL ZERO
  1175'   E1                    	POP	H			;GET POINTER TO FBUFFR
  1176'   C9                    	RET				;ALL DONE.
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-39
FLOATING POINT OUTPUT ROUTINE

                                
                                	SUBTTL	EXPONENTIATION AND THE SQUARE ROOT FUNCTION
                                					;ALL DONE
                                
                                					;SUBROUTINE FOR FPWR, ATN
  1177'   21 02F5'              PSHNEG:	LXI	H,NEG			;GET THE ADDRESS OF NEG
  117A'   E3                    	XTHL				;SWITCH RET ADDR AND ADDR OF NEG
  117B'   E9                    	PCHL				;RETURN, THE ADDRESS OF NEG IS ON THE STACK
                                
                                					;SQUARE ROOT FUNCTION
                                					;WE USE SQR(X)=X^.5
  117C'   CD 031A'              SQR:	CALL	PUSHF			;SAVE ARG X
  117F'   21 10C9'              	LXI	H,FHALF			;GET 1/2
  1182'   CD 0327'              	CALL	MOVFM			;SQR(X)=X^.5
                                
  1185'   C3 118B'              	JMP	FPWRT			;SKIP OVER THE NEXT 3 BYTES
                                					;ENTRY FROM THE OPERATOR DISPATCH ROUTINES
                                	PUBLIC	FPWRQ
  1188'   CD 0475'              FPWRQ:	CALL	FRCSNG			;MAKE SURE THE FAC IS A SNG
  118B'   C1                    FPWRT:	POP	B
  118C'   D1                    	POP	D
                                					;GET ARG IN REGISTERS, ENTRY TO FPWR IF
                                					; ARGUMENT IS ON STACK.  FALL INTO FPWR
                                
                                
                                					;EXPONENTIATION    ---    X^Y
                                					;N.B.  0^0=1
                                					;FIRST WE CHECK IF Y=0, IF SO, THE RESULT IS 1.
                                					;NEXT, WE CHECK IF X=0, IF SO, THE RESULT IS 0.
                                					;THEN WE CHECK IF X IS POSITIVE, IF NOT, WE CHECK THAT Y IS A
                                					;NEGATIVE INTEGER, AND WHETHER IT IS EVEN OR ODD.  IF Y IS A NEGATIVE
                                					;INTEGER, WE NEGATE X.  IF NOT, LOG WILL GIVE AN FC ERROR WHEN WE CALL
                                					;IT.  IF X IS NEGATIVE AND Y IS ODD, WE PUSH THE ADDRESS OF NEG ON THE
                                					;STACK SO WE WILL RETURN TO IT AND GET A NEGATIVE RESULT.  TO COMPUTE
                                					;THE RESULT WE USE X^Y=EXP(Y*LOG(X))
  118D'                         FPWR:
                                	EXTRN	CLROVC
  118D'   21 0000*              	LXI	H,CLROVC		;RETURN TO ROUTINE TO SET NORMAL
  1190'   E5                    	PUSH	H			;OVERFLOW MODE
  1191'   3E 01                 	MVI	A,1
  1193'   32 0000*              	STA	FLGOVC			;SET UP ONCE ONLY OVERFLOW MODE
  1196'   CD 02C6'              	CALL	SIGN			;SEE IF Y IS ZERO
  1199'   78                    	MOV	A,B			;SEE IF X IS ZERO
  119A'   CA 11D9'              	JZ	EXP			;IT IS, RESULT IS ONE
  119D'   F2 11A4'              	JP	POSEXP			;POSITIVE EXPONENT
  11A0'   B7                    	ORA	A			;IS IT ZERO TO MINUS POWER?
  11A1'   CA 0B47'              	JZ	INTDV2			;GIVE DIV BY ZERO AND CONTINUE
  11A4'   B7                    POSEXP:	ORA	A
  11A5'   CA 0077'              	JZ	ZERO0			;IT IS, RESULT IS ZERO
  11A8'   D5                    	PUSH	D
  11A9'   C5                    	PUSH	B
                                					;SAVE X ON STACK
  11AA'   79                    	MOV	A,C			;CHECK THE SIGN OF X
  11AB'   F6 7F                 	ORI	177O			;TURN THE ZERO FLAG OFF
  11AD'   CD 0335'              	CALL	MOVRF			;GET Y IN THE REGISTERS
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-40
EXPONENTIATION AND THE SQUARE ROOT FUNCTION

                                					;END INTFSW CONTITTONAL
  11B0'   F2 11C1'              	JP	FPWR1			;NO PROBLEMS IF X IS POSITIVE
  11B3'   D5                    	PUSH	D
  11B4'   C5                    	PUSH	B
                                					;SAVE Y
  11B5'   CD 050E'              	CALL	INT			;SEE IF Y IS AN INTEGER
  11B8'   C1                    	POP	B
  11B9'   D1                    	POP	D
                                					;GET Y BACK
  11BA'   F5                    	PUSH	PSW			;SAVE LO OF INT FOR EVEN AND ODD INFORMATION
  11BB'   CD 0387'              	CALL	FCOMP			;SEE IF WE HAVE AN INTEGER
  11BE'   E1                    	POP	H			;GET EVEN-ODD INFORMATION
  11BF'   7C                    	MOV	A,H			;PUT EVEN-ODD FLAG IN CARRY
  11C0'   1F                    	RAR	
  11C1'   E1                    FPWR1:	POP	H			;GET X BACK IN FAC
  11C2'   22 FFFF*              	SHLD	FAC-1			;STORE HO'S
  11C5'   E1                    	POP	H			;GET LO'S OFF STACK
  11C6'   22 0000*              	SHLD	FACLO			;STORE THEM IN FAC
  11C9'   DC 1177'              	CC	PSHNEG			;NEGATE NUMBER AT END IF Y WAS ODD
  11CC'   CC 02F5'              	CZ	NEG			;NEGATE THE NEGATIVE NUMBER
  11CF'   D5                    	PUSH	D
  11D0'   C5                    	PUSH	B
                                					;SAVE Y AGAIN
  11D1'   CD 0144'              	CALL	LOG			;COMPUTE  EXP(Y*LOG(X))
  11D4'   C1                    	POP	B
  11D5'   D1                    	POP	D
                                					;IF X WAS NEGATIVE AND Y NOT AN INTEGER THEN
  11D6'   CD 018A'              	CALL	FMULT			; LOG WILL BLOW HIM OUT OF THE WATER
                                ;	JMP	EXP
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-41
EXPONENTIATION AND THE SQUARE ROOT FUNCTION

                                
                                	SUBTTL	EXPONENTIAL FUNCTON
                                					;THE FUNCTION EXP(X) CALCULATES e^X WHERE e=2.718282
                                					;	THE TECHNIQUE USED IS TO EMPLOY A COUPLE
                                					;	OF FUNDAMENTAL IDENTITIES THAT ALLOWS US TO
                                					;	USE THE BASE 2 THROUGH THE DIFFICULT PORTIONS OF
                                					;	THE CALCULATION:
                                					;
                                					;		(1)e^X=2^y  WHERE y=X*LOG2(e) [LOG2(e) IS
                                					;						LOG BASE 2
                                					;						OF e ]
                                					;
                                					;		(2) 2^y=2^[ INT(y)+(y-INT(y)]
                                					;		(3) IF Ny=INT(y) THEN
                                					;		    2^(Ny+y-Ny)=[2^Ny]*[2^(y-Ny)]
                                					;
                                					;	NOW, SINCE 2^Ny IS EASY TO COMPUTE (AN EXPONENT
                                					;	CALCULATION WITH MANTISSA BITS OF ZERO) THE DIFFICULT
                                					;	PORTION IS TO COMPUTE 2^(Y-Ny) WHERE 0.LE.(Y-Ny).LT.1
                                					;	THIS IS ACCOMPLISHED WITH A POLYNOMIAL APPROXIMATION
                                					;	TO 2^Z WHERE 0.LE.Z.LT.1  . ONCE THIS IS COMPUTED WE
                                					;	HAVE TO EFFECT THE MULTIPLY BY 2^Ny .
  11D9'   01 8138               EXP:	LXI	B,201Q*256+070Q
  11DC'   11 AA3B               	LXI	D,252Q*256+073Q		;GET LOG2(e)
  11DF'   CD 018A'              	CALL	FMULT			;y=FAC*LOG2(e)
  11E2'   3A 0000*              	LDA	FAC			;MUST SEE IF TOO LARGE
  11E5'   FE 88                 	CPI	210O			;ABS .GT. 128?
  11E7'   D2 120E'              	JNC	EXP100			;IF SO OVERFLOW
  11EA'   FE 68                 	CPI	150O			;IF TOO SMALL ANSWER IS 1
  11EC'   DA 1220'              	JC	EXP200
  11EF'   CD 031A'              	CALL	PUSHF			;SAVE y
  11F2'   CD 050E'              	CALL	INT			;DETERMINE INTEGER POWER OF 2
  11F5'   C6 81                 	ADI	201O			;INTEGER WAS RETURNED IN A
                                					;BIAS IS 201 BECAUSE BINARY
                                					;POINT IS TO LEFT OF UNDERSTOOD 1
  11F7'   C1                    	POP	B
  11F8'   D1                    	POP	D			;RECALL y
  11F9'   CA 1211'              	JZ	EXP110			;OVERFLOW
  11FC'   F5                    	PUSH	PSW			;SAVE EXPONENT
  11FD'   CD 000C'              	CALL	FSUB			;FAC=y-INT(y)
  1200'   21 122A'              	LXI	H,EXPBCN		;WILL USE HART 1302 POLY. EVAL NOW
  1203'   CD 1256'              	CALL	POLY			;COMPUTE 2^[y-INT(y)]
  1206'   C1                    	POP	B			;INTEGER POWER OF 2 EXPONENT
  1207'   11 0000               	LXI	D,0+0
  120A'   4A                    	MOV	C,D			;NOW HAVE FLOATING REPRESENTATION 
                                					;OF INT(y) IN (BCDE)
  120B'   C3 018A'              	JMP	FMULT			;MULTIPLY BY 2^[y-INT(y)] AND RETURN
  120E'   CD 031A'              EXP100:	CALL	PUSHF			;
  1211'                         EXP110:
  1211'   3A FFFF*              	LDA	FAC-1			;IF NEG. THEN JUMP TO ZERO
  1214'   B7                    	ORA	A
  1215'   F2 121D'              	JP	EXP115			;OVERFLOW IF PLUS
  1218'   F1                    	POP	PSW			;NEED STACK RIGHT
  1219'   F1                    	POP	PSW
  121A'   C3 0076'              	JMP	ZERO			;GO ZERO THE FAC
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-42
EXPONENTIAL FUNCTON

  121D'   C3 0B0F'              EXP115:	JMP	OVFIN6			;OVERFLOW
  1220'   01 8100               EXP200:	LXI	B,201Q*256+000Q
  1223'   11 0000               	LXI	D,000Q*256+000Q		;1.
  1226'   CD 032A'              	CALL	MOVFR
  1229'   C9                    	RET	
                                ;*************************************************************
                                ;	Hart 1302 polynomial coefficients
                                ;*************************************************************
  122A'   07                    EXPBCN:	DB	7			;DEGREE + 1
  122B'   7C                    	DB	174O			;.00020745577403-
  122C'   88                    	DB	210O
  122D'   59                    	DB	131O
  122E'   74                    	DB	164O
  122F'   E0                    	DB	340O			;.00127100574569-
  1230'   97                    	DB	227O
  1231'   26                    	DB	046O
  1232'   77                    	DB	167O
  1233'   C4                    	DB	304O			;.00965065093202+
  1234'   1D                    	DB	035O
  1235'   1E                    	DB	036O
  1236'   7A                    	DB	172O
  1237'   5E                    	DB	136O			;.05549656508324+
  1238'   50                    	DB	120O
  1239'   63                    	DB	143O
  123A'   7C                    	DB	174O
  123B'   1A                    	DB	032O			;.24022713817633-
  123C'   FE                    	DB	376O
  123D'   75                    	DB	165O
  123E'   7E                    	DB	176O
  123F'   18                    	DB	030O			;.69314717213716+
  1240'   72                    	DB	162O
  1241'   31                    	DB	061O
  1242'   80                    	DB	200O
  1243'   00                    	DB	000			;1.0
  1244'   00                    	DB	0000
  1245'   00                    	DB	0000
  1246'   81                    	DB	201O
                                					;END INTFSW CONDITIONAL
                                
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-43
EXPONENTIAL FUNCTON

                                
                                	SUBTTL	POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR
                                					;EVALUATE P(X^2)*X
                                					;POINTER TO DEGREE+1 IS IN (HL)
                                					;THE CONSTANTS FOLLOW THE DEGREE
                                					;CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
                                					;WE COMPUTE:
                                					; C0*X+C1*X^3+C2*X^5+C3*X^7+...+C(N)*X^(2*N+1)
  1247'   CD 031A'              POLYX:	CALL	PUSHF			;SAVE X
  124A'   11 0616'              	LXI	D,FMULTT		;PUT ADDRESS OF FMULTT ON STACK SO WHEN WE
  124D'   D5                    	PUSH	D			; RETURN WE WILL MULTIPLY BY X
  124E'   E5                    POLYX2:	PUSH	H			;SAVE CONSTANT POINTER
  124F'   CD 0335'              	CALL	MOVRF			;SQUARE X
  1252'   CD 018A'              	CALL	FMULT
  1255'   E1                    	POP	H			;GET CONSTANT POINTER
                                					;FALL INTO POLY
                                
                                
                                					;POLYNOMIAL EVALUATOR
                                					;POINTER TO DEGREE+1 IS IN (HL), IT IS UPDATED
                                					;THE CONSTANTS FOLLOW THE DEGREE
                                					;CONSTANTS SHOULD BE STORED IN REVERSE ORDER, FAC HAS X
                                					;WE COMPUTE:
                                					; C0+C1*X+C2*X^2+C3*X^3+...+C(N-1)*X^(N-1)+C(N)*X^N
  1256'   CD 031A'              POLY:	CALL	PUSHF			;SAVE X
  1259'   7E                    	MOV	A,M			;GET DEGREE
  125A'   23                    	INX	H			;INCREMENT POINTER TO FIRST CONSTANT
  125B'   CD 0327'              	CALL	MOVFM			;MOVE FIRST CONSTANT TO FAC
  125E'   06                    	DB	006			;"MVI	B" OVER NEXT BYTE
  125F'   F1                    POLY1:	POP	PSW			;GET DEGREE
  1260'   C1                    	POP	B
  1261'   D1                    	POP	D
                                					;GET X
  1262'   3D                    	DCR	A			;ARE WE DONE?
  1263'   C8                    	RZ				;YES, RETURN
  1264'   D5                    	PUSH	D
  1265'   C5                    	PUSH	B
                                					;NO, SAVE X
  1266'   F5                    	PUSH	PSW			;SAVE DEGREE
  1267'   E5                    	PUSH	H			;SAVE CONSTANT POINTER
  1268'   CD 018A'              	CALL	FMULT			;EVALUATE THE POLY, MULTIPLY BY X
  126B'   E1                    	POP	H			;GET LOCATION OF CONSTANTS
  126C'   CD 0338'              	CALL	MOVRM			;GET CONSTANT
  126F'   E5                    	PUSH	H			;STORE LOCATION OF CONSTANTS SO FADD AND FMULT
  1270'   CD 000F'              	CALL	FADD			; WILL NOT SCREW THEM UP, ADD IN CONSTANT
  1273'   E1                    	POP	H			;MOVE CONSTANT POINTER TO NEXT CONSTANT
  1274'   C3 125F'              	JMP	POLY1			;SEE IF DONE
                                
                                
                                					;PSUEDO-RANDOM NUMBER GENERATOR
                                					;IF ARG=0, THE LAST RANDOM NUMBER GENERATED IS RETURNED
                                					;IF ARG .LT. 0, A NEW SEQUENCE OF RANDOM NUMBERS IS STARTED
                                					; USING THE ARGUMENT
                                					;TO FORM THE NEXT RANDOM NUMBER IN THE SEQUENCE, WE MULTIPLY THE
                                					;PREVIOUS RANDOM NUMBER BY A RANDOM CONSTANT, AND ADD IN ANOTHER
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-44
POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR

                                					;RANDOM CONSTANT.  THEN THE HO AND LO BYTES ARE SWITCHED, THE
                                					;EXPONENT IS PUT WHERE IT WILL BE SHIFTED IN BY NORMAL, AND THE
                                					;EXPONENT IN THE FAC SET TO 200 SO THE RESULT WILL BE LESS THAN 1.
                                					;THIS IS THEN NORMALIZED AND SAVED FOR THE NEXT TIME.
                                					;THE HO AND LO BYTES WERE SWITCHED SO WE HAVE A RANDOM CHANCE OF
                                					;GETTING A NUMBER LESS THAN OR GREATER THAN .5
                                	PUBLIC	RNDCOP
  1277'   52                    RNDCOP:	DB	122O			;A COPY OF RNDX TO COPY AT RUN TIME
  1278'   C7                    	DB	307O
  1279'   4F                    	DB	117O
  127A'   80                    	DB	200O
                                	PUBLIC	RNDMON
  127B'   CD 0000*              RNDMON:	CALL	CHRGTR
                                	PUBLIC	RNDMN2
  127E'   E5                    RNDMN2:	PUSH	H			;SAVE TEXT POINTER FOR MONADIC RND
  127F'   21 011E'              	LXI	H,FONE			;PRETEND ARG IS 1.0
  1282'   CD 0327'              	CALL	MOVFM
  1285'   CD 128C'              	CALL	RND			;PICK UP A RANDOM VALUE
  1288'   E1                    	POP	H			;GET BACK THE TEXT POINTER
  1289'   C3 04B7'              	JMP	VALSNG
  128C'   CD 02C6'              RND:	CALL	SIGN			;GET SIGN OF ARG
  128F'   21 12F7'              	LXI	H,RNDCNT+1
  1292'   FA 12ED'              	JM	RNDSTR			;START NEW SEQUENCE IF NEGATIVE
  1295'   21 1318'              	LXI	H,RNDX			;GET LAST NUMBER GENERATED
  1298'   CD 0327'              	CALL	MOVFM
  129B'   21 12F7'              	LXI	H,RNDCNT+1
  129E'   C8                    	RZ				;RETURN LAST NUMBER GENERATED IF ZERO
  129F'   86                    	ADD	M			;GET COUNTER INTO CONSTANTS
                                					;AND ADD ONE
  12A0'   E6 07                 	ANI	7
  12A2'   06 00                 	MVI	B,0
  12A4'   77                    	MOV	M,A
  12A5'   23                    	INX	H
  12A6'   87                    	ADD	A
  12A7'   87                    	ADD	A
  12A8'   4F                    	MOV	C,A
  12A9'   09                    	DAD	B
  12AA'   CD 0338'              	CALL	MOVRM
  12AD'   CD 018A'              	CALL	FMULT
  12B0'   3A 12F6'              	LDA	RNDCNT
  12B3'   3C                    	INR	A
  12B4'   E6 03                 	ANI	3
  12B6'   06 00                 	MVI	B,0
  12B8'   FE 01                 	CPI	1
  12BA'   88                    	ADC	B
  12BB'   32 12F6'              	STA	RNDCNT
  12BE'   21 1318'              	LXI	H,RNDTB2-4
  12C1'   87                    	ADD	A
  12C2'   87                    	ADD	A
  12C3'   4F                    	MOV	C,A
  12C4'   09                    	DAD	B
  12C5'   CD 0003'              	CALL	FADDS
  12C8'   CD 0335'              RND1:	CALL	MOVRF			;SWITCH HO AND LO BYTES,
  12CB'   7B                    	MOV	A,E			;GET LO
  12CC'   59                    	MOV	E,C			;PUT HO IN LO BYTE
  12CD'   EE 4F                 	XRI	117O
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-45
POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR

  12CF'   4F                    	MOV	C,A			;PUT LO IN HO BYTE
  12D0'   36 80                 	MVI	M,200O			;MAKE RESULT POSITIVE
  12D2'   2B                    	DCX	H			;GET POINTER TO EXPONENT
  12D3'   46                    	MOV	B,M			;PUT EXPONENT IN OVERFLOW POSITION
  12D4'   36 80                 	MVI	M,200O			;SET EXP SO RESULT WILL BE BETWEEN 0 AND 1
  12D6'   21 12F5'              	LXI	H,RNDCNT-1
  12D9'   34                    	INR	M			;INCREMENT THE PERTUBATION COUNT
  12DA'   7E                    	MOV	A,M			;SEE IF ITS TIME
  12DB'   D6 AB                 	SUI	253O
  12DD'   C2 12E4'              	JNZ	NTPTRB
  12E0'   77                    	MOV	M,A			;ZERO THE COUNTER
  12E1'   0C                    	INR	C
  12E2'   15                    	DCR	D
  12E3'   1C                    	INR	E
  12E4'   CD 0061'              NTPTRB:	CALL	NORMAL			;NORMALIZE THE RESULT
  12E7'   21 1318'              	LXI	H,RNDX			;SAVE RANDOM NUMBER GENERATED FOR NEXT
  12EA'   C3 0341'              	JMP	MOVMF			; TIME
  12ED'   77                    RNDSTR:	MOV	M,A			;ZERO THE COUNTERS
  12EE'   2B                    	DCX	H
  12EF'   77                    	MOV	M,A
  12F0'   2B                    	DCX	H
  12F1'   77                    	MOV	M,A
  12F2'   C3 12C8'              	JMP	RND1
                                
                                					;STORAGE FOR RND
  12F5'   00                    	DB	0
                                	PUBLIC	RNDCNT
  12F6'   00                    RNDCNT:	DB	0
  12F7'   00                    	DB	0
  12F8'   35                    RNDTAB:	DB	65O
  12F9'   4A                    	DB	112O
  12FA'   CA                    	DB	312O
  12FB'   99                    	DB	231O
  12FC'   39                    	DB	71O
  12FD'   1C                    	DB	34O
  12FE'   76                    	DB	166O
  12FF'   98                    	DB	230O
  1300'   22                    	DB	42O
  1301'   95                    	DB	225O
  1302'   B3                    	DB	263O
  1303'   98                    	DB	230O
  1304'   0A                    	DB	12O
  1305'   DD                    	DB	335O
  1306'   47                    	DB	107O
  1307'   98                    	DB	230O
  1308'   53                    	DB	123O
  1309'   D1                    	DB	321O
  130A'   99                    	DB	231O
  130B'   99                    	DB	231O
  130C'   0A                    	DB	012O
  130D'   1A                    	DB	032O
  130E'   9F                    	DB	237O
  130F'   98                    	DB	230O
  1310'   65                    	DB	145O
  1311'   BC                    	DB	274O
  1312'   CD                    	DB	315O
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-46
POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR

  1313'   98                    	DB	230O
  1314'   D6                    	DB	326O
  1315'   77                    	DB	167O
  1316'   3E                    	DB	076O
  1317'   98                    	DB	230O
                                	PUBLIC	RNDX
  1318'   52                    RNDX:	DB	122O			;LAST RANDOM NUMBER GENERATED, BETWEEN 0 AND 1
  1319'   C7                    	DB	307O
  131A'   4F                    	DB	117O
  131B'   80                    	DB	200O
  131C'   68                    RNDTB2:	DB	150O
  131D'   B1                    	DB	261O
  131E'   46                    	DB	106O
  131F'   68                    	DB	150O
  1320'   99                    	DB	231O
  1321'   E9                    	DB	351O
  1322'   92                    	DB	222O
  1323'   69                    	DB	151O
  1324'   10                    	DB	020O
  1325'   D1                    	DB	321O
  1326'   75                    	DB	165O
  1327'   68                    	DB	150O
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-47
POLYNOMIAL EVALUATOR AND THE RANDOM NUMBER GENERATOR

                                
                                	SUBTTL	SINE, COSINE AND TANGENT FUNCTIONS
                                					;COSINE FUNCTION
                                					;IDEA:  USE COS(X)=SIN(X+PI/2)
  0000                          BOBTST	SET	0
  1328'   21 139E'              COS:	LXI	H,PI2			;ADD PI/2 TO FAC
  132B'   CD 0003'              	CALL	FADDS
                                					;END INTFSW
                                					;FALL INTO SIN
                                
                                
                                					;SINE FUNCTION
                                					;IDEA: USE IDENTITIES TO GET FAC IN QUADRANTS I OR IV
                                					;THE FAC IS DIVIDED BY 2*PI AND THE INTEGER PART IS IGNORED BECAUSE
                                					;SIN(X+2*PI)=SIN(X).  THEN THE ARGUMENT CAN BE COMPARED WITH PI/2 BY
                                					;COMPARING THE RESULT OF THE DIVISION WITH PI/2/(2*PI)=1/4.
                                					;IDENTITIES ARE THEN USED TO GET THE RESULT IN QUADRANTS I OR IV.
                                					;AN APPROXIMATION POLYNOMIAL IS THEN USED TO COMPUTE SIN(X).
  132E'                         SIN:
  132E'   3A 0000*              	LDA	FAC			;WILL SEE IF .LT.2^-10
                                					;AND IF SO SIN(X)=X
  1331'   FE 77                 	CPI	167O			;
  1333'   D8                    	RC	
                                					;SIN BY HART #3341
  1334'   01 7E22               	LXI	B,176Q*256+042Q
  1337'   11 F983               	LXI	D,371Q*256+203Q		;WILL CALCULATE X=FAC/(2*PI)
  133A'   CD 018A'              	CALL	FMULT
  133D'   CD 031A'              	CALL	PUSHF			;SAVE X
  1340'   CD 050E'              	CALL	INT			;FAC=INT(X)
  1343'   C1                    	POP	B
  1344'   D1                    	POP	D
                                					;FETCH X TO REGISTERS
  1345'   CD 000C'              	CALL	FSUB			;FAC=X-INT(X)
  1348'   01 7F00               	LXI	B,177Q*256+000Q
  134B'   11 0000               	LXI	D,000Q*256+000Q		;GET 1/4
  134E'   CD 0387'              	CALL	FCOMP			;FAC=FAC-1/4
  1351'   FA 1378'              	JM	SIN2A
  1354'   01 7F80               	LXI	B,177Q*256+200Q
  1357'   11 0000               	LXI	D,000Q*256+000Q		;-1/4
  135A'   CD 000F'              	CALL	FADD			;
  135D'   01 8080               	LXI	B,200Q*256+200Q
  1360'   11 0000               	LXI	D,000Q*256+000Q		;-1/2
  1363'   CD 000F'              	CALL	FADD			;X=X-1/2
  1366'   CD 02C6'              	CALL	SIGN
  1369'   F4 02F5'              	CP	NEG			;MAKE SURE IF QUADRANTS II,IV
                                					;WE WORK WITH 1/4-X
  136C'   01 7F00               SIN2:	LXI	B,177Q*256+000Q
  136F'   11 0000               	LXI	D,000Q*256+000Q		;1/4
  1372'   CD 000F'              	CALL	FADD			;
  1375'   CD 02F5'              	CALL	NEG			;
  1378'   3A FFFF*              SIN2A:	LDA	FAC-1			;MUST REDUCE TO [0,1/4]
  137B'   B7                    	ORA	A			;SIGN IN PSW
  137C'   F5                    	PUSH	PSW			;SAVE FOR POSSIBLE NEG. AFTER CALC
  137D'   F2 1385'              	JP	SIN3
  1380'   EE 80                 	XRI	200O			;
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-48
SINE, COSINE AND TANGENT FUNCTIONS

  1382'   32 FFFF*              	STA	FAC-1			;NOW IN [0,1/4]
  1385'   21 13A6'              SIN3:	LXI	H,SINCON		;POINT TO HART COEFFICIENTS
  1388'   CD 1247'              	CALL	POLYX			;DO POLY EVAL
  138B'   F1                    	POP	PSW			;NOW TO DO SIGN
  138C'   F0                    	RP				;OK IF POS
  138D'   3A FFFF*              	LDA	FAC-1			;FETCH SIGN BYTE
  1390'   EE 80                 	XRI	200O			;MAKE NEG
  1392'   32 FFFF*              	STA	FAC-1			;REPLACE SIGN
  1395'   C9                    	RET	
                                					;END OF INTFSW COND
                                
                                					;CONSTANTS FOR SIN, COS
  1396'   00                    P1B2PI:	DB	000			;1/(2*PI)
  1397'   00                    	DB	000
  1398'   00                    	DB	000
  1399'   00                    	DB	000
  139A'   83                    	DB	203O
  139B'   F9                    	DB	371O
  139C'   22                    	DB	042O
  139D'   7E                    	DB	176O
  139E'   DB                    PI2:	DB	333O			; PI/2
  139F'   0F                    	DB	017O
  13A0'   49                    	DB	111O
  13A1'   81                    	DB	201O
  13A2'   00                    FR4:	DB	000			; 1/4
  13A3'   00                    	DB	000
  13A4'   00                    	DB	000
  13A5'   7F                    	DB	177O
  13A6'                         SINCON:					;HART ALGORITHM 3341 CONSTANTS
                                ;NOTE THAT HART CONSTANTS HAVE BEEN SCALED BY A POWER OF 2
                                ;THIS IS DUE TO RANGE REDUCTION AS A % OF 2*PI RATHER THAN PI/2
                                ;WOULD NEED TO MULTIPLY ARGUMENT BY 4 BUT INSTEAD WE FACTOR THIS
                                ;THRU THE CONSTANTS.
  13A6'   05                    	DB	5			;DEGREE
  13A7'   FB                    	DB	373O			; .1514851E-3
  13A8'   D7                    	DB	327O
  13A9'   1E                    	DB	036O
  13AA'   86                    	DB	206O
  13AB'   65                    	DB	145O			; -.4673767E-2
  13AC'   26                    	DB	046O
  13AD'   99                    	DB	231O
  13AE'   87                    	DB	207O
  13AF'   58                    	DB	130O			; .7968968E-1
  13B0'   34                    	DB	064O
  13B1'   23                    	DB	043O
  13B2'   87                    	DB	207O
  13B3'   E1                    	DB	341O			; -.6459637
  13B4'   5D                    	DB	135O
  13B5'   A5                    	DB	245O
  13B6'   86                    	DB	206O
  13B7'   DB                    	DB	333O			; 1.570796
  13B8'   0F                    	DB	017O
  13B9'   49                    	DB	111O
  13BA'   83                    	DB	203O
                                
                                					;TANGENT FUNCTION
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-49
SINE, COSINE AND TANGENT FUNCTIONS

                                					;TAN(X)=SIN(X)/COS(X)
  13BB'   CD 031A'              TAN:	CALL	PUSHF			;SAVE ARG
  13BE'   CD 132E'              	CALL	SIN			;   TAN(X)=SIN(X)/COS(X)
  13C1'   C1                    	POP	B			;GET X OFF STACK
  13C2'   E1                    	POP	H			;PUSHF SMASHES (DE)
  13C3'   CD 031A'              	CALL	PUSHF
  13C6'   EB                    	XCHG				;GET LO'S WHERE THEY BELONG
  13C7'   CD 032A'              	CALL	MOVFR
  13CA'   CD 1328'              	CALL	COS
  13CD'   C3 01EE'              	JMP	FDIVT
                                
                                	PAGE
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-50
SINE, COSINE AND TANGENT FUNCTIONS

                                
                                	SUBTTL	ARCTANGENT FUNCTION
                                					;IDEA: USE IDENTITIES TO GET ARG BETWEEN 0 AND 1 AND THEN USE AN
                                					;APPROXIMATION POLYNOMIAL TO COMPUTE ARCTAN(X)
  13D0'   CD 02C6'              ATN:	CALL	SIGN			;SEE IF ARG IS NEGATIVE
  13D3'   FC 1177'              	CM	PSHNEG			;IF ARG IS NEGATIVE, USE:
  13D6'   FC 02F5'              	CM	NEG			;   ARCTAN(X)=-ARCTAN(-X)
  13D9'   3A 0000*              	LDA	FAC			;SEE IF FAC .GT. 1
  13DC'   FE 81                 	CPI	201O
  13DE'   DA 13ED'              	JC	ATN2
  13E1'   01 8100               	LXI	B,201O*400O+0		;GET THE CONSTANT 1
  13E4'   51                    	MOV	D,C
  13E5'   59                    	MOV	E,C			;COMPUTE RECIPROCAL TO USE THE IDENTITY:
  13E6'   CD 01F0'              	CALL	FDIV			;  ARCTAN(X)=PI/2-ARCTAN(1/X)
  13E9'   21 0009'              	LXI	H,FSUBS			;PUT FSUBS ON THE STACK SO WE WILL RETURN
  13EC'   E5                    	PUSH	H			; TO IT AND SUBTRACT THE REULT FROM PI/2
  13ED'   21 13F7'              ATN2:	LXI	H,ATNCON		;EVALUATE APPROXIMATION POLYNOMIAL
  13F0'   CD 1247'              	CALL	POLYX
  13F3'   21 139E'              	LXI	H,PI2			;GET POINTER TO PI/2 IN CASE WE HAVE TO
  13F6'   C9                    	RET				; SUBTRACT THE RESULT FROM PI/2
                                
                                					;CONSTANTS FOR ATN
  13F7'   09                    ATNCON:	DB	11O			;DEGREE
  13F8'   4A                    	DB	112O			; .002866226
  13F9'   D7                    	DB	327O
  13FA'   3B                    	DB	073O
  13FB'   78                    	DB	170O
  13FC'   02                    	DB	002			; -.01616574
  13FD'   6E                    	DB	156O
  13FE'   84                    	DB	204O
  13FF'   7B                    	DB	173O
  1400'   FE                    	DB	376O			; .04290961
  1401'   C1                    	DB	301O
  1402'   2F                    	DB	057O
  1403'   7C                    	DB	174O
  1404'   74                    	DB	164O			; -.07528964
  1405'   31                    	DB	061O
  1406'   9A                    	DB	232O
  1407'   7D                    	DB	175O
  1408'   84                    	DB	204O			; .1065626
  1409'   3D                    	DB	075O
  140A'   5A                    	DB	132O
  140B'   7D                    	DB	175O
  140C'   C8                    	DB	310O			; -.142089
  140D'   7F                    	DB	177O
  140E'   91                    	DB	221O
  140F'   7E                    	DB	176O
  1410'   E4                    	DB	344O			; .1999355
  1411'   BB                    	DB	273O
  1412'   4C                    	DB	114O
  1413'   7E                    	DB	176O
  1414'   6C                    	DB	154O			; -.3333315
  1415'   AA                    	DB	252O
  1416'   AA                    	DB	252O
  1417'   7F                    	DB	177O
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	3-51
ARCTANGENT FUNCTION

  1418'   00                    	DB	000			; 1.0
  1419'   00                    	DB	000
  141A'   00                    	DB	000
  141B'   81                    	DB	201O
                                
                                	END	
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	S
ARCTANGENT FUNCTION

Macros:

Symbols:
089B'	$DECA4          0893'	$DECF1          08B8'	$PPARG          
08A7'	$PSARG          02E8I'	ABS             0B43*	ARG             
0F2D*	ARGLO           13D0I'	ATN             13ED'	ATN2            
13F7I'	ATNCON          0000 	BOBTST          059D*	BSERR           
00FF 	BUFLEN          0B7D*	CALTTY          04BCI'	CHKSTR          
127C*	CHRGTR          000E 	CLMWID          118E*	CLROVC          
0000*	CNSGET          04ABI'	CONDS           0300I'	CONIA           
0450I'	CONIS           045C'	CONIS1          0466'	CONIS2          
0462'	CONISD          047FI'	CONSD           0492I'	CONSI           
0495I'	CONSIH          000F 	CONTO           1328I'	COS             
0005 	CPMENT          0000 	CPMWRM          0024 	CURNCY          
06A7I'	DADD            06C3'	DADD1           06D3'	DADD2           
0707'	DADD3           077D'	DADDA           077B'	DADDAA          
0772'	DADDD           0780'	DADDFO          0789'	DADDL           
078A'	DADDOP          0783'	DADDS           0785'	DADDS1          
0080 	DATPSC          0000 	DBLTRN          08A0'	DC4             
03F4I'	DCOMP           03E7'	DCOMP1          03C4I'	DCOMPD          
0BAD*	DCOMPR          0A50'	DCRART          04ECI'	DCXBRT          
02A0'	DCXHRT          0847'	DD04            0857'	DD05            
0874'	DD10            08C9I'	DDIV            08E7'	DDIV1           
0833'	DDIV10          08F9'	DDIV2           1025*	DFACLO          
10C5'	DHALF           052D'	DIN00           054A'	DIN05           
0527I'	DINT            0537'	DINT1           054BI'	DINT2           
057B'	DINTA           057E'	DINTA1          0550I'	DINTFO          
01E5'	DIV10           0250'	DIV2A           024B'	DIV2AA          
0B49*	DIVMSG          092D'	DMLDV1          0937'	DMUL10          
0922'	DMULDV          07E5I'	DMULT           07FA'	DMULT2          
0803'	DMULT3          0812'	DMULT4          081A'	DMULT5          
0793'	DNEGR           079D'	DNEGR1          0713'	DNORM1          
0720'	DNORM2          0733'	DNORM3          073B'	DNORM5          
0712I'	DNORML          0763'	DRONA1          075E'	DROUNA          
074F'	DROUNB          074C'	DROUND          07DA'	DSHFLC          
07A8'	DSHFR1          07B2'	DSHFR2          07BD'	DSHFR3          
07C0'	DSHFR4          07C7'	DSHFR5          07C4'	DSHFRA          
07D2'	DSHFRB          07AE'	DSHFRM          07DC'	DSHFTL          
07A6'	DSHFTR          06A0I'	DSUB            082B'	DTEN            
0BB9*	DV0ERR          0000*	ERRFLG          0000*	ERROR           
11D9I'	EXP             120E'	EXP100          1211'	EXP110          
121D'	EXP115          1220'	EXP200          122A'	EXPBCN          
13DA*	FAC             11C7*	FACLO           000FI'	FADD            
0029'	FADD1           0050'	FADD3           00C9'	FADDA           
0000I'	FADDH           0003I'	FADDS           0AD3'	FADDT           
005E'	FADFLT          0D32*	FANSII          1136*	FBUFFR          
0149*	FCERR           0387I'	FCOMP           03A1'	FCOMP2          
039E'	FCOMPD          02CF'	FCOMPS          0408'	FDBINT          
01F0I'	FDIV            0215'	FDIV1           0232'	FDIV2           
025C'	FDIV2A          025E'	FDIV2B          0220'	FDIVA           
021C'	FDIVB           0218'	FDIVC           0223'	FDIVG           
01EEI'	FDIVT           10CD'	FFXDXM          0EB1'	FFXFLV          
0EAA'	FFXIFL          0DC2'	FFXIX1          0ED7'	FFXLV1          
0F0F'	FFXLV2          0EE5'	FFXLV3          0F08'	FFXLV4          
0EBC'	FFXS03          0E42'	FFXSD2          0E37'	FFXSDC          
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	S-1
ARCTANGENT FUNCTION

0E20'	FFXSDO          0EB7'	FFXSFL          0E29'	FFXSFX          
0E63'	FFXXS2          0E75'	FFXXS4          0E7B'	FFXXS6          
0E69'	FFXXV2          0E85'	FFXXV3          0E96'	FFXXV6          
0EA1'	FFXXV7          0E67'	FFXXV8          0E5C'	FFXXVS          
10C9'	FHALF           0956I'	FIN             097E'	FIN1            
097E'	FINC            0990'	FINC1           0962'	FINCHR          
0A29'	FINDBF          094FI'	FINDBL          0A98'	FINDG1          
0A9A'	FINDG2          0AB7'	FINDG3          0ABA'	FINDGD          
0A92'	FINDGE          0A9E'	FINDGV          0A65'	FINDIG          
0A52'	FINDIV          0A0B'	FINDP           09EA'	FINE            
09EE'	FINE2           09FD'	FINE2C          09DD'	FINEC           
0AD8'	FINEDG          0AE7'	FINEDO          09D4'	FINEX           
09D3'	FINEX1          0A33'	FINFRC          0A18'	FININT          
0ACD'	FINLOG          0A43'	FINMLT          0A42'	FINMUL          
1174'	FINOHO          0958*	FINOVC          0A2A'	FINSNF          
04EEI'	FIXER           1194*	FLGOVC          02D5I'	FLOAT           
02DAI'	FLOATR          01D8'	FML5B1          01D8'	FMLT5B          
018AI'	FMULT           01AC'	FMULT2          01E0'	FMULT3          
01B6'	FMULT4          01C4'	FMULT5          01C2'	FMULTA          
01BD'	FMULTB          0616'	FMULTT          10D5'	FODTBL          
0D6A'	FOFLDN          0D4B'	FOFRS1          0D5A'	FOFRS2          
0D3D'	FOFV5A          1121'	FOITBL          011EI'	FONE            
0F80'	FONVC1          0F86'	FONVC2          0F21'	FORBIG          
111B'	FOSTBL          0FA7'	FOTCD1          0F9B'	FOTZEC          
0F8B'	FOTZER          0F94'	FOTZNC          0F8C'	FOTZR1          
0F97'	FOTZRC          0C3B'	FOTZS1          0C5E'	FOTZS2          
0C67'	FOTZS3          0C5B'	FOTZS4          0DC7'	FOUBE1          
0DDB'	FOUBE2          0DFB'	FOUBE3          0E05'	FOUBE4          
0DC8'	FOUBE5          0FFE'	FOUCD1          1007'	FOUCD2          
103A'	FOUCDC          0D7D'	FOUCE1          0D7F'	FOUCE2          
107C'	FOUCI1          108F'	FOUCI2          1040'	FOUCS1          
104E'	FOUCS2          0FD6'	FOUED1          0D22'	FOUFRF          
0C77'	FOUFRV          0D47'	FOUFV6          0E0D'	FOUFXV          
0FAF'	FOUICC          0C6E'	FOUINI          0F3C'	FOUNDB          
0F3F'	FOUNV1          0F62'	FOUNV2          0F6A'	FOUNV3          
0F51'	FOUNV4          0F57'	FOUNV5          0F6E'	FOUNVC          
0BE5I'	FOUT            0BF0'	FOUT1           0C02'	FOUT2           
0FB7'	FOUTAN          0FAE'	FOUTCC          0FA2'	FOUTCD          
1076'	FOUTCI          102D'	FOUTCS          0FDE'	FOUTCV          
0FC0'	FOUTD1          10B5'	FOUTDL          0D8C'	FOUTDN          
0FCE'	FOUTDP          10BD'	FOUTDU          0FCB'	FOUTE1          
0FCA'	FOUTED          0D93'	FOUTFX          112EI'	FOUTH           
0F18'	FOUTNV          112BI'	FOUTO           0DAF'	FOUTTD          
0DB8'	FOUTTS          0D8B'	FOUTZR          0C1E'	FOUTZS          
118DI'	FPWR            11C1'	FPWR1           1188I'	FPWRQ           
118B'	FPWRT           13A2'	FR4             04A1I'	FRCDBL          
0443'	FRCI3A          043E'	FRCIAA          041A'	FRCIN2          
041D'	FRCIN3          0449'	FRCIN4          03FBI'	FRCINT          
0475I'	FRCSNG          04BCI'	FRCSTR          0414'	FRDBIN          
1132*	FRQINT          000CI'	FSUB            0009'	FSUBS           
082F'	FTEN            0C92'	FU1             0C94'	FU2             
0CA3'	FU2A            0CB3'	FU3             0CC3'	FU4             
0CC8'	FU5             0CE1'	FU5A            0CF7'	FU6             
0CFF'	FU7             0D0A'	FU8             0D0F'	FU9             
033AI'	GETBCD          0FE0*	GETYPR          05B2I'	IADD            
05B5'	IADDS           03B4I'	ICOMP           02D0'	ICOMPS          
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	S-2
ARCTANGENT FUNCTION

0629I'	IDIV            0642'	IDIV1           064B'	IDIV2           
064C'	IDIV3           05F8'	IMLDIV          068EI'	IMOD            
0663'	IMULDV          05D2I'	IMULT           05E4'	IMULT1          
05F2'	IMULT2          0602'	IMULT3          061B'	IMULT4          
060A'	IMULT5          0B42'	INDV0A          0B45'	INDV0B          
0679I'	INEG            0684I'	INEG2           066B'	INEGA           
0689'	INEGAD          066A'	INEGH           066F'	INEGHL          
0BCA'	INFM            0BC6'	INFP            0BCEI'	INPRT           
02D3I'	INRART          050EI'	INT             0B25'	INTDV0          
0B21'	INTDV1          0B47'	INTDV2          0BD0*	INTXT           
033FI'	INXHRT          0313I'	ISIGN           05A6I'	ISUB            
0050 	LINLN           0BDAI'	LINOUT          0BD6I'	LINPRT          
0144I'	LOG             0157'	LOG2            0122'	LOGP            
0133'	LOGQ            0084 	LPTLEN          115B'	MAKDIG          
045DI'	MAKINT          0003 	MD.RND          0001 	MD.SQI          
0002 	MD.SQO          09DB*	MINPLS          0000*	MINUTK          
02A2'	MLDVEX          0344I'	MOVE            034EI'	MOVE1           
0327I'	MOVFM           032AI'	MOVFR           0341I'	MOVMF           
0335I'	MOVRF           0338I'	MOVRM           0349'	MOVVFM          
02AF'	MUL10           0284'	MULDIV          02A7'	MULDV1          
02A8'	MULDV2          027A'	MULDVA          0277'	MULDVS          
05A3'	MULRET          0028 	NAMLEN          02F5I'	NEG             
00D5'	NEGR            1167'	NOLEAD          0BBB'	NOODTP          
0064'	NORM1           007B'	NORM2           0082'	NORM2F          
008D'	NORM2U          0095'	NORM3           0098'	NORM3A          
0061I'	NORMAL          09BA'	NOTE            1164'	NOTHAL          
12E4'	NTPTRB          001D 	NUMLEV          000A 	NUMTMP          
0970*	OCTCNS          114A'	OCTONE          0B9F*	ONELIN          
0000*	OUTDO           1144'	OUTHLP          1146'	OUTOLP          
0B6C'	OV1A            0B7F'	OV1B            0BB6*	OVERR           
0BC0*	OVERRI          0B01'	OVF2A           0B02'	OVF2B           
0B08'	OVF2C           0B1D'	OVFI4B          0AEC'	OVFIN1          
0AF1'	OVFIN2          0B11'	OVFIN3          0B19'	OVFIN4          
0B0E'	OVFIN5          0B0F'	OVFIN6          0B10'	OVFIN7          
0B18'	OVFIN8          0AF0'	OVFIN9          0B8C'	OVFINA          
0B9E'	OVFINB          0B4E'	OVFINT          0B7F'	OVFPRT          
0BBD*	OVRMSG          1396'	P1B2PI          139E'	PI2             
0000*	PLUSTK          1256'	POLY            125F'	POLY1           
1247'	POLYX           124E'	POLYX2          01DEI'	POPHRT          
11A4'	POSEXP          08BE'	PPA10           08AD'	PSA10           
1177'	PSHNEG          0BE6I'	PUFOUT          031AI'	PUSHF           
04C3I'	QINT            04E7'	QINTA           128CI'	RND             
12C8'	RND1            12F6I'	RNDCNT          1277I'	RNDCOP          
127EI'	RNDMN2          127BI'	RNDMON          12ED'	RNDSTR          
12F8'	RNDTAB          131C'	RNDTB2          1318I'	RNDX            
00AA'	ROUND           00BC'	ROUNDA          00AB'	ROUNDB          
02FDI'	SGN             0112'	SHFTC           00EB'	SHFTR1          
00F8'	SHFTR2          010C'	SHFTR3          0102'	SHFTRF          
00E9'	SHIFTR          0110'	SHRADD          02C6I'	SIGN            
02CBI'	SIGNC           02D1I'	SIGNS           132EI'	SIN             
136C'	SIN2            1378'	SIN2A           1385'	SIN3            
13A6I'	SINCON          0000*	SNERR           117CI'	SQR             
0BD7*	STROUI          0BD3*	STROUT          0B70*	STRPRN          
0003 	STRSIZ          0000*	SYNCHR          13BBI'	TAN             
0FD1*	TEMP2           0FB0*	TEMP3           10AD'	TENTEN          
0823'	TENTH           0509*	TMERR           0000 	TRUROM          
MATHPK FOR BASIC MCS 8080  GATES/ALLEN/DAVIDOFF	MACRO-80 3.44	09-Dec-81	PAGE	S-3
ARCTANGENT FUNCTION

0B73*	TTYPOS          0586I'	UMULT           0591'	UMULT1          
059F'	UMULT2          0357I'	UNPACK          04B4'	VALDBL          
0460I'	VALINT          04B7I'	VALSNG          0C0B*	VALTYP          
037CI'	VDFACS          0501I'	VINT            0375I'	VMOVAF          
034AI'	VMOVE           036CI'	VMOVFA          036FI'	VMOVFM          
0378I'	VMOVMF          037B'	VMVVFM          02ECI'	VNEG            
0307I'	VSIGN           09B9'	WUZ             09A8'	WUZELS          
03CAI'	XDCOMP          0076I'	ZERO            0077'	ZERO0           



No Fatal error(s)


ULT2          0357I'	UNPACK          04B4'	VALDBL          
0460I'	VALINT          04B7I'	VALSNG          0C0B*	VALTYP   