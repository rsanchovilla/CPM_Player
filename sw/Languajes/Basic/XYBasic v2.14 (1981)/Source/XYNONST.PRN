                	TITLE	'XYBASIC	REV 2.14.00	05/27/81'
                
                ;VERSION 05/18/81
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980, 1981 BY MARK WILLIAMS COMPANY, CHICAGO
                ;VERSION EQUATES
                
 FFFF =         TRUE	EQU	-1
 0000 =         FALSE	EQU	0
                	PAGE	0		;LINES PER PAGE ON PRN LISTING
                
                ;VERSION SELECTION SWITCHES
 5398 =         VERSN	EQU	21400		;CURRENT VERSION NUMBER
 0000 =         CPM	EQU	FALSE		;IFF CP/M VERSION
 FFFF =         NONST	EQU	TRUE 		;IFF NONSTANDARD (CUSTOM I/O) VERSION
 0000 =         ISIS2	EQU	FALSE		;IFF ISIS-II VERSION
                
                ;CONDITIONAL ASSEMBLY SWITCHES
 FFFF =         STRNG	EQU	TRUE		;IFF STRING VERSION
 FFFF =         FLOAT	EQU	TRUE		;IFF FLOATING POINT VERSION
 FFFF =         ROM	EQU	NONST		;IFF ROM VERSION (NONST ONLY)
 0000 =         ROMSQ	EQU	FALSE		;IFF ROMSQ VERSION
 0000 =         COMPL	EQU	FALSE		;IFF COMPILER VERSION (NONST ROM ONLY)
 0000 =         RTPAK	EQU	FALSE		;IFF RUNTIME VERSION (ROMSQ COMPL ONLY)
 FFFF =         EDITC	EQU	TRUE 		;IFF EDITING COMMANDS AUTO, DELETE, EDIT, RENUM
 0000 =         SDISK	EQU	FALSE		;IFF SEQUENTIAL DISK VERSION (CP/M STRNG ONLY)
 0000 =         F9511	EQU	FALSE		;IFF 9511 FLOATING POINT CHIP VERSION
 0000 =         FPBCD	EQU	FALSE		;IFF BCD FLOATING POINT, 10 DIGIT MANTISSA
 0000 =         REALT	EQU	FALSE		;IFF SBC 80/20 REAL TIME CLOCK
 FFFF =         FOR0	EQU	TRUE		;IFF E.G. FOR I = 1 TO 0 NEVER ENTERED
 0000 =         ASM80	EQU	FALSE		;IFF ASSEMBLING UNDER ASM80
 FFFF =         KEY80	EQU	TRUE 		;IFF MORE THAN 80H KEYWORDS
 0000 =         DEBUG	EQU	FALSE		;IFF DEBUGGING
                				;CPM AND DEBUG: ^B GETS SID, ^X ECHOES TO DISK
                				;ISIS2 AND DEBUG: ^B GETS MONITOR
                				;NONST:  DEBUG HAS NO EFFECT
                				;PACKI AND DEBUG: 8251 INITIALIZATION SKIPPED
                
                ;CUSTOMIZED VERSIONS
 0000 =         AMD	EQU	FALSE		;IFF AMD
 0000 =         BENDX	EQU	FALSE		;IFF BENDIX (STRNG NONST ONLY)
 0000 =         CAMAC	EQU	FALSE		;IFF KINETICSYSTEMS (STRNG, NONST OR CP/M ONLY)
 0000 =         C3908	EQU	FALSE		;IFF CAMAC VERSION FOR 3908, FALSE IFF 3909
 0000 =         C3885	EQU	FALSE		;IFF CP/M SDISK CAMAC VERSION FOR 3885
 0000 =         EPSTN	EQU	FALSE		;IFF EPSTEIN (NONST ONLY)
 0000 =         GENMC	EQU	FALSE		;IFF GENERAL MICROWAVE (NONST ONLY)
 0000 =         PACKI	EQU	FALSE		;IFF PACKARD INSTRUMENTS
 0000 =         WILD	EQU	FALSE		;IFF WILD HEERBRUGG
                
                ;LOCATION
                	IF	ASM80
                	NAME	XYBASIC		;ISIS-II MODULE NAME FOR ASM80
                	CSEG			;START OF RELOCATABLE CODE SEGMENT
                	ELSE
 0100 =         ROMORG	EQU	00100H		;FIRST ROM LOCATION
                	IF	ROM
 4000 =         RAMORG	EQU	04000H		;FIRST RAM LOCATION
                	ENDIF
                	ENDIF
 0100           	ORG	ROMORG
                
                ;GLOBAL EQUATES
 0008 =         MAXNL	EQU	8		;MAX VAR NAME LENGTH(>=7 FOR STRING CONVERSION)
 0008 =         INTTN	EQU	8		;MAX # OF INTERRUPT TABLE ENTRIES (< 32)
 0041 =         INTTL	EQU	INTTN * 8 + 1	;INT TABLE LENGTH = N 8-BYTE ENTRIES + EOF
 64B5 =         RANDA	EQU	64B5H		;PSEUDORANDOM NUMBER GENERATOR MULTIPLIER
 3A73 =         RANDC	EQU	3A73H		;PSEUDORANDOM NUMBER GENERATOR CONSTANT
 0080 =         STAKL	EQU	80H		;STACK LENGTH
 0019 =         STAKM	EQU	25		;MAX STACK USE WITHOUT RECURSION BY GTEXP
 0003 #         VBYTS	SET	3		;BYTES PER ESTACK VALUE ENTRY IF INTEGER ONLY
 000A #         DBYTS	SET	10		;BYTES NEEDED FOR STRING SPACE AND FILE AREAS
 0050 =         NLMAX	EQU	80		;INPUT BUFFER LENGTH
                	IF	STRNG
 0004 =         STMAX	EQU	4		;NUMBER OF STRING TEMPORARIES
 0004 #         VBYTS	SET	4		;BYTES PER VALUE ENTRY IF STRING
 010A #         DBYTS	SET	DBYTS+100H	;100H BYTES FOR STRING SPACE
                	ENDIF
                	IF	FLOAT
                	IF	FPBCD		;BCD FLOATING POINT
                VBYTS	SET	7		;BYTES PER VALUE ENTRY
                FBYTS	EQU	6		;BYTES PER FOR-ENTRY VALUE
                	ELSE			;BINARY FLOATING POINT
 0005 #         VBYTS	SET	5		;BYTES PER VALUE ENTRY IF FLOATING
 0004 =         FBYTS	EQU	4		;BYTES PER FOR-ENTRY VALUE
 0013 =         SINDX	EQU	19		;# SIGNIFICANT BINARY PLACES
                	ENDIF
                	ELSE			;NOT FLOATING POINT VERSION
                FBYTS	EQU	2		;BYTES PER FOR-ENTRY VALUE IF INTEGER
                	ENDIF
                
                ;ASCII CHARACTER EQUIVALENTS
 0002 =         CNTLB	EQU	02H
 0004 =         CNTLD	EQU	04H
 0005 =         CNTLE	EQU	05H
 0006 =         CNTLF	EQU	06H
 0007 =         CNTLG	EQU	07H
 0008 =         CNTLH	EQU	08H
 000A =         LF	EQU	0AH
 000B =         CNTLK	EQU	0BH
 000C =         CNTLL	EQU	0CH
 000D =         CR	EQU	0DH
 000E =         CNTLN	EQU	0EH
 000F =         CNTLO	EQU	0FH
 0011 =         CNTLQ	EQU	11H
 0012 =         CNTLR	EQU	12H
 0013 =         CNTLS	EQU	13H
 0014 =         CNTLT	EQU	14H
 0018 =         CNTLX	EQU	18H
 0019 =         CNTLY	EQU	19H
 001A =         CNTLZ	EQU	1AH
 003B =         SEMIC	EQU	3BH
                	IF	NOT EPSTN
 0003 =         CNTLC	EQU	03H
 0010 =         CNTLP	EQU	10H
 0015 =         CNTLU	EQU	15H
 007F =         RBOUT	EQU	7FH
                	ELSE			;EPSTEIN VERSION CONTROL CHARS
                CNTLC	EQU	0AH
                CNTLP	EQU	04H
                CNTLU	EQU	0BH
                RBOUT	EQU	1AH
                ESCAP	EQU	1BH
                	ENDIF
                
                ;INFORMATION PASSED TO COMPILER
                	IF	COMPL AND NOT RTPAK
                	DB	REMT		;REM TOKEN VALUE
                	DW	ROMEND+1-ROMORG	;ROM USE
                	DW	RAMEND+1-RAMORG	;RAM USE
                	ENDIF
                
 0100 C34237    START:	JMP	INIT		;START INITIALIZATION DIALOG
 0103 C38304    	JMP	GTPAR		;TO GET PARAMETERS FOR CALL
                
                ;NONSTANDARD SYSTEM EQUATES
                	IF	NONST AND NOT CAMAC
 8C13 =         TIMEM	EQU	8C13H		;TIME COUNTS
 FE12 =         TIMEN	EQU	0FE12H
 0073 =         TIMEH	EQU	73H
                	IF	NOT WILD
                	IF	GENMC
                HEADL	EQU	17		;HEADER LENGTH
                	ELSE
 000D =         HEADL	EQU	13
                	ENDIF
 003A =         STBYT	EQU	3AH		;START BYTE
 0000 =         TYBYT	EQU	0		;TYPE BYTE -- FOR FUTURE USE
                ;JUMP VECTOR FOR I/O ROUTINES
 0106 C3F804    	JMP	CONIN
 0109 C31A05    	JMP	CNOUT
 010C C31F05    	JMP	RDRIN
 010F C32705    	JMP	POUT
 0112 C32F05    	JMP	LOUT
 0115 C30140    	JMP	CSTAT
                ;JMP TABLE FOR USER-DEFINED DEVICE DRIVERS
                JMPTA:	REPT	24
                	JMP	0
                	ENDM
 0118+C30000    	JMP	0
 011B+C30000    	JMP	0
 011E+C30000    	JMP	0
 0121+C30000    	JMP	0
 0124+C30000    	JMP	0
 0127+C30000    	JMP	0
 012A+C30000    	JMP	0
 012D+C30000    	JMP	0
 0130+C30000    	JMP	0
 0133+C30000    	JMP	0
 0136+C30000    	JMP	0
 0139+C30000    	JMP	0
 013C+C30000    	JMP	0
 013F+C30000    	JMP	0
 0142+C30000    	JMP	0
 0145+C30000    	JMP	0
 0148+C30000    	JMP	0
 014B+C30000    	JMP	0
 014E+C30000    	JMP	0
 0151+C30000    	JMP	0
 0154+C30000    	JMP	0
 0157+C30000    	JMP	0
 015A+C30000    	JMP	0
 015D+C30000    	JMP	0
                	IF	COMPL
                BOOT:	JMP	0		;ABSOLUTE ADDRESS, ELSE COMPILATION RELOCATES
                	ELSE
 0160 C33940    BOOT:	JMP	DMODC		;^B SAME AS ^C IN NONSTANDARD VERSIONS
                	ENDIF
                	ENDIF			;END OF NOT WILD CONDITIONAL
                	ENDIF			;END OF NONST CONDITIONAL
                
                ;CP/M EQUATES
                	IF	CPM
                CPMBA	EQU	0H		;CP/M BASE ADDRESS
                IOBYT	EQU	CPMBA+3H	;IO BYTE ADDRESS
                BDOS	EQU	CPMBA+5H	;DOS ENTRY POINT
                FCBAD	EQU	CPMBA+5CH	;DEFAULT FILE CONTROL BLOCK ADDRESS
                FCBFN	EQU	FCBAD + 1	;FILE NAME ADDRESS
                FCBFT	EQU	FCBAD + 9	;FILE TYPE ADDRESS
                FCBCR	EQU	FCBAD + 32	;CURRENT RECORD NUMBER
                DMAAD	EQU	CPMBA+80H	;DEFAULT DMA ADDRESS
                DKOPF	EQU	15		;DISK OPEN FUNCTION
                DKCLF	EQU	16		;CLOSE
                DKDLF	EQU	19		;DELETE
                DKRDF	EQU	20		;READ
                DKWTF	EQU	21		;WRITE
                DKMKF	EQU	22		;MAKE
                DKDMF	EQU	26		;SET DMA ADDRESS FUNCTION
                TIMEM	EQU	8C13H		;TIME COUNTS
                TIMEN	EQU	0FE12H
                TIMEH	EQU	73H
                	IF	AMD		;SERIAL SAVE/LOAD FOR AMD VERSION
                HEADL	EQU	13
                STBYT	EQU	3AH		;START BYTE
                TYBYT	EQU	0		;TYPE BYTE -- FOR FUTURE USE
                	ENDIF
                	IF	SDISK
                FILEN	EQU	166		;NUMBER OF BYTES PER SEQUENTIAL ACCESS FILE
                DBYTS	SET	DBYTS+2*FILEN	;NUMBER OF BYTES NEEDED
                	ENDIF
                	IF	DEBUG
                BOOT	EQU	CPMBA+38H	;^B GETS SID INSTEAD OF CP/M
                	ELSE
                BOOT	EQU	CPMBA		;^B GETS CP/M IF NOT DEBUGGING
                	ENDIF
                	ENDIF			;END OF CPM CONDITIONAL
                
                ;ISIS-II EQUATES
                	IF	ISIS2
                ISIS	EQU	40H		;ISIS-II ENTRY POINT
                DKOPF	EQU	0		;DISK OPEN FUNCTION
                DKCLF	EQU	1		;CLOSE
                DKRDF	EQU	3		;READ
                DKWRF	EQU	4		;WRITE
                EXITF	EQU	9		;EXIT TO ISIS-II
                ERRI2	EQU	12		;ERROR
                TIMEM	EQU	947BH		;TIME COUNTS
                TIMEN	EQU	0FE36H
                TIMEH	EQU	6BH
                ;MDS MONITOR EQUATES
                CONIN	EQU	0F803H		;CONSOLE IN
                CNOUT	EQU	0F809H		;CONSOLE OUT
                LOUT	EQU	0F80FH		;LIST OUT
                CSTAT	EQU	0F812H		;CONSOLE STATUS
                MECHK	EQU	0F81BH		;TOP OF FREE RAM FUNCTION
                IOBYT	EQU	3		;IOBYTE LOCATION
                	ENDIF			;END OF ISIS2 CONDITIONAL
                
                ;CAMAC RTPAK I/O JMP VECTOR
                	IF	CAMAC AND NONST AND TRUE 
                CONIN:	JMP	0
                CNOUT:	JMP	0
                RDRIN:	JMP	0
                POUT:	JMP	0
                LOUT:	JMP	0
                CSTAT:	JMP	0
                BOOT:	JMP	0
                	ENDIF
                
                ;WILD VERSION EQUATES
                	IF	WILD
                	IF	RTPAK
                	JMP	WTOKE		;TOKENIZATION MODULE ENTRY POINT
                WEOM:	DW	6000H		;DEFAULT END OF RAM
                BOOT	EQU	0H		;BOOT AFTER PROGRAM COMPLETION IN RTPAK
                	ENDIF
                WMON	EQU	38H		;WILD MONITOR ENTRY POINT
                WDBL	EQU	80H		;LENGTH OF CENTRAL DATA BUFFER -- 254 MAX
                WDBUF	EQU	80H		;BASE ADDRESS OF CENTRAL DATA BUFFER
                WEXEC	EQU	40H		;BASE ADDRESS OF 18-BYTE EXEC BUFFER
                	ENDIF
                
                ;ROMSQ VERSION DEFAULT VALUE BYTES
                	IF	ROMSQ AND NOT WILD
                DFLTW:	DB	0		;DEFAULT WIDTH
                DFLTM:	DW	1		;DEFAULT END OF MEMORY
                DFLTA:	DW	0		;DEFAULT PROGRAM ADDRESS
                	ENDIF
                
                ;CAMAC VERSION BOOT AND CONDITIONAL INTERRUPT ENABLE ON REENTRY
                	IF	CAMAC AND NONST AND (NOT TRUE )
                BOOT:	JMP	NSDDI		;DI AND RETURN TO DOS
                	IF	NOT RTPAK
                	CALL	CNDEI		;CONDITIONAL EI, THEN DMODE
                	ENDIF
                	ENDIF
                
                ;PACKARD INSTRUMENTS VERSION XYBASIC REENTRY AND INTERRUPT ENTRY POINT
                	IF	PACKI
                	JMP	DMOD2		;TO DMODE
                	JMP	PAISR		;INTERRUPT SERVICE ROUTINE ENTRY POINT
                	ENDIF
                
                ;REAL-TIME CLOCK VERSION CLOCK TICK ROUTINE ENTRY POINT
                	IF	REALT
                	JMP	DMOD2		;TO DMODE
                	JMP	CLOCK		;CLOCK ROUTINE ENTRY
                	ENDIF
                
                ;IFTYP IS A MACRO TO SIMPLIFY CODING OF CONDITIONAL TYPE BRANCHES.
                IFTYP	MACRO	FADDR,SADDR
                	IF	FLOAT
                	JNZ	FADDR		;;BRANCH TO FLOATING ROUTINE
                	ENDIF
                	IF	STRNG
                	JC	SADDR		;;BRANCH TO STRING ROUTINE
                	ENDIF			;;ELSE FALL THROUGH TO INTEGER ROUTINE
                	ENDM
                
                ;PUSH3 (AND PUSH4) IS A MACRO TO SAVE BC, DE, HL (AND PSW) ON ROUTINE ENTRY.
                ;THE CORRESPONDING EXIT IS JMP POP3 (POP4), DEFINED IN INOUT.
                PUSH3	MACRO
                	PUSH	B
                	PUSH	D
                	PUSH	H
                	ENDM
                PUSH4	MACRO
                	PUSH3
                	PUSH	PSW
                	ENDM
                
                ;DZ IS A MACRO TO FILL BLOCKS OF RAM WITH 0 (USED LIKE DS).
                DZ	MACRO	N
                	REPT	N
                	DB	0
                	ENDM
                	ENDM
                
                ;RIM AND SIM ARE 8085 OPCODES TO READ AND SET INTERRUPT MASK.
                RIM	MACRO
                	DB	20H
                	ENDM
                SIM	MACRO
                	DB	30H
                	ENDM
                
                ;ERROR IS A MACRO TO DEFINE ERROR CALLS.
                ;TYP MAY BE F, N OR C FOR FATAL, NONFATAL, OR CONTINUE SCANNING.
                ;M1 AND M2 ARE THE ERROR MESSAGE, M2 BEING THE LAST BYTE.
                ERROR	MACRO	TYP, M1, M2
                	CALL	ERRO&TYP		;;CALL ERROF, ERRON OR ERROC
                	DB	'&M1', '&M2' OR 80H	;;ERROR MESSAGE
                	ENDM
                
                
                ;END OF VERSION
                	PAGE
                
                ;AUX 11/19/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;STATEMENT AUXILLIARY ROUTINES
                
                ;GENERAL PURPOSE ROUTINES USED IN STATEMENT EXECUTION
                
                ;LINBC GETS CURRENT LINE # IN BC.
                ;CALL:	(LNNUM)	CURRENT LINE # ADDRESS, 0 IF DIRECT
                ;RETN:	A	CLOBBERED
                ;	BC	IF (LNNUM) = 0 THEN 0 ELSE ((LNNUM))
                ;	DE	PRESERVED
                ;	HL	IF (LNNUM) = 0 THEN 0 ELSE (LNNUM) + 1
                ;	ZERO	SET IFF (LNNUM) = 0
 0163 2A4B40    LINBC:	LHLD	LNNUM
 0166 7C        LINB1:	MOV	A,H
 0167 B5        	ORA	L
 0168 CA6F01    	JZ	LINB2		;LINE # IS 0, I.E. DIRECT
 016B 4E        	MOV	C,M
 016C 23        	INX	H
 016D 46        	MOV	B,M		;LINE # TO BC
 016E C9        	RET
 016F 47        LINB2:	MOV	B,A
 0170 4F        	MOV	C,A		;0 TO BC
 0171 C9        	RET
                
                ;IDTST ISSUES A FATAL ID ERROR IF CURRENT STATEMENT IS DIRECT, I.E. (LNNUM)=0.
                ;IITST PERFORMS EOS TEST, THEN ISSUES FATAL II ERROR IF CURRENT IS INDIRECT.
                	IF	COMPL
                IDTST	EQU	LINBC		;JUST RETURN CURRENT LINE IN BC
                	ELSE
 0172 CD6301    IDTST:	CALL	LINBC		;ZERO SET IFF DIRECT
 0175 C0        	RNZ
                IDERR:	ERROR	F, I, D		;FATAL ID ERROR
 0176+CDC616    	CALL	ERROF
 0179+49C4      	DB	'I', 'D' OR 80H
 017B CD8E01    IITST:	CALL	EOS
 017E CD6301    	CALL	LINBC		;ZERO SET IFF DIRECT
 0181 C8        	RZ			;OK IF DIRECT
                	ERROR	F, I, I		;ISSUE FATAL II ERROR
 0182+CDC616    	CALL	ERROF
 0185+49C9      	DB	'I', 'I' OR 80H
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                
                ;RTEST RETURNS ZERO SET IFF LOCATION HL IS RAM.
 0187 7E        RTEST:	MOV	A,M		;FETCH BYTE
 0188 2F        	CMA
 0189 77        	MOV	M,A		;STORE COMPLEMENT
 018A BE        	CMP	M		;COMPARE TO STORED VALUE
 018B 2F        	CMA
 018C 77        	MOV	M,A		;RESTORE VALUE
 018D C9        	RET
                
                	IF	ROMSQ AND NOT COMPL
                ;ISSRC RETURNS IF SOURC ADDRESS WORKING SPACE, ISSUES FATAL RO ERROR OTHERWISE.
                ISSRC:	LXI	D,SRCAD
                	LHLD	SOURC
                	CALL	CMDHU		;COMPARE SOURC TO SRCAD
                	RZ			;ADDRESSING WORKING SPACE, OK
                ROERR:	ERROR	F, R, O		;FATAL RO ERROR
                
                ;ISROM CHECKS IF CURRENT PROGRAM IS RUNNING IN ROM, ISSUES NONFATAL RO ERROR
                ;AND SCANS TO NEXT COMMAND IF SO.
                ISROM:	LHLD	SOURC
                	CALL	RTEST		;TEST IF ROM
                	RZ			;RAM, OK
                	ERROR	C, R, O		;NONFATAL RO ERROR AND SCAN ON
                
                	ENDIF			;END OF ROMSQ AND NOT COMPL CONDITIONAL
                
                ;EOS CHECKS FOR GARBAGE ON END OF STATEMENT, AND IS CALLED BY ROUTINES WHICH
                ;ALTER NORMAL CONTROL FLOW (GOTO, GOSUB, RETURN, ETC.).
                ;FALLS THROUGH TO SYNTAX ERROR IF NEXT NONSPACE CHAR IS NOT :, ' OR <CR>.
                ;RETN:	A	NEXT NONSPACE CHAR
                ;	BC,DE	PRESERVED
                ;	HL	ADDRESS OF NEXT NONSPACE CHAR (I.E. OF :, ' OR <CR>)
 018E CD9C01    EOS:	CALL	DTST0
 0191 D0        	RNC			;OK IF NEXT IS DELIMITER
                SNERR:	ERROR	C, S, N		;ISSUE SN ERROR AND SCAN TO NEXT
 0192+CDCC16    	CALL	ERROC
 0195+53CE      	DB	'S', 'N' OR 80H
                EXERR:	ERROR	F, E, X		;FATAL EX ERROR
 0197+CDC616    	CALL	ERROF
 019A+45D8      	DB	'E', 'X' OR 80H
                
                	IF	COMPL
                UFERR:	ERROR	C, U, F		;ISSUE UF ERROR AND SCAN TO NEXT
                	ENDIF
                
                ;DTEST TESTS WHETHER A CONTAINS A DELIMITER.
                ;RETN:	CARRY	RESET IFF (A) = :, ' OR <CR>
                ;	REGISTERS	PRESERVED
 019C CD4917    DTST0:	CALL	GTCHO
 019F FE3A      DTEST:	CPI	':'
 01A1 C8        	RZ
 01A2 FE0D      DTST1:	CPI	CR
 01A4 C8        	RZ
                	IF	RTPAK OR NOT COMPL	;COMMENTS ALREADY PURGED IF COMPILED
 01A5 FE27      	CPI	''''
 01A7 C8        	RZ
                	ENDIF
 01A8 37        	STC
 01A9 C9        	RET
                
                ;GTLHS GETS A DESTINATION VARIABLE REFERENCE.  IT CALLS GTVAR WITH
                ;INLHS TRUE (TO INDICATE TRACING MAY BE DESIRED) AND STORES THE
                ;DESTINATION RETURNED IN LHSAD FOR ASSGN TO PERFORM ASSIGNMENT.
                GTLHS:	IF	NOT COMPL
 01AA 3EFF      	MVI	A,255
 01AC 325140    	STA	INLHS		;SET INLHS TO TRUE
                	ENDIF
 01AF CD8419    	CALL	GTVAR		;PERFORM VARIABLE REFERENCE
 01B2 DA9201    	JC	SNERR		;NO VARIABLE NAME
 01B5 32BF41    	STA	LHSTY		;SAVE TYPE
 01B8 22C041    	SHLD	LHSAD		;SAVE DESTINATION
                	IF	NOT COMPL
 01BB 47        	MOV	B,A		;SAVE TYPE
 01BC AF        	XRA	A
 01BD 325140    	STA	INLHS		;RESET INLHS TO FALSE
 01C0 78        	MOV	A,B		;RESTORE TYPE
                	ENDIF
 01C1 C9        	RET
                
                ;ASIGN IS CALLED BY FOR, NEXT, LET, READ, INPUT TO CHANGE A VARIABLE'S VALUE.
                ;THE VALUE ADDRESSED BY HL IS ASSIGNED TO THE DESTINATION LHSAD.
                ;TRACE INFORMATION IS PRINTED IF (VTRAC) IS NEGATIVE.
 01C2 CDB408    ASIGV:	CALL	ESVAL		;VALUE TO ESTACK
 01C5 2AC441    	LHLD	ESTKP
 01C8 23        	INX	H		;POINT TO VALUE
 01C9 3ABF41    ASIGN:	LDA	LHSTY		;DESIRED TYPE TO A
 01CC CDD90A    	CALL	CNVRT		;CONVERT VALUE TO DESIRED TYPE
                	IF	STRNG
 01CF FE03      	CPI	STRST
 01D1 CC1527    	CZ	SCOPV		;COPY TO STRING SPACE IF TYPE STRING
                	ENDIF
 01D4 CD0902    	CALL	BYTSD		;# BYTES IN VALUE TO DE
 01D7 23        	INX	H		;POINT TO VALUE
 01D8 44        	MOV	B,H
 01D9 4D        	MOV	C,L		;VALUE SOURCE TO BC
 01DA 2AC041    	LHLD	LHSAD		;DESTINATION TO HL
                	IF	COMPL
                	JMP	MOVED		;VALUE TO DESTINATION AND RETURN IF COMPL
                	ELSE
 01DD F5        	PUSH	PSW		;SAVE TYPE
 01DE C5        	PUSH	B		;AND SAVE VALUE LOCATION
 01DF CDB631    	CALL	MOVED		;VALUE TO DESTINATION
 01E2 E1        	POP	H		;VALUE LOCATION TO HL
 01E3 C1        	POP	B		;VALUE TYPE TO B
                				;AND FALL THROUGH TO TRVAL
                ;TRVAL PRINTS VARIABLE VALUE IF TRACING IS DESIRED.
                ;CALL:	VTRAC	BIT 7 SET IFF TRACING DESIRED
                ;	B	VALUE TYPE
                ;	HL	VALUE LOCATION
 01E4 3A5240    TRVAL:	LDA	VTRAC
 01E7 B7        	ORA	A
 01E8 F0        	RP			;DONE IF NOT TRACING
 01E9 3E3D      TRVA1:	MVI	A,'='		;BTEST ENTRY POINT
 01EB CD2D15    	CALL	WRITC		;WRITE THE =
 01EE 2B        	DCX	H		;POINT TO TYPE
 01EF 78        	MOV	A,B		;FETCH TYPE
                	IF	STRNG
 01F0 FE03      	CPI	STRST
 01F2 C2AC23    	JNZ	PRVAL		;PRINT NONSTRING VALUE
 01F5 EB        	XCHG
 01F6 219B40    	LXI	H,STEMP
 01F9 34        	INR	M		;INCREMENT STEMP COUNT BEFORE FETCHING STRING
 01FA EB        	XCHG
                	ENDIF
 01FB C3AC23    	JMP	PRVAL		;PRINT THE VALUE AND RETURN
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                
                ;ASIGI PERFORMS TRACED INTEGER ASSIGNMENT FOR NEXT AND SCALL VALUE RETURN.
 01FE 70        ASIGI:	MOV	M,B
 01FF 2B        	DCX	H
 0200 71        	MOV	M,C		;VALUE TO DESTINATION
                	IF	NOT COMPL
 0201 C5        	PUSH	B
 0202 0601      	MVI	B,INTST
 0204 CDE401    	CALL	TRVAL		;PRINT TRACE INFO IF DESIRED
 0207 C1        	POP	B
                	ENDIF
 0208 C9        	RET
                
                ;BYTSD RETURNS WITH THE NUMBER OF BYTES IN AN VALUE IN DE.
 0209 110400    BYTSD:	LXI	D,VBYTS-1
                	IF	FLOAT
 020C FE02      	CPI	SNGST
 020E C8        	RZ			;RETURN 4 IF FLOATING
                	IF	FPBCD
                	MVI	E,3
                	ELSE
 020F 1B        	DCX	D
                	ENDIF
                	ENDIF
                	IF	STRNG
 0210 FE03      	CPI	STRST
 0212 C8        	RZ			;RETURN 3 IF STRING
                	ENDIF
                	IF	FLOAT OR STRNG
 0213 1B        	DCX	D
                	ENDIF
 0214 C9        	RET			;RETURN 2 IF INTEGER
                
                ;FETCH FETCHES A VALUE ADDRESSED BY HL AND RETURNS ITS TYPE IN THE STATUS BITS.
                ;CALL:	HL	POINTER TO TYPE
                ;RETN:	A	TYPE TOKEN
                ;	BC	VALUE IF INTEGER, CARRY RESET AND ZERO SET
                ;	C,DE	LENGTH, LOCATION IF STRING, CARRY SET AND ZERO SET
                ;	FACC	VALUE IF FLOATING, CARRY RESET AND ZERO RESET
                ;FETBC DOES A FETCH OF ARG IN BC.
 0215 60        FETBC:	MOV	H,B
 0216 69        	MOV	L,C
 0217 7E        FETCH:	MOV	A,M		;FETCH THE TYPE TOKEN
                FETC1:	IF	FLOAT
 0218 FE02      	CPI	SNGST
 021A CA3E02    	JZ	FETCF		;FETCH FLOATING
                	ENDIF
                	IF	STRNG
 021D FE03      	CPI	STRST
 021F CA2F02    	JZ	FETCS		;FETCH STRING
                	ENDIF
 0222 FE01      FETCI:	CPI	INTST
 0224 C29701    	JNZ	EXERR
                	IF	FLOAT
 0227 22B040    	SHLD	ARGAD		;SAVE LOCATION FOR RETRY OF AMBIGUOUS OP
                	ENDIF
 022A 23        MOBCM:	INX	H		;ZERO IS SET, CARRY RESET
 022B 4E        	MOV	C,M
 022C 23        	INX	H
 022D 46        	MOV	B,M		;FETCH INTEGER TO BC
 022E C9        	RET
                	IF	STRNG
 022F 23        FETCS:	INX	H
 0230 4E        	MOV	C,M		;LENGTH TO C
 0231 CD5502    	CALL	MODEM		;LOCATION TO DE
 0234 219B40    	LXI	H,STEMP
 0237 35        	DCR	M		;DECREMENT # STRING TEMPS IN USE
 0238 FA9701    	JM	EXERR		;EX ERROR IF NEGATIVE
 023B AF        	XRA	A		;ZERO IS SET
 023C 37        	STC			;AND CARRY SET ALSO
 023D C9        	RET
                	ENDIF
                	IF	FLOAT
                	IF	F9511		;9511 VERSION FETCHES TO 9511 STACK
                FETCF:	PUSH	H
                	PUSH	B
                	INX	H		;POINT TO FIRST VALUE BYTE
                	CALL	LOD95		;LOAD VALUE TO 9511 STACK
                	POP	B		;RESTORE BC
                	POP	H		;RESTORE HL
                	MVI	A,SNGST		;FLOATING POINT TOKEN TO A
                	ORA	A		;CLEAR CARRY AND ZERO
                	RET			;AND RETURN
                	ELSE			;NOT F9511
                FETCF:	PUSH3			;SAVE REGISTERS
 023E+C5        	PUSH	B
 023F+D5        	PUSH	D
 0240+E5        	PUSH	H
 0241 23        	INX	H		;POINT TO VALUE
 0242 CDEB0D    	CALL	FLOAD		;LOAD VALUE TO FACC
 0245 3E02      	MVI	A,SNGST		;RETURN TYPE IN A
 0247 B7        	ORA	A		;CARRY RESET, ZERO RESET
 0248 C3A108    	JMP	POP3		;RESTORE REGISTERS AND RETURN
                	ENDIF
                	ENDIF
                
                ;MVDEM RETURNS (M):(M-1) IN DE, (HL)-2 IN HL
                ;BC, PSW PRESERVED
 024B 56        MVDEM:	MOV	D,M
 024C 2B        	DCX	H
 024D 5E        	MOV	E,M
 024E 2B        	DCX	H
 024F C9        	RET
                
                ;MVMDE MOVES (DE) TO (M-1):(M-2), RETURNS (HL)-2 IN HL
 0250 2B        MVMDE:	DCX	H
 0251 72        	MOV	M,D
 0252 2B        	DCX	H
 0253 73        	MOV	M,E
 0254 C9        	RET
                
                ;MODEM MOVEDS (M+2):(M+1) TO DE, RETURNS (HL)+2 IN HL.
 0255 23        MODEM:	INX	H
 0256 5E        	MOV	E,M
 0257 23        	INX	H
 0258 56        	MOV	D,M
 0259 C9        	RET
                
                ;ISBYT CHECKS WHETHER (B) = 0.  IF SO, IT RETURNS.
                ;IF NOT, A NONFATAL BY ERROR IS ISSUED AND B IS SET TO 0.
                ;A CLOBBERED, B FORCED TO 0, OTHER REGISTERS PRESERVED.
 025A 78        ISBYT:	MOV	A,B
 025B B7        	ORA	A		;CLEAR CARRY, SET ZERO IFF (B) = 0
 025C C8        	RZ
 025D 0600      	MVI	B,0		;FORCE (B) TO 0
                	ERROR	N, B, Y		;NONFATAL BYTE ERROR
 025F+CDD216    	CALL	ERRON
 0262+42D9      	DB	'B', 'Y' OR 80H
 0264 C9        	RET			;AND RETURN
                
                ;CPLDE REPLACES (DE) WITH ITS TWO'S COMPLEMENT.
                ;CPLD1 REPLACES (DE) WITH ITS ONE'S COMPLEMENT.
                ;RETN:	A	CLOBBERED
                ;	BC,HL	PRESERVED
                ;	DE	TWO'S COMPLEMENTED
                ;	CARRY	SET IFF (DE) = 8000H, I.E. OVERFLOW
 0265 1B        CPLDE:	DCX	D
 0266 7B        CPLD1:	MOV	A,E		;ENTRY POINT TO ONE'S COMPLEMENT DE --
 0267 2F        	CMA			;   NB CARRY SET IF CALLED WITH 7FFFH
 0268 5F        	MOV	E,A
 0269 7A        	MOV	A,D
 026A 2F        	CMA
 026B 57        	MOV	D,A
 026C EE80      	XRI	80H
 026E B3        	ORA	E		;ZERO SET IFF (DE) = 8000H
 026F C0        	RNZ
 0270 3F        	CMC			;SET CARRY IF OVERFLOW
 0271 C9        	RET
                
                ;ADAHL ADDS (A) + (HL), LEAVES RESULT IN HL AND SETS CARRY ON OVERFLOW.
 0272 85        ADAHL:	ADD	L
 0273 6F        	MOV	L,A
 0274 D0        	RNC			;DONE IF NO CARRY
 0275 24        	INR	H		;ELSE INC HIGH ORDER
 0276 C8        	RZ			;RETURN WITH CARRY SET IFF OVERFLOW
 0277 3F        	CMC
 0278 C9        	RET
                
                ;SBAHL SUBTRACTS (HL) - (A), LEAVES RESULT IN HL AND SETS CARRY ON UNDERFLOW.
 0279 95        SBAHL:	SUB	L		;(A) - (L) TO A, CARRY SET IFF L > A
 027A 2F        	CMA			;L - A - 1
 027B 6F        	MOV	L,A
 027C 23        	INX	H		;L - A
 027D D8        	RC
 027E 25        	DCR	H
 027F C9        	RET
                
                ;CMBDU COMPARES (BC) TO (DE) AS 16 BIT UNSIGNED INTEGERS.
                ;RETN:	A	CLOBBERED
                ;	BC,DE,HL	UNCHANGED
                ;	ZERO	SET IFF (BC) = (DE)
                ;	CARRY	SET IFF (BC) < (DE)
 0280 78        CMBDU:	MOV	A,B
 0281 BA        	CMP	D		;CARRY SET IFF (B) < (D)
 0282 C0        	RNZ			;FINISHED UNLESS (B) = (D)
 0283 79        	MOV	A,C		;(B) = (D), SO COMPARE (C) TO (E)
 0284 BB        	CMP	E
 0285 C9        	RET
                
                ;CMDHU SAME AS CMBDU EXCEPT DE::HL
 0286 7A        CMDHU:	MOV	A,D
 0287 BC        	CMP	H
 0288 C0        	RNZ
 0289 7B        	MOV	A,E
 028A BD        	CMP	L
 028B C9        	RET
                
                ;CMBDS COMPARES (BC) TO (DE) AS 16 BIT SIGNED (TWO'S COMPLEMENT) INTEGERS.
                ;RETN:	SAME AS CMBDU ABOVE.
 028C 78        CMBDS:	MOV	A,B
 028D AA        	XRA	D		;SIGN SET IFF SIGNS AGREE
 028E F28002    	JP	CMBDU		;UNSIGNED COMPARE WORKS WHEN SIGNS AGREE
 0291 78        	MOV	A,B		;SIGNS DISAGREE, SIGN OF B GIVES RESULT
 0292 17        	RAL			;NB ZERO IS RESET FROM XRA ABOVE
 0293 C9        	RET
                
                ;FLIP IS CALLED BY READ AND INPUT TO EXCHANGE TEXT POINTERS IN TEXTP AND TXTP2.
                ;CLOBBERS DE, PRESERVES PSW, LEAVES TEXTP IN HL.
 0294 2ABB41    FLIP:	LHLD	TXTP2
 0297 EB        	XCHG			;TXTP2 TO DE
 0298 2A8242    	LHLD	TEXTP
 029B 22BB41    	SHLD	TXTP2		;TEXTP TO TXTP2
 029E EB        	XCHG
 029F 228242    	SHLD	TEXTP		;TXTP2 TO TEXTP
 02A2 C9        	RET
                
                ;DMODX IS A COMMON EXIT FOR VARIOUS VERSIONS OF LOAD AND EXEC.
                ;FIRST THE CONTROL AND EXPR STACKS ARE RESET.  THEN EXECUTION CONTINUES
                ;IF THE COMMAND WAS DIRECT, AND XYBASIC RETURNS TO DMODE IF INDIRECT
                ;(SINCE THE SOURCE PROGRAM HAS BEEN CHANGED BY THE EXEC OR LOAD).
                ;CALL:	HL	EOF ADDRESS OF NEW PROGRAM
                	IF	NOT COMPL
 02A3 CD3822    DMODX:	CALL	NEW1		;RESET STACKS
 02A6 CD6301    	CALL	LINBC		;ZERO SET IFF DIRECT
 02A9 C8        	RZ			;CONTINUE NORMALLY IF DIRECT
 02AA C34B06    	JMP	DMOD2		;OTHERWISE TO DMODE
                	ENDIF
                
                ;BDTST IS CALLED FROM FOR AND NEXT TO TEST FOR-LOOP TERMINATION.
                ;CALL:	BC OR FACC	NEW FOR-VARIABLE VALUE (INTEGER OR FLOATING)
                ;	DE	INCREMENT POINTER
                ;	HL	BOUND POINTER
                ;	LHSTY	FOR-VARIABLE TYPE
                ;RETN:	CARRY	SET IFF EXIT CONDITION SATISFIED, I.E. VALUE>BOUND AND INR>=0
                ;			OR VALUE<BOUND AND INR<0
 02AD 13        BDTST:	INX	D		;POINT TO SECOND INCR BYTE
                	IF	FLOAT
 02AE 3ABF41    	LDA	LHSTY
 02B1 FE02      	CPI	SNGST
 02B3 C2C102    	JNZ	BDTS1		;INTEGER TYPE
 02B6 D5        	PUSH	D
                	IF	F9511
                	CALL	LOD95		;LOAD BOUND TO 9511 STACK
                	CALL	CMPF0		;PERFORM FLOATING COMPARE, NO ARG SWITCH
                	ELSE
 02B7 CD2312    	CALL	CMPFL		;DO FLOATING COMPARE
                	ENDIF
 02BA D1        	POP	D
 02BB C8        	RZ			;VALUE=BOUND, RETURN CARRY RESET
                	IF	F9511 OR FPBCD
                	DCX	D		;FIRST BYTE HAS SIGN OF 9511, BCD
                	ENDIF
 02BC 1A        	LDAX	D
 02BD 07        	RLC			;INCR SIGN TO CARRY
 02BE F8        	RM			;VALUE<BOUND, RETURN INCR SIGN AS RESULT
 02BF 3F        	CMC			;VALUE>BOUND, RETURN COMPLEMENTED INCR SIGN
 02C0 C9        	RET
                	ENDIF
 02C1 1A        BDTS1:	LDAX	D
 02C2 5E        	MOV	E,M
 02C3 23        	INX	H
 02C4 56        	MOV	D,M		;INTEGER BOUND TO DE
 02C5 07        	RLC
 02C6 D43113    	CNC	BCDE		;EXCHANGE VALUE AND BOUND IF INCR>=0
 02C9 C38C02    	JMP	CMBDS		;AND CMBDS RETURNS DESIRED CARRY STATUS
                
                ;FNDST IS CALLED FROM FOR AND READ TO SCAN THROUGH A PROGRAM FOR
                ;THE MATCHING NEXT OR NEXT DATA STATEMENT.
                ;CALL:	(TEXTP)	TEXT ADDRESS AT WHICH SCANNING IS TO BEGIN
                ;	B	TOKEN TO BE MATCHED (NEXT OR DATA)
                ;		(1) FOUND				(2) NOTFOUND
                ;RETN:	A	TOKEN					0
                ;	B	PRESERVED				PRESERVED
                ;	C,DE	CLOBBERED				CLOBBERED
                ;	HL	ADDRESS OF NEXT UNPARSED TEXT CHAR	EOF ADDRESS
                ;	CARRY	RESET					SET
                ;	(TEXTP)	DITTO					EOF ADDRESS - 1
 02CC CD9C01    FNDS0:	CALL	DTST0		;CHECK IF AT DELIMITER
 02CF 3F        	CMC
 02D0 D0        	RNC			;RETURN CARRY RESET IF NOT
                				;ELSE EMPTY DATA, FALL THROUGH TO RETRY
 02D1 0E01      FNDST:	MVI	C,1		;INITIALIZE FOR COUNT
 02D3 110400    	LXI	D,4		;TO SKIP BYTES AFTER <CR>
 02D6 CD3B17    FNDS1:	CALL	GTCHA		;GET NEXT CHAR
 02D9 B8        	CMP	B
 02DA CA0503    	JZ	FNDS3		;FOUND ONE
 02DD FE3A      	CPI	':'
 02DF CAD602    	JZ	FNDS1		;MULTIPLE STATEMENTS -- LOOK AT NEXT
                	IF	RTPAK OR NOT COMPL	;COMMENTS PURGED IF COMPILED
 02E2 FE27      	CPI	''''
 02E4 CCA824    	CZ	REM		;ON-LINE COMMENT -- SCAN TO <CR>
                	ENDIF
 02E7 FE0D      	CPI	CR
 02E9 CAF902    	JZ	FNDS2		;CR
 02EC FE91      	CPI	FORT
 02EE CCF702    	CZ	INRC		;INCREMENT FOR-COUNT IF FOR
 02F1 CD9817    	CALL	GTDEL		;SCAN TO DELIMITER
 02F4 C3D602    	JMP	FNDS1		;KEEP TRYING
 02F7 0C        INRC:	INR	C
 02F8 C9        	RET
 02F9 7E        FNDS2:	MOV	A,M		;FETCH NEXT LINE LENGTH BYTE
 02FA B7        	ORA	A		;CHECK FOR END OF FILE
 02FB CA7417    	JZ	BKUPC		;RETURN CARRY SET IF FAILED
 02FE 19        	DAD	D		;POINT TO NEXT TEXT BYTE
 02FF 228242    	SHLD	TEXTP		;STORE NEW POINTER
 0302 C3D602    	JMP	FNDS1		;AND KEEP LOOKING
 0305 FE9B      FNDS3:	CPI	DATAT
 0307 CACC02    	JZ	FNDS0		;DONE IF DATA
 030A CD0E19    FNDS4:	CALL	GTNAM		;LOOK FOR VAR NAME AFTER NEXT
 030D 0D        	DCR	C		;DECREMENT COUNT
 030E D21603    	JNC	FNDS5
 0311 3F        	CMC			;CLEAR CARRY IN CASE FOUND
 0312 C8        	RZ			;DONE IF NEXT AND FOR COUNT IS 0
 0313 C3D602    	JMP	FNDS1		;AND KEEP LOOKING
 0316 C8        FNDS5:	RZ			;RETURN IF COUNTED TO 0
 0317 CD5D17    	CALL	GTCOM		;LOOK FOR COMMA AFTER <VAR NAME>
 031A DAD602    	JC	FNDS1		;NONE
 031D C30A03    	JMP	FNDS4		;ELSE LOOK FOR MORE
                
                ;FNDLN FINDS THE LINE # ADDRESS OF THE LINE WHICH DE POINTS INTO.
                ;USED BY READ FOR DATA SYNTAX ERRORS.
                ;CALL:	DE	POINTER INTO TEXT
                ;RETN:	BC,DE	PRESERVED
                ;	HL	LINE # ADDRESS OF DESIRED TEXT LINE
                FNDLN:	IF	NOT ROMSQ
 0320 218B42    	LXI	H,SRCAD
                	ELSE
                	LHLD	SOURC
                	ENDIF
 0323 22B941    FNLN1:	SHLD	TEMP		;SAVE LENGTH BYTE ADDRESS
 0326 7E        	MOV	A,M		;FETCH LENGTH
 0327 CD7202    	CALL	ADAHL		;ADDRESS NEXT LINE
 032A CD8602    	CALL	CMDHU		;COMPARE TO DESIRED POINTER
 032D D22303    	JNC	FNLN1		;KEEP LOOKING
 0330 2AB941    	LHLD	TEMP		;RESTORE LENGTH BYTE ADDR
 0333 23        	INX	H		;POINT TO LINE #
 0334 C9        	RET
                
                	IF	REALT
                ;CLOCK IS THE INTERRUPT SERVICE ROUTINE TO TICK THE REAL-TIME CLOCK.
                ;THE INTERRUPT BRANCHES TO 10H, POKED DURING INITIALIZATION TO COME HERE.
                ;THE FOUR BYTES AT TIMEX CONTAIN 20THS-20, SECONDS-60, MINUTES-60 AND HOURS-24.
                CLOCK:	PUSH	PSW
                	PUSH	H
                	LXI	H,TIMEX		;ADDRESS 20THS COUNTER
                	INR	M		;TICK IT
                	JNZ	CLOCX		;DONE
                	MVI	M,255 AND -20	;RESET TO -20
                	INX	H		;ADDRESS SECONDS COUNTER
                	INR	M		;TICK IT
                	JNZ	CLOCX		;DONE
                	MVI	M,255 AND -60	;RESET TO -60
                	INX	H		;ADDRESS MINUTES COUNTER
                	INR	M		;TICK...
                	JNZ	CLOCX		;DONE
                	MVI	M,255 AND -60	;RESET
                	INX	H		;ADDRESS HOURS COUNTER
                	INR	M		;TICK...
                	JNZ	CLOCX		;DONE
                	MVI	M,255 AND -24	;WELCOME TO TOMORROW
                CLOCX:	POP	H
                	MVI	A,20H
                	OUT	0D8H		;REINITIALIZE THE CLOCK
                	POP	PSW
                	EI			;REENABLE INTERRUPTS
                	RET
                	ENDIF
                
                	IF	EDITC AND (NOT COMPL)
                ;LNREF CHANGES ALL OCCURRENCES OF <LINE #>S IN SOURCE TEXT FOR RENUM.
 0335 218B42    LNREF:	LXI	H,SRCAD		;BEGIN AT THE BEGINNING
                ;PROCESS NEXT LINE OF SOURCE TEXT
 0338 7E        LNRE1:	MOV	A,M		;FETCH LENGTH BYTE
 0339 B7        	ORA	A
 033A C8        	RZ			;EOF, DONE
 033B E5        	PUSH	H
 033C 23        	INX	H
 033D 23        	INX	H
 033E 23        	INX	H
 033F 23        	INX	H		;ADDRESS FIRST TEXT BYTE
                ;PROCESS NEXT BYTE OF SOURCE TEXT
 0340 7E        LNRE2:	MOV	A,M		;FETCH A TEXT BYTE
 0341 23        	INX	H
 0342 FE0D      	CPI	CR		;CHECK IF END OF LINE
 0344 CA5104    	JZ	LNRE5		;YES
 0347 FE27      	CPI	''''
 0349 CA4A04    	JZ	LNRE4		;ON-LINE COMMENT, SCAN TO <CR>
 034C FEAE      	CPI	REMT
 034E CA4A04    	JZ	LNRE4		;REM, SCAN TO <CR>
                	IF	KEY80
 0351 FE20      	CPI	20H
 0353 DA5B03    	JC	LNRE3		;RESERVED WORD TOKEN, CHECK IT
                	ENDIF
 0356 FE80      	CPI	80H
 0358 DA4003    	JC	LNRE2		;NOT A TOKEN, TRY NEXT
                ;FOUND A <TOKEN>, CHECK IF <LINE #> CAN AND DOES FOLLOW
 035B CD5904    LNRE3:	CALL	KLTST		;TEST IF TOKEN CAN HAVE <LINE #> FOLLOWING
 035E DA4003    	JC	LNRE2		;NO, TRY NEXT
 0361 32BB41    	STA	TXTP2		;SAVE TOKEN IN TXTP2 IN CASE ON LIST OR LIST
 0364 228242    	SHLD	TEXTP		;SET TEXTP TO SCAN POSSIBLE <LINE #>
 0367 CD4917    LNR3J:	CALL	GTCHO		;SKIP SPACES, IF ANY
 036A E5        	PUSH	H		;SAVE HL POINTING TO FIRST NONSPACE
 036B CD2E18    	CALL	GTLNO		;LOOK FOR <LINE #>
 036E E3        	XTHL			;RESTORE HL
 036F C1        	POP	B		;FIRST NONDIGIT LOCATION TO BC
 0370 DA4003    	JC	LNRE2		;NOT A <LINE #>, TRY NEXT BYTE
                ;FOUND A <LINE #>
 0373 E5        	PUSH	H		;SAVE FIRST FOR INSERTION OF NEW LINE #
 0374 EB        	XCHG
 0375 CD6502    	CALL	CPLDE		;- FIRST
 0378 EB        	XCHG
 0379 09        	DAD	B		;LAST + 1 - FIRST = <LINE #> LENGTH TO HL
 037A E5        	PUSH	H		;SAVE LENGTH
 037B CDC131    	CALL	FINDL		;LOOK FOR <LINE #>
 037E DAC203    	JC	LNR3C		;NOT FOUND, FLAG THE LINE
 0381 E5        	PUSH	H		;SAVE LOCATION
 0382 2AAE40    	LHLD	RNOLD
 0385 EB        	XCHG
 0386 CDC131    	CALL	FINDL		;FIND LOCATION OF FIRST RENUMBERED LINE
 0389 D1        	POP	D		;LOCATION OF DESIRED LINE TO DE
 038A CD8602    	CALL	CMDHU
 038D DACE03    	JC	LNR3D		;BEFORE RENUMBERED LINES, UNCHANGED
 0390 E5        	PUSH	H		;SAVE FIRST LOC
 0391 2AAC40    	LHLD	RNINC
 0394 44        	MOV	B,H
 0395 4D        	MOV	C,L		;INCREMENT TO BC
 0396 2AAA40    	LHLD	RNNEW		;FIRST DESTINATION LINE # TO HL
 0399 CAA903    	JZ	LNR3B		;MATCHED, TAKE FIRST LINE #
                ;COMPUTE NEW <LINE #> CORRESPONDING TO OLD <LINE #>
 039C E3        LNR3A:	XTHL			;FIRST LINE LOC TO HL
 039D 7E        	MOV	A,M
 039E CD7202    	CALL	ADAHL		;ADDRESS NEXT LINE
 03A1 CD8602    	CALL	CMDHU		;COMPARE TO DESIRED LINE #
 03A4 E3        	XTHL
 03A5 09        	DAD	B		;COMPUTE NEW LINE #
 03A6 C29C03    	JNZ	LNR3A		;NO MATCH, TRY NEXT
                ;CONVERT NEW <LINE #> TO STRING AND COMPARE TO LENGTH OF OLD
 03A9 D1        LNR3B:	POP	D		;DISCARD SAVED LOCATION
 03AA 44        	MOV	B,H
 03AB 4D        	MOV	C,L		;NEW LINE # TO BC
 03AC AF        	XRA	A
 03AD CD2816    	CALL	CVTIS		;AND CONVERTED TO STRING, NO LEADING CHAR
 03B0 CD3113    	CALL	BCDE		;LOCATION TO BC, LENGTH TO E
 03B3 E1        	POP	H		;LENGTH OF OLD LINE # TO L
 03B4 95        	SUB	L		;NEW LENGTH - OLD LENGTH
 03B5 E1        	POP	H		;OLD LINE # LOC TO HL
 03B6 FAD303    	JM	LNR3E		;OLD LINE # LONGER
 03B9 C20004    	JNZ	LNR3F		;OLD LINE # SHORTER
 03BC CDB431    	CALL	MOVD0		;MOVE NEW LINE # TO REPLACE OLD
 03BF C32C04    	JMP	LNR3H		;AND KEEP SCANNING
                ;OLD <LINE #> NOT FOUND, FLAG BIT 7 OF LINE BREAK BYTE
 03C2 E1        LNR3C:	POP	H		;DISCARD SAVED LENGTH
 03C3 E1        	POP	H		;AND DISCARD SAVED FIRST LOC
 03C4 E1        	POP	H		;LENGTH BYTE ADDR TO HL
 03C5 E5        	PUSH	H		;AND RESAVED
 03C6 23        	INX	H
 03C7 23        	INX	H
 03C8 23        	INX	H		;ADDRESS BREAK BYTE
 03C9 3680      	MVI	M,80H		;SET BIT 7 TO INDICATE LINE # NOT FOUND
 03CB C32C04    	JMP	LNR3H		;AND KEEP SCANNING
                ;OLD <LINE #> PRECEDES RENUMBERED LINES, LEAVE UNCHANGED
 03CE E1        LNR3D:	POP	H		;DISCARD SAVED LENGTH
 03CF E1        	POP	H		;AND DISCARD SAVED FIRST LOC
 03D0 C32C04    	JMP	LNR3H		;AND KEEP SCANNING
                ;OLD <LINE #> LONGER THAN NEW <LINE #>
 03D3 F5        LNR3E:	PUSH	PSW		;SAVE OFFSET
 03D4 CDB431    	CALL	MOVD0		;COPY NEW LINE # TO OLD PLACE
 03D7 228242    	SHLD	TEXTP		;AND SET NEW TEXTP
 03DA EB        	XCHG			;NEW DESTINATION TO DE
 03DB F1        	POP	PSW		;RESTORE OFFSET
 03DC E1        	POP	H		;LINE LENGTH POINTER TO HL
 03DD F5        	PUSH	PSW
 03DE 86        	ADD	M		;ADD OFFSET
 03DF 77        	MOV	M,A		;AND STORE NEW LINE LENGTH
 03E0 F1        	POP	PSW
 03E1 E5        	PUSH	H		;RESAVE LINE LENGTH POINTER
 03E2 2F        	CMA
 03E3 3C        	INR	A		;COMPLEMENT OFFSET
 03E4 EB        	XCHG			;RESTORE DESTINATION TO HL
 03E5 E5        	PUSH	H		;SAVE DESTINATION
 03E6 CD7202    	CALL	ADAHL		;+OFFSET = SOURCE
 03E9 E5        	PUSH	H
 03EA EB        	XCHG
 03EB CD6502    	CALL	CPLDE		;-SOURCE
 03EE 2A8642    	LHLD	EOFAD
 03F1 23        	INX	H
 03F2 19        	DAD	D		;COUNT BYTES TO MOVE
 03F3 EB        	XCHG			;TO DE
 03F4 C1        	POP	B
 03F5 E1        	POP	H
 03F6 CDB631    	CALL	MOVED		;BLOCK MOVE THE REMAINING TEXT
 03F9 2B        	DCX	H
 03FA 228642    	SHLD	EOFAD		;STORE NEW EOF
 03FD C32C04    	JMP	LNR3H		;AND KEEP SCANNING
                ;OLD <LINE #> SHORTER THAN NEW
 0400 F5        LNR3F:	PUSH	PSW
 0401 C5        	PUSH	B
 0402 D5        	PUSH	D
 0403 E5        	PUSH	H		;SAVE ALL
 0404 EB        	XCHG			;FIRST OLD LINE # BYTE ADDR TO DE
 0405 2A8642    	LHLD	EOFAD
 0408 44        	MOV	B,H
 0409 4D        	MOV	C,L		;END OF FILE TO BC
 040A CD7202    	CALL	ADAHL		;OFFSET + EOF = NEW EOF
 040D 228642    	SHLD	EOFAD		;STORE NEW EOF
 0410 0A        LNR3G:	LDAX	B		;FETCH A TEXT BYTE
 0411 77        	MOV	M,A		;AND STORE IN NEW LOCATION
 0412 0B        	DCX	B
 0413 2B        	DCX	H
 0414 7B        	MOV	A,E
 0415 B9        	CMP	C
 0416 C21004    	JNZ	LNR3G
 0419 7A        	MOV	A,D
 041A B8        	CMP	B
 041B C21004    	JNZ	LNR3G		;COPY MORE TEXT BYTES
 041E E1        	POP	H
 041F D1        	POP	D
 0420 C1        	POP	B		;RESTORE NEW LINE # INFO
 0421 CDB431    	CALL	MOVD0		;AND COPY LINE # INTO TEXT
 0424 228242    	SHLD	TEXTP
 0427 F1        	POP	PSW		;OFFSET
 0428 E1        	POP	H		;LINE LENGTH ADDR
 0429 86        	ADD	M		;OLD LENGTH + OFFSET
 042A 77        	MOV	M,A		;GIVES NEW LENGTH
 042B E5        	PUSH	H
 042C 3ABB41    LNR3H:	LDA	TXTP2		;RECOVER TOKEN PRECEDING <LINE #>
 042F 2A8242    	LHLD	TEXTP
 0432 FE93      	CPI	GOTOT
 0434 CA4104    	JZ	LNR3I		;GOTO
 0437 FE94      	CPI	GSUBT
 0439 CA4104    	JZ	LNR3I		;GOSUB
 043C FEB2      	CPI	LISTT
 043E C24003    	JNZ	LNRE2		;NOT GOTO, GOSUB NOR LIST, KEEP SCANNING
 0441 CD5D17    LNR3I:	CALL	GTCOM		;LOOK FOR COMMA
 0444 DA4003    	JC	LNRE2		;NONE, KEEP SCANNING
 0447 C36703    	JMP	LNR3J		;LOOK FOR NEXT ELEMENT IN <LINE #> LIST
                ;SCAN TO NEXT <CR>
 044A 7E        LNRE4:	MOV	A,M
 044B 23        	INX	H
 044C FE0D      	CPI	CR
 044E C24A04    	JNZ	LNRE4
                ;END OF SOURCE TEXT LINE, TRY THE NEXT
 0451 E1        LNRE5:	POP	H		;LENGTH BYTE ADDR TO HL
 0452 7E        	MOV	A,M
 0453 CD7202    	CALL	ADAHL		;ADDRESS NEXT LINE
 0456 C33803    	JMP	LNRE1		;AND TRY NEXT LINE
                
                ;KLTST TESTS IF TOKEN IN A MAY HAVE <LINE #> FOLLOWING.
                ;CALL:	A	TOKEN
                ;RETN:	C	CLOBBERED
                ;	A,B,DE,HL	PRESERVED
                ;	CARRY	SET IFF NOT FOUND
 0459 E5        KLTST:	PUSH	H
 045A 0E0A      	MVI	C,KLNCT		;TABLE COUNT TO C
 045C 21DB2D    	LXI	H,KLNTA		;TABLE ADDR TO HL
 045F BE        KLTS1:	CMP	M		;COMPARE TOKEN TO TABLE ENTRY
 0460 CA6904    	JZ	KLTS2		;MATCHED
 0463 23        	INX	H
 0464 0D        	DCR	C
 0465 C25F04    	JNZ	KLTS1		;TRY NEXT
 0468 37        	STC			;NOT FOUND
 0469 E1        KLTS2:	POP	H		;RESTORE HL
 046A C9        	RET			;AND RETURN
                	ENDIF			;END OF EDITC CONDITIONAL
                
                	IF	NOT COMPL
                ;BKNAM CONSTRUCTS A 3-BYTE SYMBOL TABLE 'NAME' AT BUFAD FOR A LINE BREAK.
                ;BYTE 1 IS H6-H0, BYTE 2 IS L6-L0, BOTH WITH BIT 7 RESET.
                ;BYTE 3 HAS 1,H7,L7 IN BITS 7-5 AND BITS 4-0 RESET.
                ;CALL:	HL	DESIRED BREAK ENTRY 'NAME' (I.E. LINE # ADDR)
 046B EB        BKNAM:	XCHG			;DESIRED LINE # ADDR TO DE
 046C 21C841    	LXI	H,BUFAD
 046F 7A        	MOV	A,D
 0470 E67F      	ANI	7FH
 0472 77        	MOV	M,A		;BYTE 1 = D6-D0 TO BUFAD
 0473 23        	INX	H
 0474 7B        	MOV	A,E
 0475 E67F      	ANI	7FH
 0477 77        	MOV	M,A		;BYTE 2 = E6-E0 TO BUFAD+1
 0478 23        	INX	H
 0479 7A        	MOV	A,D
 047A 17        	RAL			;D7 TO CARRY
 047B 7B        	MOV	A,E
 047C 1F        	RAR			;D7, E7 TO A7, A6
 047D 37        	STC
 047E 1F        	RAR			;1, D7, E7 TO A7-5
 047F E6E0      	ANI	0E0H		;MASK OFF A4-0
 0481 77        	MOV	M,A		;BYTE 3 TO BUFAD+2
 0482 C9        	RET
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                
                ;GTPAR GETS A PARAMETER FROM CALL COMMAND LINE.
                ;PARAMETERS MUST BE <VAR REF> OR *<ARRAY VAR NAME>.
                ;RETN:	A	0 IF NO MORE PARAMS, 1 IF INTEGER, 2 IF STRING, 3 IF FLOATING
                ;	B	BYTES PER ENTRY
                ;	C	# DIMS
                ;	DE	ADDRESS OF FIRST DIMENSION
                ;	HL	ADDRESS OF FIRST DATA ITEM
 0483 CD6617    GTPAR:	CALL	GTCND		;LOOK FOR COMMA NOT FOLLOWED BY DELIMITER
 0486 3E00      	MVI	A,0
 0488 D8        	RC			;NO MORE PARAMETERS, RETURN 0
 0489 16C4      	MVI	D,MULTT
 048B CD6F17    	CALL	GTD		;LOOK FOR *
 048E D2A004    	JNC	GTPA1		;ARRAY PASSED
 0491 CD8419    	CALL	GTVAR		;ELSE VAR REF
 0494 010000    	LXI	B,0		;# DIMS = 0 TO C
 0497 C5        	PUSH	B		;PUSH 0 FOR DE
 0498 D2AE04    	JNC	GTPA2		;AND CONTINUE BELOW
                MCERR:	ERROR	F, M, C		;FATAL MC ERROR
 049B+CDC616    	CALL	ERROF
 049E+4DC3      	DB	'M', 'C' OR 80H
 04A0 CD6719    GTPA1:	CALL	FDVAR		;LOOK FOR VAR NAME
 04A3 DA9B04    	JC	MCERR
 04A6 1A        	LDAX	D		;FETCH TYPE
 04A7 4E        	MOV	C,M		;# DIMS TO C
 04A8 0600      	MVI	B,0		;TO ALLOW DAD
 04AA 23        	INX	H		;POINT TO FIRST DIM BYTE
 04AB E5        	PUSH	H		;AND SAVE
 04AC 09        	DAD	B
 04AD 09        	DAD	B		;POINT TO FIRST DATA BYTE
 04AE CD0902    GTPA2:	CALL	BYTSD		;BYTES PER ENTRY TO DE
 04B1 43        	MOV	B,E		;AND THEN TO B
 04B2 D1        	POP	D		;DIM ADDR TO DE
 04B3 78        	MOV	A,B
 04B4 3D        	DCR	A		;A GETS 1 FOR INT, 2 STRING, 3 FLOATING
 04B5 C9        	RET
                
                ;DISAB DISABLES ALL INTERRUPTS
                	IF	NOT WILD
 04B6 AF        DISAB:	XRA	A
 04B7 325540    	STA	INTTC		;RESET INTERRUPT TABLE COUNT
 04BA 325640    	STA	INTAD		;CLEAR INTERRUPT TABLE
 04BD C9        	RET
                
                ;<BYTE EXPR> , <BYTE EXPR> [, <BYTE EXPR>] [,$]
                ;IINFO GETS INTERRUPT INFORMATION FOR ENABLE AND WAIT.
                ;FOUR BYTES CORRESPONDING TO THE FIRST FOUR BYTES OF AN INTERRUPT TABLE
                ;ENTRY ARE RETURNED IN BCDE (TYPE, PORT, MASK, VALUE).
 04BE CDAA0B    IINFO:	CALL	GTBEX
 04C1 41        	MOV	B,C		;PORT # TO  B
 04C2 0EC0      	MVI	C,0C0H		;TYPE TO C
 04C4 C5        	PUSH	B		;AND SAVED
 04C5 CDA40B    	CALL	GTCBE
 04C8 51        	MOV	D,C		;VALUE TO D
 04C9 1E00      	MVI	E,0		;MASK 0 FOR NOW
 04CB CD5D17    	CALL	GTCOM
 04CE DAF604    	JC	IINF3		;DEFAULT MASK 0, NULL $
 04D1 CD4917    	CALL	GTCHO
 04D4 FE24      	CPI	'$'
 04D6 CAE304    	JZ	IINF1		;DEFAULT MASK 0, $
 04D9 CDAA0B    	CALL	GTBEX
 04DC 59        	MOV	E,C		;MASK TO E
 04DD CD5D17    	CALL	GTCOM
 04E0 DAF304    	JC	IINF2		;NULL $
 04E3 CD3B17    IINF1:	CALL	GTCHA
 04E6 FE24      	CPI	'$'
 04E8 C29201    	JNZ	SNERR
 04EB 7A        	MOV	A,D
 04EC 2F        	CMA
 04ED B3        	ORA	E
 04EE 57        	MOV	D,A		;VALUE = NOT VALUE OR MASK (IF $)
 04EF C1        	POP	B
 04F0 0EE0      	MVI	C,0E0H		;SET TYPE $ BIT
 04F2 C9        	RET
 04F3 7A        IINF2:	MOV	A,D
 04F4 B3        	ORA	E
 04F5 57        	MOV	D,A		;VALUE = VALUE OR MASK (IF NULL $)
 04F6 C1        IINF3:	POP	B
 04F7 C9        	RET
                	ENDIF			;END OF NOT WILD CONDITIONAL
                
                
                ;END OF AUX
                	PAGE
                
                ;NONST 08/06/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;ROUTINES FOR NONSTANDARD VERSION SAVE AND LOAD, PLUS GTFIL
                ;INCLUDES CUSTOM EPSTN AND GENMC VERSIONS
                
                
                	IF	NONST		;NONST VERSIONS
                
                	IF	(NOT CAMAC) OR (NOT RTPAK)	;NOT FOR CAMAC RTPAK VERSION
                ;DOIO IS COMMON ROUTINE TO PERFORM I/O OPERATIONS IN NONSTANDARD VERSION.
                ;CALL:	A	OFFSET OF DESIRED JMP FROM BEGINNING OF JUMP VECTOR
                ;	E	SHIFT COUNT FOR FINDING DESIRED IOBYTE FIELD
 04F8 AF        CONIN:	XRA	A
 04F9 D5        CONI1:	PUSH	D		;SAVE DE
 04FA 1E01      	MVI	E,1
 04FC E5        DOIO:	PUSH	H		;SAVE HL
 04FD 211801    	LXI	H,JMPTA		;JMP VECTOR BASE ADDRESS TO HL
 0500 CD7202    	CALL	ADAHL		;+OFFSET = JMP ADDRESS FOR DEVICE #0
 0503 3A0040    	LDA	IOBYT		;I/O BYTE TO A
 0506 1D        DOIO1:	DCR	E
 0507 CA0E05    	JZ	DOIO2		;SHIFT NO MORE
 050A 1F        	RAR
 050B C30605    	JMP	DOIO1
 050E E603      DOIO2:	ANI	3		;MASK TO DESIRED FIELD ONLY
 0510 5F        	MOV	E,A		;SAVE IN E
 0511 17        	RAL			;DESIRED DEVICE # * 2
 0512 83        	ADD	E		;DESIRED DEVICE # * 3
 0513 CD7202    	CALL	ADAHL		; + BASE = JMP ADDRESS FOR SELECTED DEVICE
 0516 D1        	POP	D		;SAVED HL TO DE
 0517 E3        	XTHL			;SAVED DE TO HL, DEVICE JMP ADDRESS TO STACK
 0518 EB        	XCHG			;RESTORE DE AND HL
 0519 C9        	RET			;BRANCH TO DESIRED DEVICE DRIVER
 051A 3E0C      CNOUT:	MVI	A,12
 051C C3F904    	JMP	CONI1
 051F 3E18      RDRIN:	MVI	A,24
 0521 D5        	PUSH	D
 0522 1E03      	MVI	E,3
 0524 C3FC04    	JMP	DOIO
 0527 3E24      POUT:	MVI	A,36
 0529 D5        	PUSH	D
 052A 1E05      	MVI	E,5
 052C C3FC04    	JMP	DOIO
 052F 3E30      LOUT:	MVI	A,48
 0531 D5        	PUSH	D
 0532 1E07      	MVI	E,7
 0534 C3FC04    	JMP	DOIO
                	ENDIF			;END OF NOT CAMAC OR NOT RTPAK CONDITIONAL
                
                	IF	COMPL
                SAVE	EQU	UFERR		;UF ERROR IN COMPL VERSION
                LOAD	EQU	UFERR
                	ELSE
                
                	IF	(NOT EPSTN) AND (NOT GENMC) AND (NOT BENDX)
                ;NORMAL NONST SAVE AND LOAD
                ;SAVE <FILENAME>
 0537 CDC116    SAVE:	CALL	PRNTM		;PRINT SAVING MESSAGE
 053A 534156494E	DB	'SAVING', ' ' OR 80H
 0541 CD1806    	CALL	GTFIL		;GET FILE NAME
                	IF	PACKI
                	MVI	C,CNTLR
                	CALL	POUT		;TAPEON
                	CALL	SAVE7		;PUNCH LEADING NULLS
                	ENDIF
                	IF	NOT ROMSQ
 0544 118942    	LXI	D,SRCAD-2
 0547 CD6502    	CALL	CPLDE
 054A 2A8642    	LHLD	EOFAD
                	ELSE
                	LHLD	SOURC
                	DCX	H		;FIRST TO HL
                	PUSH	H
                	PUSH	H		;AND SAVED
                	CALL	LAST		;LAST TO HL
                	POP	D		;FIRST TO DE
                	CALL	CPLDE		;-FIRST TO DE
                	INX	D		;-FIRST + 1
                	ENDIF
 054D 19        	DAD	D		;LAST - FIRST + 1 = LENGTH
 054E E5        	PUSH	H		;AND SAVED
 054F 213C40    	LXI	H,HEADR
 0552 1E0D      	MVI	E,HEADL		;HEADER LENGTH TO E
 0554 4E        SAVE1:	MOV	C,M		;HEADER CHAR TO C
 0555 CD2705    	CALL	POUT		;AND OUT TO PUNCH DEVICE
 0558 23        	INX	H
 0559 1D        	DCR	E
 055A C25405    	JNZ	SAVE1		;KEEP SENDING HEADER CHARS
 055D D1        	POP	D		;FILE LENGTH TO DE
                	IF	ROMSQ
                	POP	H
                	ELSE
 055E 218A42    	LXI	H,SRCAD-1	;SAVE POINTER TO HL
                	ENDIF
 0561 13        SAVE2:	INX	D
 0562 D5        	PUSH	D		;SAVE LENGTH+1
 0563 7A        	MOV	A,D
 0564 B7        	ORA	A		;ZERO SET IFF LENGTH < 255
 0565 CA6A05    	JZ	SAVE3
 0568 1E00      	MVI	E,0
 056A 1D        SAVE3:	DCR	E		;LENGTH OF BLOCK TO E
 056B 0E3A      	MVI	C,STBYT
 056D CD2705    	CALL	POUT		;SEND START  BYTE
 0570 0E00      	MVI	C,TYBYT
 0572 CD2705    	CALL	POUT		;SEND TYPE BYTE
 0575 4B        	MOV	C,E
 0576 CD2705    	CALL	POUT		;SEND LENGTH BYTE
 0579 7B        	MOV	A,E
 057A B7        	ORA	A		;CHECK IF LENGTH = 0
 057B CA9305    	JZ	SAVE5		;YES, DONE
 057E CDBF15    	CALL	CTEST		;CHECK FOR CONSOLE BREAK CHAR
 0581 1600      	MVI	D,0		;CHECKSUM IN D
 0583 4E        SAVE4:	MOV	C,M
 0584 CD2705    	CALL	POUT		;SEND SOURCE CHAR
 0587 7E        	MOV	A,M
 0588 82        	ADD	D
 0589 57        	MOV	D,A		;UPDATE CHECKSUM
 058A 23        	INX	H
 058B 1D        	DCR	E
 058C C28305    	JNZ	SAVE4		;SEND MORE SOURCE CHARS
 058F 4A        	MOV	C,D
 0590 CD2705    	CALL	POUT		;SEND CHECKSUM
 0593 D1        SAVE5:	POP	D		;RECOVER LENGTH + 1  TO DE
 0594 7A        	MOV	A,D
 0595 B7        	ORA	A
                	IF	PACKI
                	JZ	SAVE6
                	ELSE
 0596 C8        	RZ			;DONE IF LENGTH < 255
                	ENDIF
 0597 15        	DCR	D		;ELSE NEW LENGTH = LENGTH+1-256 = LENGTH-255
 0598 C36105    	JMP	SAVE2		;AND SAVE MORE BLOCKS
                	IF	PACKI
                SAVE6:	CALL	SAVE7		;PUNCH TRAILING NULLS
                	MVI	A,CNTLT
                	JMP	WRITC		;TAPEOFF AND RETURN
                SAVE7:	LXI	B,(64 SHL 8)	;64 TO B, 0 TO C
                SAVE8:	CALL	POUT		;PUNCH A NULL
                	DCR	B
                	JNZ	SAVE8		;PUNCH MORE NULLS
                	RET
                	ENDIF
                
                
                ;LOAD <FILENAME>
                LOAD:	IF	ROMSQ
                	CALL	ISSRC		;MUST BE ADDRESSING WORKING SPACE
                	ENDIF
 059B 213E40    	LXI	H,HEADR+2	;FIRST FILENAME CHAR ADDRESS TO HL
 059E 010800    	LXI	B,8		;0 TO B, # FILENAME CHARS TO C
 05A1 CD351E    	CALL	FILLM		;FILL FILENAME WITH 0S
 05A4 CDC116    	CALL	PRNTM		;PRINT LOADING MESSAGE
 05A7 4C4F414449	DB	'LOADING', ' ' OR 80H
 05AF CD4917    	CALL	GTCHO		;LOOK AT NEXT CHAR
 05B2 CD9F01    	CALL	DTEST		;CHECK IF DELIMITER
 05B5 DC1806    	CC	GTFIL		;GET FILE NAME AND SET UP HEADER IF NOT
                	IF	PACKI
                	MVI	C,CNTLQ
                	CALL	POUT		;XON TO TURN ON RDR
                	ENDIF
 05B8 213C40    LOAD1:	LXI	H,HEADR
 05BB 0E0D      	MVI	C,HEADL
 05BD CDBF15    	CALL	CTEST		;CHECK FOR CONSOLE BREAK CHAR
                ;NB TARBELL NEEDS DIFFERENT STARTUP
                ;LXI H,HEADR+2 AND MVI C,HEADL-2 ABOVE
                ;MVI A,10H AND OUT 6EH HERE
 05C0 CD1F05    LOAD2:	CALL	RDRIN		;READ A CHAR
 05C3 BE        	CMP	M		;COMPARE TO HEADER CHAR
 05C4 CACC05    	JZ	LOAD3		;MATCHED, TRY NEXT
 05C7 7E        	MOV	A,M		;ELSE FETCH HEADER CHAR
 05C8 B7        	ORA	A		;CHECK IF NULL, I.E. LOAD <CR> TYPED
 05C9 C2B805    	JNZ	LOAD1		;NOT NULL, TRY AGAIN FROM THE TOP
 05CC 23        LOAD3:	INX	H
 05CD 0D        	DCR	C
 05CE C2C005    	JNZ	LOAD2		;SEE IF NEXT MATCHES TOO
 05D1 CD2A22    	CALL	NEW		;GOT THE FILE HEADER, PREPARE TO LOAD
 05D4 218A42    	LXI	H,SRCAD-1	;LOAD ADDRESS TO HL
 05D7 CD1F05    LOAD4:	CALL	RDRIN		;READ START BYTE
 05DA FE3A      	CPI	STBYT		;CHECK IF START BYTE
 05DC C21006    	JNZ	CSERR		;ISSUE CS ERROR IF NOT
 05DF CDBF15    	CALL	CTEST		;CHECK FOR CONSOLE BREAK CHAR
 05E2 CD1F05    	CALL	RDRIN		;READ TYPE BYTE
 05E5 FE00      	CPI	TYBYT		;CHECK IF TYPE BYTE
 05E7 C21006    	JNZ	CSERR		;ISSUE CS ERROR IF NOT
 05EA CD1F05    	CALL	RDRIN		;READ LENGTH BYTE
 05ED B7        	ORA	A
                	IF	PACKI
                	JZ	LOAD6		;XOFF BEFORE EXITING IN PACKARD VERSION
                	ELSE
 05EE CAA302    	JZ	DMODX		;BLOCK LENGTH 0, DONE
                	ENDIF
 05F1 5F        	MOV	E,A		;BLOCK LENGTH TO E
 05F2 3C        	INR	A
 05F3 F5        	PUSH	PSW		;SAVE LENGTH+1
 05F4 1600      	MVI	D,0		;CHECKSUM TO D
 05F6 CD1F05    LOAD5:	CALL	RDRIN		;READ A CHAR
 05F9 77        	MOV	M,A		;STORE IT
 05FA 23        	INX	H
 05FB 82        	ADD	D
 05FC 57        	MOV	D,A		;UPDATE CHECKSUM
 05FD 1D        	DCR	E
 05FE C2F605    	JNZ	LOAD5		;MORE CHARS IN BLOCK
 0601 CD1F05    	CALL	RDRIN		;READ THE CHECKSUM
 0604 BA        	CMP	D
 0605 C21006    	JNZ	CSERR		;CHECKSUM ERROR
 0608 F1        	POP	PSW		;RECOVER BLOCK LENGTH+1
 0609 CAD705    	JZ	LOAD4		;LENGTH WAS 255, SO LOAD MORE BLOCKS
 060C 2B        	DCX	H		;POINT TO NEW EOF ADRESS
                	IF	PACKI
                LOAD6:	MVI	C,CNTLS
                	CALL	POUT		;XOFF TO TURN OFF RDR
                	ENDIF
 060D C3A302    	JMP	DMODX		;RESET STACKS AND CONTINUE IFF DIRECT
 0610 CD2A22    CSERR:	CALL	NEW		;ERASE THE GARBAGE
                	IF	PACKI
                	MVI	C,CNTLS
                	CALL	POUT		;XOFF TO TURN OFF RDR
                	ENDIF
                	ERROR	F, C, S		;FATAL CS ERROR
 0613+CDC616    	CALL	ERROF
 0616+43D3      	DB	'C', 'S' OR 80H
                	ENDIF			;END NORMAL NONST CONDITIONAL
                
                	IF	(NOT EPSTN) AND (NOT BENDX)	;NONST GTFIL, INCLUDING GENMC
                ;THE NONSTANDARD VERSION OF GTFIL GETS A FILE NAME AND INITIALIZES HEADER BLOCK
 0618 CD3B06    GTFIL:	CALL	GTFL4		;SKIP THE OPEN QUOTE
                	IF	NOT GENMC
 061B 013E40    	LXI	B,HEADR+2	;POINT TO FILENAME LOCATION WITH BC
                	ELSE
                	LXI	B,HEADR+3
                	ENDIF
 061E CD5117    	CALL	GTALP		;GET FIRST CHAR
 0621 DA9201    	JC	SNERR
 0624 1608      	MVI	D,8		;MAX CHAR COUNT TO D
 0626 02        GTFL1:	STAX	B		;STORE A FILENAME CHAR IN HEADER
 0627 03        	INX	B
                	IF	NOT GENMC
 0628 CD2D15    	CALL	WRITC		;AND ECHO TO CONSOLE
                	ENDIF
 062B CDD117    	CALL	GTILD
 062E DA4006    	JC	GTFL5		;NO MORE CHARS, PAD WITH SPACES
 0631 15        GTFL2:	DCR	D
 0632 C22606    	JNZ	GTFL1		;STORE ANOTHER
 0635 CDD117    GTFL3:	CALL	GTILD
 0638 D23506    	JNC	GTFL3		;SCAN REMAINING CHARS, IF ANY
 063B 1622      GTFL4:	MVI	D,'"'
 063D C38717    	JMP	GTDSN		;GET QUOTE MARK AND RETURN
 0640 3E20      GTFL5:	MVI	A,' '
 0642 15        GTFL6:	DCR	D
 0643 CA3B06    	JZ	GTFL4
 0646 02        	STAX	B
 0647 03        	INX	B
 0648 C34206    	JMP	GTFL6
                	ENDIF
                
                
                	IF	EPSTN		;EPSTN VERSIONS
                
                ;SAVE <FILENAME>
                SAVE:	LXI	H,SAVMA		;SAVING MESSAGE ADDRESS TO HL
                	CALL	GTFIL		;GET FILE NAME
                	IF	NOT ROMSQ
                	LXI	B,SRCAD-1
                	ELSE
                	CALL	FIRST
                	ENDIF			;FIRST ADDR TO BC
                	CALL	WRTBH		;WRITE THE START ADDRESS IN HEX
                	MVI	A,'-'
                	CALL	WRITC		;WRITE A -
                	IF	ROMSQ
                	CALL	LAST		;LAST ADDR TO BC
                	ELSE
                	LHLD	EOFAD
                	MOV	B,H
                	MOV	C,L
                	ENDIF
                	CALL	WRTBH		;WRITE BC AS HEX NUMBER
                SAVE1:	CALL	PRNTM		;PRINT ESCAPE SEQUENCE
                	DB	CR, ESCAP, ESCAP OR 80H
                	RET			;AND RETURN
                SAVMA:	DB	CR, LF, ESCAP, 'DSAV', ' ' OR 80H
                
                ;LOAD <FILENAME>
                LOAD:	IF	ROMSQ
                	CALL	ISSRC		;MUST BE ADDRESSING WORKING SPACE
                	ENDIF
                	LXI	H,LODMA
                	CALL	GTFIL		;GET FILE NAME AND SET UP HEADER
                	CALL	NEW		;GOT THE FILE, PREPARE TO LOAD
                	CALL	SAVE1		;WRITE ESCAPE SEQUENCE
                	IF	ROMSQ
                	CALL	LAST
                	ELSE
                	LXI	D,-1
                	CALL	FINDL
                	MOV	A,M
                	CALL	ADAHL
                	ENDIF			;LAST ADDR TO HL
                	JMP	DMODX		;RESET STACKS AND CONTINUE IFF DIRECT
                LODMA:	DB	CR, LF, ESCAP, 'DLOD', ' ' OR 80H
                
                GTFIL:	PUSH	H		;SAVE MESSAGE ADDRESS
                	MVI	D,'"'
                	CALL	GTDSN		;SKIP OPEN QUOTE
                	LXI	D,BUFAD-1	;DESTINATION-1 TO DE
                	CALL	GTALP		;LOOK FOR ALPHA FIRST CHAR
                	JC	SNERR		;SN ERROR IF NONE
                	MVI	C,5		;MAX CHAR COUNT TO C
                GTFL1:	INX	D
                	STAX	D		;STORE A FILENAME CHAR
                GTFL2:	CALL	GTILD		;LOOK FOR FOLLOWING LETTER OR DIGIT
                	JC	GTFL3		;DONE IF NONE
                	DCR	C		;ELSE DECREMENT COUNT
                	JP	GTFL1		;AND STORE THE CHAR
                	JMP	GTFL2		;OR SCAN AND IGNORE REMAINING CHARS
                GTFL3:	LDAX	D		;RECOVER LAST FILENAME CHAR
                	ORI	80H		;TURN ON HIGH BIT
                	STAX	D		;AND REPLACE
                	MVI	D,'"'
                	CALL	GTDSN		;SKIP CLOSE QUOTE
                	POP	H		;RESTORE MESSAGE ADDR
                	CALL	PRTST		;PRINT IT
                	LXI	H,BUFAD
                	CALL	PRTST		;PRINT THE FILENAME
                	CALL	PRNTM		;PRINT FILETYPE XYB
                	DB	'.XYB', ' ' OR 80H
                	RET			;AND RETURN
                
                ;WRITH WRITES (A3-A0) AS A HEX DIGIT, MASKING OFF A7-A4.
                ;WRTBH WRITES (BC) AS HEX WORD, CURRENTLY AS #DDDD WITHOUT SUPPRESSING ZEROES.
                WRITH:	ANI	0FH		;00H, ... , 09H, 0AH, ... , 0FH
                	ADI	90H		;90H, ... , 99H, 9AH, ... , 9FH
                	DAA			;90H, ... , 99H, 0H+C,... , 5H+C
                	ACI	40H		;D0H, ... , D9H, 41H, ... , 46H
                	DAA			;30H, ... , 39H, 41H, ... , 46H
                	JMP	WRITC		;WRITE AND RETURN
                
                WRTBH:	PUSH	D
                	MVI	D,255
                WRTW1:	MOV	A,B
                	RRC
                	RRC
                	RRC
                	RRC			;ROTATE RIGHT FOUR PLACES
                	CALL	WRITH		;WRITE MS FOUR BITS
                	MOV	A,B
                	CALL	WRITH		;WRITE LS FOUR BITS
                	INR	D
                	MOV	B,C
                	JZ	WRTW1
                	POP	D
                	RET
                
                	ENDIF			;END OF EPSTN CONDITIONAL
                
                	IF	GENMC		;GENMC VERSIONS SAVE AND LOAD
                ;SAVE <FILENAME>
                SAVE:	CALL	PRNTM		;PRINT SAVING MESSAGE
                	DB	'SAVING', ' ' OR 80H
                	CALL	GTFIL		;GET FILE NAME
                	LXI	H,HEADR+3
                	CALL	PRTST		;ECHO THE <FILENAME>
                	LDA	OMODE
                	PUSH	PSW		;SAVE CURRENT OMODE
                	MVI	A,80H
                	STA	OMODE		;RESET OMODE FOR ASCII SAVING
                	LXI	H,HEADR
                	CALL	PRTST		;SAVE HEADER
                	IF	ROMSQ
                	LHLD	SOURC
                	ELSE
                	LXI	H,SRCAD		;FIRST PROG ADDR TO HL
                	ENDIF
                	LXI	B,-1
                	CALL	LIST1		;DO THE ASCII SAVE
                	MVI	C,CNTLZ
                	CALL	POUT		;AND WRITE AN EOF
                	POP	PSW
                	STA	OMODE		;RESTORE OMODE
                	RET
                
                ;LOAD [<FILENAME>]
                LOAD:	IF	ROMSQ
                	CALL	ISSRC		;ILLEGAL IF NOT ADDRESSING WORKING SPACE
                	ENDIF
                	CALL	PRNTM		;PRINT LOADING MESSAGE
                	DB	'LOADING', ' ' OR 80H
                	CALL	GTCHO		;LOOK AT NEXT CHAR
                	CALL	DTEST		;TEST IF DELIMITER
                	JNC	LOAD5		;NO <FILENAME>, JUST LOAD NEXT
                	CALL	GTFIL		;GET <FILENAME> TO HEADER
                ;LOAD1 LOOKS FOR <FILENAME> MATCHING HEADER
                LOAD1:	LXI	H,HEADR
                	MVI	C,HEADL-1
                	CALL	LOADH		;LOOK FOR MATCHING FILENAME FROM RDR
                	JNZ	LOAD1		;DOES NOT MATCH <FILENAME>
                	CALL	RDRCH		;READ LAST, SHOULD BE <LF>
                	CPI	LF
                	JNZ	LOAD1		;NO MATCH
                ;AT LOAD2 THE APPRORIATE HEADER HAS BEEN FOUND, SO FILE IS LOADED
                LOAD2:	LXI	H,HEADR+3
                	CALL	PRTST		;ECHO THE <FILENAME>
                	CALL	NEW		;ERASE OLD PROGRAM
                	MVI	A,7FH
                	STA	OMODE		;RESET OMODE FOR ASCII LOADING
                LOAD3:	CALL	GTLIN
                	CALL	TKIZE
                	JC	LOAD3
                	CNZ	ADDLN
                	JMP	LOAD3
                ;LOAD5 GETS THE NEXT FILE, REGARDLESS OF FILENAME
                LOAD5:	LXI	H,HEADR
                	MVI	C,3
                	CALL	LOADH		;LOOK FOR <CR> <LF> ' FROM RDR
                	JNZ	LOAD5		;NOT FOUND, TRY AGAIN
                	MVI	C,8		;NOW SCAN EIGHT <FILENAME> CHARS
                LOAD6:	CALL	RDRCH
                	MOV	M,A		;SAVE THE CHAR
                	INX	H
                	DCR	C
                	JNZ	LOAD6
                	MVI	C,5
                	CALL	LOADH		;LOOK FOR .BAS <CR>
                	JNZ	LOAD5		;NO MATCH
                	CALL	RDRCH		;READ <LF>
                	CPI	LF
                	JNZ	LOAD5
                	JMP	LOAD2		;FOUND GOOD HEADER, LOAD IT
                ;LOADH LOOKS FOR (C) CHARS FROM RDR
                ;RETN:	ZERO	SET IFF (C) CHARS MATCH STRING ADDRESSED BY HL
                LOADH:	CALL	RDRCH		;READ A CHAR
                	CMP	M
                	RNZ			;NO MATCH, RETURN ZERO RESET
                	INX	H
                	DCR	C
                	JNZ	LOADH		;LOOK AT NEXT
                	RET			;MATCH, RETURN ZERO SET
                
                DKOUT	EQU	POUT		;WRITE TO PUN DEVICE
                
                RDRCH:	CALL	CTEST		;CHECK FOR CONSOLE BREAK CHAR
                	CALL	RDRIN		;READ FROM READER
                	ANI	7FH		;MASK OFF PARITY
                	JZ	RDRCH		;IGNORE NULLS (ASCII 0S)
                	CPI	CNTLY		;CHECK IF <CONTROL-Y>
                	RNZ
                	ERROR	F, E, F		;FATAL EF ERROR
                DLOAD:	CALL	RDRCH
                	CPI	CNTLZ		;LOOK FOR EOF
                	JNZ	POP3
                	JMP	DMOD2		;RETURN TO DMODE IF EOF
                
                	ENDIF			;END OF GENMC CONDITIONAL
                
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                	ENDIF			;END OF NONST CONDITIONAL
                
                
                ;END OF NONST
                	PAGE
                
                ;DRIVER 10/22/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;INTERPRETER DRIVER
                
                
                ;THE INTERPRETER DRIVER HAS SEVERAL ENTRY POINTS.
                ;DMOD2, AFTER ERRORS, RESETS SP AND FALLS THROUGH TO...
                ;DMODE, AFTER EXECUTION, PRINTS OK PROMPT, THEN...
                ;DMOD3 IS THE DRIVER ITSELF.  GETS A LINE OF USER TEXT, TOKENIZES IT AND
                ;EITHER EXECUTES IT (NO LINE #) OR ADDS IT TO SOURCE TEXT, THEN GETS ANOTHER.
                
                	IF	COMPL		;RETURN TO DMODE BOOTS IN COMPL VERSION
                DMOD2	EQU	BOOT
                DMODC	EQU	BOOT
                DMODE	EQU	BOOT
                	ELSE
 064B 319E41    DMOD2:	LXI	SP,STACK	;RESET SP
 064E CDBD16    DMODE:	CALL	PRTM0		;PRINT OK MESSAGE
                	IF	EPSTN
                	DB	CR, LF, 13H, 'OK', 12H, CR, LF OR 80H
                	ELSE
 0651 0D0A4F4B0D	DB	CR, LF, 'OK', CR, LF OR 80H
                	ENDIF
 0657 AF        	XRA	A
 0658 329A40    	STA	GCHAR		;CLEAR GET CHARACTER
 065B 328142    	STA	TRACL		;CLEAR TRACING STATUS
                	IF	STRNG
 065E 329B40    	STA	STEMP		;CLEAR # STRING TEMPS IN USE
                	ENDIF
 0661 CDAB31    DMOD3:	CALL	LNNU0		;RESET LNNUM TO 0 IN CASE ^C TYPED
 0664 CD342E    	CALL	GTLIN		;GET A LINE FROM USER
 0667 CD2730    	CALL	TKIZE		;TOKENIZE IT
 066A DACA06    	JC	XSTA1		;EXECUTE IT IF NO LINE #
 066D C42431    	CNZ	ADDLN		;ELSE ADD TO SOURCE TEXT UNLESS <CR>
 0670 C36106    	JMP	DMOD3		;AND GET ANOTHER LINE
                	ENDIF			;END OF COMPL CONDITIONAL
                
                ;NEXTC SCANS TO NEXT COMMAND, RESETS SP AND FALLS THROUGH TO NEXTS.
 0673 2AC241    NEXTC:	LHLD	CSTKP
 0676 22C441    	SHLD	ESTKP		;RESET ESTACK IN CASE ERROR WITHIN EXPR
 0679 CD9817    	CALL	GTDEL		;SCAN TO DELIMITER
 067C 319E41    	LXI	SP,STACK	;RESET SP AND FALL THROUGH TO NEXTS
                
                ;NEXTS IS BRANCHED TO WITH TEXTP POINTING TO A DELIMITER (: ' <CR>), ELSE IT
                ;ISSUES A SN ERROR.  PERFORMS BREAK CHAR AND INTERRUPT TESTS.
                ;RETURNS TO DMOD1 IF AT EOF.  MOVES TEXTP TO FIRST CHAR
                ;OF NEXT STATEMENT, UPDATES LNNUM AND PERFORMS BREAK TEST.  THEN FALLS THROUGH
                ;TO XSTAT FOR STATEMENT EXECUTION.
                NEXTS:	IF	CAMAC AND NONST AND (NOT RTPAK)
                	IN	1
                	ANI	2
                	CNZ	CTST0		;READ CHAR IF PRESENT
                	ELSE
 067F CD0140    	CALL	CSTAT		;TEST CONSOLE FOR BREAK CHAR
 0682 0F        	RRC
 0683 DCC315    	CC	CTST0		;READ CHAR IF PRESENT
                	ENDIF
                	IF	NOT WILD
 0686 3A5640    	LDA	INTAD
 0689 07        	RLC			;TEST WHETHER INTERRUPT TABLE EMPTY
 068A DC8B07    	CC	ITEST		;NO, CHECK IF INTERRUPT OCCURS
                	ENDIF
 068D 2A8242    	LHLD	TEXTP
 0690 22BD41    	SHLD	SAVTP		;SAVE TEXTP
 0693 7E        	MOV	A,M		;INLINE CALL GTCH1 TO GET NEXT CHAR
 0694 23        	INX	H
 0695 FE20      	CPI	' '
 0697 CA9306    	JZ	$-4
 069A 228242    	SHLD	TEXTP
 069D FE3A      	CPI	':'
 069F CAC006    	JZ	XSTAT		;ANOTHER STATEMENT ON SAME LINE
                	IF	RTPAK OR NOT COMPL	;COMMENTS ARE REMOVED IF COMPILED
 06A2 FE27      	CPI	''''
 06A4 CCA824    	CZ	REM		;ON-LINE COMMENT
                	ENDIF
 06A7 FE0D      	CPI	CR
 06A9 C29201    	JNZ	SNERR		;SYNTAX ERROR -- GARBAGE AFTER STATEMENT
 06AC 7E        	MOV	A,M		;FETCH LENGTH BYTE OF NEXT LINE
 06AD B7        	ORA	A
 06AE CA4E06    	JZ	DMODE		;END OF SOURCE TEXT
 06B1 23        	INX	H
 06B2 224B40    	SHLD	LNNUM		;SAVE LINE NUMBER ADDRESS
 06B5 23        	INX	H
 06B6 23        	INX	H
 06B7 7E        	MOV	A,M		;FETCH BREAK BYTE
 06B8 23        	INX	H		;POINT TO FIRST TEXT BYTE
 06B9 228242    	SHLD	TEXTP		;SET TEXT POINTER
                	IF	NOT COMPL
 06BC 1F        	RAR			;NB CARRY WAS RESET ABOVE!
 06BD DCF606    	CC	BTEST		;TEST FOR BREAK IF BIT 0 WAS SET
                
                ;XSTAT IS BRANCHED TO WITH TEXTP POINTING TO FIRST CHAR OF A STATEMENT.
                ;PERFORMS TRACE MODE TEST, THEN FALLS THROUGH TO XSTA1 FOR
                ;ACTUAL STATEMENT EXECUTION.
                ;XSTA1 IS ENTRY POINT FROM DIRECT MODE, TO AVOID TRACE CHECKS.
                ;XSTA2 IS ENTRY POINT FOR THENPART OF AN IF STATEMENT.
 06C0 3A5040    XSTAT:	LDA	TRACE
 06C3 328142    	STA	TRACL		;SET TRACING STATUS OF CURRENT STATEMENT
 06C6 B7        	ORA	A
 06C7 C46A07    	CNZ	TPRNT		;PRINT TRACE LINE # IF TRACEON
                	ENDIF			;SKIP TRACE TESTS IN COMPL VERSION
 06CA 017F06    XSTA1:	LXI	B,NEXTS
                	IF	COMPL
                XSTAT	EQU	XSTA1
                	ENDIF
 06CD C5        	PUSH	B		;STACK NORMAL RETURN ADDRESS TO ALLOW RET
 06CE 2A8242    XSTA2:	LHLD	TEXTP		;INLINE CALL GTCHA FOLLOWS TO GET NEXT TOKEN
 06D1 7E        	MOV	A,M
 06D2 23        	INX	H
 06D3 FE20      	CPI	' '
 06D5 CAD106    	JZ	$-4
 06D8 228242    	SHLD	TEXTP
 06DB B7        	ORA	A
 06DC F2E621    	JP	LET0		;NOT TOKEN, MUST BE LET OR NULL STATEMENT
                	IF	WILD
                	CPI	WBUFT
                	JZ	WLETB		;BUFFER LEGAL LHS IN WILD VERSION
                	ENDIF
 06DF D68F      	SUI	CMDTK		;SUBTRACT MIN TOKEN VALUE
 06E1 DA9201    	JC	SNERR		;TOO SMALL, NOT A COMMAND TOKEN
 06E4 FE31      	CPI	NCMDS		;COMPARE TO NUMBER OF COMMANDS
 06E6 D29201    	JNC	SNERR		;TOO BIG
 06E9 21352A    	LXI	H,CMDTA		;COMMAND BRANCH TABLE ADDRESS TO HL
 06EC 87        	ADD	A		; * 2 BYTES PER ENTRY
 06ED 4F        	MOV	C,A
 06EE 0600      	MVI	B,0
 06F0 09        	DAD	B		;ADD OFFSET TO BASE ADDRESS
 06F1 7E        	MOV	A,M		;LOW ORDER ADDRESS TO A, TEMPORARILY
 06F2 23        	INX	H
 06F3 66        	MOV	H,M		;HIGH ORDER ADDR TO H
 06F4 6F        	MOV	L,A		;LOW ORDER ADDR TO L
 06F5 E9        	PCHL			;BRANCH TO ADDRESS
                
                ;BTEST CHECKS FOR LINE BREAKPOINTS.
                ;CALLED BEFORE XSTAT, SO TRACL IS NOT YET REINITIALIZED.
                ;CALL:	A	LINE BREAK BYTE, RARED ONCE.
                	IF	NOT COMPL
 06F6 B7        BTEST:	ORA	A		;TEST FURTHER IF MORE BITS SET
 06F7 21CA06    	LXI	H,XSTA1		;REPLACE XSTAT RETURN ADDR WITH XSTA1 TO
 06FA E3        	XTHL			;	AVOID RESETTING TRACL ON RETURN
 06FB CA6A07    	JZ	TPRNT		;PRINT BREAK LINE AND RETURN IF ONLY BIT 0 SET
 06FE 0F        	RRC			;BIT 1 OF BREAK BYTE TO CARRY
 06FF D25507    	JNC	BTST2		;NO COUNT OR VARIABLES, CHECK FOR DMODE BREAK
 0702 F5        	PUSH	PSW		;SAVE BREAK BYTE, ROTATED TWICE
                ;NOW THE SYMBOL TABLE ENTRY CONTAINING LINE BREAK INFO MUST BE FOUND.
 0703 2A4B40    	LHLD	LNNUM
 0706 CD6B04    	CALL	BKNAM		;BREAK ENTRY 'NAME' TO BUFAD
 0709 3E05      	MVI	A,BRKST
 070B CD1F1B    	CALL	STLK0		;LOOK UP BREAK ENTRY
 070E DA9701    	JC	EXERR		;NOT FOUND -- EX ERROR
                ;NEXT THE COUNT (# TIMES BEFORE NEXT BREAK) IS FETCHED.
 0711 5E        	MOV	E,M
 0712 23        	INX	H
 0713 56        	MOV	D,M		;COUNT TO DE
 0714 1B        	DCX	D		;DECREMENT COUNT
 0715 7A        	MOV	A,D
 0716 B3        	ORA	E
 0717 C25D07    	JNZ	BTST3		;NONZERO -- RETURN
                ;COUNTED TO ZERO, SO RESET COUNT TO ORIGINAL VALUE AND PRINT BREAK INFO.
 071A 44        	MOV	B,H
 071B 4D        	MOV	C,L
 071C 0B        	DCX	B		;BC POINTS TO COUNT
 071D 23        	INX	H		;HL POINTS TO RESET
 071E 7E        	MOV	A,M
 071F 02        	STAX	B
 0720 03        	INX	B
 0721 23        	INX	H
 0722 7E        	MOV	A,M
 0723 02        	STAX	B		;COPY RESET TO COUNT
 0724 CD6A07    	CALL	TPRNT		;PRINT BREAK [<LINE #>]
 0727 F1        	POP	PSW		;RESTORE BREAK BYTE
 0728 0F        	RRC			;BIT 2 OF BREAK BYTE TO CARRY
 0729 D25407    	JNC	BTST1		;SKIP VAR PRINTING
                ;THE BREAK SPECIFIED A <VAR LIST>, SO VARIABLE VALUES MUST BE PRINTED.
 072C F5        	PUSH	PSW		;SAVE BREAK BYTE, RRCED 3 TIMES
 072D 23        	INX	H		;POINT TO VAR LIST ADDR
 072E 7E        	MOV	A,M
 072F 23        	INX	H
 0730 66        	MOV	H,M
 0731 6F        	MOV	L,A		;VARLIST ADDRESS TO HL
 0732 22BB41    	SHLD	TXTP2
 0735 CD9402    	CALL	FLIP		;SCAN VAR LIST
 0738 215040    	LXI	H,TRACE
 073B 7E        	MOV	A,M
 073C F5        	PUSH	PSW		;SAVE TRACE
 073D 36FF      	MVI	M,255		;AND SET TRACE TO TRUE
 073F CDAA01    BTST0:	CALL	GTLHS		;GET VAR REF
 0742 47        	MOV	B,A		;SAVE TYPE
 0743 CDE901    	CALL	TRVA1		;PRINT = VALUE
 0746 CD5D17    	CALL	GTCOM		;LOOK FOR ANOTHER
 0749 D23F07    	JNC	BTST0		;PRINT MORE VARS
 074C F1        	POP	PSW
 074D 325040    	STA	TRACE		;RESTORE TRACE
 0750 CD9402    	CALL	FLIP		;RESTORE TEXTP
 0753 F1        	POP	PSW
                ;BTEST RETURNS OR BREAKS TO DMODE, DEPENDING ON WHETHER BREAK SPECIFIED $.
 0754 07        BTST1:	RLC
 0755 E602      BTST2:	ANI	2		;TEST BIT 3 (AFTER TWO ROTATES)
 0757 C8        	RZ			;NO $ -- CONTINUE
 0758 3EA5      	MVI	A,CSLBK		;LINE BREAK ENTRY TOKEN TO A
 075A C32D26    	JMP	STOP1		;$
 075D 72        BTST3:	MOV	M,D
 075E 2B        	DCX	H
 075F 73        	MOV	M,E		;NEW VALUE TO COUNT
 0760 F1        	POP	PSW		;RESTORE BREAK BYTE
 0761 E1        	POP	H		;POP THE RETURN TO XSTA1
 0762 C3C006    	JMP	XSTAT		;AND RETURN TO XSTAT FOR TRACL INITIALIZATION
                
                ;BPRNT PRINTS <TAB>[<LINE #>] IF NOT TRACL, AND IS CALLED BY NEXT AND TRSET.
                ;TPRNT PRINTS <TAB>[<LINE #>] AND SETS TRACL TO TRUE.
                ;BOTH PRESERVE BC,DE,HL AND CLOBBER A.
 0765 3A8142    BPRNT:	LDA	TRACL
 0768 B7        	ORA	A
 0769 C0        	RNZ			;SUPPRESS BREAK PRINTOUT IF TRACED
                TPRNT:	PUSH3
 076A+C5        	PUSH	B
 076B+D5        	PUSH	D
 076C+E5        	PUSH	H
 076D CD7115    	CALL	WCRLF		;WRITE CRLF
 0770 3E5B      	MVI	A,'['
 0772 CD2D15    	CALL	WRITC		;WRITE [
 0775 2A4B40    	LHLD	LNNUM		;LINE NUMBER ADDRESS TO HL
 0778 CD7B16    	CALL	PRNTL		;PRINT THE LINE
 077B 3E5D      	MVI	A,']'		;WRITE ]
 077D CD2D15    	CALL	WRITC
                	IF	WILD
                	CALL	WRTSP		;WRITE A SPACE (NO TAB ROUTINE)
                	ELSE
 0780 CDD123    	CALL	PRCO1		;TAB TO NEXT TAB STOP
                	ENDIF
 0783 3EFF      	MVI	A,255
 0785 328142    	STA	TRACL		;SET TRACL TO INDICATE LINE TRACED ALREADY
 0788 C3A108    	JMP	POP3
                
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                
                ;ITEST DETERMINES WHETHER INTERRUPT OCCURS AND THEN RETURNS OR INTERRUPTS.
                ;IF NO INTERRUPT:
                ;RETN:	A,BC,DE	CLOBBERED
                ;	HL	ADDRESS OF INTERRUPT TABLE EOF
                ;IF INTERRUPT OCCURS, ITEST'S RETURN ADDRESS IS POPED, A NORMAL STATEMENT
                ;RETURN ADDRESS IS PUSHED, AND A GOSUB TO THE APPROPRIATE LINE # IS EXECUTED.
                	IF	NOT WILD
 078B 215640    ITEST:	LXI	H,INTAD		;FIRST BYTE ADDRESS TO HL
 078E 07        ITST1:	RLC			;TEST ENABLE/SUSPEND BIT
 078F D2A807    	JNC	ITST3		;SUSPENDED -- LOOK FOR MORE
 0792 4F        	MOV	C,A		;SAVE $ BIT IN SIGN BIT OF C
 0793 54        	MOV	D,H
 0794 5D        	MOV	E,L		;SAVE FIRST BYTE ADDRESS IN DE
 0795 23        	INX	H		;POINT TO PORT # BYTE
 0796 7E        	MOV	A,M
 0797 CD4511    	CALL	RDP1		;READ THE PORT
 079A 23        	INX	H		;POINT TO MASK BYTE
 079B B6        	ORA	M
 079C 23        	INX	H		;POINT TO VALUE BYTE
 079D AE        	XRA	M		;COMPARE & CLEAR CARRY
 079E CAA207    	JZ	ITST2
 07A1 37        	STC			;CARRY SET IFF COMPARE NOT ZERO
 07A2 1F        ITST2:	RAR			;CARRY TO SIGN BIT OF A
 07A3 A9        	XRA	C		;SIGN BIT SET IFF NO INTERRUPT
 07A4 F2B207    	JP	ITST4		;INTERRUPT OCCURS
 07A7 EB        	XCHG			;RESTORE FIRST BYTE ADDRESS TO HL
 07A8 110800    ITST3:	LXI	D,8
 07AB 19        	DAD	D		;ADDRESS NEXT ENTRY
 07AC 7E        	MOV	A,M		;FIRST BYTE OF TABLE ENTRY TO A
 07AD 07        	RLC			;TEST ON/OFF BIT
 07AE D0        	RNC			;NO MORE TABLE ENTRIES -- RETURN
 07AF C38E07    	JMP	ITST1		;AND CHECK IT
 07B2 CD6301    ITST4:	CALL	LINBC		;ZERO SET IFF DIRECT MODE
 07B5 C8        	RZ			;NO INTERRUPTS FROM DIRECT MODE
 07B6 EB        	XCHG			;RESTORE FIRST BYTE ADDRESS TO HL
 07B7 E3        	XTHL			;POP ITEST RETURN, PUSH FIRST BYTE ADDRESS
 07B8 3E87      	MVI	A,CSINT
 07BA CD6C1B    	CALL	CPUSH		;TOKEN, TEXTP, LNNUM TO CONTROL STACK
 07BD D1        	POP	D
 07BE CD5002    	CALL	MVMDE
 07C1 EB        	XCHG			;  AND TO HL
 07C2 7E        	MOV	A,M		;FETCH FIRST BYTE
 07C3 E6BF      	ANI	0BFH		;SUSPEND INTERRUPT ENTRY
 07C5 77        	MOV	M,A
 07C6 110700    	LXI	D,7
 07C9 19        	DAD	D		;ADDRESS BYTE 8 OF ENTRY
 07CA CD4B02    	CALL	MVDEM
 07CD E5        	PUSH	H		;SAVE ENTRY PTR
 07CE CDC131    	CALL	FINDL		;LOOK FOR ENABLE LINE # ADDRESS
 07D1 DA8D1F    	JC	ENERR		;NONE, EN ERROR
 07D4 23        	INX	H		;POINT TO LINE # BYTE
 07D5 E3        	XTHL			;PUSH ENABLE LINE # ADDRESS, RECOVER PTR
 07D6 CD4B02    	CALL	MVDEM		;DESIRED INTERRUPT ROUTINE LINE # TO DE
 07D9 217F06    	LXI	H,NEXTS
 07DC E3        	XTHL			;POP ENABLE LINE # ADDRESS, PUSH RETURN ADDR
 07DD 224B40    	SHLD	LNNUM		;SET LNNUM IN CASE LINE NOT FOUND
 07E0 C33E21    	JMP	GOTO2		;FIND LINE #, CONTINUE FROM THERE
                	ENDIF			;END OF NOT WILD CONDITIONAL
                
                
                ;END OF DRIVER
                	PAGE
                
                ;EVAL 06/10/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;EXPRESSION EVALUATOR
                
                ;EVAL EVALUATES AN EXPRESSION.
                ;SPACE ABOVE THE CONTROL STACK IS USED AS A WORKING STACK, CALLED THE
                ;E(XPRESSION)STACK.  EACH EXPRESSION COMPONENT ALREADY SCANNED IS STORED ON
                ;THE ESTACK AS A BYTE IDENTIFIER SPECIFYING ITS TYPE (E.G. DELIMITER, PAREN,
                ;UNARY OP) AND PRECEDENCE.  FNS AND OPS HAVE AN ADDTIONAL BYTE CONTAINING
                ;THE FN ID.  VALUES ARE STORED AS A TYPE BYTE FOLLOWED BY VALUE BYTES.  STRING
                ;VALUES SAVED IN THE ESTACK ARE ADDRESSED BY STRING TEMPORARIES, FOR ACCESS
                ;DURING GARBAGE COLLECTION.
                ;MANY TYPES OF ERRORS MAY OCCUR DURING EVAL.
                ;SN ERROR OCCURS IF AN EXPRESSION IS ILLFORMED.
                ;OM ERROR OCCURS IF ESTACK OVERFLOWS THE AVAILABLE SPACE.
                ;TM ERROR OCCURS IF ARGUMENTS ARE OF WRONG TYPE.
                ;FC, OV, BY AND SIMILAR ERRORS CAN OCCUR DURING FN/OP EXECUTION.
                ;EX ERRORS SHOULD NEVER OCCUR, AND INDICATE SOMETHING IS WRONG.
                ;RETN:	CARRY	SET IFF NO <EXPR> FOUND, I.E. FIRST CHAR PARSED IS BAD
                ;	A	TYPE TOKEN OF RESULT, PRESERVED IF CARRY
                ;	BC, DE	PRESERVED
                ;	HL	POINTER TO TYPE (FOLLOWED BY VALUE BYTES), PRESERVED IF CARRY
                
                EVAL:	PUSH4			;SAVE ALL IN CASE FAILURE
 07E3+C5        	PUSH	B
 07E4+D5        	PUSH	D
 07E5+E5        	PUSH	H
 07E6+F5        	PUSH	PSW
 07E7 0E11      	MVI	C,ISDEL+1	;DELIMITER TYPE/PREC TO C
                
                ;EVAL0 SAVES THE TOKEN IN C ON THE ESTACK.  IF IT IS A FN OR OP,
                ;THE ID IN B IS ALSO ESTACKED.
 07E9 79        EVAL0:	MOV	A,C		;FETCH TYPE/PREC
 07EA FE70      	CPI	ISOP1
 07EC DAF507    	JC	EVA0A		;NOT A FN/OP, JUST ESTACK TYPE/PREC
 07EF 48        	MOV	C,B		;ELSE ID TO C
 07F0 47        	MOV	B,A		;SAVE TYPE/PREC IN B
 07F1 CD630B    	CALL	ESPSH		;ESTACK THE ID
 07F4 48        	MOV	C,B		;RESTORE TYPE/PREC TO C
 07F5 CD630B    EVA0A:	CALL	ESPSH		;ESTACK THE TYPE/PREC
                
                ;EVAL1 IS THE 'EXPECTING VALUE' STATE
                ;THE NEXT ITEM PARSED MUST BE A LITERAL, VARIABLE REFERENCE OR 0-ARY FN
                ;(EVALUATED AND ESTACKED, THEN EXPECTING OP), OR ELSE A FN NAME, ( OR
                ;UNARY OP (ESTACKED, THEN EXPECTING VALUE).  ANY OTHER ACTS AS DELIMITER.
 07F8 2A8242    EVAL1:	LHLD	TEXTP
 07FB 7E        EVA1A:	MOV	A,M		;FETCH NEXT TEXT CHAR
 07FC 23        	INX	H
 07FD FE20      	CPI	' '
 07FF CAFB07    	JZ	EVA1A		;TRY NEXT IF SPACE
 0802 FE40      	CPI	40H
 0804 DADC08    	JC	EVLIP		;0-3FH, MUST BE LITERAL OR (
 0807 B7        	ORA	A
 0808 F2F208    	JP	EVVAR		;40-7FH, MUST BE VAR REF
 080B CD490B    	CALL	GTTYP		;TYPE TO A, ID INFO TO BC
 080E DAA508    	JC	EVALX		;NOT A FN OR OP
 0811 228242    	SHLD	TEXTP		;READ THE FN OR OP
 0814 FE70      	CPI	ISOP1
 0816 DA5709    	JC	EVFN0		; 0-ARY OR USER-DEFINED FUNCTION
 0819 CAE907    	JZ	EVAL0		;ESTACK UNARY OP
 081C FE80      	CPI	ISOP2
 081E CA1909    	JZ	EVOPU		;BINARY OP MUST BE UNARY + OR -
 0821 1628      EVA1B:	MVI	D,'('		;OTHERWISE MUST BE A FUNCTION ID
 0823 CD8717    	CALL	GTDSN		;SO SKIP ( AFTER FN
 0826 C3E907    	JMP	EVAL0		;ESTACK TYPE/PREC AND ID AND EXPECT VALUE
                
                ;EVAL2 PUSHES A VALUE (TYPE TOKEN AND VALUE BYTES) TO ESTACK.
 0829 CDB408    EVAL2:	CALL	ESVAL		;VALUE TO ESTACK
                
                ;EVAL3 IS THE 'EXPECTING OP' STATE.
                ;THE NEXT ITEM PARSED SHOULD BE A COMMA [FN(EXPR,EXPR)] OR
                ;BINARY OP [EXPR OP EXPR] OR ) [FN(EXPR) OR FN(EXPR,EXPR) OR (EXPR)].
                ;ANY OTHER IS TREATED AS A DELIMITER.
 082C 2AC441    EVAL3:	LHLD	ESTKP
 082F 7E        	MOV	A,M
 0830 E6F0      	ANI	TMASK
 0832 57        	MOV	D,A		;PREVIOUS TYPE TO D
 0833 7E        	MOV	A,M
 0834 E60F      	ANI	PMASK
 0836 3C        	INR	A
 0837 5F        	MOV	E,A		;PREVIOUS PRECEDENCE + 1 TO E
 0838 010500    	LXI	B,VBYTS
 083B 09        	DAD	B		;ADDRESS NEW ESTACK TOP
 083C 22C441    	SHLD	ESTKP		;AND UPDATE THE POINTER
 083F CD4917    	CALL	GTCHO		;LOOK AT NEXT ITEM
 0842 CD490B    	CALL	GTTYP		;FIND ITS TYPE
 0845 DC3909    	CC	EVARP		;NOT AN OP, MUST BE ) OR COMMA OR DELIMITER
 0848 FE80      	CPI	ISOP2		;CHECK IF BINARY OP
 084A C25A08    	JNZ	EVAL4		;NO, MUST BE DELIMITER -- REDUCE
                ;COMPARE PRECEDENCES OF CURRENT AND PREVIOUS OP AND REDUCE WHEN APPROPRIATE.
 084D 79        	MOV	A,C		;FETCH CURRENT TYPE/PREC
 084E E60F      	ANI	PMASK
 0850 BB        	CMP	E		;COMPARE CURRENT TO PREVIOUS+1
 0851 DA5A08    	JC	EVAL4		;REDUCE
 0854 CD3B17    	CALL	GTCHA		;ELSE READ CURRENT
 0857 C3E907    	JMP	EVAL0		;AND STACK THE INFO BYTES
                
                ;AT EVAL4 PREVIOUS .>=. CURRENT PRECEDENCE, SO THE STACKTOP IS REDUCED
 085A 2AC441    EVAL4:	LHLD	ESTKP
 085D 01FCFF    	LXI	B,-VBYTS+1
 0860 09        	DAD	B		;ADDRESS VALUE ON ESTACK
 0861 7A        	MOV	A,D		;FETCH PREVIOUS TYPE
 0862 FE10      	CPI	ISDEL
 0864 CA9808    	JZ	EVAL5		;DELIMITER, DONE
 0867 FE70      	CPI	ISOP1
 0869 CA7C0A    	JZ	EVOP1		;UNARY OP
 086C FE80      	CPI	ISOP2
 086E CA840A    	JZ	EVOP2		;BINARY OP
 0871 E5        	PUSH	H		;OTHERWISE CURRENT CHAR MUST BE )
 0872 CD3B17    	CALL	GTCHA		;SO READ IT
 0875 FE29      	CPI	')'
 0877 C29201    	JNZ	SNERR
 087A E1        	POP	H		;AND RESTORE VALUE POINTER
 087B 7A        	MOV	A,D		;RESTORE PREVIOUS TYPE
 087C FE40      	CPI	ISCOM
 087E CA6F0A    	JZ	EVFN2		;COMMA -- DO A BINARY FUNCTION
 0881 FE20      	CPI	ISLP
 0883 CA2D09    	JZ	EVPAR		;( <EXPR> ) BECOMES <EXPR>
 0886 FE90      	CPI	ISFN1
 0888 CA7C0A    	JZ	EVFN1		;UNARY FUNCTION
 088B FE60      	CPI	ISUFN
 088D CAA009    	JZ	EVUF1		;UNARY USER-DEFINED FUNCTION
 0890 FEA0      	CPI	ISFN2
 0892 CA9201    	JZ	SNERR		;BINARY FN WITH ONE ARG
 0895 C39701    	JMP	EXERR		;ELSE FATAL EX ERROR -- SOMETHING WRONG
                
                ;EVAL5 IS THE EXIT FROM A SUCCESSFUL EVAL.
 0898 D1        EVAL5:	POP	D		;DISCARD SAVED PSW VALUE
 0899 D1        	POP	D		;AND ALSO SAVED HL VALUE
 089A E5        	PUSH	H		;SAVE RETURN VALUE FOR HL
 089B 7E        	MOV	A,M		;FETCH RESULT TYPE
 089C 2B        	DCX	H		;NB CARRY IS RESET FROM CPI ISDEL
 089D 2B        	DCX	H		;HL POINTS TO LOCATION BEFORE DELIMITER
 089E 22C441    EVAL6:	SHLD	ESTKP		;RESET ESTACK PAST DELIMITER
 08A1 E1        POP3:	POP	H		;VALUE TO HL
 08A2 D1        	POP	D
 08A3 C1        POP1:	POP	B		;RESTORE REGISTERS
 08A4 C9        	RET			;AND DONE
                
                ;EVALX IS THE ABNORMAL EXIT FROM EVAL.  IF ESTACK CONTAINS ONLY THE
                ;INITIAL DELIMITER, RETURNS WITH CARRY.  OTHERWISE ISSUES SN ERROR.
 08A5 2AC441    EVALX:	LHLD	ESTKP
 08A8 7E        	MOV	A,M		;FETCH TOP ESTACK ITEM
 08A9 FE11      	CPI	ISDEL+1		;COMPARE TO DELIMITER TYPE/PREC
 08AB C29201    	JNZ	SNERR		;ESTACK NONEMPTY, SN ERROR
 08AE 2B        	DCX	H		;ELSE POINT PAST DELIMITER
 08AF F1        	POP	PSW		;RESTORE A
 08B0 37        	STC			;SET CARRY
 08B1 C39E08    	JMP	EVAL6		;RESTORE AND RETURN
                
                
                ;ESVAL PUSHES A VALUE TO THE ESTACK.
                ;ENTRY:	A	TYPE TOKEN
                ;	BC	VALUE IF INTEGER
                ;	C,DE	VALUE IF STRING
                ;	(TEMP),BCD	VALUE IF FLOATING
 08B4 2AC441    ESVAL:	LHLD	ESTKP
 08B7 23        	INX	H
 08B8 77        	MOV	M,A		;STORE TYPE TOKEN
 08B9 23        	INX	H		;POINT TO FIRST VALUE BYTE
                	IF	FLOAT
 08BA FE02      	CPI	SNGST
 08BC C2C508    	JNZ	ESVL1		;NOT FLOATING
 08BF 3AB941    	LDA	TEMP		;RECOVER VALUE FOR A
                	IF	F9511
                	JMP	STO95		;STORE FLOATING VALUE ON ESTACK AND RETURN
                	ELSE
 08C2 C3BE0D    	JMP	FSTOR		;STORE FLOATING VALUE ON ESTACK AND RETURN
                	ENDIF
                	ENDIF
                ESVL1:	IF	STRNG
 08C5 FE03      	CPI	STRST
 08C7 C2D308    	JNZ	ESVL2		;NOT STRING
 08CA CDDF26    	CALL	ATEMP		;ASSIGN ESTACK LOCATION TO STRING TEMP
 08CD 71        	MOV	M,C		;LENGTH TO ESTACK
 08CE 23        	INX	H
 08CF 73        	MOV	M,E
 08D0 23        	INX	H
 08D1 72        	MOV	M,D		;LOCATION TO ESTACK
 08D2 C9        	RET
                	ENDIF
 08D3 FE01      ESVL2:	CPI	INTST
 08D5 C29701    	JNZ	EXERR		;NOT INTEGER
 08D8 71        	MOV	M,C
 08D9 23        	INX	H
 08DA 70        	MOV	M,B		;INTEGER VALUE TO ESTACK
 08DB C9        	RET
                
                ;EVLIP LOOKS FOR ( AND STACKS IF PRESENT, ELSE FALLS THROUGH TO...
                ;EVLIT EVALUATES A LITERAL, JUMPS TO EVALX IF NONE.
 08DC FE28      EVLIP:	CPI	'('
 08DE C2E908    	JNZ	EVLIT		;NOT (, MUST BE LITERAL
 08E1 228242    	SHLD	TEXTP		;READ THE (
 08E4 0E22      	MVI	C,ISLP+2	;TYPE/PREC TO C
 08E6 C3E907    	JMP	EVAL0		;( TO ESTACK AND EXPECT VALUE NEXT
 08E9 CD3C18    EVLIT:	CALL	GTLT1		;GET LITERAL
 08EC DAA508    	JC	EVALX		;EXIT IF NOT FOUND
 08EF C32908    	JMP	EVAL2		;AND ESTACK IT
                
                ;EVVAR EVALUATES A VARIABLE REFERENCE.
 08F2 CD8419    EVVAR:	CALL	GTVAR		;PERFORM VARIABLE REFERENCE
 08F5 DAA508    	JC	EVALX		;NO VAR
                	IF	STRNG
 08F8 FE03      	CPI	STRST		;CHECK IF TYPE STRING
 08FA C20909    	JNZ	EVVA0		;NONSTRING
 08FD EB        	XCHG
 08FE 2AC441    	LHLD	ESTKP
 0901 23        	INX	H
 0902 23        	INX	H		;POINT TO VALUE DESTINATION
 0903 CDDF26    	CALL	ATEMP		;ASSIGN STRING TEMPORARY
 0906 EB        	XCHG			;RESTORE VALUE LOCATION
 0907 3E03      	MVI	A,STRST		;AND RESTORE TYPE TOKEN
                	ENDIF
 0909 44        EVVA0:	MOV	B,H		;EVFN0 ENTRY POINT
 090A 4D        	MOV	C,L		;SOURCE TO BC
 090B 2AC441    EVVA1:	LHLD	ESTKP		;EVPAR ENTRY POINT
 090E 23        	INX	H
 090F 77        	MOV	M,A		;ESTACK THE TYPE
 0910 23        	INX	H		;VALUE DESTINATION TO HL
 0911 1E04      	MVI	E,VBYTS-1	;BYTE COUNT TO E
 0913 CDB431    	CALL	MOVD0		;MOVE VALUE TO ESTACK
 0916 C32C08    	JMP	EVAL3		;AND EXPECT OP
                
                ;EVOPU DEALS WITH UNARY + AND -.
 0919 78        EVOPU:	MOV	A,B		;REFETCH ID
 091A FE02      	CPI	PLUST-UDFNT
 091C CAF807    	JZ	EVAL1		;IGNORE UNARY PLUS
 091F 017C00    	LXI	B,ISOP1+12	;ID=0 TO B, TYPE/PREC TO C FOR UNARY MINUS
 0922 FE03      	CPI	MINT-UDFNT
 0924 CAE907    	JZ	EVAL0		;STACK UNARY MINUS
 0927 CD4C17    	CALL	BAKUP		;ELSE UNREAD THE BINARY OP
 092A C3A508    	JMP	EVALX		;AND EXIT
                
                ;EVPAR REDUCES (<EXPR>) TO <EXPR>.
 092D 7E        EVPAR:	MOV	A,M		;TYPE TO A
 092E E5        	PUSH	H
 092F 2B        	DCX	H		;ADDRESS (
 0930 2B        	DCX	H		;ADDRESS PREVIOUS
 0931 22C441    	SHLD	ESTKP		;RESET ESTACK
 0934 C1        	POP	B
 0935 03        	INX	B		;VALUE LOCATION TO BC
 0936 C30B09    	JMP	EVVA1		;AND MOVE DOWN THE VALUE
                
                ;EVARP DEALS WITH ) OR COMMA IN EXPECTING OP STATE, LOADING C WITH TYPE/PREC.
                ;THE PREVIOUS ITEM MUST BE CHECKED BECAUSE OF CASES LIKE DIM A (2,3).
 0939 7A        EVARP:	MOV	A,D		;FETCH PREVIOUS TYPE
 093A FE10      	CPI	ISDEL
 093C CA5409    	JZ	EVAR1		;PREVIOUS WAS DELIM, TREAT CURRENT AS DELIM
 093F 78        	MOV	A,B		;REFETCH CURRENT
 0940 0E32      	MVI	C,ISRP+2	;RIGHT PAREN TYPE/PREC TO C
 0942 FE29      	CPI	')'
 0944 C8        	RZ
 0945 0E43      	MVI	C,ISCOM+3	;COMMA TYPE/PREC TO C
 0947 FE2C      	CPI	','
 0949 C25409    	JNZ	EVAR1		;TREAT OTHERS AS DELIMITERS
 094C 3E40      	MVI	A,ISCOM		;COMMA TYPE TO A
 094E BA        	CMP	D		;COMPARE TO PREVIOUS TYPE
 094F 3E80      	MVI	A,ISOP2		;FOR COMPARE ON RETURN
 0951 C0        	RNZ			;RETURN UNLESS CURRANT AND PREVIOUS BOTH COMMA
 0952 1D        	DCR	E		;TO ALLOW SUCCESSIVE COMMAS FOR TERNARY FNS
 0953 C9        	RET
 0954 0E10      EVAR1:	MVI	C,ISDEL		;TREAT ANY OTHER AS DELIMITER
 0956 C9        	RET
                
                ;EVFN0 EVALUATES A 0-ARY FUNCTION AND EVALUATES (IF 0-ARY)
                ;OR ESTACKS (IF N-ARY) A USER-DEFINED FUNCTION.
 0957 FE50      EVFN0:	CPI	ISFN0
 0959 78        	MOV	A,B		;FN ID TO A
 095A CA930A    	JZ	EXCUT		;EXECUTE 0-ARY FUNCTION
                ;THE CURRENT ITEM IS A USER-DEFINED FUNCTION CALL.
 095D CD0E19    	CALL	GTNAM		;GET FUNCTION NAME
 0960 2B        	DCX	H
 0961 E5        	PUSH	H		;SAVE TEXTP
 0962 3E04      	MVI	A,UFNST
 0964 CD1F1B    	CALL	STLK0		;LOOK UP THE FN NAME
 0967 DA9201    	JC	SNERR		;NOT FOUND
 096A 3A9E41    	LDA	VARTY
 096D 4F        	MOV	C,A		;SAVE DESIRED RESULT TYPE IN C
 096E 1A        	LDAX	D		;FETCH TYPE
 096F E6E0      	ANI	0E0H		;MASK OFF TYPE BYTES
 0971 CA9109    	JZ	EXUF0		;EXECUTE 0-ARY USER-DEFINED FUNCTION
 0974 FE20      	CPI	20H
 0976 C2A012    	JNZ	FCERF		;NOT 0-ARY OR N-ARY, MUST BE ACTIVE ALREADY
                ;N-ARY USER-DEFINABLE FUNCTION INFORMATION IS ESTACKED.
 0979 C5        	PUSH	B		;SAVE DESIRED RESULT TYPE
 097A E5        	PUSH	H
 097B 42        	MOV	B,D
 097C 4B        	MOV	C,E		;TYPE BYTE ADDR TO BC
 097D CD5F0B    	CALL	EPSH2		;AND ESTACKED
 0980 E1        	POP	H
 0981 4E        	MOV	C,M
 0982 23        	INX	H
 0983 46        	MOV	B,M		;BOUND VAR ADDR TO BC
 0984 CD5F0B    	CALL	EPSH2		;AND ESTACKED
 0987 C1        	POP	B		;RECOVER DESIRED RESULT TYPE
 0988 CD630B    	CALL	ESPSH		;AND ESTACK IT
 098B E1        	POP	H		;POP TEXTP
 098C 0E62      	MVI	C,ISUFN+2	;TYPE TOKEN TO C
 098E C32108    	JMP	EVA1B		;SKIP ( AND ESTACK TYPE
 0991 7E        EXUF0:	MOV	A,M
 0992 23        	INX	H
 0993 66        	MOV	H,M
 0994 6F        	MOV	L,A		;FUNCTION BODY ADDRESS TO HL
 0995 228242    	SHLD	TEXTP		;RESET TEXTP TO SCAN FN BODY
 0998 2AC641    	LHLD	SYMTA
 099B E5        	PUSH	H		;SAVE SYMTA
 099C 79        	MOV	A,C		;DESIRED RESULT TYPE TO A
 099D C3FE09    	JMP	EXUFN		;AND EXECUTE THE FN
                
                ;EVUFN EVALUATES A USER-DEFINED FUNCTION.
 09A0 0601      EVUF1:	MVI	B,1		;NUMBER OF ARGS IS IN B
 09A2 EB        EVUFN:	XCHG			;BOUND VAR VAL ADDR TO DE
 09A3 2A8242    	LHLD	TEXTP
 09A6 E5        	PUSH	H		;SAVE TEXTP
 09A7 2AC641    	LHLD	SYMTA
 09AA E5        	PUSH	H		;AND SYMTA
 09AB 21F9FF    	LXI	H,-7
 09AE 19        	DAD	D
 09AF 22C441    	SHLD	ESTKP		;RESET ESTACK
 09B2 CD5502    	CALL	MODEM		;FETCH TYPE BYTE ADDR
 09B5 D5        	PUSH	D		;AND SAVE IT
 09B6 CD5502    	CALL	MODEM		;BOUND VAR ADDR TO DE
 09B9 EB        	XCHG
 09BA 228242    	SHLD	TEXTP		;BOUND VAR ADDR TO TEXTP
 09BD EB        	XCHG
 09BE 23        	INX	H
 09BF 7E        	MOV	A,M
 09C0 F5        	PUSH	PSW		;SAVE DESIRED RESULT TYPE
 09C1 23        	INX	H
 09C2 23        	INX	H		;POINT TO BOUND VAR VALUE
 09C3 E5        EVUF2:	PUSH	H		;SAVE VALUE LOCATION
 09C4 C5        	PUSH	B		;SAVE # ARGS LEFT
 09C5 E5        	PUSH	H		;AND SAVE VALUE LOCATION
 09C6 CD0E19    	CALL	GTNAM		;SCAN THE BOUND VAR
 09C9 DA9701    	JC	EXERR
 09CC 4F        	MOV	C,A		;NAME LENGTH TO C
 09CD CD7019    	CALL	FDVA1		;AND BUILD A NEW SYMBOL TABLE ENTRY FOR IT
 09D0 23        	INX	H		;POINT TO VALUE DESTINATION
 09D1 E3        	XTHL			;SAVE DESTINATION, BOUND VAR VALUE LOC TO HL
 09D2 3A9E41    	LDA	VARTY		;BOUND VAR TYPE
 09D5 CDD90A    	CALL	CNVRT		;CONVERT TO DESIRED TYPE
                	IF	STRNG
 09D8 FE03      	CPI	STRST
 09DA CC1527    	CZ	SCOPV		;FREE TEMP AND COPY TO STRING SPACE IF STRING
                	ENDIF
 09DD 23        	INX	H		;POINT TO VALUE
 09DE E3        	XTHL			;DESTINATION TO HL
 09DF C1        	POP	B		;VALUE LOC TO BC
 09E0 CD0902    	CALL	BYTSD		;BYTE COUNT TO DE
 09E3 CDB631    	CALL	MOVED		;COPY VALUE TO DESTINATION
 09E6 C1        	POP	B		;ARG COUNT TO B
 09E7 05        	DCR	B		;AND DECREMENTED
 09E8 CAF809    	JZ	EVUF3		;NO MORE ARGS
 09EB 162C      	MVI	D,','
 09ED CD8717    	CALL	GTDSN		;SKIP COMMA
 09F0 E1        	POP	H		;VALUE LOCATION TO HL
 09F1 110600    	LXI	D,VBYTS+1
 09F4 19        	DAD	D		;ADDRESS NEXT VALUE
 09F5 C3C309    	JMP	EVUF2		;AND REPEAT FOR NEXT BOUND VAR
 09F8 E1        EVUF3:	POP	H		;POP SAVED VALUE LOCATION
 09F9 CD8E17    	CALL	GTREQ		;SKIP ) = AFTER LAST BOUND VAR
 09FC F1        	POP	PSW		;RESTORE DESIRED RESULT TYPE
 09FD D1        	POP	D		;TYPE BYTE LOCATION TO DE
                				;AND EXECUTE THE FN
                ;EXUFN EXECUTES A USER-DEFINED FUNCTION.
                ;ENTRY:	A	DESIRED RESULT TYPE
                ;	DE	SYMBOL TABLE FN ENTRY TYPE BYTE ADDR
                ;	STACKED	SYMTA AND TEXTP VALUES
 09FE F5        EXUFN:	PUSH	PSW
 09FF 1A        	LDAX	D		;REFETCH TYPE BYTE
 0A00 F680      	ORI	80H		;TURN ON ACTIVE BIT
 0A02 12        	STAX	D		;AND STORE
 0A03 EB        	XCHG
 0A04 113741    	LXI	D,STACK+STAKM-STAKL
 0A07 CD6502    	CALL	CPLDE
 0A0A EB        	XCHG
 0A0B 39        	DAD	SP		;CHECK FOR STACK OVERFLOW
 0A0C D2A012    	JNC	FCERF		;FATAL FC ERROR, RECURSION TOO DEEP
 0A0F CDE307    	CALL	EVAL		;EVALUATE THE FN BODY
 0A12 F5        	PUSH	PSW		;SAVE CARRY STATUS
 0A13 1A        	LDAX	D
 0A14 E67F      	ANI	7FH
 0A16 12        	STAX	D		;RESET ACTIVE BIT
 0A17 F1        	POP	PSW
 0A18 EB        	XCHG			;SAVE RESULT LOCATION IN DE
 0A19 E1        	POP	H
 0A1A 7C        	MOV	A,H		;DESIRED RESULT TYPE TO A
 0A1B E1        	POP	H
 0A1C 22C641    	SHLD	SYMTA		;RESET SYMTA
 0A1F E1        	POP	H
 0A20 228242    	SHLD	TEXTP		;AND RESET TEXTP
 0A23 DAA012    	JC	FCERF		;UNSUCCESSFUL EVAL
 0A26 EB        	XCHG			;RECOVER RESULT LOCATION
 0A27 CDD90A    	CALL	CNVRT		;CONVERT RESULT TO DESIRED TYPE
 0A2A 23        	INX	H		;POINT TO VALUE
 0A2B C30909    	JMP	EVVA0		;AND ESTACK THE RESULT
                
                ;EVCOM DEALS WITH TERNARY MID$ AND INSTR AND N-ARY USER-DEFINED FNS.
 0A2E C1        EVCOM:	POP	B		;POP THE SAVED ARG ADDRESS
 0A2F 0602      	MVI	B,2		;# ARGS SEEN THUS FAR TO B
 0A31 23        EVCO1:	INX	H		;POINT TO ARG
 0A32 FE62      	CPI	ISUFN+2
 0A34 CAA209    	JZ	EVUFN		;N-ARY USER-DEFINED FN
                	IF	STRNG
 0A37 FEA2      	CPI	ISFN2+2
 0A39 CA470A    	JZ	EVFN3		;BINARY FN, MUST BE TERNARY MID$ OR INSTR
                	ENDIF
 0A3C FE43      	CPI	ISCOM+3		;LOOK FOR ANOTHER COMMA
 0A3E C29201    	JNZ	SNERR		;NOT FOUND, SOMETHING IS WRONG
 0A41 04        	INR	B		;BUMP ARG COUNT
 0A42 19        	DAD	D		;ADDRESS NEXT TOKEN OF ESTACK
 0A43 7E        	MOV	A,M		;AND FETCH IT
 0A44 C3310A    	JMP	EVCO1		;AND LOOK FOR MORE
                
                ;EVFN3 DEALS WITH THE SPECIAL CASES TERNARY MID$ AND TERNARY INSTR.
                ;BRANCHES TO ROUTINE IINST3 OR MID3 WITH ARG POINTERS TO ARGS 1,2,3
                ;IN BC,DE,HL AND RETURN ADDRESS TO EVAL2 STACKED.
                	IF	STRNG
 0A47 78        EVFN3:	MOV	A,B
 0A48 D603      	SUI	3
 0A4A C29201    	JNZ	SNERR		;NUMBER OF ARGS MUST BE 3
 0A4D E5        	PUSH	H
 0A4E 2B        	DCX	H
 0A4F 2B        	DCX	H
 0A50 7E        	MOV	A,M		;FETCH FN ID
 0A51 2B        	DCX	H
 0A52 22C441    	SHLD	ESTKP		;RESET ESTACK
 0A55 110600    	LXI	D,VBYTS+1
 0A58 212908    	LXI	H,EVAL2
 0A5B E3        	XTHL			;PUSH RETURN ADDRESS, ARG1 ADDR TO HL
 0A5C E5        	PUSH	H
 0A5D 19        	DAD	D		;ADDRESS ARG2
 0A5E E5        	PUSH	H
 0A5F 19        	DAD	D		;ADDRESS ARG3
 0A60 D1        	POP	D
 0A61 C1        	POP	B
 0A62 FE2F      	CPI	INSTT-UDFNT
 0A64 CA3229    	JZ	INST3		;TERNARY INSTR
 0A67 FE2E      	CPI	MIDST-UDFNT
 0A69 CA212A    	JZ	MID3		;TERNARY MID$
 0A6C C39201    	JMP	SNERR		;ELSE SN ERROR
                	ENDIF
                
                ;EVOP1 EVALUATES A UNARY OP.
                ;EVFN1 EVALUATES A UNARY FUNCTION.
                ;EVFN2 EVALUATES A BINARY FUNCTION.
 0A6F E5        EVFN2:	PUSH	H		;SAVE ARG2 ADDRESS
 0A70 11F9FF    	LXI	D,-VBYTS-2
 0A73 19        	DAD	D
 0A74 7E        	MOV	A,M		;FETCH TYPE/PREC BYTE
 0A75 FEA2      	CPI	ISFN2+2
 0A77 C22E0A    	JNZ	EVCOM		;MUST BE TERNARY FN OR N-ARY USER-DEFINED FN
 0A7A 23        	INX	H		;POINT TO ARG1
 0A7B D1        	POP	D		;ARG2 ADDRESS TO DE
                EVOP1:
 0A7C 44        EVFN1:	MOV	B,H
 0A7D 4D        	MOV	C,L		;ARG1 ADDRESS TO BC
 0A7E 2B        	DCX	H		;TO TYPE
 0A7F 2B        	DCX	H		;TO ID
 0A80 7E        	MOV	A,M		;FN ID TO A
 0A81 C38F0A    	JMP	EVOPA		;AND EXECUTE IT
                
                ;EVOP2 EVALUATES A BINARY OPERATOR.
 0A84 E5        EVOP2:	PUSH	H		;SAVE ARG2 ADDRESS
 0A85 2B        	DCX	H
 0A86 2B        	DCX	H
 0A87 7E        	MOV	A,M		;OP ID TO A
 0A88 11FBFF    	LXI	D,-VBYTS
 0A8B 19        	DAD	D
 0A8C D1        	POP	D		;ARG2 ADDR TO DE
 0A8D 44        	MOV	B,H
 0A8E 4D        	MOV	C,L		;ARG1 ADDR TO BC
 0A8F 2B        EVOPA:	DCX	H
 0A90 22C441    	SHLD	ESTKP		;RESET ESTACK
                				;AND FALL THROUGH TO EXCUT TO EXECUTE
                
                ;EXCUT EXECUTES A FUNCTION OR OPERATOR.
                ;ENTRY:	A	FN/OP IDENTIFIER
                ;	BC	POINTER TO ARG1 (IF ANY) IN EXPR STACK
                ;	DE	POINTER TO ARG2 (IF ANY) IN EXPR STACK
                ;EXIT:	A	RESULT TOKEN
                ;	BC	RESULT IF INTEGER
                ;	C,DE	RESULT IF STRING
                ;	(FACC)	RESULT IF FLOATING
                ;EXCUT FETCHES THE DESIRED ARG TYPES, FN/OP ADDRESS AND RESULT TYPE FROM
                ;THE FN/OP TYPE INFORMATION TABLE.  IF THE DESIRED ARG TYPE IS NONZERO
                ;(ZERO MEANS NO ARG OR ARG OF AMBIGUOUS TYPE), THE DESIRED AND ACTUAL
                ;ARG TYPES ARE COMPARED AND CONVERSION TO THE DESIRED TYPE PERFORMED IF
                ;NECESSARY.  IF THE DESIRED ARG TYPE IS INTEGER, THE
                ;POINTER IN BC OR DE IS REPLACED BY THE ACTUAL VALUE OF THE ARG.  IF
                ;THE DESIRED ARG1 TYPE IS FLOATING, THE VALUE IS LOADED TO FACC.  OTHERWISE
                ;EXCUT BRANCHES TO THE FN/OP ROUTINE WITH THE POINTERS IN BC AND DE INTACT.
                ;THE RESULT TYPE IS RETURNED FROM THE FN/OP ROUTINE IF TYPE AMBST, OTHERWISE
                ;THE SPECIFIED RESULT TYPE IS TAKEN AS THE ACTUAL RESULT TYPE.
 0A93 2600      EXCUT:	MVI	H,0
 0A95 6F        	MOV	L,A		;ID * 1
 0A96 29        	DAD	H		;ID * 2
 0A97 29        	DAD	H		;ID * 4
 0A98 CD7202    	CALL	ADAHL		;ID * 5
 0A9B D5        	PUSH	D
 0A9C 11D72A    	LXI	D,FUNTA
 0A9F 19        	DAD	D		;+ BASE ADDRESS = FIRST INFO ADDR
 0AA0 D1        	POP	D
 0AA1 7E        	MOV	A,M		;FETCH ARG2 DESIRED TYPE
 0AA2 B7        	ORA	A
 0AA3 CAAF0A    	JZ	EXCU1		;SKIP CONVERSION
 0AA6 C5        	PUSH	B		;SAVE ARG1 ADDRESS
 0AA7 42        	MOV	B,D
 0AA8 4B        	MOV	C,E		;ARG2 ADDR TO BC
 0AA9 CD320B    	CALL	CNVTB		;CONVERT ARG2 TO DESIRE TYPE
 0AAC 50        	MOV	D,B
 0AAD 59        	MOV	E,C		;AND RETURN TO DE
 0AAE C1        	POP	B		;RESTORE ARG1
 0AAF 23        EXCU1:	INX	H
 0AB0 7E        	MOV	A,M		;FETCH ARG1 DESIRED TYPE
 0AB1 B7        	ORA	A
 0AB2 C4320B    	CNZ	CNVTB		;CONVERT ARG1
 0AB5 23        	INX	H
 0AB6 7E        	MOV	A,M
 0AB7 23        	INX	H
 0AB8 E5        	PUSH	H		;SAVE INFO POINTER
 0AB9 66        	MOV	H,M
 0ABA 6F        	MOV	L,A		;FN/OP ADDRESS TO HL
 0ABB E5        	PUSH	H
 0ABC 21C10A    	LXI	H,EXRET
 0ABF E3        	XTHL			;RETURN ADDR TO STACK, FN/OP ADDR TO HL
 0AC0 E9        	PCHL			;EXECUTE IT
 0AC1 E1        EXRET:	POP	H		;RESTORE INFO POINTER
 0AC2 23        	INX	H
 0AC3 32B941    	STA	TEMP		;SAVE RETURNED RESULT TYPE INFO
 0AC6 7E        	MOV	A,M
                	IF	F9511
                	CPI	SNGST		;CHECK IF 9511 FLOATING POINT OP
                	JZ	EXRE1		;YES
                	ENDIF
 0AC7 B7        	ORA	A
 0AC8 C22908    	JNZ	EVAL2		;RETURN SPECIFIED RESULT TYPE
 0ACB 21B941    	LXI	H,TEMP
 0ACE 7E        	MOV	A,M		;ELSE PASS RETURNED RESULT TYPE
 0ACF 73        	MOV	M,E		;AND SAVE E IN TEMP IN CASE FLOATING
 0AD0 C32908    	JMP	EVAL2		;AND ESTACK THE RESULT
                	IF	F9511
                EXRE1:	CALL	FET95		;FETCH RESULT FROM 9511 STACK
                	STA	TEMP		;SAVE A VALUE
                	MOV	A,M		;RESTORE FLOATING RESULT TYPE
                	JMP	EVAL2		;AND ESTACK THE RESULT
                	ENDIF
                
                ;CNVRT CONVERTS BETWEEN DIFFERING VARIABLE TYPES.
                ;CALL:	A	DESIRED TYPE TOKEN
                ;	HL	POINTER TO VALUE TO CONVERT
                ;RETN:	A,BC,DE,HL	PRESERVED, HL NOW POINTING TO CONVERTED VALUE.
                ;A NONFATAL TM ERROR OCCURS IF CONVERSION IS IMPOSSIBLE.
                ;AN EX ERROR SHOULD NEVER OCCUR.
                ;EVALT DOES AN EVALS, THEN CONVERTS RESULT TO TYPE LHSTY.
 0AD3 CD850B    EVALT:	CALL	EVALS
 0AD6 3ABF41    	LDA	LHSTY		;FETCH DESIRED TYPE, FALL THROUGH TO...
 0AD9 BE        CNVRT:	CMP	M		;COMPARE ACTUAL TO DESIRED TYPE
 0ADA C8        	RZ			;ACTUAL = DESIRED, DONE
 0ADB C5        	PUSH	B
 0ADC D5        	PUSH	D
 0ADD E5        	PUSH	H		;SAVE REGISTERS
 0ADE 47        	MOV	B,A		;SAVE DESIRED TYPE IN B
                	IF	STRNG
 0ADF FE03      	CPI	STRST
 0AE1 CA2B0B    	JZ	TMERR		;DESIRED=STRING, ACTUAL=NUMERIC
 0AE4 7E        	MOV	A,M		;FETCH ACTUAL
 0AE5 FE03      	CPI	STRST
 0AE7 CA2B0B    	JZ	TMERR		;DESIRED=NUMERIC, ACTUAL=STRING
 0AEA 78        	MOV	A,B		;RESTORE DESIRED
                	ENDIF
                	IF	FLOAT
 0AEB FE01      	CPI	INTST
 0AED CA100B    	JZ	CNVFI		;CONVERT FLOATING TO INTEGER
 0AF0 FE02      	CPI	SNGST
 0AF2 C29701    	JNZ	EXERR
                ;FLOAT AN INTEGER VALUE
 0AF5 7E        	MOV	A,M		;FETCH ACTUAL
 0AF6 FE01      	CPI	INTST
 0AF8 C29701    	JNZ	EXERR		;MUST BE INTEGER
 0AFB 70        	MOV	M,B		;STORE NEW TYPE = FLOATING
 0AFC 23        	INX	H
                	IF	F9511		;LOAD INTEGER VALUE TO 9511 STACK
                	PUSH	H		;SAVE LOCATION
                	MOV	A,M		;FETCH LOW ORDER BYTE
                	OUT	D9511		;AND STACK
                	INX	H
                	MOV	A,M		;FETCH HIGH ORDER BYTE
                	OUT	D9511		;AND STACK
                	MVI	A,FLT95
                	CALL	O9511		;FLOAT THE INTEGER VALUE
                	CALL	FET95		;FETCH VALUE FROM 9511 STACK
                	POP	H		;RESTORE VALUE DESTINATION
                	CALL	STO95		;AND STORE ON ESTACK
                	JMP	CNVRX		;RESTORE REGISTERS AND RETURN AS BELOW
                	ELSE
 0AFD E5        	PUSH	H
 0AFE 4E        	MOV	C,M		;LSBYTE OF VALUE TO C
 0AFF 23        	INX	H
 0B00 46        	MOV	B,M		;MSBYTE TO B
                	IF	FPBCD
                	CALL	FFLOT		;FLOAT THE VALUE
                	ELSE
 0B01 110000    	LXI	D,0		;0 TO DE
 0B04 3E10      	MVI	A,16		;SCALE FACTOR TO A
 0B06 CD9210    	CALL	FLOT1		;FLOAT THE VALUE
                	ENDIF
 0B09 E1        	POP	H
 0B0A CDBE0D    	CALL	FSTOR		;AND STORE THE FLOATED VALUE
 0B0D C3260B    	JMP	CNVRX		;RESTORE REGISTERS AND RETURN AS BELOW
                	ENDIF
                ;CNVFI FIXES A FLOATING VALUE.
 0B10 7E        CNVFI:	MOV	A,M		;FETCH ACTUAL
 0B11 FE02      	CPI	SNGST
 0B13 C29701    	JNZ	EXERR		;ACTUAL MUST BE FLOATING
 0B16 70        	MOV	M,B		;STORE NEW ACTUAL TYPE = INTEGER
 0B17 23        	INX	H
 0B18 E5        	PUSH	H		;SAVE LOCATION
                	IF	F9511
                	CALL	LOD95		;VALUE TO 9511 STACK
                	CALL	INT95		;FIX FLOATING VALUE
                	JNC	CNVF1		;SUCCESSFUL CONVERSION
                	ERROR	N, O, V		;ELSE NONFATAL OV ERROR
                	ELSE
 0B19 CDEB0D    	CALL	FLOAD		;LOAD VALUE TO FACC
 0B1C CDD613    	CALL	IINT		;CONVERT TO INTEGER
 0B1F DCCC18    	CC	IOVER		;CANNOT FIX, NONFATAL OV ERROR
                	ENDIF
 0B22 E1        CNVF1:	POP	H		;RESTORE VALUE LOC
 0B23 71        	MOV	M,C		;STORE LSBYTE
 0B24 23        	INX	H
 0B25 70        	MOV	M,B		;STORE MSBYTE
 0B26 E1        CNVRX:	POP	H		;RESTORE LOCATION
 0B27 7E        	MOV	A,M		;TYPE TO A
 0B28 D1        	POP	D		;RESTORE DE
 0B29 C1        	POP	B		;AND BC
 0B2A C9        	RET
                	ENDIF
                TMERR:	ERROR	C, T, M		;ISSUE TM ERROR AND SCAN ON
 0B2B+CDCC16    	CALL	ERROC
 0B2E+54CD      	DB	'T', 'M' OR 80H
                
                ;CNVRB IS CALLED FROM EXCUT TO PERFORM TYPE CONVERSION ON ARGUMENTS.
                ;CALL:	A	TYPE TOKEN
                ;	BC	ARG POINTER
                ;RETN:	A,DE,HL	PRESERVED
                ;	BC	ARG POINTER TO CONVERTED TYPE, OR ARG VALUE IF INTEGER
                ;	FACC	ARG VALUE IF FLOATING
 0B30 3E01      CNVBI:	MVI	A,INTST		;CONVERT TO INTEGER
 0B32 C5        CNVTB:	PUSH	B
 0B33 E3        	XTHL			;HL SAVED, POINTER TO HL
 0B34 CDD90A    	CALL	CNVRT		;DO THE CONVERSION
 0B37 FE01      	CPI	INTST
 0B39 CA440B    	JZ	CNVB1		;INTEGER, FETCH IT
                	IF	FLOAT
 0B3C FE02      	CPI	SNGST
 0B3E CC3E02    	CZ	FETCF		;FLOATING, LOAD THE FACC
                	ENDIF
 0B41 E3        	XTHL			;POINTER SAVED, HL RESTORED
 0B42 C1        	POP	B		;POINTER TO BC
 0B43 C9        	RET
 0B44 CD2202    CNVB1:	CALL	FETCI		;FETCH INTEGER VALUE
 0B47 E1        	POP	H		;RESTORE HL
 0B48 C9        	RET
                
                ;GTTYP GETS TYPE AND PRECEDENCE INFO FOR A FN/OP.
                ;CALL:	A	TOKEN
                ;RETN:	A	TOKEN TYPE (PRECEDENCE MASKED OFF)
                ;	B	FN ID (OFFSET INTO FUNCTION TABLE), ISDEL IF CARRY
                ;	C	TYPE/PRECEDENCE BYTE
                ;	DE, HL	PRESERVED
                ;	CARRY	SET IFF (A) NOT FN/OP TOKEN
 0B49 47        GTTYP:	MOV	B,A		;CHAR TO B
 0B4A D6C0      	SUI	UDFNT		;SUBTRACT FIRST FN/OP TOKEN
 0B4C D8        	RC
 0B4D FE40      	CPI	NFUNS		;COMPARE TO # OF FNS
 0B4F 3F        	CMC
 0B50 D8        	RC
 0B51 47        	MOV	B,A		;ID TO B
 0B52 E5        	PUSH	H
 0B53 21972A    	LXI	H,TYPTA
 0B56 CD7202    	CALL	ADAHL		;ADDR TYPE/PREC BYTE
 0B59 4E        	MOV	C,M		;TYPE/PREC BYTE TO C
 0B5A E1        	POP	H
 0B5B 79        	MOV	A,C
 0B5C E6F0      	ANI	TMASK		;TYPE TO A
 0B5E C9        	RET
                
                ;ESPSH PUSHES C TO ESTACK AND CHECKS FOR OM ERROR.
                ;SINCE A VALUE WILL BE ESTACKED NEXT, ESPSH ASSURES THAT
                ;AT LEAST VBYTS OF SPACE REMAIN ABOVE THE PUSHED TOKEN.
 0B5F CD630B    EPSH2:	CALL	ESPSH		;PUSH ONE BYTE
 0B62 48        	MOV	C,B		;AND FALL THROUGH TO PUSH ANOTHER
 0B63 2AC641    ESPSH:	LHLD	SYMTA
 0B66 11FAFF    	LXI	D,-VBYTS-1
 0B69 19        	DAD	D
 0B6A EB        	XCHG			;SYMTA - VBYTS - 1 TO DE
 0B6B 2AC441    	LHLD	ESTKP
 0B6E 23        	INX	H		;ESTKP + 1 TO HL
 0B6F CD8602    	CALL	CMDHU
 0B72 DA7A0B    	JC	ESERR		;SYMTA <= ESTKP + VBYTS + 1
 0B75 71        	MOV	M,C		;STORE VALUE
 0B76 22C441    	SHLD	ESTKP		;AND UPDATE POINTER
 0B79 C9        	RET
 0B7A 2A8642    ESERR:	LHLD	EOFAD
 0B7D CD4622    	CALL	CSPST		;RESET CONTROL STACK
                	ERROR	C, O, M		;ISSUE OM ERROR AND SCAN TO NEXT
 0B80+CDCC16    	CALL	ERROC
 0B83+4FCD      	DB	'O', 'M' OR 80H
                
                ;EVALS DOES AN EVAL, ISSUES SN ERROR IF NO <EXPR> FOUND.
 0B85 CDE307    EVALS:	CALL	EVAL
 0B88 D0        	RNC
 0B89 C39201    	JMP	SNERR
                
                ;IEVAL DOES AN EVAL, CONVERTS RESULT TO INTEGER AND RETURNS IT IN BC.
 0B8C E5        IEVAL:	PUSH	H
 0B8D CDE307    	CALL	EVAL
 0B90 DA9B0B    	JC	IEVA1		;NO EXPR
 0B93 3E01      	MVI	A,INTST
 0B95 CDD90A    	CALL	CNVRT		;CONVERT TO INTEGER
 0B98 CD2202    	CALL	FETCI		;RESULT INTEGER TO BC
 0B9B E1        IEVA1:	POP	H		;RESTORE HL
 0B9C C9        	RET
                
                ;GTEXP DOES AN IEVAL, ISSUES SN ERROR IF NO <EXPR> FOUND.
 0B9D CD8C0B    GTEXP:	CALL	IEVAL
 0BA0 D0        	RNC
 0BA1 C39201    	JMP	SNERR
                
                ;GTBEX GETS A BYTE-VALUED EXPRESSION.
                ;GTCBE GETS A COMMA FOLLOWED BY A BYTE-VALUED EXPRESSION, BRANCHES TO SN ERROR
                ;IF COMMA IS NOT PRESENT.
 0BA4 CD5D17    GTCBE:	CALL	GTCOM
 0BA7 DA9201    	JC	SNERR
 0BAA CD9D0B    GTBEX:	CALL	GTEXP
 0BAD C35A02    	JMP	ISBYT
                
                
                ;END OF EVAL
                	PAGE
                
                ;FINOUT 10/10/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;FLOATING POINT INPUT/OUTPUT ROUTINES
                
                	IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)
                
                ;CONSTANTS
 0BB0 81000000  FPONE:	DW   81H, 0		;FLOATING POINT 1.
 0BB4 84200000  FPTEN:	DB   84H, 20H, 0, 0	;FLOATING POINT 10.
 0BB8 6C0637BC  FPRND:	DB   6CH, 6H, 37H, 0BCH	;FLOATING POINT ROUNDER .000 000 5
                
                
                ;FLOATING POINT INPUT
 0BBC 5E        FINP:	MOV  E,M	;1ST CHARACTER OF STRING
 0BBD CDA90D    	CALL SVAD	;SET CHARACTER ADDR,PNT FLG,EXP
 0BC0 23        	INX  H		;TO ADDR THE VALUE SIGN
 0BC1 3680      	MVI  M,80H	;SET VALUE SIGN POSITIVE
 0BC3 21B340    	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 0BC6 72        	MOV  M,D	;SET ACC TO ZERO
 0BC7 3AB941    	LDA  TEMP	;FETCH DESIRED VALUE SIGN
 0BCA B7        	ORA  A
 0BCB 7B        	MOV  A,E	;1ST CHARACTER
 0BCC CAD30B    	JZ  INP2	;IF POSITIVE DESIRED
 0BCF 21BD40    	LXI  H,TMP3	;TO ADDR THE VALUE SIGN
 0BD2 72        	MOV  M,D	;SET VALUE SIGN NEGATIVE
                ;ANALYZE THE NEXT CHARACTER IN THE STRING
 0BD3 0600      INP2:	MVI  B,0	;DIGIT 2ND WORD OR DECIMAL EXPONENT
 0BD5 FE2E      	CPI  '.'	;COMPARE TO DECIMAL POINT
 0BD7 CA1C0C    	JZ   INP3	;IF DECIMAL POINT
 0BDA FE45      	CPI  'E'	;COMPARE TO EXPONENTIATION SIGN
 0BDC CA2A0C    	JZ   INP4	;IF EXPONENTIATION
 0BDF FE65      	CPI  'E'+20H
 0BE1 CA2A0C    	JZ   INP4	;ALLOW LOWER CASE E IN CASE UNTOKENIZED
 0BE4 D630      	SUI  '0'	;SUBTRACT ASCII BIAS
 0BE6 FE0A      	CPI  0AH	;SET CARRY IF CHARACTER IS VALID DIGIT
 0BE8 D2750C    	JNC  INP8	;IF CHARACTER IS NOT A VALID DIGIT
 0BEB 32C240    	STA  TMP4	;SAVE THE CURRENT DIGIT
 0BEE 21B40B    	LXI  H,FPTEN	;TO ADDR FLOATING POINT 10
 0BF1 CD080E    	CALL FMUL	;MULTIPLY BY TEN
 0BF4 21BE40    	LXI  H,VALE	;TO ADDR THE VALUE
 0BF7 CDBE0D    	CALL FSTOR	;STORE OLD VALUE TIMES 10
 0BFA 23        	INX  H		;TO ADDR THE CURRENT DIGIT
 0BFB 7E        	MOV  A,M	;CURRENT DIGIT
 0BFC 0600      	MVI  B,0	;CLEAR 2ND WORD OF DIGIT
 0BFE 48        	MOV  C,B	;CLEAR 3RD WORD OF DIGIT
 0BFF 50        	MOV  D,B	;CLEAR 4TH WORD OF DIGIT
 0C00 1E08      	MVI  E,08	;INDICATE DIGIT IS IN REGISTER A
 0C02 CD8C10    	CALL FFLOT	;CONVERT DIGIT TO FLOATING POINT
 0C05 21BE40    	LXI  H,VALE	;TO ADDR THE VALUE
 0C08 CD550E    	CALL FADD	;ADD OLD VALUE TIMES 10
 0C0B 21BC40    	LXI  H,TMP2	;TO ADDR THE DECIMAL POINT FLAG
 0C0E 7E        	MOV  A,M	;DECIMAL POINT FLAG
 0C0F A7        	ANA  A		;SET CONTROL BITS
 0C10 CA150C    	JZ   INP1	;IF NO DECIMAL POINT ENCOUNTERED
 0C13 2B        	DCX  H		;TO ADDR THE INPUT EXPONENT
 0C14 35        	DCR  M		;DECREMENT THE INPUT EXPONENT
 0C15 CDB40D    INP1:	CALL CHAD	;GET ADDR OF NEXT CHARACTER
 0C18 7E        	MOV  A,M	;NEXT CHAR
 0C19 C3D30B    	JMP  INP2	;TO PROCESS NEXT CHARACTER
 0C1C 21BC40    INP3:	LXI  H,TMP2	;TO ADDR THE DECIMAL POINT FLAG
 0C1F AE        	XRA  M		;ZERO IF FLAG SET
 0C20 77        	MOV  M,A	;SET DECIMAL POINT FLAG
 0C21 C2150C    	JNZ  INP1	;IF FLAG NOT ALREADY SET
 0C24 2AB940    	LHLD ADRL	;READDRESS THE INPUT STRING
 0C27 C3750C    	JMP  INP8	;IF 2ND DECIMAL POINT
                
                ;PROCESS DECIMAL EXPONENT
 0C2A CDB40D    INP4:	CALL CHAD	;GET ADDR OF NEXT CHARACTER
 0C2D 7E        	MOV  A,M	;NEXT CHARACTER OF STRING
 0C2E 1E00      	MVI  E,0	;POSSIBLE EXPONENT SIGN (-) TO E
 0C30 FEC3      	CPI  MINT	;COMPARE TO MINUS CHARACTER
 0C32 CA450C    	JZ   INP5	;IF MINUS SIGN
 0C35 FE2D      	CPI  '-'
 0C37 CA450C    	JZ   INP5	;ALLOW UNTOKENIZED MINUS
 0C3A 5F        	MOV  E,A	;ELSE SIGN POSITIVE (NONZERO) TO E
 0C3B FEC2      	CPI  PLUST	;COMPARE TO PLUS CHARACTER
 0C3D CA450C    	JZ   INP5	;PLUS
 0C40 FE2B      	CPI  '+'	;CHECK FOR UNTOENIZED PLUS
 0C42 C2470C    	JNZ  INP6	;IF NOT PLUS SIGN
 0C45 23        INP5:	INX  H		;TO ADDR THE NEXT CHARACTER
 0C46 7E        	MOV  A,M	;NEXT CHARACTER OF STRING
 0C47 D630      INP6:	SUI  '0'	;SUBTRACT ASCII BIAS
 0C49 CA450C    	JZ   INP5	;IGNORE LEADING ZERO ON EXPONENT
 0C4C 0600      	MVI  B,0	;POSSIBLE DECIMAL EXPONENT
 0C4E FE0A      	CPI  0AH	;SET CARRY IF A DECIMAL DIGIT
 0C50 D2750C    	JNC  INP8	;IF NOT A DECIMAL DIGIT
 0C53 47        	MOV  B,A	;DECIMAL EXPONENT EQUAL DIGIT
 0C54 23        	INX  H		;TO ADDR THE NEXT CHARACTER
 0C55 7E        	MOV  A,M	;NEXT CHARACTER OF STRING
 0C56 D630      	SUI  '0'	;SUBTRACT ASCII BIAS
 0C58 FE0A      	CPI  0AH	;SET CARRY IF A DECIMAL DIGIT
 0C5A D26E0C    	JNC  INP7	;IF NOT A DECIMAL DIGIT
 0C5D 23        	INX  H		;ADDRESS NEXT CHAR
 0C5E 4F        	MOV  C,A	;LSD OF DECIMAL EXPONENT
 0C5F 7E        	MOV  A,M	;FETCH NEXT
 0C60 D630      	SUI  '0'	;SUBTRACT ASCII BIAS
 0C62 FE0A      	CPI  0AH
 0C64 DAA20C    	JC   INPOV	;THREE DIGITS, SCAN REMAINING AND RETURN 0 OR OV
 0C67 78        	MOV  A,B	;MSD OF DECIMAL EXPONENT
                ;FORM COMPLETE DECIMAL EXPONENT
 0C68 87        	ADD  A		;2*MSD
 0C69 87        	ADD  A		;4*MSD
 0C6A 80        	ADD  B		;5*MSD
 0C6B 87        	ADD  A		;10*MSD
 0C6C 81        	ADD  C		;10*MSD + LSD
 0C6D 47        	MOV  B,A	;DECIMAL EXPONENT
 0C6E 7B        INP7:	MOV  A,E	;SIGN OF DECIMAL EXPONENT
 0C6F A7        	ANA  A		;SET CONTROL BITS
 0C70 C2750C    	JNZ  INP8	;IF SIGN POSITIVE
 0C73 90        	SUB  B		;COMPLEMENT DECIMAL EXPONENT
 0C74 47        	MOV  B,A	;DECIMAL EXPONENT
 0C75 228242    INP8:	SHLD TEXTP
 0C78 21BD40    	LXI  H,TMP3	;TO ADDR THE INPUT SIGN
 0C7B 4E        	MOV  C,M	;INPUT SIGN
 0C7C 21B440    	LXI  H,ACCS	;TO ADDR THE ACC SIGN
 0C7F 71        	MOV  M,C	;ACC SIGN
 0C80 78        	MOV  A,B	;DECIMAL EXPONENT
                
                ;CONVERT DECIMAL EXPONENT TO BINARY
 0C81 21BB40    INP9:	LXI  H,TMP1	;TO ADDR THE DECIMAL EXPONENT
 0C84 86        	ADD  M		;ADJUST DECIMAL EXPONENT
 0C85 CAD70D    	JZ   FTEST	;IF DECIMAL EXPONENT IS ZERO
 0C88 77        	MOV  M,A	;CURRENT DECIMAL EXPONENT
 0C89 21B40B    	LXI  H,FPTEN	;TO ADDR FLOATING POINT 10
 0C8C F2970C    	JP   INP10	;IF MULTIPLY REQUIRED
 0C8F CD330E    	CALL FDIV	;DIVIDE BY 10
 0C92 3E01      	MVI  A,1	;TO INCREMENT THE DECIMAL EXPONENT
 0C94 C3810C    	JMP  INP9	;TO TEST FOR COMPLETION
 0C97 CD080E    INP10:	CALL FMUL	;MULTIPLY BY 10
 0C9A 3EFF      	MVI  A,-1	;TO DECREMENT THE DECIMAL EXPONENT
 0C9C D2810C    	JNC  INP9	;TO TEST FOR COMPLETION
 0C9F C3470E    	JMP  FOVER	;OV ERROR ON OVERFLOW AND RETURN FPMAX
 0CA2 23        INPOV:	INX  H
 0CA3 7E        	MOV  A,M
 0CA4 D630      	SUI  '0'
 0CA6 FE0A      	CPI  0AH
 0CA8 DAA20C    	JC   INPOV	;SCAN REMAINING EXPONENT DIGITS
 0CAB 228242    	SHLD TEXTP	;RESET TEXTP TO FIRST NONDIGIT
 0CAE 7B        	MOV  A,E	;SIGN OF DECIMAL EXPONENT
 0CAF B7        	ORA  A
 0CB0 CAC60D    	JZ  FZRO	;LARGE NEGATIVE EXPONENT, RETURN 0.
 0CB3 C3470E    	JMP  FOVER	;POSITIVE, ISSUE FLOATING OVERFLOW ERROR
                
                
                ;FLOATING POINT OUTPUT
                ;THE CONTENTS OF THE FACC IS NOT PRESERVED
 0CB6 21C741    FOUT:	LXI  H,BUFAD-1	;USE BUFAD TO STORE CONVERTED VALUE
 0CB9 CDA90D    	CALL SVAD	;SET CHARACTER ADDRESS, DIGIT COUNT, DECIMAL EXPONENT
 0CBC CDD70D    	CALL FTEST	;LOAD ACC TO REGISTERS
 0CBF 21BE40    	LXI  H,VALE	;TO ADDR THE ACC SAVE AREA
 0CC2 CDBE0D    	CALL FSTOR	;REGISTER STORE
                
                ;OUTPUT SIGN CHARACTER
 0CC5 CDB40D    	CALL CHAD	;GET ADDR OF CHARACTER
 0CC8 3620      	MVI  M,' '	;STORE SPACE CHARACTER
 0CCA A7        	ANA  A		;SET CONTROL BITS
 0CCB CAF10C    	JZ   OUT3	;IF ACC IS ZERO
 0CCE 5F        	MOV  E,A	;ACC EXPONENT
 0CCF 78        	MOV  A,B	;ACC SIGN AND 1ST FRACTION
 0CD0 A7        	ANA  A		;SET CONTROL BITS
 0CD1 7B        	MOV  A,E	;ACC EXPONENT
 0CD2 F2D70C    	JP   OUT0	;IF ACC IS POSITIVE
 0CD5 362D      	MVI  M,'-'	;CHANGE SIGN TO MINUS
                ;CHECK IF ACCUMULATOR IN RANGE .01 TO 1 TO ALLOW .01
 0CD7 FE7A      OUT0:	CPI  7AH	;COMPARE TO .01 EXPONENT
 0CD9 DAE10C    	JC   OUT1	;TOO SMALL, SCALE NORMALLY
 0CDC FE81      	CPI  81H
 0CDE DA020D    	JC   OUT5	;SKIP SCALING IF BETWEEN .01 AND 1
                ;SCALE ACCUMULATOR TO 0.1 TO 1.0 RANGE
 0CE1 FE7E      OUT1:	CPI  7EH	;COMPARE TO SMALL EXPONENT
 0CE3 21B40B    OUT2:	LXI  H,FPTEN	;TO ADDR FLOATING POINT 10
 0CE6 DAF80C    	JC   OUT4	;IF EXPONENT TOO SMALL
 0CE9 FE81      	CPI  81H	;COMPARE TO LARGE EXPONENT
 0CEB DA020D    	JC   OUT5	;IF EXPONENT NOT TOO LARGE
 0CEE CD330E    	CALL FDIV	;DIVIDE BY 10
 0CF1 21BC40    OUT3:	LXI  H,TMP2	;TO ADDR THE DECIMAL EXPONENT
 0CF4 34        	INR  M		;INCREMENT DECIMAL EXPONENT
 0CF5 C3E30C    	JMP  OUT2	;TO TEST FOR SCALING COMPLETE
 0CF8 CD080E    OUT4:	CALL FMUL	;MULTIPLY BY 10
 0CFB 21BC40    	LXI  H,TMP2	;TO ADDR THE DECIMAL EXPONENT
 0CFE 35        	DCR  M		;DECREMENT DECIMAL EXPONENT
 0CFF C3E10C    	JMP  OUT1	;TO TEST FOR SCALING COMPLETE
                
                ;ROUND THE VALUE BY ADDING 0.000 000 5
 0D02 CDCF0D    OUT5:	CALL FABS	;MAKE ACC POSITIVE
 0D05 21B80B    	LXI  H,FPRND	;TO ADDR THE ROUNDER
 0D08 CD550E    	CALL FADD	;ADD THE ROUNDER
 0D0B FE81      	CPI  81H	;CHECK FOR OVERFLOW
 0D0D D2E30C    	JNC  OUT2	;IF EXPONENT TOO LARGE
                
                ;SET DIGIT COUNTS
 0D10 21BC40    	LXI  H,TMP2	;TO ADDR THE DECIMAL EXPONENT
 0D13 7E        	MOV  A,M	;DECIMAL EXPONENT
 0D14 5F        	MOV  E,A	;DIGITS BEFORE DECIMAL EXPONENT
 0D15 FE07      	CPI  7		;COMPARE TO LARGE EXPONENT
 0D17 DA1C0D    	JC   OUT6	;IF EXPONENT IN RANGE
 0D1A 1E01      	MVI  E,1	;DIGITS BEFORE DECIMAL EXPONENT
 0D1C 93        OUT6:	SUB  E		;ADJUST DECIMAL EXPONENT
 0D1D 77        	MOV  M,A	;DECIMAL EXPONENT
 0D1E 3E06      	MVI  A,6	;TOTAL NUMBER OF DIGITS
 0D20 93        	SUB  E		;DIGITS AFTER DECIMAL POINT
 0D21 23        	INX  H		;TO ADDR THE 2ND DIGIT COUNT
 0D22 77        	MOV  M,A	;DIGITS AFTER DECIMAL POINT
 0D23 1D        	DCR  E		;DECREMENT THE DIGIT COUNT
 0D24 7B        	MOV  A,E	;DIGITS BEFORE THE DECIMAL POINT
                
                ;OUTPUT SIGNIFICANT DIGITS
 0D25 21BB40    OUT7:	LXI  H,TMP1	;TO ADDR THE DIGIT COUNT
 0D28 86        	ADD  M		;ADJUST THE DIGIT COUNT
 0D29 77        	MOV  M,A	;NEW DIGIT COUNT
 0D2A FA490D    	JM   OUT8	;IF COUNT RUN OUT
 0D2D 21B40B    	LXI  H,FPTEN	;TO ADDR FLOATING POINT 10
 0D30 CD080E    	CALL FMUL	;MULTIPLY BY 10
 0D33 1E08      	MVI  E,8	;TO PLACE DIGIT IN REGISTER 'A'
 0D35 CDA210    	CALL FFIX	;CONVERT TO FIXED FORMAT
 0D38 CDB40D    	CALL CHAD	;GET CHARACTER ADDRESS
 0D3B C630      	ADI  '0'	;ADD ASCII BIAS
 0D3D 77        	MOV  M,A	;OUTPUT DECIMAL DIGIT
 0D3E AF        	XRA  A		;CLEAR CURRENT DIGIT
 0D3F 1E08      	MVI  E,8	;BINARY SCALING FACTOR
 0D41 CD8C10    	CALL FFLOT	;RESTORE VALUE MINUS DIGIT
 0D44 3EFF      	MVI  A,-1	;TO ADJUST THE DIGIT COUNT
 0D46 C3250D    	JMP  OUT7	;LOOP FOR NEXT DIGIT
 0D49 21BD40    OUT8:	LXI  H,TMP3	;TO ADDR 2ND DIGIT COUNT
 0D4C 7E        	MOV  A,M	;DIGITS AFTER DECIMAL POINT
 0D4D 36FF      	MVI  M,-1	;SET 2ND COUNT NEGATIVE
 0D4F A7        	ANA  A		;SET CONTROL BITS
 0D50 FA5B0D    	JM   OUT9	;IF 2ND COUNT RAN OUT
 0D53 CDB40D    	CALL CHAD	;CHARACTER ADDRESS ROUTINE
 0D56 362E      	MVI  M,'.'	;STORE DECIMAL POINT
 0D58 C3250D    	JMP  OUT7	;LOOP FOR NEXT DIGIT
 0D5B 2AB940    OUT9:	LHLD ADRL	;ADDR THE LAST DIGIT STORED
 0D5E 7E        OUT9A:	MOV  A,M	;FETCH IT
 0D5F 2B        	DCX  H
 0D60 FE30      	CPI  '0'
 0D62 CA5E0D    	JZ   OUT9A	;SUPPRESS TRAILING ZEROS
 0D65 FE2E      	CPI  '.'
 0D67 CA6B0D    	JZ  OUT9B	;SUPPRESS TRAILING DECIMAL POINT
 0D6A 23        	INX  H		;READDRESS LAST DIGIT
 0D6B 22B940    OUT9B:	SHLD ADRL	;STORE FUDGED POINTER
 0D6E 21BC40    	LXI  H,TMP2	;ADDR THE DECIMAL EXPONENT
 0D71 7E        	MOV  A,M
 0D72 B7        	ORA  A
 0D73 CAA30D    	JZ   OUT13	;IF DECIMAL EXPONENT IS ZERO
                
                ;OUTPUT DECIMAL EXPONENT
 0D76 062B      	MVI  B,'+'	;PLUS SIGN
 0D78 F2800D    	JP   OUT10	;IF EXPONENT IS POSITIVE
 0D7B 062D      	MVI  B,'-'	;MINUS SIGN
 0D7D 4F        	MOV  C,A	;NEGATIVE EXPONENT
 0D7E AF        	XRA  A		;ZERO
 0D7F 91        	SUB  C		;COMPLEMENT THE EXPONENT
 0D80 0E2F      OUT10:	MVI  C,'0'-1	;EMBRYO ASCII TENS DIGIT
 0D82 0C        OUT11:	INR  C		;INCREMENT TENS DIGIT
 0D83 D60A      	SUI  0AH	;REDUCE REMAINDER
 0D85 D2820D    	JNC  OUT11	;IF MORE TENS
 0D88 C63A      	ADI  3AH	;RESTORE AND ADD ASCII BIAS
 0D8A 57        	MOV  D,A	;UNITS DIGIT
 0D8B 3E45      	MVI  A,'E'	;EXPONENT SIGN
 0D8D CDB40D    	CALL CHAD	;GET CHARACTER ADDRESS
 0D90 CDBE0D    	CALL FSTOR	;STORE LAST 4 CHARACTERS
 0D93 23        OUT12:	INX  H		;LAST ADDR + 1
 0D94 7D        	MOV  A,L	;LAST + 1 TO A
 0D95 F5        	PUSH PSW	;SAVE LAST+1
 0D96 21BE40    	LXI  H,VALE	;TO ADDR THE ACC SAVE AREA
 0D99 CDEB0D    	CALL FLOAD	;RESTORE ACC
 0D9C F1        	POP  PSW	;RESTORE LAST+1
 0D9D 11C841    	LXI  D,BUFAD	;FIRST TO DE
 0DA0 93        	SUB  E		;LAST+1 - FIRST = LENGTH TO A
 0DA1 4F        	MOV  C,A	;AND TO C
 0DA2 C9        	RET
                
                ;EXPONENT IS ZERO, DONE
 0DA3 2AB940    OUT13:	LHLD ADRL	;ADDRESS OF LAST CHAR TO HL
 0DA6 C3930D    	JMP  OUT12	;AND CONTINUE AS ABOVE
                
                ;SAVE THE CHARACTER STRING ADDRESS
 0DA9 7D        SVAD:	MOV  A,L	;CHARACTER STRING WORD
 0DAA 44        	MOV  B,H	;CHARACTER STRING BANK
 0DAB 0E00      	MVI  C,0	;INPUT EXPONENT OR DIGIT COUNT
 0DAD 51        	MOV  D,C	;DECIMAL POINT FLAG OR DECIMAL EXPONENT
 0DAE 21B940    	LXI  H,ADRL	;TO ADDR THE CHARACTER STRING ADDRESS
 0DB1 C3BE0D    	JMP  FSTOR	;STORE A, B, C, AND D AND RETURN THRU STR
                
                ;OBTAIN THE ADDRESS OF THE NEXT CHARACTER
 0DB4 2AB940    CHAD:	LHLD ADRL	;TO ADDR THE CHARACTER STRING ADDRESS
 0DB7 23        	INX  H		;BUMP IT
 0DB8 22B940    	SHLD ADRL	;RESTORE IT
 0DBB C9        	RET		;RETURN TO CALLER
                
                	ENDIF		;END OF FLOAT CONDITIONAL
                
                ;END OF FINOUT
                	PAGE
                
                ;FMATH 06/09/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;FLOATING POINT MATH PACKAGE
                
                
                	IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)
                
                ;THE FLOATING POINT (FP) MATH PACKAGE OPERATES ON NORMALIZED FLOATING
                ;BINARY POINT NUMBERS STORED IN FOUR CONSECUTIVE BYTES OF MEMORY.
                ;BYTE 1			BINARY EXPONENT E
                ;BYTE 2 BIT 7		SIGN S
                ;BYTE 2 BITS 6-0	MANTISSA MSB M1
                ;BYTE 3			MANTISSA 2SB M2
                ;BYTE 4			MANTISSA LSB M3
                ;IF E IS 0, THE VALUE IS 0 AND BYTES 2-4 ARE MEANINGLESS;  OTHERWISE
                ;E REPRESENTS THE BINARY EXPONENT WITH A BIAS OF 80H.
                ;THE SIGN BIT S IS 0 FOR POSITIVE, 1 FOR NEGATIVE.
                ;THE COMPLETE MANTISSA IS M1-M3 WITH A HIDDEN 1 REPLACING S IN M1 BIT 7
                ;AND THE BINARY POINT LOCATED LEFT OF M1.  THUS A NONZERO VALUE IS
                ; S * [2^(E-80H)] * [(80H+M1) * (2^-8)] * [M2 * (2^-16)] * [M3 * (2^-24)].
                
                ;THE FLOATING POINT ACCUMULATOR (FACC) CONTAINS A FLOATING POINT VALUE
                ;UNPACKED INTO FIVE CONSECUTIVE BYTES OF RAM STARTING AT ACCE.
                ;BYTE 1 (ACCE)		EXPONENT E, BIASED AS ABOVE
                ;BYTE 2 (ACCS)		SIGN, 0 IF NEGATIVE AND 80H IF POSITIVE
                ;BYTES 3-5 (ACC1-ACC3)	MANTISSA WITH HIDDEN 1 RESTORED IN ACC1
                
                ;FLOATING POINT STORE
 0DBC 73        FSTR0:	MOV  M,E	;STORE ZEROETH WORD
 0DBD 23        	INX  H		;TO ADDR THE 1ST WORD
 0DBE 77        FSTOR:	MOV  M,A	;STORE 1ST WORD
 0DBF 23        FSTR1:	INX  H		;TO ADDR THE 2ND WORD
 0DC0 70        	MOV  M,B	;STORE 2ND WORD
 0DC1 23        	INX  H		;TO ADDR THE 3RD WORD
 0DC2 71        	MOV  M,C	;STORE 3RD WORD
 0DC3 23        	INX  H		;TO ADDR THE 4TH WORD
 0DC4 72        	MOV  M,D	;STORE 4TH WORD
 0DC5 C9        	RET		;RETURN TO CALLER
                
                ;FLOATING POINT ZERO
 0DC6 21B340    FZRO:	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 0DC9 AF        	XRA  A		;ZERO
 0DCA 77        	MOV  M,A	;CLEAR ACC EXPONENT
 0DCB C9        	RET		;RETURN TO CALLER
                
                ;FLOATING POINT CHANGE SIGN
 0DCC 3E80      FCHS:	MVI  A,80H	;MASK TO CHANGE ACC SIGN BIT
 0DCE 06        	DB   6		;THIS MVI A, SAVES A JUMP
                			;AND CONTINUE AS IN FABS
                
                ;FLOATING POINT ABSOLUTE VALUE
 0DCF AF        FABS:	XRA  A		;NB MUST BE 1-BYTE INSTRUCTION
 0DD0 21B440    	LXI  H,ACCS	;TO ADDR THE ACC SIGN
 0DD3 A6        	ANA  M		;COMPLIMENT OF SIGN
 0DD4 EE80      	XRI  80H	;COMPLIMENT THE SIGN BIT
 0DD6 77        	MOV  M,A	;ACC SIGN
                
                ;FLOATING POINT TEST
 0DD7 21B340    FTEST:	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 0DDA 7E        	MOV  A,M	;ACC EXPONENT
 0DDB A7        	ANA  A		;SET CONTROL BITS
 0DDC CAC60D    	JZ   FZRO	;IF ACC IS ZERO
 0DDF 5F        	MOV  E,A	;ACC EXPONENT
 0DE0 23        	INX  H		;TO ADDR THE ACC SIGN
 0DE1 7E        	MOV  A,M	;ACC SIGN
 0DE2 23        	INX  H		;TO ADDR THE ACC 1ST FRACTION
 0DE3 AE        	XRA  M		;ACC SIGN AND 1ST FRACTION
 0DE4 23        	INX  H		;TO ADDR THE ACC 2ND FRACTION
 0DE5 4E        	MOV  C,M	;ACC 2ND FRACTION
 0DE6 23        	INX  H		;TO ADDR THE ACC 3RD FRACTION
 0DE7 56        	MOV  D,M	;ACC 3RD FRACTION
 0DE8 C3FA0E    	JMP  FADD8	;TO SET EXIT CONDITIONS
                
                ;FLOATING POINT LOAD
 0DEB 7E        FLOAD:	MOV  A,M	;OPERAND EXPONENT
 0DEC A7        	ANA  A		;SET CONTROL BITS
 0DED CAC60D    	JZ   FZRO	;IF OPERAND IS ZERO
 0DF0 5F        	MOV  E,A	;OPERAND EXPONENT
 0DF1 23        	INX  H		;TO ADDR THE OPERAND SIGN AND 1ST FRACTION
 0DF2 7E        	MOV  A,M	;OPERAND SIGN AND 1ST FRACTION
 0DF3 23        	INX  H		;TO ADDR THE OPERAND 2ND FRACTION
 0DF4 4E        	MOV  C,M	;OPERAND 2ND FRACTION
 0DF5 23        	INX  H		;TO ADDR THE OPERAND 3RD FRACTION
 0DF6 56        	MOV  D,M	;OPERAND 3RD FRACTION
                
                ;STORE THE OPERAND IN THE ACCUMULATOR
 0DF7 6F        	MOV  L,A	;OPERAND SIGN AND 1ST FRACTION
 0DF8 F680      	ORI  80H	;ACC 1ST FRACTION
 0DFA 47        	MOV  B,A	;ACC 1ST FRACTION
 0DFB AD        	XRA  L		;ACC SIGN
 0DFC 21B340    	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 0DFF CDBC0D    	CALL FSTR0	;SET THE ACC
 0E02 A8        	XRA  B		;ACC SIGN AND 1ST FRACTION
                
                ; SET CONTROL BITS AND EXIT
                
 0E03 47        	MOV  B,A	;ACC SIGN AND 1ST FRACTION
 0E04 F601      	ORI  01		;SET SIGN BIT FOR EXIT
 0E06 7B        	MOV  A,E	;ACC EXPONENT
 0E07 C9        	RET		;RETURN TO CALLER
                
                ;FLOATING POINT MULTIPLY
 0E08 7E        FMUL:	MOV  A,M	;OPERAND EXPONENT
 0E09 A7        	ANA  A		;SET CONTROL BITS
 0E0A C4160F    	CNZ  MDEX	;READ OPERAND IF NOT ZERO
 0E0D CAC60D    	JZ   FZRO	;IF ZERO OR UNDERFLOW
 0E10 DA470E    	JC   FOVER	;IF OVERFLOW
 0E13 CDCF0F    	CALL MULX	;FIXED POINT MULTIPLY 
                
                ;NORMALIZE IF NECESSARY
 0E16 78        	MOV  A,B	;1ST PRODUCT
 0E17 A7        	ANA  A		;SET CONTROL BITS
 0E18 FA260E    	JM   RNDA	;IF NO NORMALIZATION REQUIRED
 0E1B 21B340    	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 0E1E 7E        	MOV  A,M	;ACC EXPONENT
 0E1F DE01      	SBI  01		;DECREMENT ACC EXPONENT
 0E21 77        	MOV  M,A	;ACC EXPONENT
 0E22 C8        	RZ		;RETURN TO CALLER IF UNDERFLOW
 0E23 CD3C0F    	CALL LSH	;LEFT SHIFT SUBROUTINE
                
                ;ROUND IF NECESSARY
 0E26 CDB10F    RNDA:	CALL ROND	;ROUNDING SUBROUTINE
 0E29 DA470E    	JC   FOVER	;IF OVERFLOW
 0E2C 47        	MOV  B,A	;ACC SIGN AND 1ST FRACTION
 0E2D F601      	ORI  01		;SET SIGN BIT
 0E2F 7B        	MOV  A,E	;ACC EXPONENT
 0E30 C9        	RET		;RETURN TO CALLER
                
                ;FLOATING POINT DIVIDE
 0E31 EB        FDIVD:	XCHG		;XYBASIC ENTRY POINT
 0E32 23        	INX	H
 0E33 AF        FDIV:	XRA  A		;ZERO
 0E34 96        	SUB  M		;COMPLEMENT OF DIVISOR EXPONENT
 0E35 FE01      	CPI  01		;SET CARRY IF DIVISION BY ZERO
 0E37 D4160F    	CNC  MDEX	;READ OPERAND IF NOT ZERO
 0E3A DA470E    	JC   FOVER	;IF OVERFLOW OR DIVISION BY ZERO
 0E3D CAC60D    	JZ   FZRO	;IF UNDERFLOW OR ZERO
 0E40 4F        	MOV  C,A	;DIVISOR 1ST FRACTION
 0E41 CD1810    	CALL DIVX	;FIXED POINT DIVIDE
 0E44 DA260E    	JC   RNDA	;IF NO OVERFLOW
                ;FLOATING OVERFLOW -- ISSUE NONFATAL OV ERROR AND RETURN MAX VALUE
                FOVER:	ERROR N, O, V	;ISSUE NONFATAL OV ERROR
 0E47+CDD216    	CALL	ERRON
 0E4A+4FD6      	DB	'O', 'V' OR 80H
 0E4C 214034    	LXI  H,FPMAX	;MAX POSITIVE FP VALUE
 0E4F C3EB0D    	JMP  FLOAD	;TO ACC AND RETURN
                
                ;FLOATING POINT SUBTRACT
 0E52 3E80      FSUB:	MVI  A,80H	;MASK TO CHANGE OPERAND SIGN
 0E54 06        	DB   6		;THIS MVI B, SAVES A JUMP
                			;CONTINUE AS IN FADD
                
                ;FLOATING POINT ADD
 0E55 AF        FADD:	XRA  A		;NB MUST BE 1-BYTE INSTRUCTION
                ;LOAD THE OPERAND
 0E56 5E        	MOV  E,M	;OPERAND EXPONENT
 0E57 23        	INX  H		;TO ADDR THE OPERAND SIGN, 1ST FRACTION
 0E58 AE        	XRA  M		;OPERAND SIGN AND 1ST FRACTION
 0E59 47        	MOV  B,A	;OPERAND SIGN AND 1ST FRACTION
 0E5A 23        	INX  H		;TO ADDR THE OPERAND 2ND FRACTION
 0E5B 4E        	MOV  C,M	;OPERAND 2ND FRACTION
 0E5C 23        	INX  H		;TO ADDR THE OPERAND 3RD FRACTION
 0E5D 56        	MOV  D,M	;OPERAND 3RD FRACTION
                
                ;SAVE INITIAL EXPONENT
 0E5E 21B340    	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 0E61 7E        	MOV  A,M	;ACC EXPONENT
 0E62 2B        	DCX  H		;TO ADDR THE INITIAL EXPONENT
 0E63 77        	MOV  M,A	;INITIAL EXPONENT
                
                ;CHECK FOR ZERO OPERAND
 0E64 7B        	MOV  A,E	;OPERAND EXPONENT
 0E65 A7        	ANA  A		;SET CONTROL BITS
 0E66 CAD70D    	JZ   FTEST	;IF OPERAND IS ZERO
                
                ;GENERATE SUBTRACT FLAG AND RESTORE SUPPRESSED FRACTION BIT
 0E69 68        	MOV  L,B	;OPERAND SIGN AND 1ST FRACTION
 0E6A 78        	MOV  A,B	;OPERAND SIGN AND 1ST FRACTION
 0E6B F680      	ORI  80H	;OPERAND 1ST FRACTION
 0E6D 47        	MOV  B,A	;OPERAND 1ST FRACTION
 0E6E AD        	XRA  L		;OPERAND SIGN
 0E6F 21B440    	LXI  H,ACCS	;TO ADDR THE ACC SIGN
 0E72 AE        	XRA  M		;SUBTRACTION FLAG
 0E73 32B840    	STA  SFLAG	;SUBTRACTION FLAG
                
                ;DETERMINE RELATIVE MAGNITUDES OF OPERAND AND ACCUMULATOR
 0E76 2B        	DCX  H		;TO ADDR THE ACC EXPONENT
 0E77 7E        	MOV  A,M	;ACC EXPONENT
 0E78 A7        	ANA  A		;SET CONTROL BITS
 0E79 CA070F    	JZ   FADD9	;IF ACC IS ZERO
 0E7C 93        	SUB  E		;DIFFERENCE OF EXPONENTS
 0E7D DA8B0E    	JC   FADD2	;IF ACC SMALLER THAN OPERAND
                
                ;CHECK FOR INSIGNIFICANT OPERAND
 0E80 FAD70D    	JM   FTEST	;IF OPERAND IS INSIGNIFICANT
 0E83 FE19      	CPI  19H	;COMPARE SHIFT COUNT TO 25
 0E85 DAAB0E    	JC   FADD3	;POSITION THE OPERAND
 0E88 C3D70D    	JMP  FTEST	;OPERAND IS INSIGNIFICANT
                
                ;CHECK FOR INSIGNIFICANT ACCUMULATOR
 0E8B F2070F    FADD2:	JP   FADD9	;IF ACC IS INSIGNIFICANT
 0E8E FEE7      	CPI  0E7H	;COMPARE SHIFT COUNT TO -25
 0E90 DA070F    	JC   FADD9	;IF ACC IS INSIGNIFICANT
 0E93 73        	MOV  M,E	;OPERAND EXPONENT
 0E94 5F        	MOV  E,A	;SHIFT COUNT
 0E95 3AB840    	LDA  SFLAG	;SUBTRACT FLAG
 0E98 21B440    	LXI  H,ACCS	;TO ADDR THE ACC SIGN
 0E9B AE        	XRA  M		;OPERAND SIGN
 0E9C 77        	MOV  M,A	;ACC SIGN
 0E9D AF        	XRA  A		;ZERO
 0E9E 93        	SUB  E		;COMPLIMENT SHIFT COUNT
                
                ;EXCHANGE ACCUMULATOR AND OPERAND
 0E9F 23        	INX  H		;TO ADDR THE ACC 1ST FRACTION
 0EA0 5E        	MOV  E,M	;ACC 1ST FRACTION
 0EA1 70        	MOV  M,B	;OPERAND 1ST FRACTION
 0EA2 43        	MOV  B,E	;ACC 1ST FRACTION
 0EA3 23        	INX  H		;TO ADDR THE ACC 2ND FRACTION
 0EA4 5E        	MOV  E,M	;ACC 2ND FRACTION
 0EA5 71        	MOV  M,C	;OPERAND 2ND FRACTION
 0EA6 4B        	MOV  C,E	;ACC 2ND FRACTION
 0EA7 23        	INX  H		;TO ADDR THE ACC 3RD FRACTION
 0EA8 5E        	MOV  E,M	;ACC 3RD FRACTION
 0EA9 72        	MOV  M,D	;OPERAND 3RD FRACTION
 0EAA 53        	MOV  D,E	;ACC 3RD FRACTION
                
                ;POSITION THE OPERAND
 0EAB CD490F    FADD3:	CALL RSH	;POSITION THE OPERAND
 0EAE 3AB840    	LDA  SFLAG	;SUBTRACT FLAG
 0EB1 A7        	ANA  A		;SET CONTROL BITS
 0EB2 21B740    	LXI  H,ACC3	;TO ADDR THE ACC 3RD FRACTION
 0EB5 FADD0E    	JM   FADD5	;IF SUBTRACT REQUIRED
                
                ;ADD ADDEND TO AUGEND
 0EB8 7E        FADD4:	MOV  A,M	;AUGEND 3RD FRACTION
 0EB9 82        	ADD  D		;ADDEND 3RD FRACTION
 0EBA 57        	MOV  D,A	;SUM 3RD FRACTION
 0EBB 2B        	DCX  H		;TO ADDR THE AUGEND 2ND FRACTION
 0EBC 7E        	MOV  A,M	;AUGEND 2ND FRACTION
 0EBD 89        	ADC  C		;ADDEND 2ND FRACTION
 0EBE 4F        	MOV  C,A	;SUM 2ND FRACTION
 0EBF 2B        	DCX  H		;TO ADDR THE AUGEND 1ST FRACTION
 0EC0 7E        	MOV  A,M	;AUGEND 1ST FRACTION
 0EC1 88        	ADC  B		;ADDEND 1ST FRACTION
 0EC2 47        	MOV  B,A	;SUM 1ST FRACTION
 0EC3 D2F40E    	JNC  FADD7	;IF NO CARRY FROM 1ST FRACTION
                
                ;RIGHT SHIFT SUM TO NORMALIZED POSITION
 0EC6 1F        	RAR		;RIGHT SHIFT SUM 1ST FRACTION
 0EC7 47        	MOV  B,A	;SUM 1ST FRACTION
 0EC8 79        	MOV  A,C	;SUM 2ND FRACTION
 0EC9 1F        	RAR		;RIGHT SHIFT SUM 2ND FRACTION
 0ECA 4F        	MOV  C,A	;SUM 2ND FRACTION
 0ECB 7A        	MOV  A,D	;SUM 3RD FRACTION
 0ECC 1F        	RAR		;RIGHT SHIFT SUM 3RD FRACTION
 0ECD 57        	MOV  D,A	;SUM 3RD FRACTION
 0ECE 1F        	RAR		;4TH FRACTION = LOW BIT OF 3RD
 0ECF 5F        	MOV  E,A	;SUM 4TH FRACTION
 0ED0 21B340    	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 0ED3 7E        	MOV  A,M	;ACC EXPONENT
 0ED4 C601      	ADI  1		;INCREMENT THE ACC EXPONENT
 0ED6 DA470E    	JC   FOVER	;IF OVERFLOW
 0ED9 77        	MOV  M,A	;ACC EXPONENT
 0EDA C3F40E    	JMP  FADD7	;TO ROUND FRACTION
                
                ;SUBTRACT SUBTRAHEND FROM MINUEND
 0EDD AF        FADD5:	XRA  A		;MINUEND 4TH FRACTION IS ZERO
 0EDE 93        	SUB  E		;SUBTRAHEND 4TH FRACTION
 0EDF 5F        	MOV  E,A	;DIFFERENCE 4TH FRACTION
 0EE0 7E        	MOV  A,M	;MINUEND 3RD FRACTION
 0EE1 9A        	SBB  D		;SUBTRAHEND 3RD FRACTION
 0EE2 57        	MOV  D,A	;DIFFERENCE 3RD FRACTION
 0EE3 2B        	DCX  H		;TO ADDR THE MINUEND 2ND FRACTION
 0EE4 7E        	MOV  A,M	;MINUEND 2ND FRACTION
 0EE5 99        	SBB  C		;SUBTRAHEND 2ND FRACTION
 0EE6 4F        	MOV  C,A	;DIFFERENCE 2ND FRACTION
 0EE7 2B        	DCX  H		;TO ADDR THE MINUEND 1ST FRACTION
 0EE8 7E        	MOV  A,M	;MINUEND 1ST FRACTION
 0EE9 98        	SBB  B		;SUBTRAHEND 1ST FRACTION
 0EEA 47        	MOV  B,A	;DIFFERENCE 1ST FRACTION
 0EEB DC6F0F    FADD6:	CC   COMP	;COMPLIMENT IF NEGATIVE
 0EEE F4820F    	CP   NORM	;NORMALIZE IF NECESSARY
 0EF1 F2C60D    	JP   FZRO	;IF UNDERFLOW OR ZERO
 0EF4 CDB10F    FADD7:	CALL ROND	;ROUNDING
 0EF7 DA470E    	JC   FOVER	;IF OVERFLOW
 0EFA 47        FADD8:	MOV  B,A	;ACC SIGN AND 1ST FRACTION
 0EFB 21B240    	LXI  H,PREX	;TO ADDR THE PREVIOUS EXPONENT
 0EFE 7B        	MOV  A,E	;ACC EXPONENT
 0EFF 96        	SUB  M		;DIFFERENCE THE EXPONENTS
 0F00 6F        	MOV  L,A	;DIFFERENCE IN EXPONENTS
 0F01 78        	MOV  A,B	;ACC SIGN AND 1ST FRACTION
 0F02 F601      	ORI  1		;SET SIGN BIT FOR EXIT
 0F04 7B        	MOV  A,E	;ACC EXPONENT
 0F05 5D        	MOV  E,L	;SIGNIFICANCE INDEX
 0F06 C9        	RET		;RETURN TO CALLER
                
                ;LOAD THE ACCUMULATOR WITH THE OPERAND
 0F07 3AB840    FADD9:	LDA  SFLAG	;SUBTRACTION FLAG
 0F0A 21B440    	LXI  H,ACCS	;TO ADDR THE ACC SIGN
 0F0D AE        	XRA  M		;OPERAND SIGN
 0F0E 2B        	DCX  H		;TO ADDR THE ACC EXPONENT
 0F0F CDBC0D    	CALL FSTR0	;SET THE ACC
 0F12 A8        	XRA  B		;ACC SIGN AND 1ST FRACTION
 0F13 C3FA0E    	JMP  FADD8	;JOIN EXIT CODE
                
                ;READ THE OPERAND AND CHECK THE ACCUMULATOR EXPONENT
 0F16 47        MDEX:	MOV  B,A	;EXPONENT MODIFIER
 0F17 23        	INX  H		;TO ADDR THE OPERAND SIGN AND 1ST FRACTION
 0F18 4E        	MOV  C,M	;OPERAND SIGN AND 1ST FRACTION
 0F19 23        	INX  H		;TO ADDR OPERAND 2ND FRACTION
 0F1A 56        	MOV  D,M	;OPERAND 2ND FRACTION
 0F1B 23        	INX  H		;TO ADDR OPERAND 3RD FRACTION
 0F1C 5E        	MOV  E,M	;OPERAND 3RD FRACTION
 0F1D 21B340    	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 0F20 7E        	MOV  A,M	;ACC EXPONENT
 0F21 A7        	ANA  A		;SET CONTROL BITS
 0F22 C8        	RZ		;RETURN IF ACC IS ZERO
 0F23 80        	ADD  B		;RESULT EXPONENT PLUS BIAS
 0F24 47        	MOV  B,A	;RESULT EXPONENT PLUS BIAS
 0F25 1F        	RAR		;CARRY TO SIGN BIT
 0F26 A8        	XRA  B		;CARRY AND SIGN MUST DIFFER
 0F27 78        	MOV  A,B	;RESULT EXPONENT PLUS BIAS
 0F28 0680      	MVI  B,80H	;EXPONENT BIAS, SIGN MASK, MSB
 0F2A F2380F    	JP   OVUN	;IF OVERFLOW OR UNDERFLOW
 0F2D 90        	SUB  B		;REMOVE EXCESS EXPONENT BIAS
 0F2E C8        	RZ		;RETURN IF UNDERFLOW
 0F2F 77        	MOV  M,A	;RESULT EXPONENT
 0F30 23        	INX  H		;TO ADDR THE ACC SIGN
 0F31 7E        	MOV  A,M	;ACC SIGN
 0F32 A9        	XRA  C		;RESULT SIGN IN SIGN BIT
 0F33 A0        	ANA  B		;RESULT SIGN
 0F34 77        	MOV  M,A	;RESULT SIGN
 0F35 79        	MOV  A,C	;OPERAND SIGN AND 1ST FRACTION
 0F36 B0        	ORA  B		;OPERAND 1ST FRACTION
 0F37 C9        	RET		;RETURN TO CALLER
 0F38 07        OVUN:	RLC		;SET CARRY BIT IF OVERFLOW
 0F39 D8        	RC		;RETURN IF OVERFLOW
 0F3A AF        	XRA  A		;ZERO
 0F3B C9        	RET		;RETURN IF UNDERFLOW
                
                ;LEFT SHIFT THE B, C, D, AND E REGISTERS ONE BIT
 0F3C 7B        LSH:	MOV  A,E	;ORIGINAL CONTENTS OF E
 0F3D 17        	RAL		;LEFT SHIFT E
 0F3E 5F        	MOV  E,A	;RESTORE TO E
 0F3F 7A        	MOV  A,D	;ORIGINAL CONTENTS OF D
 0F40 17        	RAL		;LEFT SHIFT D
 0F41 57        	MOV  D,A	;RESTORE TO D
 0F42 79        	MOV  A,C	;ORIGINAL CONTENTS OF C
 0F43 17        	RAL		;LEFT SHIFT C
 0F44 4F        	MOV  C,A	;RESTORE TO C
 0F45 78        	MOV  A,B	;ORIGINAL CONTENTS OF B
 0F46 8F        	ADC  A		;LEFT SHIFT B
 0F47 47        	MOV  B,A	;RESTORE TO B
 0F48 C9        	RET		;RETURN TO CALLER
                
                ;RIGHT SHIFT THE B, C, D, AND E REGISTERS
                ;BY THE SHIFT COUNT IN THE A REGISTER.
                ;              - OR -
                ;SHIFT OPERAND TO REGISTER INDICATED
                ;BY THE SHIFT COUNT(MODULO 8).
 0F49 1E00      RSH:	MVI  E,0	;OPERAND 4TH FRACTION IS ZERO
 0F4B 2E08      	MVI  L,08	;EACH REG IS 8 BITS OF SHIFT
 0F4D BD        RSH1:	CMP  L		;COMPARE SHIFT COUNT TO 8
 0F4E FA5A0F    	JM   RSH2	;IF REQUIRED SHIFT IS < 8
 0F51 5A        	MOV  E,D	;OPERAND 4TH FRACTION
 0F52 51        	MOV  D,C	;OPERAND 3RD FRACTION
 0F53 48        	MOV  C,B	;OPERAND 2ND FRACTION
 0F54 0600      	MVI  B,0	;OPERAND 1ST FRACTION IS ZERO
 0F56 95        	SUB  L		;REDUCE SHIFT COUNT BY ONE REGISTER
 0F57 C24D0F    	JNZ  RSH1	;IF MORE SHIFTS REQUIRED
                
                ;SHIFT OPERAND RIGHT BY 'SHIFT COUNT' BITS
 0F5A A7        RSH2:	ANA  A		;SET CONTROL BITS
 0F5B C8        	RZ		;RETURN IF SHIFT COMPLETE
 0F5C 6F        	MOV  L,A	;SHIFT COUNT
 0F5D A7        RSH3:	ANA  A		;CLEAR CARRY BIT
 0F5E 78        	MOV  A,B	;OPERAND 1ST FRACTION
 0F5F 1F        	RAR		;RIGHT SHIFT 1ST FRACTION
 0F60 47        	MOV  B,A	;OPERAND 1ST FRACTION
 0F61 79        	MOV  A,C	;OPERAND 2ND FRACTION
 0F62 1F        	RAR		;RIGHT SHIFT 2ND FRACTION
 0F63 4F        	MOV  C,A	;OPERAND 2ND FRACTION
 0F64 7A        	MOV  A,D	;OPERAND 3RD FRACTION
 0F65 1F        	RAR		;RIGHT SHIFT 3RD FRACTION
 0F66 57        	MOV  D,A	;OPERAND 3RD FRACTION
 0F67 7B        	MOV  A,E	;OPERAND 4TH FRACTION
 0F68 1F        	RAR		;RIGHT SHIFT 4TH FRACTION
 0F69 5F        	MOV  E,A	;OPERAND 4TH FRACTION
 0F6A 2D        	DCR  L		;DECREMENT SHIFT COUNT
 0F6B C25D0F    	JNZ  RSH3	;IF MORE SHIFTS REQUIRED
 0F6E C9        	RET		;RETURN TO CALLER
                
                ;COMPLIMENT THE B, C, D, AND E REGISTERS
 0F6F 2B        COMP:	DCX  H		;TO ADDR THE ACC SIGN
 0F70 7E        	MOV  A,M	;ACC SIGN
 0F71 EE80      	XRI  80H	;CHANGE SIGN
 0F73 77        	MOV  M,A	;ACC SIGN
 0F74 AF        COMP1:	XRA  A		;ZERO -- FFIX ENTRY POINT
 0F75 6F        	MOV  L,A	;ZERO
 0F76 93        	SUB  E		;COMPLIMENT 4TH FRACTION
 0F77 5F        	MOV  E,A	;RESTORE TO E
 0F78 7D        	MOV  A,L	;ZERO
 0F79 9A        	SBB  D		;COMPLIMENT 3RD FRACTION
 0F7A 57        	MOV  D,A	;RESTORE TO D
 0F7B 7D        	MOV  A,L	;ZERO
 0F7C 99        	SBB  C		;COMPLIMENT 2ND FRACTION
 0F7D 4F        	MOV  C,A	;RESTORE TO C
 0F7E 7D        	MOV  A,L	;ZERO
 0F7F 98        	SBB  B		;COMPLIMENT 1ST FRACTION
 0F80 47        	MOV  B,A	;RESTORE TO B
 0F81 C9        	RET		;RETURN TO CALLER
                
                ;NORMALIZE THE REGISTERS
 0F82 2E20      NORM:	MVI  L,20H	;MAXIMUM NORMALIZING SHIFT
 0F84 78        NORM1:	MOV  A,B	;1ST FRACTION
 0F85 A7        	ANA  A		;SET CONTROL BITS
 0F86 C2A20F    	JNZ  NORM3	;IF 1ST FRACTION IS NON ZERO
 0F89 41        	MOV  B,C	;1ST FRACTION
 0F8A 4A        	MOV  C,D	;2ND FRACTION
 0F8B 53        	MOV  D,E	;3RD FRACTION
 0F8C 5F        	MOV  E,A	;ZERO 4TH FRACTION
 0F8D 7D        	MOV  A,L	;NORMALIZING SHIFT COUNT
 0F8E D608      	SUI  08		;REDUCE SHIFT COUNT
 0F90 6F        	MOV  L,A	;NORMALIZING SHIFT COUNT
 0F91 C2840F    	JNZ  NORM1	;IF FRACTION NON ZERO
 0F94 C9        	RET		;IF FRACTION IS ZERO
 0F95 2D        NORM2:	DCR  L		;DECREMENT SHIFT COUNT
 0F96 7B        	MOV  A,E	;ORIGINAL CONTENTS OF E
 0F97 17        	RAL		;LEFT SHIFT E
 0F98 5F        	MOV  E,A	;RESTORE TO E
 0F99 7A        	MOV  A,D	;ORIGINAL CONTENTS OF D
 0F9A 17        	RAL		;LEFT SHIFT D
 0F9B 57        	MOV  D,A	;RESTORE TO D
 0F9C 79        	MOV  A,C	;ORIGINAL CONTENTS OF C
 0F9D 17        	RAL		;LEFT SHIFT C
 0F9E 4F        	MOV  C,A	;RESTORE TO C
 0F9F 78        	MOV  A,B	;ORIGINAL CONTENTS OF B
 0FA0 8F        	ADC  A		;LEFT SHIFT B
 0FA1 47        	MOV  B,A	;RESTORE TO B
 0FA2 F2950F    NORM3:	JP   NORM2	;IF NOT YET NORMALIZED
 0FA5 7D        	MOV  A,L	;NORMALIZING SHIFT COUNT
 0FA6 D620      	SUI  20H	;REMOVE BIAS
 0FA8 21B340    	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 0FAB 86        	ADD  M		;ADJUST ACC EXPONENT
 0FAC 77        	MOV  M,A	;NEW ACC EXPONENT
 0FAD C8        	RZ		;RETURN IF ZERO EXPONENT
 0FAE 1F        	RAR		;BORROW BIT TO SIGN
 0FAF A7        	ANA  A		;SET SIGN TO INDICATE UNDERFLOW
 0FB0 C9        	RET		;RETURN TO CALLER
                
                ;ROUND THE B, C, AND D REGISTERS
 0FB1 21B340    ROND:	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 0FB4 7B        	MOV  A,E	;4TH FRACTION
 0FB5 A7        	ANA  A		;SET CONTROL BITS
 0FB6 5E        	MOV  E,M	;ACC EXPONENT
 0FB7 FCC10F    	CM   RNDR	;CALL 2ND LEVEL ROUNDER
 0FBA D8        	RC		;RETURN IF OVERFLOW
 0FBB 78        	MOV  A,B	;1ST FRACTION
 0FBC 23        	INX  H		;TO ADDR THE ACC SIGN
 0FBD AE        	XRA  M		;ACC SIGN AND 1ST FRACTION
 0FBE C3BF0D    	JMP  FSTR1	;RETURN THRU 'STORE' SUBROUTINE
                
                ;SECOND LEVEL ROUNDER
 0FC1 14        RNDR:	INR  D		;ROUND 3RD FRACTION
 0FC2 C0        	RNZ		;RETURN IF NO CARRY
 0FC3 0C        	INR  C		;CARRY TO 2ND FRACTION
 0FC4 C0        	RNZ		;RETURN IF NO CARRY
 0FC5 04        	INR  B		;CARRY TO 1ST FRACTION
 0FC6 C0        	RNZ		;RETURN IF NO CARRY
 0FC7 7B        	MOV  A,E	;ACC EXPONENT
 0FC8 C601      	ADI  1		;INCREMENT ACC EXPONENT
 0FCA 5F        	MOV  E,A	;NEW ACC EXPONENT
 0FCB 0680      	MVI  B,80H	;NEW 1ST FRACTION
 0FCD 77        	MOV  M,A	;NEW ACC EXPONENT
 0FCE C9        	RET		;RETURN TO 1ST LEVEL ROUNDER
                
                ;FIXED POINT MULTIPLY
 0FCF 211840    MULX:	LXI  H,MULX4+9	;TO ADDR THE 1ST MULTIPLICAND
 0FD2 77        	MOV  M,A	;1ST MULTIPLICAND
 0FD3 211440    	LXI  H,MULX4+5	;TO ADDR THE 2ND MULTIPLICAND
 0FD6 72        	MOV  M,D	;2ND MULTIPLICAND
 0FD7 211040    	LXI  H,MULX4+1	;TO ADDR THE 3RD MULTIPLICAND
 0FDA 73        	MOV  M,E	;3RD MULTIPLICAND
 0FDB AF        	XRA  A		;CLEAR 6TH PRODUCT
 0FDC 5F        	MOV  E,A	;CLEAR 5TH PRODUCT
 0FDD 57        	MOV  D,A	;CLEAR 4TH PRODUCT
                
                ;MULTIPLY BY EACH ACCUMULATOR FRACTION IN TURN
 0FDE 21B740    	LXI  H,ACC3	;TO ADDR THE 3RD FRACTION
 0FE1 CDF00F    	CALL MULX2	;MULTIPLY BY ACC 3RD FRACTION
 0FE4 21B640    	LXI  H,ACC2	;TO ADDR THE 2ND FRACTION
 0FE7 CDED0F    	CALL MULX1	;MULTIPLY BY ACC 2ND FRACTION
 0FEA 21B540    	LXI  H,ACC1	;TO ADDR THE 1ST FRACTION
                
                ;MULTIPLY BY ONE ACCUMULATOR WORD
 0FED 7A        MULX1:	MOV  A,D	;5TH PARTIAL PRODUCT
 0FEE 59        	MOV  E,C	;4TH PARTIAL PRODUCT
 0FEF 50        	MOV  D,B	;3RD PARTIAL PRODUCT
 0FF0 46        MULX2:	MOV  B,M	;MULTIPLIER
 0FF1 6F        	MOV  L,A	;5TH PARTIAL PRODUCT
 0FF2 AF        	XRA  A		;ZERO
 0FF3 4F        	MOV  C,A	;TO 2ND PARTIAL PRODUCT
 0FF4 90        	SUB  B		;SET CARRY BIT FOR EXIT FLAG
 0FF5 D2D010    	JNC  FFIX0	;MULTIPLY BY 0
                
                ;LOOP FOR EACH BIT OF MULTIPLIER WORD
 0FF8 7D        MULX3:	MOV  A,L	;5TH PARTIAL PRODUCT, EXIT FLAG
 0FF9 8F        	ADC  A		;SHIFT EXIT FLAG OUT IF DONE
 0FFA C8        	RZ		;EXIT IF MULTIPLICATION DONE
 0FFB 6F        	MOV  L,A	;5TH PARTIAL PRODUCT, EXIT FLAG
 0FFC 7B        	MOV  A,E	;4TH PARTIAL PRODUCT
 0FFD 17        	RAL		;SHIFT 4TH PARTIAL PRODUCT
 0FFE 5F        	MOV  E,A	;4TH PARTIAL PRODUCT
 0FFF 7A        	MOV  A,D	;3RD PARTIAL PRODUCT
 1000 17        	RAL		;SHIFT 3RD PARTIAL PRODUCT
 1001 57        	MOV  D,A	;3RD PARTIAL PRODUCT
 1002 79        	MOV  A,C	;2ND PARTIAL PRODUCT
 1003 17        	RAL		;SHIFT 2ND PARTIAL PRODUCT
 1004 4F        	MOV  C,A	;2ND PARTIAL PRODUCT
 1005 78        	MOV  A,B	;1ST PARTIAL PRODUCT AND MULTIPLIER
 1006 17        	RAL		;SHIFT THEM
 1007 47        	MOV  B,A	;1ST PARTIAL PRODUCT AND MULTIPLIER
 1008 D2F80F    	JNC  MULX3	;IF NO ADDITION REQUIRED
                
                ;ADD THE MULTIPLICAND TO THE PRODUCT IF THE MULTIPLIER BIT IS A ONE
 100B 7B        	MOV  A,E	;4TH PARTIAL PRODUCT
 100C CD0F40    	CALL MULX4	;TO RAM CODE
                
                ;COMPLETE ADDITION OF MULTIPLICAND
 100F 4F        	MOV  C,A	;2ND PARTIAL PRODUCT
 1010 D2F80F    	JNC  MULX3	;IF NO CARRY TO 1ST PRODUCT
 1013 04        	INR  B		;ADD CARRY TO 1ST PRODUCT
 1014 A7        	ANA  A		;CLEAR CARRY BIT
 1015 C3F80F    	JMP  MULX3
                
                ;FIXED POINT DIVIDE
                ;
                ;SUBTRACT THE DIVISOR FROM THE ACCUMULATOR TO OBTAIN THE FIRST REMAINDER
 1018 21B740    DIVX:	LXI  H,ACC3	;TO ADDR THE ACC 3RD FRACTION
 101B 7E        	MOV  A,M	;ACC 3RD FRACTION
 101C 93        	SUB  E		;DIVISOR 3RD FRACTION
 101D 77        	MOV  M,A	;REMAINDER 3RD FRACTION
 101E 2B        	DCX  H		;TO ADDR THE ACC 2ND FRACTION
 101F 7E        	MOV  A,M	;ACC 2ND FRACTION
 1020 9A        	SBB  D		;DIVISOR 2ND FRACTION
 1021 77        	MOV  M,A	;REMAINDER 2ND FRACTION
 1022 2B        	DCX  H		;TO ADDR THE ACC 1ST FRACTION
 1023 7E        	MOV  A,M	;ACC 1ST FRACTION
 1024 99        	SBB  C		;DIVISOR 1ST FRACTION
 1025 77        	MOV  M,A	;REMAINDER 1ST FRACTION
                
                ;HALVE THE DIVISOR AND STORE FOR ADDITION OR SUBTRACTION
 1026 79        	MOV  A,C	;DIVISOR 1ST FRACTION
 1027 17        	RAL		;SET CARRY BIT
 1028 79        	MOV  A,C	;DIVISOR 1ST FRACTION
 1029 1F        	RAR		;HALF OF DIVISOR 1ST FRACTION
 102A 322640    	STA  DIVX5+12	;1ST SUBTRACT DIVISOR
 102D 323440    	STA  DIVX6+9	;1ST ADD DIVISOR
 1030 7A        	MOV  A,D	;DIVISOR 2ND FRACTION
 1031 1F        	RAR		;HALF OF DIVISOR 2ND FRACTION
 1032 322240    	STA  DIVX5+8	;2ND SUBTRACT DIVISOR
 1035 323040    	STA  DIVX6+5	;2ND ADD DIVISOR
 1038 7B        	MOV  A,E	;DIVISOR 3RD FRACTION
 1039 1F        	RAR		;HALF OF DIVISOR 3RD FRACTION
 103A 321E40    	STA  DIVX5+4	;3RD SUBTRACT DIVISOR
 103D 322C40    	STA  DIVX6+1	;3RD ADD DIVISOR
 1040 0600      	MVI  B,0	;INIT QUOTIENT 1ST FRACTION
 1042 78        	MOV  A,B	;DIVISOR 4TH QUOTIENT IS ZERO
 1043 1F        	RAR		;LOW BIT OF DIVISOR 3RD FRACTION
 1044 321B40    	STA  DIVX5+1	;4TH SUBTRACT DIVISOR
 1047 322940    	STA  DIVX5+15	;4TH ADD DIVISOR
 104A 323740    	STA  DIVX6+12	;4TH ADD DIVISOR
                
                ;LOAD FIRST REMAINDER AND CHECK SIGN
 104D 21B540    	LXI  H,ACC1	;TO ADDR THE REMAINDER 1ST FRACTION
 1050 7E        	MOV  A,M	;REMAINDER 1ST FRACTION
 1051 23        	INX  H		;TO ADDR THE REMAINDER 2ND FRACTION
 1052 56        	MOV  D,M	;REMAINDER 2ND FRACTION
 1053 23        	INX  H		;TO ADDR THE REMAINDER 3RD FRACTION
 1054 5E        	MOV  E,M	;REMAINDER 3RD FRACTION
 1055 A7        	ANA  A		;SET CONTROL BITS
 1056 FA8410    	JM   DIVX4	;IF REMAINDER IS NEGATIVE
                
                ;ADJUST THE EXPONENT, POSITION THE REMAINDER, AND INITIALIZE THE QUOTIENT
 1059 21B340    	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 105C 4E        	MOV  C,M	;QUOTIENT EXPONENT
 105D 0C        	INR  C		;INCREMENT THE QUOTIENT EXPONENT
 105E C8        	RZ		;RETURN IF OVERFLOW
 105F 71        	MOV  M,C	;QUOTIENT EXPONENT
 1060 6B        	MOV  L,E	;REMAINDER 3RD FRACTION
 1061 62        	MOV  H,D	;REMAINDER 2ND FRACTION
 1062 5F        	MOV  E,A	;REMAINDER 1ST FRACTION
 1063 1601      	MVI  D,1	;INITIALIZE QUOTIENT 3RD FRACTION
 1065 48        	MOV  C,B	;INITIALIZE QUOTIENT 2ND FRACTION
                
                ;SUBTRACT THE DIVISOR FROM THE REMAINDER IF IT IS POSITIVE
 1066 AF        DIVX1:	XRA  A		;REMAINDER 4TH FRACTION IS ZERO
 1067 CD1A40    	CALL DIVX5	;CALL RAM CODE
 106A 07        DIVX2:	RLC		;SHIFT REMAINDER 4TH FRACTION TO CARRY
                
                ;SHIFT THE REMAINDER LEFT ONE BIT
 106B 78        	MOV  A,B	;QUOTIENT 1ST FRACTION
 106C 17        	RAL		;MSB OF QUOTIENT TO CARRY
 106D D8        	RC		;IF DIVISION COMLPETE
 106E 1F        	RAR		;REMAINDER 4TH FRACTION TO CARRY
 106F 7D        	MOV  A,L	;REMAINDER 3RD FRACTION
 1070 17        	RAL		;LEFT SHIFT REMAINDER 3RD FRACTION
 1071 6F        	MOV  L,A	;REMAINDER 3RD FRACTION
 1072 7C        	MOV  A,H	;REMAINDER 2ND FRACTION
 1073 17        	RAL		;LEFT SHIFT REMAINDER 2ND FRACTION
 1074 67        	MOV  H,A	;REMAINDER 2ND FRACTION
 1075 CD3C0F    	CALL LSH	;LEFT SHIFT IT
                
                ;BRANCH IF SUBTRACTION IS REQUIRED
 1078 7A        	MOV  A,D	;QUOTIENT 3RD FRACTION
 1079 0F        	RRC		;REMAINDER SIGN TO CARRY BIT
 107A DA6610    	JC   DIVX1	;SUBTRACT DIVISOR IF REMAINDER IS POSITIVE
                
                ;ADD THE DIVISOR IF THE REMAINDER IS NEGATIVE
 107D 7D        DIVX3:	MOV  A,L	;REMAINDER 3RD FRACTION
 107E CD2B40    	CALL DIVX6	;TO RAM CODE
 1081 C36A10    	JMP  DIVX2
                
                ;POSITION THE REMAINDER AND INITIALIZE THE QUOTIENT
 1084 6B        DIVX4:	MOV  L,E	;REMAINDER 3RD FRACTION
 1085 62        	MOV  H,D	;REMAINDER 2ND FRACTION
 1086 5F        	MOV  E,A	;REMAINDER 1ST FRACTION
 1087 50        	MOV  D,B	;INITIALIZE QUOTIENT 3RD FRACTION
 1088 48        	MOV  C,B	;INITIALIZE QUOTIENT 2ND FRACTION
 1089 C37D10    	JMP  DIVX3	;ADD DIVISOR IF REMAINDER IS NEGATIVE
                
                ;FIXED POINT TO FLOATING POINT CONVERSION
 108C 6B        FFLOT:	MOV  L,E	;INPUT EXPONENT
 108D 5A        	MOV  E,D	;4TH INPUT FRACTION
 108E 51        	MOV  D,C	;3RD INPUT FRACTION
 108F 48        	MOV  C,B	;2ND INPUT FRACTION
 1090 47        	MOV  B,A	;1ST INPUT FRACTION
 1091 7D        	MOV  A,L	;INPUT EXPONENT
 1092 EE80      FLOT1:	XRI  80H	;APPLY EXPONENT BIAS
 1094 21B340    	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 1097 77        	MOV  M,A	;ACC EXPONENT
 1098 23        	INX  H		;TO ADDR THE ACC SIGN
 1099 3680      	MVI  M,80H	;SET ACC SIGN POSITIVE
 109B 23        	INX  H		;TO ADDR THE ACC 1ST FRACTION
 109C 78        	MOV  A,B	;1ST INPUT FRACTION
 109D A7        	ANA  A		;SET SIGN BIT
 109E 17        	RAL		;INPUT SIGN TO CARRY
 109F C3EB0E    	JMP  FADD6	;COMPLETE THE CONVERSION
                
                ;FLOATING POINT TO FIXED POINT CONVERSION
 10A2 21B340    FFIX:	LXI  H,ACCE	;TO ADDR THE ACC EXPONENT
 10A5 7E        	MOV  A,M	;ACC EXPONENT
 10A6 A7        	ANA  A		;SET CONTROL BITS
 10A7 CAD310    	JZ   FFIX1	;IF ACC IS ZERO
 10AA 7B        	MOV  A,E	;INPUT EXPONENT
 10AB C67F      	ADI  7FH	;APPLY BIAS-1
 10AD 96        	SUB  M		;SHIFT COUNT - 1
 10AE DAD810    	JC   FFIX2	;CHECK FOR -32768 IF TOO LARGE
 10B1 FE1F      	CPI  1FH	;COMPARE TO LARGE SHIFT
 10B3 D2D310    	JNC  FFIX1	;IF ACC TOO SMALL
 10B6 C601      	ADI  1		;SHIFT COUNT
 10B8 21B540    	LXI  H,ACC1	;TO ADDR THE ACC 1ST FRACTION
 10BB 46        	MOV  B,M	;ACC 1ST FRACTION
 10BC 23        	INX  H		;TO ADDR THE ACC 2ND FRACTION
 10BD 4E        	MOV  C,M	;ACC 2ND FRACTION
 10BE 23        	INX  H		;TO ADDR THE ACC 3RD FRACTION
 10BF 56        	MOV  D,M	;ACC 3RD FRACTION
 10C0 CD490F    	CALL RSH	;POSITION THE FRACTION
 10C3 21B440    	LXI  H,ACCS	;TO ADDR THE ACC SIGN
 10C6 7E        	MOV  A,M	;ACC SIGN
 10C7 A7        	ANA  A		;SET CONTROL BITS
 10C8 F4740F    	CP   COMP1	;COMPLIMENT FRACTION IF NEGATIVE
 10CB 3E01      	MVI  A,1	;NON-ZERO
 10CD B0        	ORA  B		;SET CONTROL BITS FOR EXIT
 10CE 78        	MOV  A,B	;1ST RESULT
 10CF 41        	MOV  B,C	;2ND RESULT
 10D0 4A        FFIX0:	MOV  C,D	;3RD RESULT  -- MULX2 ENTRY POINT
 10D1 53        	MOV  D,E	;4TH RESULT
 10D2 C9        	RET		;RETURN TO CALLER
 10D3 AF        FFIX1:	XRA  A		;ZERO
 10D4 47        	MOV  B,A	;ZERO
 10D5 4F        	MOV  C,A	;ZERO
 10D6 57        	MOV  D,A	;ZERO
 10D7 C9        	RET		;RETURN TO CALLER
                ;FIX2 CHECKS FOR -32768 (90H, 0, 80H, 0, 0) IN FACC, OTHERWISE RETURNS CARRY.
 10D8 7E        FFIX2:	MOV  A,M
 10D9 D690      	SUI  90H
 10DB 23        	INX  H
 10DC B6        	ORA  M
 10DD 23        	INX  H
 10DE 4E        	MOV  C,M	;ACC1 TO C
 10DF 23        	INX  H
 10E0 B6        	ORA  M
 10E1 23        	INX  H
 10E2 B6        	ORA  M
 10E3 37        	STC
 10E4 C0        	RNZ		;ACCE <> 90H OR ACCS, ACC2, ACC3 <> 0
 10E5 47        	MOV  B,A	;0 TO B IN CASE SUCCESS
 10E6 79        	MOV  A,C
 10E7 FE80      	CPI  80H
 10E9 C8        	RZ		;-32768, RETURN 80H IN A AND 0 IN B
 10EA 37        	STC
 10EB C9        	RET		;ACC1 <> 80H
                
                ;FLOATING POINT INCREMENT ROUTINE FOR FAST NEXT CODE
 10EC 7E        FINCR:	MOV	A,M	;GET ARGUMENT EXPONENT
 10ED FE81      	CPI	81H	;DOES IT HAVE THE EXPONENT OF A FP ONE?
 10EF C2550E    	JNZ	FADD	;NOPE - HAVE TO PLOW THRU A FP ADD
 10F2 E5        	PUSH	H	;YUP - TEST REMAINDER OF BYTES
 10F3 23        	INX	H
 10F4 7E        	MOV	A,M
 10F5 23        	INX	H
 10F6 B6        	ORA	M
 10F7 23        	INX	H
 10F8 B6        	ORA	M
 10F9 E1        	POP	H
 10FA C2550E    	JNZ	FADD	;NOT A FP ONE, HAVE TO USE ADD
 10FD E5        	PUSH	H
 10FE 21B340    	LXI	H,ACCE	;SEE IF ACC IS EASY TO INCREMENT
 1101 7E        	MOV	A,M
 1102 B7        	ORA	A	;IS IT ZERO?
 1103 CA0911    	JZ	FINC1	;YES - HARD TO INCREMENT
 1106 3D        	DCR	A	;GENERATE A CARRY IF FACC IS >=1 AND
 1107 23        	INX	H
 1108 86        	ADD	M	;POSITIVE
 1109 E1        FINC1:	POP	H
 110A D2550E    	JNC	FADD	;NOT EASY TO INCREMENT
 110D 3AB340    	LDA	ACCE	;GET CURRENT EXPONENT
 1110 1E00      	MVI	E,0	;TO DEFEAT ETEST
 1112 FE9A      	CPI	25+81H	;WILL EXPONENTS DIFFER BY MORE THAN 23?
 1114 D0        	RNC		;YES - NO POINT IN ADDING
 1115 D681      	SUI	81H	;DIFFERENCE OF EXPONENTS NOW IN REG A
 1117 010080    	LXI	B,8000H	;PUT MANTISSA OF FP ONE INTO REGS BCD
 111A 51        	MOV	D,C
 111B CA3B11    	JZ	FINC4
 111E 5F        	MOV	E,A	;SAVE DIFFERENCE
 111F E607      	ANI	7	;TAKE DIFFERENCE MOD 8
 1121 6F        	MOV	L,A	;BITS TO ROTATE THE SIGNIFFICANT BIT
 1122 78        	MOV	A,B	;FETCH SIG BIT TO ROTATE
 1123 CA2B11    	JZ	FINC3	;BIT IN RIGHT POS, NOW PICK RIGHT BYTE
 1126 0F        FINC2:	RRC		;KEEP ROTATING UNTIL IN RIGHT PLACE
 1127 2D        	DCR	L
 1128 C22611    	JNZ	FINC2
 112B 47        FINC3:	MOV	B,A	;ASSUME BIT BELONGS IN 1ST FRACTION
 112C 7B        	MOV	A,E	;TEST NUMBER OF BITS TO SEE IF IT IS SO
 112D FE08      	CPI	8	;SET CARRY IF IT BELONGS HERE
 112F DA3B11    	JC	FINC4	;IN WHICH CASE, ALL IS SHIFTED
 1132 48        	MOV	C,B	;ASSUME BIT BELONGS IN 2ND FRACTION
 1133 45        	MOV	B,L	;ZERO 1ST FRACTION
 1134 FE10      	CPI	16	;SET CARRY IF IT BELONGS IN 2ND FRACTION
 1136 DA3B11    	JC	FINC4
 1139 51        	MOV	D,C	;WELL, IT MUST BELONG IN 3RD FRACTION
 113A 4D        	MOV	C,L	;ZERO SECOND FRACTION
 113B 21B740    FINC4:	LXI	H,ACC3	;NEEDED BY ADD4
 113E C3B80E    	JMP	FADD4
                
                
                	ENDIF		;END OF FLOAT CONDITIONAL
                
                ;END OF FMATH
                	PAGE
                
                ;FPBCD 11/19/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;BCD FLOATING POINT PACKAGE
                
                
                	IF	FLOAT AND FPBCD
                ;
                ;   FORMAT:  6 BYTES
                ;      BYTE 0
                ;           BITS 0-6:  EXCESS-64 EXPONENT
                ;           BIT  7:  SIGN
                ;      BYTES 1-5:  10-DIGIT BCD FRACTION
                ;   N = (-1)^S * 10^(E - 64) * 0.DDDDDDDDDD
                ;
                BIAS	EQU	64		;EXPONENT BIAS
                
                ;
                ;  CONSTANT DATA (ROMABLE)
                ;
                EMAX 	DB 	043H,014H,073H,0,0,0 ;MAX. EXP. ARGUMENT
                FPMAX 	DB 	07FH,099H,099H,099H,099H,099H
                INTMX 	DB 	045H,032H,076H,070H,0,0
                INTMN 	DB 	0C5H,032H,076H,080H,0,0
                ;
                ; CONSTANTS FOR USE IN FUNCTIONS
                ATAN1	DB 	040H		;ARCTAN(1)
                	DB	078H,053H,098H,016H,033H
                D12PI	DB	040H		;1/(2PI)
                	DB 	015H,091H,054H,094H,031H
                D1LE4	DB	040H		;1/(LOG E 4)
                	DB	057H,056H,046H,027H,031H
                D1L10	DB	040H		;1/LN(10)
                	DB	043H,042H,094H,048H,019H
                D4PI	DB	041H		;4/PI
                	DB	012H,073H,023H,095H,045H
                DPI2	DB	041H		;PI/2
                	DB	015H,070H,079H,063H,027H
                DPI4	DB	040H		;PI/4
                	DB	078H,053H,098H,016H,034H
                DSR22	DB	040H		;SQR(2)/2
                	DB	070H,071H,6,078H,010H
                HALF	DB	040H,050H,0,0,0,0
                LN10	DB	041H		;LN(10)
                	DB	023H,2,058H,050H,093H
                LN2	DB	040H		;LN(2)
                	DB	069H,031H,047H,018H,6 
                PI  	DB	041H,031H,041H,059H,026H,054H
                SR2M1	DB	040H		;SQR(2) - 1
                	DB	041H,042H,013H,056H,020H
                SR2P1  DB	041H		;SQR(2) + 1
                	DB	024H,014H,021H,035H,062H
                SQR10	DB	041H		;SQR(10)
                	DB	031H,062H,027H,076H,060H
                THIRD	DB	040H,033H,033H	;1/3
                	DB	033H,033H,033H
                TWO	DB	041H,020H,0
                	DB	0,0,0
                TWOPI	DB	041H,062H,083H	;2 PI
                	DB	018H,053H,7
                ;
                ;  COEFFICIENTS FOR FUNCTION EXPANSIONS
                ;
                ;  TANGENT
                TB3	DB	0C2H,015H,078H
                	DB	030H,032H,084H
                	DB	0C4H,014H,9
                	DB	063H,024H,018H
                	DB	0C2H,040H,098H
                	DB	017H,8,075H
                	DB	0C3H,015H,069H
                	DB	020H,4,022H
                	DB	0C2H,055H,020H
                	DB	040H,041H,071H
                	DB	0C1H,094H,038H
                	DB	016H,055H,098H
                TC0	DB	03FH,035H,091H
                	DB	010H,014H,097H
                ;  COSINE
                FPONE	DB	041H,010H,0
                	DB	0,0,0
                	DB	0C0H,030H,084H
                	DB	025H,013H,075H
                	DB	03FH,015H,085H
                	DB	043H,044H,020H
                	DB	0BDH,032H,059H
                	DB	091H,089H,0
                	DB	03BH,035H,090H
                	DB	086H,0,0
                CP05	DB	0B9H,024H,061H
                	DB	0,0,0
                	DB	040H,078H,053H
                	DB	098H,016H,034H
                	DB	0BFH,080H,074H
                	DB	055H,012H,019H
                	DB	03EH,024H,090H
                  	DB	039H,045H,070H
                	DB	0BCH,036H,057H
                	DB	062H,0,0
                CP14	DB	03AH,031H,033H
                	DB	0,0,0
                ;  ARCTAN
                	DB	043H,021H,060H
                	DB	062H,030H,079H
                	DB	043H,032H,026H
                	DB      062H,7,0
                	DB	043H,013H,027H
                	DB	2,039H,082H
                FATP3	DB	042H,012H,088H
                	DB	083H,083H,3
                	DB	043H,021H,060H
                	DB	062H,030H,079H
                	DB	043H,039H,046H
                	DB	082H,083H,093H
                	DB	043H,022H,010H
                	DB	050H,088H,030H
                FATQ3	DB	042H,038H,050H
                	DB	014H,086H,051H
                ;  EXP
                EB2	DB	042H,090H,0      
                	DB 	0,0,0
                	DB	042H,028H,0
                	DB	0,0,0
                	DB	043H,033H,0
                	DB	0,0,0
                	DB	0C5H,014H,058H
                	DB	0,0,0
                ;  NATURAL LOG
                LB3	DB	0C1H,013H,012H
                	DB	082H,059H,017H
                	DB	0C1H,033H,050H
                  	DB	025H,024H,081H
                	DB	0C1H,025H,084H
                	DB	017H,087H,055H
                	DB	0C0H,012H,087H
                	DB	020H,099H,053H
                	DB	0C1H,051H,002H
                	DB	099H,053H,028H
                	DB	0C1H,059H,041H
                	DB	022H,044H,090H
                LC0	DB	040H,041H,079H
                	DB	059H,018H,037H
                ;  SQUARE ROOT
                	DB	040H,014H,053H
                	DB	043H,0,051H
                	DB	041H,018H,046H
                	DB	072H,073H,095H
                	DB	0C1H,018H,078H
                	DB	050H,038H,016H
                SR3	DB	040H,090H,010H
                	DB	015H,056H,4
                ;  SQUARE ROOT (X >= .25)
                	DB	040H,025H,092H
                	DB	080H,058H,067H
                	DB	041H,010H,052H
                	DB	3,026H,060H
                SR6	DB	0C0H,031H,063H
                	DB	024H,089H,045H
                ;
                ;  BINARY-DECIMAL CONVERSION TABLE
                BDTAB	DB	0,0,1
                	DB	0,0,2
                	DB	0,0,4
                	DB	0,0,8
                	DB	0,0,016H
                	DB	0,0,032H
                	DB	0,0,064H
                	DB	0,1,028H
                	DB	0,2,056H
                	DB	0,5,012H
                	DB	0,010H,024H
                	DB	0,020H,048H
                	DB	0,040H,096H
                	DB	0,081H,092H
                	DB	1,063H,084H
                	DB	3,027H,068H
                
                ;
                ;  ADDITION  (FACC) <== (FACC) + (H,L)
                FADT2	LXI	H,FTMP2
                FADD	MOV 	A,M
                	ORA	A
                	RZ	         	;OP-2 = 0
                	LXI  	D,FACC
                	LDAX  	D
                   	ORA	A
                	JZ  	FLOAD		;OP-1 = 0
                FADD0	XRA	M
                	PUSH   	PSW		;(SF) ==> SUBTRACT
                	LDAX 	D
                	ANI	080H
                	STA	SIGN		;STORE SIGN OF OP-1
                	MVI	A,6
                	STA   	FLEN		;DEFAULT LENGTH = 6
                	MOV  	A,M
                	ANI	07FH		;FORM EXP-2
                	STA	EXP2
                	CALL	UPAC2
                	LXI  	H,EXP1
                   	MOV  	M,A
                	INX	H
                	SUB 	M		;A <== EXP1 - EXP2
                	MOV 	C,A
                	LXI	H,FACC+5
                	SHLD	RSLT		;SUM LOCATION
                	CPI	-10
                	JNC	FAD1		;-10 <= DIFF < 0
                	CPI	11
                	JC	FAD1		;0 <= DIFF <= 10
                	ORA	A
                	JP	FAD9		;DONE IF DIFF > 10
                ;    DIFF < -10
                	CALL	FZACC	  	;FACC <== 0
                	LDA 	EXP2
                	STA	EXP1		;EXP1 <== EXP2
                FAD1	MVI     B,0
                	PUSH  	B
                	XCHG			;(H,L) <== OP-2
                	INX  	H		;POINT TO FRACTION
                	MVI	C,5
                	LXI	D,ACALT+6
                	CALL  	FMOVE		;ACALT+6 <== OP-2 FRACTION
                	MOV 	H,D		;(H,L) = (D,E) = OP-2
                	MOV	L,E
                	POP	B
                	MOV	A,C
                	ORA	A
                	JZ 	FAD8		;DIFF = 0
                	JM  	FAD4		;DIFF < 0
                ;     DIFF > 0
                	ANI	1
                	JZ 	FAD2		;EVEN
                ;        DIFF > 0 AND ODD
                	INX	D
                	PUSH	B
                	LXI	B,6
                	CALL	FD10		;DIV. OP-2 BY 10
                	LHLD	RSLT		;DESTINATION
                	INX	H		;INCR. IT
                	POP	B
                	JMP	FAD3
                FAD2	LHLD	RSLT
                FAD3	MOV	A,C
                	RAR
                	MOV	C,A		;HALF OF DIFF
                	DAD	B		;ADD BYTE SHIFT TO DEST.
                        SHLD    RSLT
                	LXI	H,FLEN
                	ADD	M
                	MOV	M,A		;TOTAL FIELD LENGTH
                	JMP	FAD8
                ;     DIFF < 0
                FAD4	LXI	H,FACC+1
                	ANI	1
                	JZ	FAD5		;EVEN
                ;     ODD AND < 0
                	PUSH	B
                	LXI 	B,6
                	CALL	FD10		;FACC <==  FACC/10
                	POP	B
                FAD5	XRA	A
                	MOV	B,A		;B=0
                  	SUB	C		;A = -DIFF
                	RAR			;A = BYTE SHIFT
                	ANI	07FH
                	JZ	FAD7		;NO BYTE SHIFT
                	MOV	C,A		;(B,C) <== -DIFF/2
                	DAD	B
                	DCX	H
                	PUSH	D
                	CALL	FSTOR		;SHIFT FACC RIGHT
                	POP	D
                FAD6	DCX	H
                	MOV	M,B		;CLEAR START OF FIELD
                	DCR	C
                	JNZ	FAD6
                FAD7	LDA	EXP2
                	STA	EXP1		;EXP1 <== LARGER EXP
                FAD8	XCHG			;(H,L) <== OP-2
                	LXI	B,4
                	DAD	B
                	XCHG			;(D,E) <== LOW END OP-2
                	LHLD	RSLT
                	INR	C		;LOOP COUNTER = 6
                	INR	C
                	POP	PSW		;XOR OF SIGNS
                	JM	FSUB1		;SUBTRACT
                	CALL	FADDL		;ADD LOOP
                	CALL 	FRNRM
                	JMP	FRND		;ROUND
                FAD9	POP	PSW
                	JMP	FRND0
                ;  ADD LOOP
                FADDL	XRA	A		;CLEAR CARRY
                FADL1	LDAX	D
                	ADC	M
                	DAA
                	MOV	M,A
                	DCX	D
                	DCX	H
                	DCR	C
                	JNZ	FADL1
                	RNC			;DONE IF NO CARRY
                FADL0   MOV	A,M		;CARRY 1
                	ADI	1
                	DAA
                	MOV	M,A
                	DCX	H
                	JC	FADL0
                	RET
                ;
                ;  ABSOLUTE VALUE
                FABS	LXI	H,FACC
                	MOV	A,M
                	ANI	07FH
                	MOV	M,A
                	RET
                ;
                ;  ARCTAN
                ;  IF ABS(X) > 10 E 10 THEN FATAN(X) = SGN(X) * PI/2
                ;  IF ABS(X) <= 5 E -4 THEN FATAN(X) = X - X^3/3
                ;  ELSE  ABS(X) <= SQR(2) -1 :   X0=0, Y=X
                ;        ABS(X) > SQR(2) + 1 :   X0=INFINITY, Y = -1/X
                ;        SQR(2) - 1 < ABS(X) < SQR(2)+1:  X0=1, Y=(X-1)/(X+1)
                ;  FATAN(X) = FATAN(X0) + FATAN(Y) WHERE
                ;     FATAN(Y) = Y * P(Y^2)/Q(Y^2)
                FATAN	LXI	H,FACC
                	MOV	A,M
                	ANI 	080H
                	STA	SIGN1		;SAVE SIGN 
                	MOV	A,M
                	ANI	07FH
                	MOV	M,A		;X <== ABS(X)
                 	CPI	BIAS+11
                	JNC	FAT97		;EXP > 10
                	CPI	BIAS-4
                	JC	FAT98		;EXP < -4
                	JNZ     FAT0		;EXP > -4
                	INX	H		;EXP = -4
                	MOV	A,M
                 	DCX	H
                	CPI	6
                	JC	FAT98		;Z <= 5 E (-4)
                ;     5 E (-4) < X < E 10
                FAT0    LXI	H,SR2M1	;SQR(2) - 1
                	CALL	FCMP
                	JNC	FAT1		;X > SQR(2) -1
                ;     X <= SQR(2) -1
                	LXI 	H,FTMP2
                	MVI	C,6
                	CALL 	FZERO		;X0 = 0 = ARCTAN(0)
                	JMP	FAT4
                FAT1    LXI     H,SR2P1
                	CALL	FCMP
                	JC	FAT2
                ;     X > SQR(2) + 1
                        LXI	H,DPI2
                        LXI	D,FTMP2
                	CALL	FLOD1		;X0 = PI/2 = ARCTAN(INFINITY)
                	CALL	FLINV		;FACC <== 1/X
                	CALL	FCHS		;FACC <== -1/X
                	JMP	FAT4
                ;     SQR(2) - 1 < X < SQR(2) + 1
                FAT2	LXI	H,ATAN1
                	LXI	D,FTMP2
                	CALL	FLOD1		;X0 = ARCTAN(1)
                	LXI	H,FPONE
                	CALL	FADD		;FACC <== X+1
                	CALL	FSTT1		;SAVE IN FTMP1
                	LXI	H,TWO
                	CALL	FSUB		;FACC <== X-1
                	LXI	H,FTMP1
                	CALL	FDIV		;FACC <== (X-1)/(X+1)
                FAT4	CALL	FSTT3		;FTMP3 <== Y
                	CALL	FCO35		;FTMP1 <== Y^2
                ;     RATIONAL FUNCTION
                ;        DENOMINATOR
                	LXI     H,FATQ3 
                	MVI 	C,3  
                	CALL	FPLY0
                	CALL	FSTT4		;STORE DENOM. IN FTMP4
                ;        NUMERATOR
                	LXI	H,FTMP1
                	CALL	FLOAD
                	LXI	H,FATP3
                	MVI	C,3
                	CALL	FPOLY
                	LXI	H,FTMP3
                	CALL	FMUL		; *Y
                	LXI	H,FTMP4
                	CALL	FDIV		;P/Q
                	CALL	FADT2		;+ARCTAN(X0)
                FAT6	LXI	H,FACC
                	LDA	SIGN1
                	ORA	M		;APPEND SIGN
                	MOV	M,A
                	RET
                ;     IF X > 1 E 10 THEN FATAN(X) = SGN(X) * PI/2
                FAT97	LXI	H,DPI2
                	CALL	FLOAD
                	JMP	FAT6
                ;     IF X < 5 E (-4) THEN FATAN(X) = X - X^3/3
                FAT98	CALL	FSTT1		;STORE IN FTMP1
                	CALL	FMUL		;SQUARE X
                        LXI     H,FTMP1
                	CALL	FMUL		;CUBE X
                	LXI	H,THIRD
                	CALL	FMUL
                	LXI	H,FTMP1
                	CALL	FSUB
                	JMP	FAT6
                ;
                ;  FLOATING POINT A TO X POWER
                FATOX	XCHG
                	INX	H
                	LDA	FACC
                	ORA	A
                	JZ	FATX1		;0 TO POWER
                	JM	FATX2		;NEG TO POWER
                	PUSH	H
                FATX0	CALL	FLN
                	POP	H
                	CALL	FMUL
                	JMP	FEXP		;A^X = EXP (X * LN (A))
                ;     0 TO POWER
                FATX1	ORA	M
                	JM	FOVER		;0 TO NEGATIVE
                	RET
                ;     NEGATIVE TO POWER
                FATX2	PUSH	H
                	CALL	FSTT1		;SAVE A IN FTMP1
                	POP	H
                	PUSH	H
                	CALL	FLOAD		;LOAD POWER
                	CALL	FSTT2		;AND SAVE IN FTMP2
                	CALL	FFIX		;GET INTEGER PART OF POWER
                	POP	H
                	PUSH	B		;AND SAVE INTEGER PART
                	PUSH	H
                	CALL	FCMP
                	POP	H
                	JNZ	FATX4		;NEGATIVE A TO NONINTEGER X
                	CALL	FLONE		;LOAD 1 = A^0
                	POP	D		;INTEGER POWER TO DE
                	LDA	FTMP2
                	ORA	A
                	RZ			;DONE IF POWER IS 0
                	CM	CPLDE		;COMPLEMENT POWER IF NEGATIVE
                	MOV	A,D
                	ORA	A
                	JNZ	FOVER		;POWER TOO HIGH
                FATX3	LXI	H,FTMP1
                	PUSH 	D
                	CALL	FMUL
                	POP	D
                	DCR	E
                   	JNZ	FATX3
                	LDA	FTMP2
                	ORA	A
                	RP			;POSITIVE POWER, DONE
                ;FACC <== 1/FACC
                FLINV	CALL	FSTT1		;STORE FACC IN FTMP1
                	CALL	FLONE		;LOAD 1
                	LXI	H,FTMP1
                	JMP	FDIV		;INVERT
                FATX4	XTHL			;POP SAVED POWER, PUSH POWER ADDRESS
                	CALL	FCERN		;NONFATAL FC ERROR
                	LXI	H,FTMP1
                	CALL	FLOAD		;RELOAD A
                	CALL	FCHS		;AND FORCE POSITIVE
                	JMP	FATX0		;RETURN -A ^ X AS RESULT
                ;
                ;  CHANGE SIGN
                FCHS	LXI	H,FACC
                	MOV	A,M
                	XRI	080H
                	MOV	M,A
                	RET
                ;
                ;  COMPARE FACC WITH (H,L)
                ;     EXIT:  (CF) ==> FACC <= (H,L); (ZF) ==> EQUAL; ELSE >
                FCMP	LXI	D,FACC
                	LDAX	D
                	ORA	A
                	JP	FCM0		;FACC >= 0
                	XRA	M
                	STC
                	RM			;SIGNS DIFFER
                	XCHG			;BOTH NEGATIVE
                	JMP	FCM1
                FCM0	ORA	M
                	RM			;(H,L) <0
                FCM1	MVI	C,6
                FCM2	LDAX	D
                	SUB	M
                	RC
                	RNZ
                	INX	H
                	INX	D
                	DCR	C
                	JNZ	FCM2
                	STC
                	RET
                ;
                ;  COSINE
                ;  X <== ABS (X) SINCE COS(-X) = COS(X)
                ;  X > 10 E 10 NOT PERMITTED
                ;  IF X > 2 * PI THEN X <== X MOD 2*PI
                ;  IF X > PI THEN X <== 2*PI - X
                ;  IF X > PI/2 THEN X <== PI -X AND SIGN FLAG IS SET
                ;       (I.E., COS(X) = - COS (PI - X) )
                ;  IF X <= PI/4 THEN Y = 4X/PI, COS(X) = POLYNOMIAL(Y^2)
                ;  IF PI/4 < X <= PI/2 THEN X1 = PI/2 - X, Y = 4*X1/PI,
                ;     COS(X) = SIN(X1) = Y * POLYNOMIAL(Y^2)
                FCOS	XRA	A
                	STA	SIGN1		;SET POSITIVE
                	CALL	FABS		;COS(X) = COS(-X)
                	CPI	BIAS+11
                	JNC	FCERN		;EXP >= 10 NOT VALID
                 	LXI	H,TWOPI
                	CALL	FCMP
                	JC	FCO1		;X <= 2 PI
                ;     IF X > 2 PI  THEN X <== X (MOD 2 PI)
                	CALL	FSTT1		;STORE IN FTMP1
                	LXI	H,D12PI
                	CALL	FMUL		;DIV BY 2 PI
                	CALL	FINT		;INTEGER PART
                	LXI	H,TWOPI
                	CALL	FMUL
                	LXI	H,FTMP1
                	CALL	FSUB		;MINUS X
                	CALL	FCHS
                FCO1	LXI	H,PI
                	CALL	FCMP
                	JC 	FCO2
                ;     IF X > PI THEN X <== 2 PI - X
                	CALL	FCHS
                	LXI 	H,TWOPI
                	CALL	FADD
                FCO2	LXI	H,DPI2
                	CALL	FCMP
                	JC	FCO3
                ;     IF X > PI/2 THEN X <== PI - X AND SIGN = NEGATIVE
                	CALL 	FCHS
                	LXI	H,PI
                	CALL	FADD
                	LXI	H,SIGN1
                	MOV	A,M
                	XRI	080H
                	MOV	M,A
                FCO3	LXI	H,DPI4
                	CALL	FCMP
                	JC	FCO5		;X <= PI/4
                ;   PI/4 < X < PI/2
                ;     X0 = PI/2 - X; Y = (X0 * 4/PI)^2
                	CALL	FCHS
                	LXI	H,DPI2
                	CALL	FADD		;PI/2 -X
                	CALL	FCO34
                	CALL	FCO35
                ;    EVAL. POLYNOMIAL
                   	LXI	H,CP14
                	MVI	C,4
                	CALL	FPOLY
                	LXI	H,FTMP2		;Y
                	CALL	FMUL
                FCO4	LXI	H,FACC
                	LDA	SIGN1
                	XRA	M		;SET SIGN
                	MOV	M,A
                	RET
                ;     X <= PI/4
                ;       Y = (4X/PI)^2
                FCO5	LXI	H,D4PI
                	CALL	FMUL
                	CALL	FCO35
                ;     EVAL POLYNOMIAL
                	LXI	H,CP05
                	MVI	C,5
                	CALL	FPOLY
                	JMP	FCO4
                ;     DIVIDE VARIABLE BY PI/4
                FCO34	LXI	H,D4PI
                FC34A	CALL	FMUL
                	JMP	FSTT2		;FTMP2 = 4X/PI
                ;     SQUARE FACC AND STORE AT FTMP1
                FCO35	CALL	FSTT1
                	CALL	FMUL
                	JMP	FSTT1
                ;
                ;  FLOATING POINT DIVISION
                ;     FACC <== FACC / (H,L)
                FDIVD	XCHG
                	INX	H
                FDIV	MOV	A,M
                	ORA	A
                	JZ      FOVER		;DIV BY 0
                	CALL	UPAC1
                	ADI	BIAS+1
                	SUB	B		;GET RESULT EXPONENT
                	JC	FZACC		;UNDERFLOW
                	JZ	FZACC
                	JM	FOVER		;OVERFLOW
                	STA	EXP1
                	LXI	H,FTEMP
                	LXI	B,5
                	MOV	M,B		;FTEMP 1ST BYTE = 0
                	INX 	H
                	INX	D
                	XCHG
                	CALL	FMOVE		;FTEMP <== DIVISOR FRACTION
                	LXI	H,FACC+1
                	LXI	D,ACALT+2
                	MVI	C,5
                FD0	MOV	A,M		;ACALT+2 <== DIVIDEND FRACTION
                	MOV	M,B		;CLEAR FACC TO 0
                	STAX	D
                	INX	H
                	INX	D
                	DCR	C
                	JNZ     FD0
                	PUSH	H		;SAVE ACALT LOCATION
                	MVI	B,11		;NO. OF QUOTIENT DIGITS
                ;     DIVIDE LOOP
                FD1	LXI	H,FTEMP
                	LXI	D,ACALT+1	;QUOTIENT LOCATION
                	MVI	C,6
                FD2	LDAX	D
                	CMP	M
                	JC	FD5		;DIVIDEND < DIVISOR
                	JNZ 	FD3		;DIVISOR < DIVIDEND
                	INX	D
                	INX	H
                	DCR	C
                	JNZ 	FD2
                FD3	MVI	C,6		;DIVIDEND >= DIVISOR
                	LXI	H,FTEMP+5
                	LXI	D,ACALT+6
                	STC
                ;        SUBTRACT LOOP
                FD4	MVI	A,099H
                	ACI	0
                	SUB	M
                	XCHG
                	ADD	M
                	DAA
                	MOV	M,A
                	XCHG
                	DCX	H
                	DCX	D
                	DCR	C
                	JNZ     FD4
                	POP	H
                	PUSH	H
                	INR	M		;QUOTIENT DIGIT
                	JMP	FD1
                FD5	LXI	H,FACC+1
                	DCR	B		                        
                    	JNZ     FD6             ; NEXT DIGIT
                	MOV	A,M		;END OF DIVISION LOOP
                	ORA	A
                	JNZ     FD7		;DONE
                	MVI	B,1		;LEADING 0 - DO ONE MORE DIGIT
                	LXI	H,EXP1
                	DCR	M		;ADJUST EXP
                	LXI	H,FACC+1
                FD6	MVI	C,12
                	CALL	FM10		;SHIFT RESULT INTO FACC
                	JMP	FD1
                FD7	MVI	C,6
                	CALL	FM10		;SHIFT RESULT INTO PLACE
                	POP	H		;CLEAR STACK
                	JMP	FRND
                ;  DIVIDE FLOATING POINT FIELD AT (H,L) BY 10
                ;     ENTRY: (B,C) = NO OF BYTES
                ;     EXIT;  (H,L) = START OF FIELD
                FD10	DAD	B	;(H,L) = LOW ORDER END
                FD11	DCX	H
                	MOV	A,M
                	RRC
                	RRC
                	RRC
                	RRC
                	ANI	0FH
                	MOV	B,A		;STORE ONE DIGIT
                	DCX	H
                	MOV	A,M
                	RLC	
                	RLC
                	RLC
                	RLC
                	ANI	0F0H
                	ORA	B		;APPEND DIGIT
                	INX	H
                	MOV	M,A
                	DCR	C
                	JNZ	FD11
                	MOV	M,B		;MAKE FIRST DIGIT 0
                	RET
                ;
                ;  EXP FUNCTION
                ;  IF X = 0 THEN EXP(X) = 1
                ;  IF X < 0 THEN EXP(X) = 1 / EXP(-X)
                ;  ELSE   Z = INT (.5 + X/ LN(10))
                ;         Y = X / LN(10) - Z
                ;         B = Y / (4 LOG10 E)     I.E., 0 <= B < .3
                ;         A = 2 + B^2 * (P1/Q1)
                ;         EXP(B) = (A + B) / (A - B)
                ;         EXP(X) = 10^Z * (EXP(B))^4
                FEXP	LXI	H,EMAX
                	CALL	FCMP
                	JNC	FEX31		;> MAX
                	XRA	A
                	STA	EXP4		;CLEAR INVERT FLAG AND SIGN
                	STA	SIGN1
                	LXI	H,FACC
                	ORA	M
                	JZ	FLONE		;EXP(0) = 1
                	JP	FEXP1
                	STA	EXP4		;FLAG NEGATIVE ARGUMENT
                	ANI 	07FH
                	MOV	M,A		;MAKE ABS VALUE
                FEXP1	LXI	H,D1L10
                	CALL	FMUL		;T = X / LN(10)
                	CALL	FSTT2		;FTMP2 <== T
                	LXI	H,HALF
                	CALL	FADD
                	CALL	FFIX		;A = INT(.5 + T)
                	PUSH	B		;SAVE INT PART
                	CALL	FCHS
                	CALL	FADT2		;FRAC PART
                	LXI	H,D1LE4		;DIVIDE BY 4 LOG E
                	CALL	FC34A		;FTMP2 <== Y
                	CALL	FCO35		;FTMP1 = T = Y^2
                ;     EVALUATE CONTINUED FRACTION
                   	LXI	H,EB2
                	CALL	FTAN6
                	LXI	H,FTMP4
                	CALL	FLOAD		;LOAD P1
                	LXI	H,FTMP3
                	CALL	FDIV		;P1/Q1
                	LXI	H,FTMP1
                	CALL	FMUL		; *T
                	LXI	H,TWO
                	CALL	FADD		; +2
                	CALL	FSTT3		;FTMP3 = A = 2 + T(P1/Q1)
                 	LXI	H,FTMP2		;Y
                	CALL	FSUB
                	CALL	FSTT4		;FTMP4 = A - Y
                	LXI	H,FTMP3
                	CALL	FLOAD		;Y
                	LXI	H,FTMP2
                	CALL	FADD		;FACC = A + Y
                	LXI	H,FTMP4
                	CALL	FDIV 		; (A+Y) / (A - Y)
                	CALL  	FCO35		;SQUARE
                	CALL	FCO35		;4TH POWER
                	CALL	FLONE		;LOAD 1
                	POP	B		;GET POWER OF 10
                	INR	C
                	MOV	A,C
                	ADI	BIAS
                	STA	FACC		;FACC = 10 TO POWER
                	LXI	H,FTMP1
                	CALL	FMUL		;MULT BY E TO POWER
                	JMP	FTAN5		;SEE WHETHER TO INVERT
                FEX31	CALL	FCERN		; > MAX
                	LXI	H,FPMAX
                	JMP	FLOAD
                ;  CONVERT FACC TO 16-BIT BINARY INTEGER IN (B,C)
                FFIX	LXI	H,INTMX
                IINT	EQU	FFIX		;IINT IS SAME AS FFIX IF FPBCD
                	CALL	FCMP
                	JNC	FFIX1		;OVERFLOW
                	LXI	H,INTMN
                	CALL	FCMP
                	JZ	FF0		;-32768
                	JC	FFIX2		;UNDERFLOW
                ;     RANGE OK
                FF0	LXI	H,FACC
                	MOV	A,M
                	ORA	A
                	JNZ	FF1
                	LXI	B,0		;ZERO VALUE
                	RET
                FF1	PUSH	PSW		;SAVE SIGN
                	CALL	FINT
                	MOV	A,C
                	ORA	A
                	JNZ	FF3		;NONZERO INTEGER PART
                ;     INTEGER PART 0
                	POP	PSW
                	RP			;RETURN IF POSITIVE
                	DCX	B		;NEGATIVE FRACTION
                	JMP	FF6
                FF3	POP	PSW		;REMOVE SAVED SIGN
                	MOV	D,C		;D = NO. OF INTEGER DIGITS
                	LXI	H,0		;(H,L) = BINARY ACCUMULATOR
                	LXI	B,FACC+1	;(B,C) = LOC OF FRACTION
                FF4	LDAX	B		;CONVERSION LOOP
                	RAR
                	RAR
                	RAR
                	RAR
                	CALL	FF7		;LEFT DIGIT
                	JZ 	FF5		;END OF INTEGER DIGITS
                	LDAX	B
                	CALL	FF7		;RIGHT DIGIT
                	INX	B		;NEXT BYTE
                	JNZ	FF4		;LOOP
                FF5	MOV	B,H
                	MOV	C,L		;(B,C) <== VALUE
                	LDA	FACC
                	ORA	A
                	RP			;NOT NEGATIVE
                	DAD	D		;IF NEGATIVE ROUND DOWN
                	MOV	B,H
                	MOV	C,L
                	XRA	A		;2'S COMPLEMENT
                	SUB	C
                	MOV	C,A
                	MVI	A,0
                	SBB	B
                	MOV	B,A
                FF6	PUSH	B
                	CALL	FFLOT		;FACC <== INTEGER PART
                	POP	B		;VALUE
                	XRA	A		;CLEAR CARRY
                	RET
                FF7	PUSH	D		;ADD CURRENT DIGIT TO BINARY TOTAL
                	DAD	H		;(H,L) <== (H,L) * 10
                	MOV	E,L
                	MOV	D,H
                	DAD	H
                	DAD	H
                	DAD	D
                	ANI	0FH		;GET DIGIT
                	MOV	E,A
                	MVI	D,0
                	DAD	D		;ADD NEW DIGIT
                	POP	D
                	DCR	D
                	RET
                FFIX1	LXI	B,32767		;OVERFLOW
                	JMP	FF8
                FFIX2	LXI	B,-32768	;UNDERFLOW
                FF8	CALL	FF6 
                	STC
                	RET
                ;
                ;  FLOAT BINARY VALUE IN (B,C)
                ;     RESULT IN FACC
                FFLOT	PUSH	B
                	MVI	C,11
                	LXI	H,FACC
                	CALL	FZERO
                	POP	B
                	STA	SIGN		;POSITIVE
                	LXI	D,BDTAB-3	;CONVERSION TABLE
                	ORA	B
                	JM	FFL0  		;VALUE <0
                	JNZ	FFL1		;>0
                	CMP	C
                	RZ
                	JMP	FFL1
                FFL0	ANI	080H
                	STA	SIGN		;NEGATIVE
                	XRA	A		;NEGATE (B,C)
                	SUB	C
                	MOV	C,A
                	MVI	A,0
                	SBB	B
                 	MOV	B,A
                ;     SHIFT (B,C) RIGHT
                FFL1	MOV	A,B
                	ORA	A		;TEST FOR 0 AND CLEAR CARRY
                	JNZ     FFL2		;B IS NOT 0
                        MOV	A,C             ;B=0
                	ORA	A
                	JNZ	FFL3
                ;     DONE WHEN (B,C) = 0
                	LXI	H,EXP1
                	MVI	M,BIAS+6
                	JMP	FNORM		;NORMALIZE
                FFL2	RAR			;B <== B/10
                	MOV	B,A
                	MOV	A,C
                FFL3	RAR			;C <== C/10
                	MOV	C,A 
                	INX	D		;NEXT PLACE IN TABLE
                	INX	D
                	INX	D
                	JNC	FFL1		;0-BIT
                ;     ON 1-BIT ADD VALUE FROM TABLE
                	PUSH	D
                	PUSH	B
                	INX	D
                	INX	D
                	LXI	H,FACC+3
                	MVI	C,3
                	CALL	FADDL		;ADD DECIMAL VALUE
                	POP	B
                	POP	D
                	JMP	FFL1
                ;
                ;  INPUT FLOATING POINT VALUE FROM STRING
                ;     RESULT IN FACC
                FINP	SHLD	TEXTP		;SAVE STRING POINTER
                	CALL	FINP0
                	LHLD	TEXTP
                	JMP	BAKUP		;BACK UP THE TEXT POINTER
                FINP0	LXI	H,FACC
                	MVI	C,12
                	CALL	FZERO
                	MOV	B,A		;B = 0 = EXPONENT
                	MOV	E,A		;E = 0 = SIG DIGIT FLAG
                	STA	SIGN
                	INR	A
                	MOV	D,A		;D = DEC. POINT FLAG = 1
                FIN00	CALL	FINC		;GET CHARACTER
                	JC	FIN1B		;NON NUMERIC
                FIN0	CPI 	'0' 
                	JNZ     FIN2		;NONZERO DIGIT
                	JMP	FIN00		;SKIP A LEADING 0
                FIN1	CALL    FINC
                FIN1A	JNC	FIN2		;DIGIT
                FIN1B	CPI	'9'+1
                	JNC	FIN3		;>9
                	CPI	'.'
                	JNZ	FIN7		; END OF STRING
                	XRA	A
                	CMP	D
                	JZ	FIN7		; 2 DEC. POINTS
                	MOV	D,A		;FLAG FOR DEC. POINT
                	JMP	FIN1
                ;     PROCESS DIGIT
                FIN2	SUI	'0'		;MAKE NUMERIC
                	MOV	C,A
                	LDA	FACC+2
                 	ANI	0F0H
                	JNZ     FIN22		;10 DIGITS ALREADY IN
                	PUSH	B
                	LXI	H,FACC+1
                	MVI	C,6
                	CALL	FM10		;FACC <== FACC * 10
                	POP	B
                	MOV	A,C		;NEW DIGIT
                	ADD	M		;ADD IN NEW DIGIT
                	MOV	M,A
                	MOV	A,C		;RECOVER NEW DIGIT
                	ORA	E
                	MOV	E,A		;SIG FLAG NONZERO IF SIG DIGIT SEEN
                	MOV	A,D		;FETCH DEC PT FLAG
                	ORA	A
                	JZ	FIN21		;DEC PT SEEN
                	INR	B		;DEC PT NOT SEEN YET, BUMP EXPONENT
                FIN21	MOV	A,E		;FETCH SIG DIGIT FLAG
                	ORA	A
                	JNZ	FIN1		;TRY NEXT DIGIT
                	DCR	B		;PAST DEC PT AND NO SIG DIGIT, DCR EXPONENT
                	JMP	FIN1
                ;MORE THAN 10 SIGNIFICANT DIGITS
                FIN22	MOV	A,D		;FETCH DECIMAL POINT FLAG
                	DCR	A
                	JNZ	FIN23		;PAST DECIMAL POINT, LEAVE EXPONENT UNCHANGED
                	INR	B		;BUMP EXPONENT FOR DIGIT
                FIN23	CALL	FINC		;FETCH ANOTHER CHAR
                	JC	FIN1B		;NONDIGIT
                	JMP	FIN22		;ANOTHER DIGIT
                FIN3	CPI	'E'
                	JZ	FIN4
                	CPI	'E'+20H		;LOWER CASE E
                        JNZ     FIN7		;NOT VALID CHARACTER
                ;     PROCESS EXPONENT
                FIN4	MVI	C,0		;EXP. DIGIT COUNT
                	MOV	E,C		;BUILD EXPONENT IN E
                	CALL	FINC		;GET CHAR
                	JNC	FIN4C		;DIGIT
                	CPI	MINT
                	JZ	FIN4A		;TOKENIZED MINUS SIGN
                	CPI	PLUST
                	JZ	FIN4B		;TOKENIZED PLUS SIGN
                	CPI	'+'
                	JZ	FIN4B		;PLUS SIGN
                	CPI	'-'
                	JNZ     SNERR		;NOT DIGIT, PLUS, MINUS -- SYNTAX ERROR
                FIN4A	MVI	A,080H		;MINUS
                	STA	SIGN
                FIN4B	CALL	FINC
                	JC	SNERR		;SYNTAX ERROR IF NONDIGIT FOLLOWS SIGN
                FIN4C	CPI	'0'
                	JNZ	FIN5
                	CALL	FINC		;GET CHAR AFTER LEADING EXPONENT 0
                	JC	FIN6		;EXPONENT IS 0
                	JMP	FIN4C		;CHECK FOR ANOTHER LEADING 0
                FIN5	INR	C
                	SUI	'0'
                	ADD	E		;ADD TO EXPONENT
                	MOV 	E,A
                	CALL	FINC
                	JC      FIN6		;END
                	PUSH	PSW		;ANOTHER EXP. DIGIT
                	MOV	A,C
                	CPI	3
                	JZ	FIN5A		;TOO MANY DIGITS
                	MOV	A,E		;E <== E * 10
                	ADD	A
                	MOV	E,A
                	ADD	A
                	ADD     A
                	ADD	E
                	MOV	E,A
                	POP	PSW
                	JMP	FIN5
                FIN5A	POP	PSW
                FIN6	LDA	SIGN
                	ORA	A
                	JZ	FIN7A		;EXP >= 0
                	MOV	A,B		;NEGATE EXPONENT
                	SUB	E
                	ADI	BIAS
                	JM	FZACC		;UNDERFLOW
                	JZ 	FZACC
                	JMP	FIN8
                FIN7	MVI	E,0
                FIN7A	MOV	A,B		;FORM TOTAL EXPONENT
                	ADD	E
                	ADI	BIAS
                	JM	FOVER		;OVERFLOW
                FIN8	STA	EXP1
                	LXI	H,FACC
                	MVI	C,6
                FIN9	INX	H		;FIND NONZERO BYTE
                	MOV	A,M
                	ORA	A
                	JNZ	FIN10
                	DCR	C
                	RZ			;ZERO RESULT
                	JMP	FIN9
                FIN10	LXI	D,FACC+1	;NORMALIZE
                	CALL	FLOD1		;MOVE OVER TO START OF FACC
                	LDAX	D
                	CPI	010H
                	JNC	FIN11
                	LXI	H,FACC+1
                	MVI	C,6
                	CALL    FM10            ;HALF BYTE SHIFT
                FIN11	LXI	H,EXP1
                	LDA	TEMP		;SIGN
                	ANI	080H
                	ORA	M		;APPEND EXP.
                	STA	FACC
                	XRA	A
                	RET
                ;     GET CHARACTER FROM STRING
                ;     CF = 1 ==> NOT NUMERIC
                FINC	LHLD	TEXTP
                	MOV	A,M
                	INX	H
                	SHLD	TEXTP		;NEW TEXT POINTER
                	CPI	'0'
                	RC			;<0
                	CPI	'9'+1
                	CMC
                	RET
                ;
                ;  FACC <== INTEGER PART (TRUNCATED)
                ;  EXIT:  (D,E) = 1 IFF NONZERO DIGITS WERE TRUNCATED
                ;         (B,C) = NO. OF INTEGER DIGITS
                FINT	XRA	A
                	MOV	E,A
                	MOV	D,A
                	MOV	B,A
                	LXI	H,FACC
                	ORA	M
                	RZ			;ZERO
                	MVI	E,1		;FRACTION FLAG
                	ANI	07FH		;GET EXPONENT
                	SUI	BIAS
                	JZ	FZACC		;PURE FRACTION
                	JM	FZACC
                	MVI	E,0
                	CPI	10
                	RNC			;ALREADY INTEGER
                	PUSH	PSW		;SAVE NO. OF DIGITS
                	ORA	A
                	RAR
                	PUSH    PSW		;(CF) = 1 IF ODD
                	MOV	C,A
                	DAD	B
                	INX	H		;(H,L)= LOW END OF INTEGER PART
                	MVI	A,5
                	SUB	C
                	MOV	C,A		;C = NO OF BYTES TO CLEAR
                	POP	PSW
                	JNC	FINT2		;EVEN
                	MOV	A,M		;CLEAR RIGHT DIGIT OF BYTE
                	ANI  	0FH
                	JZ	FINT3		;NO FRACTION DIGIT
                	MVI	E,1
                	MOV	A,M
                	ANI	0F0H
                	MOV	M,A
                	JMP     FINT3
                FINT2	MOV	A,M
                	ORA	A
                	JZ	FINT3		;ALREADY 0
                	MVI	E,1		;FLAG NONZERO FRACTION
                	MVI	M,0		;CLEAR BYTE
                FINT3	INX	H
                	DCR	C
                	JNZ	FINT2
                	POP	PSW		;NO. OF DIGITS
                	MOV	C,A
                	RET
                ;
                ;  NATURAL LOG
                ; X = 10^A * Y WHERE .1 <= Y < 1
                ; Y = 2^M * Z WHERE 1/2 <= Z < 1, M=0,-1,-2,-3
                ; V = T * T
                ; LN (V) = LN (1+T)/(1-T) = T * P2(V) / Q2(V)
                ; LN (X) = A * LN (10) + (M - 1/2) * LN (2) + LN (1+T)/(1-T)
                FLN	LXI	H,FPONE
                	CALL	FCMP
                	JZ	FZACC		;LN(1) = 0
                	LXI	H,FACC
                	MOV	A,M
                	ORA	A
                	JM	FL94		;LOG OF NEGATIVE
                	JZ	FCERN		;LOG OF 0
                	MVI	M,BIAS		;MAKE PURE FRACTION
                	SUI	BIAS
                	STA     EXP3		;STORE UNBIASED EXP
                	MVI	C,0
                FL0	INX	H
                	MOV	A,M
                	CPI     050H
                	JNC	FL1		;FRAC >= .5
                	PUSH	B
                	DCX	H
                	PUSH	H
                	LXI	H,FTEMP
                	CALL	FSTOR
                	CALL	FADD		;X <== 2*X
                	POP	H
                	POP	B
                	INR	C		;COUNT
                	JMP	FL0
                FL1	LXI	H,EXP4
                	MOV	M,C		;SAVE SCALE FACTOR
                	CALL	FSTT1	 	;FTMP1 = SCALED FRACTION
                	LXI	H,DSR22	
                	CALL	FADD		;ADD SQR(2)/2
                	CALL	FSTT2
                	LXI	H,FTMP1
                	CALL	FLOAD
                	LXI	H,DSR22
                	CALL	FSUB
                	LXI	H,FTMP2
                	CALL	FDIV		;T = (Y - SQR(2)/2) /(Y + ...)
                	CALL	FSTT2		;FTMP2 = T
                	CALL	FCO35		;FTMP1 = T^2
                ;     LOG ((1+T)/(1-T)) = CONTINUED FRACTION
                	LXI	H,LB3
                	CALL	FTAN7
                	LXI	H,LC0
                	CALL	FADD
                	LXI	H,FTMP2
                	CALL	FMUL		;T * P/Q
                	CALL	FSTT1
                	LDA	EXP3
                	MOV	C,A
                	MVI	B,0		;(B,C) = EXP
                	ORA	A
                	JP	FL2
                	DCR	B		;SIGN EXTEND
                FL2	CALL	FFLOT
                	LXI	H,LN10
                	CALL	FMUL		;FACC <== EXP * LN(10)
                	CALL	FSTT2
                	LDA	EXP4		;M
                	MOV	C,A
                	MVI	B,0
                	CALL	FFLOT
                	LXI	H,HALF
                	CALL	FADD
                	LXI	H,LN2
                	CALL	FMUL		;FACC <== -(M - 1/2) * LN(2)
                	CALL	FCHS
                	CALL	FADT2
                	LXI	H,FTMP1
                	JMP 	FADD
                FL94	ANI	07FH		;LOG OF NEGATIVE
                	MOV	M,A		;MAKE POSTIVE
                	CALL    FCERN
                	JMP   	FLN
                ;
                ;  LOAD FACC FROM (H,L)
                ;     EXIT:  (D,E) = FACC
                FLONE	LXI	H,FPONE		;LOAD 1
                FLOAD	LXI	D,FACC
                FLOD1	MVI	C,6
                ;     MOVE FIELD FROM (H,L) TO (D,E)
                FMOVE	PUSH 	D
                FMOV1 	MOV	A,M
                	STAX	D
                	INX	H
                	INX	D
                	DCR	C
                	JNZ	FMOV1
                	POP	D
                	RET
                ;
                ;  F.P . MULTIPLY   FACC <== FACC * (H,L)
                FMUL	MOV 	A,M
                	ORA	A
                	JZ      FZACC     	;OP-2 = 0
                	CALL	UPAC1
                	ADD	B	 	;GET RESULT EXP
                	SUI 	BIAS-1
                	JZ	FZACC		;UNDERFLOW
                	STA     EXP1		;STORE EXP
                	XCHG
                	LXI	D,FTEMP
                        MVI     C,6
                	CALL	FMOVE		;MOVE OP-2 TO FTEMP
                	XCHG
                	MVI	M,0
                	LXI	B,5
                	DAD	B		;(H,L) = LOW END OF OP-2
                	PUSH	H
                	LXI	H,HOLD4
                	CALL	FSTOR		;HOLD4 <== OP-1
                	DCX	H		;(H,L) = END OF HOLD3
                	MVI	B,3
                	XCHG
                FM2	LXI	H,6
                	DAD	D		;(H,L) <== END OF HOLD(I+1)
                	MVI	C,6
                	ORA	A		;CLEAR CARRY
                FM3	MOV	A,M		;HOLD(I) <== 2 * HOLD(I+1)
                	ADC	A		;DOUBLE IT
                	DAA
                	STAX	D
                	DCX	D
                	DCX	H
                	DCR	C
                	JNZ	FM3
                	DCR	B
                	JNZ	FM2
                	CALL	FZACC		;CLEAR FACC
                	POP	H		;(H,L) <== OP-2
                	PUSH	H
                	CALL	FMLOP	 	;MULT LOOP FOR RIGHT DIGITS
                	LXI	H,FACC+1
                	MVI	C,10
                	CALL	FD10		;FACC <== FACC/10
                	LXI	H,FTEMP+1
                	MVI	C,5
                	CALL    FD10
                	POP	H
                	CALL	FMLOP		;MULT LOOP FOR LEFT DIGITS
                	JMP	FNORM		;NORMALIZE
                ;   MULTIPLY LOOP
                ;     FACC <== HOLD1 * RIGHT DIGITS OF FTEMP
                FMLOP	MVI	C,5		;OUTER LOOP COUNTER
                	LXI	D,FACC+11	;PRODUCT LOCATION
                	PUSH	D
                	PUSH	H		;END OF MULTIPLIER
                FML1	POP	D
                	LDAX	D		;GET MULTIPLIER DIGIT
                	DCX	D		;NEXT DIGIT
                	POP	H		;SUM LOCATION
                	DCX	H
                	PUSH	H		;NEXT SUM LOCATION
                	PUSH	D		;NEXT MPR. DIGIT
                	LXI	D,HOLD1+5
                	ANI	0FH		;DIGIT
                	RLC			;PUT IN LEFT NIBBLE
                	RLC
                	RLC
                	RLC
                FML2	ORA	A
                	JZ	FML4		;SKIP LOOP ON ZERO DIGIT
                	PUSH	H		;ACCUM LOCATION
                	ADD	A		;DOUBLE DIGIT
                	MOV	B,A
                	JNC	FML3		;NO ADD ON 0 BIT
                	PUSH	B
                	PUSH	D
                	MVI	C,6
                	CALL	FADDL		;ACCUMULATE PRODUCT
                	POP	D
                	POP	B
                FML3	LXI	H,6
                	DAD	D		;NEXT HOLD BUFFER
                	XCHG
                	POP	H		;ACCUM. LOCATION 
                	MOV	A,B		;GET DIGIT
                	JMP	FML2		;INNER LOOP
                FML4	DCR	C
                	JNZ	FML1		;OUTER LOOP (NEXT DIGIT)
                	POP	H
                	POP	H		;CLEAR STACK
                	RET
                ;  MULTIPLY FLOATING POINT VALUE AT (H,L) BY 10
                ;   ENTRY:  C = NO OF BYTES IN FIELD
                FM10	MOV	A,M
                	ANI	0FH
                	RAL	
                	RAL
                	RAL
                	RAL
                	MOV	M,A
                	INX	H
                	MOV	A,M
                	RAR
                	RAR
                	RAR
                	RAR
                	ANI	0FH
                	DCX	H
                	ORA	M
                	MOV	M,A		;STORE DIGIT PAIR
                	INX	H
                	DCR	C
                	JNZ	FM10
                	DCX	H
                	ANI	0F0H		;LAST DIGIT = 0
                	MOV	M,A
                	RET
                ;
                ;  NORMALIZE
                FNORM	LXI	H,FACC+1
                	MVI	C,0
                FN0	MOV	A,M		;FIND HIGHEST NON-0 DIGIT
                	ORA	A
                	JNZ	FN1
                	INR	C		;COUNT ZEROS
                	INR	C
                	INX	H
                	JMP	FN0
                FN1	XRA	A
                	CMP	C
                	JZ	FN2		;FIRST BYTE NON-0
                	DCX	H
                	PUSH	B
                	CALL    FLOAD           ;MOVE FRACTION LEFT
                	POP	B
                	LXI	H,FACC+1
                FN2	MOV	A,M
                	ANI	0F0H
                	JNZ	FN3	        ;DONE
                	INR	C
                	PUSH	B
                	LXI	B,6
                	CALL	FM10		;SHIFT LEFT 1/2 BYTE
                	POP	B
                FN3	LXI	H,EXP1
                	MOV	A,M
                	SUB	C		;ADJUST EXP.
                	JZ	FZACC		;UNDERFLOW TO 0
                	JC	FZACC
                	JM	FOVER		;OVERFLOW
                	MOV	M,A
                	JMP	FRND
                ;
                ;  OUTPUT FROM FLOATING POINT TO STRING
                FOUT	LXI	H,BUFAD		;RESULT ADDRESS
                	PUSH	H		;SAVE ORIG. BUFAD
                	PUSH	H		;CURRENT CHAR. POINTER
                	LXI	H,FACC
                	MOV	A,M
                	ORA     A
                	JNZ	FOU1
                	POP	H		;ZERO VALUE
                	MVI	M,' ' 		;OUTPUT ' 0'
                	INX	H
                	MVI	M,'0'
                	MVI	C,2
                	POP	D
                	RET
                FOU1	ANI     080H		;SIGN
                	STA	SIGN
                	MOV	A,M
                	ANI	07FH
                	STA	EXP1		;STORE EXP.
                	MVI	M,0		;MAKE FACC PURE FRACTION
                	LXI	H,FACC+5
                	CALL    FRND1		;ROUND TO 8 PLACES
                	POP	H
                	MVI	B,' '		;OUTPUT LEADING ' ' OR '-'
                	LDA	SIGN
                	ORA	A
                	JP	FOU2
                	MVI	B,'-'
                FOU2	MOV	M,B
                	MVI	C,1		;CHAR. COUNT
                	INX	H
                	LDA	EXP1
                	SUI	BIAS		;UNBIASED EXPONENT
                	MOV	E,A		;E = EXP
                	MOV	B,A		;B = INTEGER DIGIT COUNTER
                	JM	FOU3		;EXP < 0
                	JZ      FOU3		;EXP = 0
                	CPI 	9
                	JC	FOU4		;EXP <= 8
                FOU3	MVI	M,'.'		;LEADING POINT
                	INR	C
                	INX	H
                	CPI	-7
                	JC	FOU4		;LARGE NEG EXPONENT, USE E NOTATION
                FOU3A	MVI	M,'0'		;ELSE STORE 0 AFTER .
                	INR	C
                	INX	H
                	INR	A
                	JNZ	FOU3A
                	MVI	E,0		;RESET EXPONENT TO 0
                FOU4	PUSH	H		;SAVE OUTPUT POINTER
                	LXI	H,FACC
                	MVI	D,4		;BYTE COUNTER
                ;      OUTPUT DIGITS
                FOU5	INX	H		;(H,L) = POINTER TO FACC
                	MOV 	A,M
                	RAR			;LEFT DIGIT
                	RAR
                	RAR
                	RAR
                	ANI	0FH
                	XTHL			;(H,L) <== OUTPUT POINTER
                	CALL	FOUT1		;OUTPUT DIGIT
                	XTHL
                	MOV 	A,M
                	XTHL
                	ANI	0FH		;RIGHT DIGIT
                	CALL	FOUT1
                	XTHL
                	DCR	D
                	JNZ	FOU5
                	POP	H		;CHAR POINTER
                FOU6	DCX	H		;BACK UP TO LAST CHAR
                	DCR	C
                	MOV	A,M
                	CPI	'.'
                	JZ      FOU7		;DELETE TRAILING POINT
                	CPI	'0'
                	JZ  	FOU6		;BACK UP TO NONZERO
                	INX	H
                	INR	C
                ;     SEE IF 'E' NOTATION NEEDED
                FOU7	MOV	A,E
                	ORA 	A
                	JM	FOU8
                	CPI	9
                	JC	FOU12		;0 <= EXP <= 8
                ;     OUTPUT 'E' AND EXPONENT
                FOU8	MVI	M,'E'
                	INX	H
                	INR	C
                	ORA	A
                	JP	FOU9
                	MVI	M,'-'		;NEGATIVE EXP
                	INX	H
                	INR	C
                	XRA	A
                	SUB	E		;MAKE EXP POSITIVE
                FOU9	CPI	10
                	JC	FOU11		;ONE-DIGIT EXP
                ;  GET FIRST DIGIT OF EXP
                   	MVI	D,0		;D <== EXP/10
                FOU10 	SUI	10
                	INR	D
                	CPI	10
                	JNC	FOU10
                	MOV	E,A		;E <== REMAINDER
                	MOV	A,D
                	ADI	'0'
                	MOV	M,A		;OUTPUT FIRST DIGIT
                	INX	H
                	INR	C
                	MOV	A,E
                FOU11	ADI	'0'
                	MOV	M,A
                	INR	C
                FOU12	POP	D		;(D,E) = BUFAD
                	RET
                ;     OUTPUT DIGIT
                FOUT1	ADI	'0'  		;MAKE CHARACTER
                	MOV	M,A
                	INR	C		;CHAR COUNT
                	INX	H
                	DCR	B		;INTEGER COUNT
                	RNZ
                	MVI	M,'.'		;DECIMAL POINT
                	INR	C
                	INX	H
                	RET
                ;  OVERFLOW
                FOVER	ERROR	N,O,V
                	LXI	H,FPMAX
                	CALL	FLOAD		;LOAD MAX VALUE
                	LXI	H,FACC
                	LDA	SIGN
                	ORA	M		;APPEND SIGN
                	MOV	M,A
                	RET
                ;
                ;  EVALUATE POLYNOMIAL
                ;    ENTRY:  FTMP1 = VARIABLE,  (C) = DEGREE, (H,L) = HIGHEST ORDER COEFFICIENT
                ; P(Y) = (...(Y*CN+ C(N-1)) * Y + ...) * Y + C0
                FPOLY	PUSH  	B
                	PUSH	H
                	CALL	FMUL		;MULT BY HIGHEST COEFFICIENT
                	JMP	FPLY1
                FPLY0	PUSH	B
                	PUSH	H
                	CALL	FADD
                	LXI	H,FTMP1
                	CALL	FMUL		;MULT BY VARIABLE
                FPLY1	POP	H
                	POP	B
                	LXI	D,-6
                	DAD	D		;NEXT COEFFICIENT
                	DCR	C		;DEGREE COUNT
                	JNZ	FPLY0
                	JMP	FADD		;ADD LAST COEFFICIENT
                ;  RENORMALIZE
                FRNRM	LXI	H,FACC
                	MOV	A,M
                	ORA	A
                	RZ			;NO RENORM NEEDED
                	LXI	B,7
                	CALL	FD10		;SHIFT RIGHT 1/2 BYTE
                	LXI	H,EXP1		;INCR. EXP
                	INR	M
                	JM	FOVER		;OVERFLOW
                	RET
                ;
                ;  ROUND FLOATING POINT VALUE
                FRND	LXI	H,ACALT
                	CALL	FRND1 
                FRND0	LXI	H,SIGN
                	LDA	EXP1
                	ORA	M		;REPACK RESULT
                	STA	FACC
                	RET
                FRND1	MOV	A,M
                	ADI	050H
                	DAA
                	RNC			;DONE IF NO CARRY
                	DCX	H
                	CALL	FADL0		;CARRY ONE
                	JMP	FRNRM		;RENORMALIZE
                ;
                ;  SINE FUNCTION
                ; IF ABS(X) < 4 E (-7) RETURN X
                ; ELSE SIN (X) = COS (X - PI/2)
                FSIN	LXI	H,FACC
                	MOV	A,M
                	ANI	07FH		;GET EXP
                	CPI	039H
                ;     IF ABS(X) < 4 E (-7) THEN RETURN X
                	RC			;EXP < -7
                	JNZ	FS0
                	INX	H
                	MOV	A,M
                	CPI	040H
                	RC
                ;     ELSE SIN(X) = COS (X - PI/2)
                FS0	LXI	H,DPI2
                	CALL	FSUB
                	JMP	FCOS
                ;
                ;  SQUARE ROOT
                ; X = Y * 10^A WHERE .1 <= Y < 1
                ; B <== INT (A/2)
                ; C <== (A - 2*B) * SQR(10)
                ; Z0 <== POLYNOMIAL(Y)
                ; Z1 <== 1/2 (Z0 + Y/Z0), ETC.
                ; SQR(X) = Z * 10^B * SQR(10) IF C=1
                ;        = Z * 10^B IF C = 0
                FSQR	LXI	H,FACC
                	MOV	A,M
                	ORA	A
                	CM	FCERN		;SQR OF NEGATIVE
                	ANI	7FH
                	MOV	M,A		;FORCE POSITIVE
                	SUI	BIAS		;UNBIAS EXP
                	RAR			;A <== EXP/2
                	PUSH	PSW		;SAVE EVEN/ODD FLAG
                	STA	SIGN1		;STORE EXP/2
                	MVI	M,BIAS		;SET EXP TO 0
                	CALL	FSTT1		;SAVE X
                	INX	H
                	MOV	A,M
                	CPI	025H
                	JNC	FSQ4		;X > .25
                ;     X <= .25
                	LXI	H,SR3
                	MVI	C,3
                FSQ0	CALL	FPOLY		;POLYNOMIAL
                ;     2 NEWTON-RAPHSON ITERATIONS
                	CALL	FSQ2
                	CALL	FSQ2
                	POP	PSW		;EVEN/ODD FLAG
                	JNC	FSQ1		;EVEN
                	LXI	H,SQR10
                	CALL	FMUL		;IF ODD MULT BY SQR(10)
                FSQ1	LXI	H,FACC
                	LDA	SIGN1		;GET EXP/2
                	ADD	M
                	MOV	M,A		; SET RESULT EXP
                	RET
                ;     NEWTON-RAPHSON ITERATION
                ;       Z1 =   (X/Z0 + Z0) * .5
                FSQ2	CALL	FSTT2		;STORE Z
                	LXI	H,FTMP1
                	CALL	FLOAD
                	LXI 	H,FTMP2
                	CALL  	FDIV		;X/Z0
                	LXI	H,FTMP2
                	CALL	FADD
                	LXI	H,HALF
                	JMP	FMUL
                ;     X > .25
                FSQ4	LXI	H,SR6
                	MVI	C,2
                	JMP	FSQ0
                ;
                ;  STORE FACC AT (H,L)
                ;     EXIT:  (H,L) = DESTINATION FIELD
                FSTT4	LXI	H,FTMP4
                	JMP	FSTOR
                FSTT3	LXI	H,FTMP3
                	JMP	FSTOR
                FSTT2	LXI	H,FTMP2
                	JMP	FSTOR
                FSTT1	LXI	H,FTMP1
                FSTOR	PUSH	B
                	LXI	B,5
                	DAD	B		;(H,L) = LOW END OF FIELD
                	INX	B
                	LXI	D,FACC+5
                FST0	LDAX	D
                	MOV	M,A
                	DCX	D
                	DCX	H
                	DCR	C
                	JNZ	FST0
                	INX	H
                	POP	B
                	RET
                ;
                ;  FLOATING POINT SUBTRACTION		FACC <== FACC - (H,L)
                FSUB 	MOV	A,M
                	ORA	A
                	RZ			;OP - 2 = 0
                	LXI	D,FACC
                	LDAX	D
                	ORA	A
                	JZ	FSUB0		;SUBTRACT FROM 0
                   	XRI	080H		;REVERSE SIGN
                	JMP	FADD0
                FSUB0	CALL	FLOAD		;LOAD OP-2
                	JMP	FCHS
                ;  SUBTRACT LOOP
                FSUB1	LDA	FLEN
                	MOV	C,A		;LENGTH OF LOOP
                 	STC
                FSU2 	XCHG
                	MVI	A,099H
                	ACI	0
                	SUB	M
                	XCHG
                	ADD	M
                	DAA
                	MOV	M,A
                	DCX	H
                	DCX	D
                	DCR	C
                	JNZ	FSU2
                	JC	FSU4		;FORM CORRECT
                	LHLD	RSLT
                	LDA	FLEN
                	MOV	C,A
                	STC
                FSU3	MVI	A,099H		;RECOMPLEMENT
                	ACI	0
                	SUB	M
                	ORA	A		;CLEAR ACY  
                	DAA
                	MOV	M,A
                	DCX	H
                	DCR	C
                	JNZ 	FSU3
                	LXI	H,SIGN
                	MOV	A,M
                	XRI	080H		;REVERSE SIGN ON RECOMPLEMENT
                	MOV	M,A
                FSU4	LXI	H,FACC+1
                	MVI	C,7
                FSU5	MOV	A,M		;CHECK FOR 0 RESULT
                	ORA	A
                	JNZ	FNORM		;NORMALIZE NON-0
                	INX	H
                 	DCR	C
                	JNZ	FSU5	
                	RET			;RETURN 0
                ;
                ;  TANGENT
                ; STORE SIGN AND MAKE ABS VALUE
                ; Y <== 4X/PI
                ; R <== FRAC(Y)
                ; A <== INT(Y) (MOD 4)
                ; IF A > 2 THEN REVERSE SIGN
                ; IF A IS ODD, R <== 1-R
                ; IF A = 1 OR 2 (MOD 4) SET COTAN FLAG
                ; Y <== R * PI/4
                ; T <== Y * Y
                ; TAN (X) = X * (C0 + P2(T)/Q2(T))
                ; IF FLAG IS SET, TAKE COTAN I.E. 1/TAN
                ; APPEND SIGN
                FTAN	XRA	A
                 	STA	EXP4		;CLEAR COTAN FLAG
                	LXI	H,FACC
                	MOV	A,M
                	ANI	080H		;GET SIGN
                	STA	SIGN1
                	MOV	A,M
                	ANI	07FH		;GET EXP
                	MOV	M,A		;MAKE ABS. VALUE
                	CALL	FCO34		;FTMP2 <== 4X/PI
                	LXI	H,INTMX
                	CALL	FCMP
                	JNC	FCERN		;VALUE TOO LARGE
                	CALL	FFIX		;GET INTEGER PART
                	PUSH	B		;SAVE INT PART
                	CALL	FCHS		;GET FRAC PART
                	CALL	FADT2		;R = FRAC PART
                	POP	B
                	MOV	A,C
                	ANI	3		;A <== INT PART (MOD 4)
                	CPI	2
                	JC	FTAN2
                	LXI	H,SIGN1		;IF > 2 (MOD 4) REVERSE SIGN
                	PUSH	PSW
                	MOV	A,M
                	XRI	080H
                	MOV	M,A
                	POP	PSW
                FTAN2	PUSH	PSW
                	RAR
                	JNC	FTAN3		;EVEN
                	CALL	FCHS		;IF ODD, R = 1 - R
                	LXI	H,FPONE
                	CALL	FADD
                FTAN3	POP	PSW
                	INR	A
                	ANI	2
                	JZ	FTAN4		;A WAS 0 OR 3 (MOD 4)
                	STA	EXP4		;IF 1 OR 2 (MOD 4) SET COTAN FLAG
                FTAN4	LXI	H,DPI4
                	CALL	FC34A		;FTMP2 = Y = R * PI/4
                	CALL	FCO35	 	;FTMP1 = Y^2
                	LXI	H,TB3
                	CALL	FTAN7		;EVAL. CONTINUED FRAC.
                	LXI	H,TC0
                	CALL	FADD
                	LXI	H,FTMP2
                	CALL	FMUL		;*Y
                FTAN5	LDA	EXP4		;GET INVERT FLAG
                	ORA	A
                	CNZ	FLINV		;INVERT IF DESIRED
                	JMP	FAT6		;APPEND SIGN
                ;     EVALUATE CONTINUED FRACTION
                ; P1 <== C2 (X + B3)
                ; Q1 <== (X + B2) (X + B3) + C3
                ; P2 <== C1 * Q1
                ; Q2 <== (X + B1) * Q1 + P1
                FTAN6	PUSH	H
                	CALL	FADD		;X + B3
                	CALL	FSTT3		;FTMP3 = X + B3
                	POP	H
                	LXI	D,6
                	DAD	D		;NEXT COEFFICIENT
                	PUSH	H
                	CALL	FMUL		;* C3
                	CALL	FSTT4		;FTMP4 = P1
                	LXI	H,FTMP1
                	CALL	FLOAD		;X
                	POP	H
                	LXI	D,6
                	DAD	D
                 	PUSH	H
                	CALL	FADD		;+ B2
                	LXI	H,FTMP3
                	CALL	FMUL		; * (X + B3)
                	POP	H
                	LXI	D,6
                	DAD	D
                	PUSH	H
                	CALL	FADD		; + C3
                	CALL	FSTT3		;FTMP3 = Q1
                	POP	H
                	RET
                FTAN7	CALL	FTAN6
                	PUSH	H
                	LXI	H,FTMP1
                	CALL	FLOAD		;X
                	POP	H
                	LXI	D,6
                	DAD	D
                	PUSH	H
                	CALL	FADD		; + B1
                	LXI	H,FTMP3
                	CALL	FMUL		; * Q1
                	LXI	H,FTMP4
                	CALL	FADD		; + P1
                	CALL	FSTT4		; FTMP4 = Q2
                	LXI	H,FTMP3
                	CALL	FLOAD		; Q1
                	POP	H
                	LXI	D,6
                	DAD	D
                	CALL	FMUL		; * C1 = P2
                	LXI	H,FTMP4        ; P2/Q2
                	JMP	FDIV
                ;
                ;  ZERO OUT FACC
                FZACC	MVI	C,6
                	LXI	H,FACC
                ;  ZERO OUT FLOATING POINT FIELD AT (H,L)
                FZERO	XRA	A
                FZER1	MOV	M,A
                	INX	H
                	DCR	C
                	JNZ	FZER1
                	RET
                ;
                ;  UNPACK FLOATING POINT OPERANDS FOR DIV. AND MULT.
                UPAC1	ANI	07FH		;GET EXP-2 
                	MOV	B,A		;SAVE EXP-2 IN B
                	LXI	D,FACC
                	LDAX	D
                	ORA	A
                	JNZ	UNP1
                ;     OP-1 = 0
                	INX	SP		;EXIT FROM CALL
                	INX	SP
                	RET			;RETURN 0
                UNP1	XRA	M		;GET RESULT SIGN
                	ANI	080H
                	STA	SIGN
                UPAC2	XCHG			;(D,E) = OP-2
                	MOV	A,M
                	PUSH	PSW		;SAVE EXP-1
                	MVI 	M,0		;FACC <== PURE FRACTION
                	LXI	H,ACALT
                	MVI	C,7
                	CALL	FZERO		;CLEAR ACALT
                	POP	PSW
                	ANI	07FH		;EXP-1
                	RET
                
                	ENDIF
                
                ;END OF MODULE FPBCD
                ;FNSOPS 11/05/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;ARITHMETIC AND CONTROL FUNCTION AND OP ROUTINES
                
                ;AUXILLIARY FUNCTIONS CALLED BY FN / OP ROUTINES
                
                ;READP READS THE PORT # GIVEN IN C.
                	IF	NOT WILD
 1141 CD5A02    READP:	CALL	ISBYT
 1144 79        	MOV	A,C
 1145 320A40    RDP1:	STA	RPORT+1		;SET PORT #
 1148 C30940    	JMP	RPORT		;READ THE PORT AND RETURN
                	ENDIF
                
                ;STBIT SETS BIT # [(E) AND (D)] OF DE.
                ;RETN:	A,HL	CLOBBERED
                ;	BC	PRESERVED
                ;	DE	BIT # [(E) AND (D)] SET, OTHERS RESET
                	IF	NOT WILD
 114B 160F      STBT0:	MVI	D,0FH
 114D 7B        STBIT:	MOV	A,E
 114E A2        	ANA	D		;(E) MASKED BY (D) TO A, CARRY RESET
 114F 110100    	LXI	D,1		;SET BIT 0 OF DE
 1152 C8        STBI1:	RZ			;DONE IF (A) = 0
 1153 EB        	XCHG
 1154 29        	DAD	H		;MOVE BIT LEFT IN HL
 1155 EB        	XCHG
 1156 3D        	DCR	A
 1157 C35211    	JMP	STBI1
                	ENDIF
                
                ;SNFIX REPLACES (BC) AND (DE) BY THEIR ABS VALUES, SETS SIGN BIT
                ;OF TEMP IFF EXACTLY ONE OF THEM WAS < 0.
                ;SNFX0 DOES SNFIX, RETURNS CARRY IF (DE) = 0.
 115A 7A        SNFX0:	MOV	A,D
 115B B3        	ORA	E
 115C 37        	STC
 115D C8        	RZ			;RETURN CARRY IF DE=0, ELSE DO SNFIX
 115E 78        SNFIX:	MOV	A,B
 115F AA        	XRA	D		;DESIRED SIGN TO A7
 1160 32B941    	STA	TEMP		;AND SAVED
 1163 CD2813    	CALL	IABS		;REPLACE BC BY ABS(BC)
 1166 D8        	RC
 1167 7A        	MOV	A,D
 1168 B7        	ORA	A
 1169 FC6502    	CM	CPLDE		;REPLACE DE BY -(DE) IF NEGATIVE
 116C C9        	RET
                
                ;MULTY MULTIPLIES NONNEGATIVE INTEGERS IN A AND DE, LEAVES HL + PRODUCT IN HL.
                ;NB MULTY IS USED BY RND TO PRODUCE (HL) + (A) * (DE) MOD 2 ^ 16 EXACTLY, EVEN
                ;ON OVERFLOW, AND IS THEREFORE MORE COMPLICATED THAN IT WOULD OTHERWISE BE.
                ;CALL:	A	NONNEGATIVE MULTIPLIER
                ;	DE	NONNEGATIVE MULTIPLICAND
                ;RETN:	A	ZERO UNLESS OVERFLOW
                ;	BC	PRESERVED
                ;	DE	CLOBBERED
                ;	HL	(HL) + (A) * (DE), MOD 2 ^ 16 IF OVERFLOW
                ;	CARRY	SET IFF OVERFLOW
                ;MULBD MULTIPLIES UNSIGNED VALUES IN BC AND DE, RETURNS RESULT IN HL.
 116D CD8002    MULBD:	CALL	CMBDU
 1170 D43113    	CNC	BCDE		;FORCE BC <= DE
 1173 78        	MOV	A,B
 1174 B7        	ORA	A
 1175 37        	STC
 1176 C0        	RNZ			;OVERFLOW IF BOTH ARGS >= 2 ^ 8
 1177 79        	MOV	A,C		;MULTIPLIER TO A AND FALL THOUGH TO MULT0
 1178 210000    MULT0:	LXI	H,0
 117B C5        MULTY:	PUSH	B
 117C 0600      	MVI	B,0		;KEEP TRACK OF OVERFLOW IN B
 117E B7        MULT1:	ORA	A		;CLEAR CARRY
 117F 1F        	RAR			;GET NEXT BIT OF MULTIPLIER IN CARRY
 1180 D28711    	JNC	MULT2
 1183 19        	DAD	D		;ADD MULTIPLICAND TO PARTIAL PRODUCT
 1184 DCD818    	CC	OVSET		;OVERFLOW
 1187 B7        MULT2:	ORA	A
 1188 CA9411    	JZ	MULT3		;DONE WHEN NO MORE BITS ON
 118B EB        	XCHG
 118C 29        	DAD	H		;SHIFT MULTIPLICAND LEFT ONE
 118D EB        	XCHG
 118E DCD818    	CC	OVSET		;OVERFLOW
 1191 C37E11    	JMP	MULT1
 1194 78        MULT3:	MOV	A,B
 1195 C1        	POP	B
 1196 17        	RAL			;CARRY SET IFF OVERFLOW
 1197 C9        	RET
                
                ;DIVD0 DOES THE WORK OF DIVISION.
                ;CALL:	BC	NONNEGATIVE DIVIDEND
                ;	DE	NONNEGATIVE NONZERO DIVISOR
                ;RETN:	DE	REMAINDER
                ;	HL	QUOTIENT
                ;THE DIVIDEND STARTS IN HL AND IS SHIFTED BIT BY BIT INTO DE AS QUOTIENT BITS
                ;ARE SHIFTED INTO HL.  AT DIVD1, WE HAVE [0 BITS : CURRENT DIVIDEND] IN DE,
                ;[DIVIDEND BITS : QUOTIENT BITS] IN HL.
                ;A TELLS US HOW MANY BITS ARE LEFT OF : IN THE ABOVE DESCRIPTION.
 1198 60        DIVD0:	MOV	H,B
 1199 69        	MOV	L,C		;DIVIDEND TO HL
 119A CD2E13    	CALL	UMIND		;- DIVISOR TO BC
 119D 110000    	LXI	D,0		;CURRENT DIVIDEND 0
 11A0 3E10      	MVI	A,16		;COUNT TO A
 11A2 B7        	ORA	A		;FIRST QUOTIENT BIT 0
 11A3 F5        DIVD1:	PUSH	PSW		;SAVE QUOTIENT BIT
 11A4 29        	DAD	H		;SHIFT HL LEFT
 11A5 F5        	PUSH	PSW		;SAVE HIGH BIT OF DIVIDEND
 11A6 EB        	XCHG
 11A7 29        	DAD	H		;SHIFT DE LEFT
 11A8 F1        	POP	PSW
 11A9 DCC111    	CC	INXH		;ADD IN DIVIDEND BIT
 11AC F1        	POP	PSW
 11AD D2B111    	JNC	DIVD3
 11B0 13        	INX	D		;ADD IN QUOTIENT BIT
 11B1 E5        DIVD3:	PUSH	H		;SAVE CURRENT DIVIDEND
 11B2 09        	DAD	B		;TRY SUBTRACTING DIVISOR
 11B3 D2B711    	JNC	DIVD4		;TOO BIG, RETAIN OLD ONE
 11B6 E3        	XTHL			;OK, KEEP NEW ONE
 11B7 E1        DIVD4:	POP	H		;CARRY SET IFF SUBTRACTION WORKED
 11B8 EB        	XCHG
 11B9 3D        	DCR	A
 11BA C2A311    	JNZ	DIVD1		;KEEP GOING
 11BD CE00      	ACI	0		;ZERO SET IFF CARRY RESET
 11BF 29        	DAD	H		;SHIFT QUOTIENT ONE MORE TIME
 11C0 C8        	RZ
 11C1 23        INXH:	INX	H		;ADD IN LAST QUOTIENT BIT
 11C2 C9        	RET
                
                ;AMBOP IS CALLED DURING EXECUTION OF AN AMBIGUOUS BINARY OP
                ;(NAMELY + - * / AND RELATIONS).  THE ARGS ARE FORCED TO
                ;MATCH AND ARE FETCHED, AND THE TYPE IS RETURNED IN THE STATUS BITS.
                ;IN ADDITION, THE ARG1 POINTER IS SAVED IN TEMP2 FOR RETRY IF INTEGER.
                ;CALL:	BC,DE	ARG1, ARG2 POINTERS
                ;RETN:	BC,DE	ARG1, ARG2 VALUES IF INTEGER
                ;	CDE,BHL	ARG1, ARG2 VALUES IF STRING
                ;	FACC,HL	ARG1 VALUE, ARG2 POINTER IF FLOATING
                ;	CARRY	SET IFF STRING
                ;	ZERO	SET IFF INTEGER
 11C3 EB        AMBOP:	XCHG			;ARG2 ADDR TO HL
 11C4 0A        	LDAX	B		;FETCH ARG1 TYPE
 11C5 BE        AMBO1:	CMP	M		;RETRY ENTRY POINT
 11C6 C4E911    	CNZ	AMBTY		;FORCE TYPES TO AGREE
 11C9 C5        	PUSH	B		;SAVE ARG1 POINTER
 11CA CD1702    	CALL	FETCH		;ARG2 POINTER TO HL
                	IFTYP	AMBOF, AMBOS	;BRANCH IF NONINTEGER
 11CD+C2E211    	JNZ	AMBOF
 11D0+DADA11    	JC	AMBOS
 11D3 E1        	POP	H		;ARG1 POINTER TO HL
 11D4 C5        	PUSH	B		;SAVE ARG2 VALUE
 11D5 CD1702    	CALL	FETCH		;FETCH ARG1 VALUE TO BC
 11D8 D1        	POP	D		;ARG2 VALUE TO DE
 11D9 C9        	RET
                	IF	STRNG
 11DA E1        AMBOS:	POP	H		;ARG1 POINTER TO HL
 11DB 41        	MOV	B,C		;ARG2 LENGTH TO B
 11DC D5        	PUSH	D		;SAVE ARG2 LOC
 11DD CD1702    	CALL	FETCH		;ARG1 TO CDE
 11E0 E1        	POP	H		;ARG2 LOC TO HL
 11E1 C9        	RET
                	ENDIF
                	IF	FLOAT
 11E2 E3        AMBOF:	XTHL			;SAVE ARG2 POINTER, ARG1 POINTER TO HL
 11E3 CD1702    	CALL	FETCH		;FETCH ARG1
 11E6 E1        	POP	H
 11E7 23        	INX	H		;POINT TO ARG2 VALUE WITH HL
 11E8 C9        	RET
                	ENDIF
                ;AMBTY FORCES BOTH ARGS TO FLOATING.
                AMBTY:	IF	FLOAT
 11E9 CD9512    	CALL	CNVTF		;FLOAT ARG2
 11EC C5        	PUSH	B
 11ED E3        	XTHL
 11EE CDD90A    	CALL	CNVRT		;FLOAT ARG1
 11F1 E3        	XTHL
 11F2 C1        	POP	B
 11F3 C9        	RET
                	ELSE
                	JMP	TMERR		;FATAL TM ERROR IF NONFLOATING VERSION
                	ENDIF
                
                ;CMPAR DOES THE WORK OF COMPARING TWO ARGS FOR RELATION ROUTINES.
                ;CALL:	BC, DE	ARG POINTERS
                ;RETN:	BC	0
                ;	CARRY, ZERO	SET AS FOR CMBDS
 11F4 CDC311    CMPAR:	CALL	AMBOP		;FETCH ARGS, SET STATUS BITS
                	IFTYP	CMPAF, CMPAS	;BRANCH IF NONINTEGER
 11F7+C20B12    	JNZ	CMPAF
 11FA+DA0412    	JC	CMPAS
 11FD CD8C02    	CALL	CMBDS		;COMPARE INTEGER ARG1 TO ARG2, SIGNED
 1200 010000    	LXI	B,0
 1203 C9        	RET
                	IF	STRNG
 1204 CD8628    CMPAS:	CALL	CMSTR		;COMPARE STRING ARG1 TO ARG2
 1207 010000    	LXI	B,0
 120A C9        	RET
                	ENDIF
                	IF	FLOAT
 120B CD2312    CMPAF:	CALL	CMPFL		;PERFORM FLOATING COMPARE
 120E 010000    	LXI	B,0
 1211 F0        	RP			;ARG1 > ARG2, RETURN CARRY RESET
 1212 C8        	RZ			;ARG1 = ARG2, RETURN ZERO SET
 1213 37        	STC			;ARG1 < ARG2, RETURN CARRY SET
 1214 C9        	RET
                
                ;ETEST TESTS THE SIGNIFICANCE VALUE IN E.  IF THE RESULT IS
                ;INSIGNIFICANT IT IS REPLACED BY A FLOATING ZERO.
                	IF	(NOT F9511) AND (NOT FPBCD)
 1215 67        ETEST:	MOV	H,A		;SAVE A
 1216 7B        	MOV	A,E
 1217 C680      	ADI	80H
 1219 FE6D      	CPI	(80H-SINDX) AND 255	;COMPARE TO DESIRED SIGNIFICANCE INDEX
 121B 7C        	MOV	A,H		;RESTORE A
 121C D0        	RNC			;RESULT SIGNIFICANT
 121D FE70      	CPI	83H-SINDX	;COMPARE EXPONENT TO SEE IF SMALL
 121F D0        	RNC			;NOT SMALL, TAKE COMPUTED VALUE
 1220 C3C60D    	JMP	FZRO		;RESULT INSIGNIFICANT, TAKE 0. INSTEAD
                	ENDIF
                
                ;CMPFL COMPARES TWO FP NUMBERS, RETURNS SIGN AND ZERO SET AS FOR FTEST.
                	IF	F9511
                CMPFL:	MVI	A,XCH95
                	CALL	O9511		;EXCHANGE ORDER OF ARGS
                CMPF0:	CALL	FSUB0		;SUBTRACT ARGS -- BDTST ENTRY POINT
                	IN	C9511		;READ RESULT STATUS
                	ANI	ZER95		;CHECK ZERO BIT
                	JNZ	CMPF1		;RESULT IS 0
                	IN	C9511
                	RAL			;SIGN STATUS TO BIT A7
                	ANI	80H		;MASK TO SIGN BIT
                	ORI	1		;RESET ZERO, SET SIGN APPROPRIATELY
                	RET
                CMPF1:	XRA	A		;SET ZERO, RESET SIGN
                	RET
                	ELSE			;NOT F9511
                	IF	FPBCD
                CMPFL:	CALL	FSUB		;SUBTRACT
                FTEST:	LDA	FACC		;FETCH RESULT SIGN/EXPONENT BYTE
                	ORA	A
                	RET			;ZERO SET IFF EQUAL, ELSE SIGN SET
                	ELSE
 1223 EB        CMPFL:	XCHG			;ARG2 EXP ADDRESS TO DE
 1224 21B340    	LXI	H,ACCE		;ARG1 (IN FACC) EXPONENT ADDRESS TO HL
 1227 7E        	MOV	A,M
 1228 B7        	ORA	A		;ZERO SET IFF EXP(ARG1) = 0
 1229 1A        	LDAX	D		;FETCH EXP(ARG2)
 122A CA7B12    	JZ	CMPF5
 122D B7        	ORA	A		;ZERO SET IFF EXP(ARG2) = 0
 122E 23        	INX	H
 122F CA7F12    	JZ	CMPF7
 1232 13        	INX	D
 1233 1A        	LDAX	D		;FETCH SIGN(ARG2)
 1234 AE        	XRA	M		;COMPARE TO SIGN(ARG1)
 1235 F27E12    	JP	CMPF6		;SIGNS NOT EQUAL
 1238 2B        	DCX	H
 1239 1B        	DCX	D
 123A 1A        	LDAX	D		;FETCH EXP(ARG2) AGAIN
 123B 96        	SUB	M		;COMPARE TO EXP(ARG1)
 123C C25C12    	JNZ	CMPF2		;EXPONENTS NOT EQUAL
 123F 23        	INX	H
 1240 23        	INX	H
 1241 13        	INX	D
 1242 1A        	LDAX	D		;FETCH MMSB(ARG2)
 1243 F680      	ORI	80H		;RESTORE HIDDEN BIT
 1245 BE        	CMP	M		;COMPARE TO MSB(ARG1)
 1246 C27312    	JNZ	CMPF4		;MSB OF FRACTION NOT EQUAL
 1249 23        	INX	H
 124A 13        	INX	D
 124B 1A        	LDAX	D		;FETCH BYTE2(ARG2)
 124C BE        	CMP	M		;COMPARE TO BYTE2(ARG1)
 124D C27312    	JNZ	CMPF4		;BYTE2 OF FRACTION NOT EQUAL
 1250 1B        	DCX	D
 1251 1B        	DCX	D		;READDRESS EXP(ARG2)
 1252 EB        CMPF1:	XCHG			;ARG2 POINTER TO HL
 1253 CD520E    	CALL	FSUB		;ARG1-ARG2
 1256 CD1512    	CALL	ETEST		;CHECK IF ALMOST 0
 1259 C3D70D    	JMP	FTEST		;SET STATUS BITS AND RETURN
 125C 3D        CMPF2:	DCR	A
 125D CA6512    	JZ	CMPF3		;EXPONENTS DIFFER BY 1
 1260 3C        	INR	A
 1261 3C        	INR	A
 1262 C27312    	JNZ	CMPF4		;EXPONENTS DIFFER BY MORE THAN 1
 1265 23        CMPF3:	INX	H
 1266 23        	INX	H
 1267 13        	INX	D
 1268 1A        	LDAX	D		;FETCH MSB(ARG2)
 1269 AE        	XRA	M		;MSB(ARG2) XOR MSB(ARG1)
 126A 1B        	DCX	D
 126B 3C        	INR	A		;ZERO SET IF NEAR EXPONENT BOUNDARY
 126C CA5212    	JZ	CMPF1		;IN WHICH CASE DO THE SUBTRACTION
 126F 2B        	DCX	H
 1270 2B        	DCX	H
 1271 1A        	LDAX	D		;FETCH EXP(ARG2)
 1272 BE        	CMP	M		;CARRY SET IF EXP(ARG2) < EXP(ARG1)
 1273 1F        CMPF4:	RAR			;CARRY TO A7
 1274 21B440    	LXI	H,ACCS		;ADDRESS ARG1 SIGN
 1277 AE        	XRA	M		;COMPLEMENT UNLESS NEGATIVE
 1278 F601      	ORI	1		;ASSURE ZERO RESET
 127A C9        	RET
 127B B7        CMPF5:	ORA	A
 127C C8        	RZ			;BOTH ARGS 0, HENCE EQUAL
 127D 13        	INX	D
 127E EB        CMPF6:	XCHG			;SIGN(ARG2) WILL GIVE RESULT
 127F 7E        CMPF7:	MOV	A,M
 1280 EE80      	XRI	80H		;COMPLEMENTED SIGN(ARG1) GIVES RESULT
 1282 F601      	ORI	1		;ASSURE ZERO RESET
 1284 C9        	RET
                	ENDIF			;END OF NOT FPBCD CONDITIONAL
                	ENDIF			;END OF NOT F9511 CONDITIONAL
                
 1285 2AB040    RETRY:	LHLD	ARGAD		;ARG1 POINTER TO HL
 1288 44        	MOV	B,H
 1289 4D        	MOV	C,L		;AND THEN TO BC
 128A 210700    	LXI	H,VBYTS+2
 128D 09        	DAD	B		;ARG2 POINTER TO HL
 128E AF        	XRA	A		;TO ASSURE NONZERO CMP AT AMBO1
 128F C3C511    	JMP	AMBO1		;CONVERT TO FLOATING AND REFETCH
 1292 2AB040    RTRY1:	LHLD	ARGAD		;RECOVER ARG POINTER
 1295 3E02      CNVTF:	MVI	A,SNGST
 1297 C3D90A    	JMP	CNVRT		;FLOAT IT AND RETURN
                	ENDIF
                
                FCERN:	ERROR	N, F, C		;ISSUE NONFATAL FC ERROR
 129A+CDD216    	CALL	ERRON
 129D+46C3      	DB	'F', 'C' OR 80H
 129F C9        	RET			;AND RETURN
                FCERF:	ERROR	F, F, C		;FATAL FC ERROR
 12A0+CDC616    	CALL	ERROF
 12A3+46C3      	DB	'F', 'C' OR 80H
                
                
                ;ROUTINES FOR FN AND OP EXECUTION
                
                ;AMBIGUOUS ARITHMETIC OPS
                ;AOP IS A MACRO FOR EXECUTING AMBIGUOUS OPS, NAMELY + - * ABS AND UNARY -.
                ;IOP, FOP AND SOP ARE ADDRESSES OF INTEGER, FLOATING AND STRING ROUTINES.
                ;UNARY IS A FLAG, TRUE IF UNARY AND FALSE IF BINARY.
                ;SGNIF IS A FLAG FOR SIGNIFICANCE CHECKING, TRUE FOR + AND -.
                ;FCERF IS FATAL FC ERROR FOR STRING ARG TO ARITHMETIC ROUTINE
                AOP	MACRO	IOP,FOP,SOP,UNARY,SNGIF
                	LOCAL	EXFOP
                	IF	UNARY		;;FIRST FETCH ARGS AND SET STATUS BITS
                	CALL	FETBC		;;FETCH ONE ARG FROM BC IF UNARY
                	ELSE
                	CALL	AMBOP		;;FETCH TWO AGREEING ARGS IF BINARY
                	ENDIF
                	IFTYP	EXFOP, SOP	;;BRANCH IF NONINTEGER
                	CALL	IOP		;;EXECUTE INTEGER OP
                	MVI	A,INTST		;;RETURN TYPE INTEGER
                	RNC			;;DONE UNLESS OVERFLOW
                	IF	FLOAT
                	IF	UNARY
                	CALL	RTRY1		;;RECOVER ARG AND FLOAT IT
                	ELSE
                	CALL	RETRY		;;RECOVER ARGS AND FLOAT THEM
                	ENDIF
                EXFOP:	CALL	FOP		;;EXECUTE FLOATING OP
                	IF	F9511
                	CALL	FET95		;;FETCH RESULT IF 9511 OP
                	ELSE
                	IF	SNGIF AND NOT FPBCD
                	CALL	ETEST		;;TEST VALUE IN E FOR SIGNIFICANCE IF SGNIF
                	ENDIF
                	ENDIF
                	MOV	E,A		;;SAVE A
                	MVI	A,SNGST		;;RETURN TYPE FLOATING
                	RET
                	ELSE
                	JMP	IOVER		;;INTEGER OV ERROR IF NOT FLOATING VERSION
                	ENDIF
                	ENDM
                
                ;ADDITION(+): {<INTEGER>|<FLOATING>|<STRING>} X {<INTEGER>|<FLOATING>|<STRING>}
                ;	--> {<INTEGER>|<FLOATING>|<STRING>}
                AADD:	AOP	IADD,FADD,SADD,FALSE,TRUE
 12A5+CDC311    	CALL	AMBOP
 12A8+C2B712    	JNZ	??0001
 12AB+DABD28    	JC	SADD
 12AE+CD3A13    	CALL	IADD
 12B1+3E01      	MVI	A,INTST
 12B3+D0        	RNC
 12B4+CD8512    	CALL	RETRY
 12B7+CD550E    ??0001:	CALL	FADD
 12BA+CD1512    	CALL	ETEST
 12BD+5F        	MOV	E,A
 12BE+3E02      	MVI	A,SNGST
 12C0+C9        	RET
                
                ;SUBTRACTION (-): {<INTEGER>|<FLOATING>} X {<INTEGER>|<FLOATING>}
                ;	--> {<INTEGER>|<FLOATING>}
                ASUB:	AOP	ISUB,FSUB,FCERF,FALSE,TRUE
 12C1+CDC311    	CALL	AMBOP
 12C4+C2D312    	JNZ	??0002
 12C7+DAA012    	JC	FCERF
 12CA+CD3613    	CALL	ISUB
 12CD+3E01      	MVI	A,INTST
 12CF+D0        	RNC
 12D0+CD8512    	CALL	RETRY
 12D3+CD520E    ??0002:	CALL	FSUB
 12D6+CD1512    	CALL	ETEST
 12D9+5F        	MOV	E,A
 12DA+3E02      	MVI	A,SNGST
 12DC+C9        	RET
                
                ;MULTIPLICATION (*): {<INTEGER>|<FLOATING>} X {<INTEGER>|<FLOATING>}
                ;	--> {<INTEGER>|<FLOATING>}
                AMUL:	AOP	IMUL,FMUL,FCERF,FALSE,FALSE
 12DD+CDC311    	CALL	AMBOP
 12E0+C2EF12    	JNZ	??0003
 12E3+DAA012    	JC	FCERF
 12E6+CD4813    	CALL	IMUL
 12E9+3E01      	MVI	A,INTST
 12EB+D0        	RNC
 12EC+CD8512    	CALL	RETRY
 12EF+CD080E    ??0003:	CALL	FMUL
 12F2+5F        	MOV	E,A
 12F3+3E02      	MVI	A,SNGST
 12F5+C9        	RET
                
                ;UNARY MINUS (-): {<INTEGER> | <FLOATING>} --> {<INTEGER> | <FLOATING>}
                AUMIN:	AOP	IUMIN,FCHS,FCERF,TRUE,FALSE
 12F6+CD1502    	CALL	FETBC
 12F9+C20813    	JNZ	??0004
 12FC+DAA012    	JC	FCERF
 12FF+CD2B13    	CALL	IUMIN
 1302+3E01      	MVI	A,INTST
 1304+D0        	RNC
 1305+CD9212    	CALL	RTRY1
 1308+CDCC0D    ??0004:	CALL	FCHS
 130B+5F        	MOV	E,A
 130C+3E02      	MVI	A,SNGST
 130E+C9        	RET
                
                ;ABS: {<INTEGER> | <FLOATING>} --> {<INTEGER> | <FLOATING>}
                AABS:	AOP	IABS,FABS,FCERF,TRUE,FALSE
 130F+CD1502    	CALL	FETBC
 1312+C22113    	JNZ	??0005
 1315+DAA012    	JC	FCERF
 1318+CD2813    	CALL	IABS
 131B+3E01      	MVI	A,INTST
 131D+D0        	RNC
 131E+CD9212    	CALL	RTRY1
 1321+CDCF0D    ??0005:	CALL	FABS
 1324+5F        	MOV	E,A
 1325+3E02      	MVI	A,SNGST
 1327+C9        	RET
                
                ;INTEGER ABS, UNARY MINUS: <INTEGER> --> <INTEGER>
                ;IABS AND IUMIN PRESERVE DE AND HL.
 1328 78        IABS:	MOV	A,B
 1329 B7        IABS1:	ORA	A		;SIGN SET IFF (BC) <0
 132A F0        	RP			;RETURN IF > 0, OTHERWISE PERFORM UNARY MINUS
 132B CD3113    IUMIN:	CALL	BCDE		;ARG TO DE, DE TO BC
 132E CD6502    UMIND:	CALL	CPLDE		;COMPLEMENT IT
                ;BCDE EXCHANGES BC AND DE.
 1331 C5        BCDE:	PUSH	B
 1332 42        	MOV	B,D
 1333 4B        	MOV	C,E
 1334 D1        	POP	D
 1335 C9        	RET
                
                ;INTEGER ADDITION AND SUBTRACTION: <INTEGER> X <INTEGER> --> <INTEGER>
 1336 CD6502    ISUB:	CALL	CPLDE		;COMPLEMENT AND ADD
 1339 D8        	RC
 133A 7A        IADD:	MOV	A,D
 133B A8        	XRA	B		;SIGN (BC) XOR SIGN (DE) TO SIGN
 133C 78        	MOV	A,B		;SIGN OF BC TO A7 IN CASE AGREE
 133D EB        	XCHG			;ARG2 TO HL
 133E 09        	DAD	B
 133F 44        	MOV	B,H
 1340 4D        	MOV	C,L		;(BC) + (DE) TO BC
 1341 FAF017    	JM	RETNC		;RESULT OK IF SIGNS DIFFER, RETURN CARRY RESET
 1344 A8        	XRA	B		;COMPARE ACTUAL & DESIRED RESULT SIGNS
 1345 F0        	RP			;RETURN IF NO OVERFLOW
 1346 37        STCR:	STC
 1347 C9        	RET
                
                ;INTEGER MULTIPLICATION: <INTEGER> X <INTEGER> --> <INTEGER>
 1348 CD5E11    IMUL:	CALL	SNFIX		;FORCE BC, DE >= 0 AND SAVE DESIRED RESULT SIGN
 134B D8        	RC
 134C CD6D11    	CALL	MULBD		;BC * DE TO HL
 134F D8        	RC
 1350 44        IMUL1:	MOV	B,H		;DIVID ENTRY POINT
 1351 4D        	MOV	C,L		;RESULT TO BC
 1352 29        	DAD	H
 1353 D8        	RC			;OVERFLOW IF >= 2 ^ 15
 1354 3AB941    	LDA	TEMP
 1357 C32913    	JMP	IABS1		;RETURN ACCORDING TO DESIRED SIGN
                
                ;INTEGER DIVISION (\): <INTEGER> X <INTEGER> --> <INTEGER>
 135A CD5A11    IDIVD:	CALL	SNFX0		;FORCE BC >= 0, DE > 0
 135D DACC18    	JC	IOVER		;INTEGER OVERFLOW IF DE=0
 1360 CD9811    	CALL	DIVD0		;QUOTIENT TO HL, REMAINDER TO DE
 1363 C35013    	JMP	IMUL1		;FIX SIGN OF RESULT AND RETURN
                
                ;MOD: <INTEGER> X <INTEGER> --> <INTEGER>
                ;X MOD Y = SIGN(X) * [ABS(X) MOD ABS(Y)], SO X = [(X/Y)*Y] + [X MOD Y].
 1366 60        OPMOD:	MOV	H,B		;SAVE DESIRED RESULT SIGN IN H
 1367 CD5A11    	CALL	SNFX0		;FORCE BC >= 0, DE > 0
 136A D8        	RC
 136B 7C        	MOV	A,H
 136C 32B941    	STA	TEMP		;DESIRED RESULT SIGN TO TEMP
 136F CD9811    	CALL	DIVD0		;REMAINDER TO DE
 1372 EB        	XCHG			;RESULT TO HL
 1373 C35013    	JMP	IMUL1		;AND RETURN ACCORDING TO DESIRED SIGN
                
                ;RELATIONS: {<INTEGER>|<FLOATING>|<STRING>} X {<INTEGER>|<FLOATING>|<STRING>}
                ;	--> <INTEGER>
                ;RELATIONS CALL CMPAR TO SET STATUS BITS AND RETURN 0 IN BC.  THE STATUS
                ;BITS ARE USED TO RETURN IF FALSE (0), OR DECREMENT BC IF TRUE (-1).
 1376 CDF411    EQUAL:	CALL	CMPAR		;COMPARE AND ZERO BC
 1379 C0        	RNZ			;FALSE IFF ZERO RESET
 137A 0B        	DCX	B		;TRUE
 137B C9        	RET
 137C CDF411    NEQ:	CALL	CMPAR
 137F C8        	RZ			;FALSE IFF ZERO SET
 1380 0B        	DCX	B
 1381 C9        	RET
 1382 CDF411    LTHAN:	CALL	CMPAR
 1385 D0        	RNC			;FALSE IFF CARRY RESET
 1386 0B        	DCX	B
 1387 C9        	RET
 1388 CDF411    GEQ:	CALL	CMPAR
 138B D8        	RC			;FALSE IFF CARRY SET
 138C 0B        	DCX	B
 138D C9        	RET
 138E CDF411    LEQ:	CALL	CMPAR
 1391 DA9513    	JC	LEQ1
 1394 C0        	RNZ			;FALSE IFF CARRY RESET AND ZERO RESET
 1395 0B        LEQ1:	DCX	B
 1396 C9        	RET
 1397 CDF411    GTHAN:	CALL	CMPAR
 139A C8        	RZ			;FALSE IF ZERO SET
 139B D8        	RC			;FALSE IF CARRY SET
 139C 0B        	DCX	B
 139D C9        	RET
                
                ;LOGOP IS A MACRO TO PERFORM LOGICAL OPS ON B AND D, AND ON C AND E.
                LOGOP	MACRO	LINST
                	MOV	A,B
                	LINST	D		;;APPLY LOGICAL INSTRUCTION TO B AND D
                	MOV	B,A		;;AND RESULT TO B
                	MOV	A,C
                	LINST	E		;;APPLY LOGICAL INSTRUCTION TO C AND E
                	MOV	C,A		;;AND RESULT TO C
                	RET
                	ENDM
                
                ;NOT, XOR: <INTEGER> --> <INTEGER>
 139E 11FFFF    OPNOT:	LXI	D,-1		;NOT IS XOR WITH -1
                OPXOR:	LOGOP	XRA
 13A1+78        	MOV	A,B
 13A2+AA        	XRA	D
 13A3+47        	MOV	B,A
 13A4+79        	MOV	A,C
 13A5+AB        	XRA	E
 13A6+4F        	MOV	C,A
 13A7+C9        	RET
                
                ;AND, RESET: <INTEGER> X <INTEGER> --> <INTEGER>
                	IF	NOT WILD
 13A8 CD4B11    RESET:	CALL	STBT0
 13AB CD6602    	CALL	CPLD1		;RESET BIT #(E) MOD 16 OF DE, THEN AND
                	ENDIF
                OPAND:	LOGOP	ANA
 13AE+78        	MOV	A,B
 13AF+A2        	ANA	D
 13B0+47        	MOV	B,A
 13B1+79        	MOV	A,C
 13B2+A3        	ANA	E
 13B3+4F        	MOV	C,A
 13B4+C9        	RET
                
                ;OR, SET: <INTEGER> X <INTEGER> --> <INTEGER>
                	IF	NOT WILD
 13B5 CD4B11    SETFN:	CALL	STBT0		;SET BIT #(E) MOD 16 OF DE, THEN OR
                	ENDIF
                OPOR:	LOGOP	ORA
 13B8+78        	MOV	A,B
 13B9+B2        	ORA	D
 13BA+47        	MOV	B,A
 13BB+79        	MOV	A,C
 13BC+B3        	ORA	E
 13BD+4F        	MOV	C,A
 13BE+C9        	RET
                
                ;JOIN: <INTEGER> X <INTEGER> --> <INTEGER>
                	IF	NOT WILD
 13BF CD5A02    JOIN:	CALL	ISBYT		;CHECK (B) = 0
 13C2 42        	MOV	B,D
 13C3 CD5A02    	CALL	ISBYT		;CHECK (D) = 0
 13C6 41        	MOV	B,C
 13C7 4B        	MOV	C,E
 13C8 C9        	RET
                	ENDIF
                
                	IF	FLOAT AND NOT F9511
                ;INT: <FLOATING> --> {<INTEGER> | <FLOATING>}
                INT:	IF	FPBCD
                	LXI	H,FTEMP
                	CALL	FSTOR		;SAVE ARG IN FTEMP IN CASE IINT FAILS
                	ENDIF
 13C9 CDD613    	CALL	IINT		;TRY TO CONVERT TO INTEGER
 13CC 3E01      	MVI	A,INTST		;RESULT TYPE = INTEGER
 13CE D0        	RNC			;RETURN IF SUCCESSFUL CONVERSION TO INTEGER
                	IF	FPBCD
                	LXI	H,FTEMP
                	CALL	FLOAD		;RESTORE ARG TO FACC
                	CALL	FINT		;TRUNCATE ARG
                	DCR	E
                	JNZ	INT1		;NO DIGITS TRUNCATED, DONE
                	LDA	FACC
                	ORA	A
                	JP	INT1		;TRUNCATED AND POSITIVE, DONE
                	LXI	H,FPONE
                	CALL	FSUB		;TRUNCATED AND NEGATIVE, SUBRACT ONE FOR RESULT
                	ELSE			;NOT FPBCD
 13CF CDE613    	CALL	FLINT		;GET INTEGER PART OF FLOATING VALUE
 13D2 5F        	MOV	E,A
                	ENDIF			;END OF NOT FPBCD CONDITIONAL
 13D3 3E02      INT1:	MVI	A,SNGST		;RESULT TYPE = FLOATING
 13D5 C9        	RET
                
                ;IINT FIXES A FLOATING VALUE TO A TWO-BYTE INTEGER VALUE.
                	IF	NOT FPBCD	;IINT IS SAME AS FFIX IN FPBCD VERSION
 13D6 1E10      IINT:	MVI	E,16
 13D8 CDA210    	CALL	FFIX		;FIX FLOATING POINT VALUE
 13DB D8        	RC			;CANNOT FIX TO INTEGER, RETURN CARRY
 13DC 48        	MOV	C,B
 13DD 47        	MOV	B,A		;RESULT TO BC
 13DE C9        	RET
                	ENDIF			;END OF NOT FPBCD CONDITIONAL
                
                ;UNS: <INTEGER> --> <FLOATING>
                	IF	FPBCD
                	IF	NOT WILD
                UNSFN:	MOV	A,B
                	ORA	A
                	PUSH	PSW		;SAVE ARG SIGN
                	CALL	FFLOT		;FLOAT THE ARG
                	POP	PSW
                	RP			;ARG WAS POSITIVE, DONE
                	LXI	H,UNSMAX
                	JMP	FADD		;ELSE RESULT IS 65536 + ARG
                UNSMAX:	DB	45H, 65H, 53H, 60H, 0, 0
                	ENDIF
                	ELSE			;NOT FPBCD
 13DF AF        UNSFN:	XRA	A		;0 TO A
 13E0 111800    	LXI	D,24		;0 TO D, 24 TO E
 13E3 C38C10    	JMP	FFLOT		;FLOAT ABCD AND RETURN
                
 13E6 1E20      FLINT:	MVI	E,32
 13E8 CDA210    	CALL	FFIX		;TRY FIXING TO 3-BYTE INTEGER
 13EB 1E20      	MVI	E,32		;SCALE FACTOR TO E
 13ED D28C10    	JNC	FFLOT		;FLOAT THE FIXED VALUE
 13F0 C3D70D    	JMP	FTEST		;FETCH THE FLOATING VALUE
                	ENDIF			;END OF NOT FPBCD CONDITIONAL
                	ENDIF
                
                ;FIRST, LAST: --> <INTEGER>
                	IF	ROMSQ AND (NOT WILD)
                FIRST:	LHLD	SOURC
                	DCX	H		;HL POINTS TO CR PRECEDING SOURCE
                	MOV	B,H
                	MOV	C,L		;TO BC
                	RET
                	ELSE
 0197 =         FIRST	EQU	EXERR		;EX ERROR IN NON-ROMSQ VERSIONS
                	ENDIF
                	IF	ROMSQ		;LAST MUST BE DEFINED IN WILD VERSIONS
                LAST:	LXI	D,-1
                	CALL	FINDL		;FIND LINE 65535
                	MOV	E,M
                	MVI	D,0		;LENGTH TO DE
                	JMP	FRE2		;LAST ADDR TO BC
                	ELSE
 0197 =         LAST	EQU	EXERR
                	ENDIF
                
                ;MSBYTE, LSBYTE: <INTEGER> --> <INTEGER>
                	IF	NOT WILD
 13F3 48        MSBYT:	MOV	C,B		;MOVE MS TO LS BYTE
 13F4 0600      LSBYT:	MVI	B,0		;ZERO MS BYTE
 13F6 C9        	RET
                	ENDIF
                
                ;BCD: <INTEGER> --> <INTEGER>
                	IF	NOT WILD
 13F7 AF        BCD:	XRA	A
 13F8 CD2816    	CALL	CVTIS		;CONVERT INTEGER TO STRING, NO LEADING CHAR
 13FB FE05      	CPI	5
 13FD D21414    	JNC	FCER0		;LENGTH >= 5, NONFATAL FC ERROR AND RETURN 0
 1400 210000    	LXI	H,0		;EMBRYO VALUE TO HL
 1403 1A        BCD1:	LDAX	D		;FETCH NEXT CHAR OF STRING
 1404 13        	INX	D		;AND POINT TO NEXT
 1405 D630      	SUI	'0'		;SUBTRACT ASCII BIAS
 1407 29        	DAD	H
 1408 29        	DAD	H
 1409 29        	DAD	H
 140A 29        	DAD	H		;RESULT LEFT ONE NIBBLE
 140B B5        	ORA	L
 140C 6F        	MOV	L,A		;AND NEW NIBBLE ORED IN
 140D 0D        	DCR	C		;COUNT DOWN LENGTH
 140E C20314    	JNZ	BCD1		;MORE CHARS IN STRING
 1411 44        	MOV	B,H
 1412 4D        	MOV	C,L		;RESULT TO BC
 1413 C9        	RET
                	ENDIF			;END OF NOT WILD CONDITIONAL
 1414 CD9A12    FCER0:	CALL	FCERN		;ISSUE NONFATAL FC ERROR
 1417 010000    	LXI	B,0
 141A 3E01      	MVI	A,INTST		;AND RETURN INTEGER 0 AS RESULT
 141C C9        	RET
                
                ;BIN: <INTEGER> --> <INTEGER>
                	IF	NOT WILD
 141D 210000    BIN:	LXI	H,0		;EMBRYO VALUE TO HL
 1420 CD2A14    	CALL	BIN1		;SUM HIGH ORDER BYTE
 1423 41        	MOV	B,C
 1424 CD2A14    	CALL	BIN1		;SUM LOW ORDER BYTE
 1427 44        	MOV	B,H
 1428 4D        	MOV	C,L		;RESULT TO BC
 1429 C9        	RET
 142A 78        BIN1:	MOV	A,B
 142B 1F        	RAR
 142C 1F        	RAR
 142D 1F        	RAR
 142E 1F        	RAR			;MS FOUR BITS TO A3-A0
 142F CD3314    	CALL	BIN2		;ADD TO SUM
 1432 78        	MOV	A,B		;LS FOUR BITS TO A3-A0
 1433 E60F      BIN2:	ANI	0FH		;MASK OFF OTHER BITS
 1435 FE0A      	CPI	0AH
 1437 D2A012    	JNC	FCERF		;NOT A BCD DIGIT, FC ERROR
 143A 54        	MOV	D,H
 143B 5D        	MOV	E,L		;COPY VALUE TO DE
                	ENDIF			;END OF NOT WILD CONDITIONAL
                ;HL10A REPLACES (HL) WITH 10*(HL)+(A), AND IS CALLED BY GTDEC.
                ;CALL:	DE,HL	VALUE TO MULTIPLY BY 10
                ;	A	VALUE TO ADD TO PRODUCT
                ;RETN:	BC	PRESERVED
                ;	DE	CLOBBERED
                ;	HL	RESULT
 143C 29        HL10A:	DAD	H		; * 2
 143D 29        	DAD	H		; * 4
 143E 19        	DAD	D		; * 5
 143F 29        	DAD	H		; * 10
 1440 D8        	RC			;FOR GTDEC, NEVER HAPPENS FROM BIN
 1441 5F        	MOV	E,A
 1442 1600      	MVI	D,0		;NEXT VALUE TO DE
 1444 19        	DAD	D		;AND ADDED ALSO
 1445 C9        	RET
                
                ;GET, GET$: --> {<INTEGER> | <STRING>}
 1446 3A9A40    GET:	LDA	GCHAR		;VALUE FOR GET IS IN GCHAR
 1449 4F        	MOV	C,A
 144A AF        	XRA	A
 144B 47        	MOV	B,A		;VALUE TO BC
 144C 329A40    	STA	GCHAR		;CLEAR GCHAR
                	IF	STRNG
 144F 1624      	MVI	D,'$'
 1451 CD6F17    	CALL	GTD		;LOOK FOR $
 1454 3E01      	MVI	A,INTST		;RETURN TYPE INTEGER
 1456 D8        	RC			;INTEGER GET
 1457 79        	MOV	A,C		;ELSE STRING GET$
 1458 0E00      	MVI	C,0
 145A B7        	ORA	A		;ZERO SET IFF NO CHAR IN GET
 145B C4EF29    	CNZ	CHRS1		;COPY CHAR TO STRING SPACE
 145E 3E03      	MVI	A,STRST		;AND RETURN TYPE STRING
 1460 C9        	RET
                	ELSE			;NOT STRNG
                	MVI	A,INTST		;RETURN TYPE INTEGER
                	RET
                	ENDIF
                
                ;IOBYTE: --> <INTEGER>
                	IF	(NOT CAMAC) AND (NOT WILD)
 1461 3A0040    IOBYF:	LDA	IOBYT
 1464 C36814    	JMP	PEEK1		;RETURN IOBYTE VALUE IN BC
                	ENDIF
                
                ;PEEK: <INTEGER> --> <INTEGER>
                	IF	NOT WILD
 1467 0A        PEEK:	LDAX	B		;FETCH THE BYTE
                	ENDIF			;PEEK1 IS NEEDED FOR POS
 1468 0600      PEEK1:	MVI	B,0		;ZERO THE MSBYTE
 146A 4F        	MOV	C,A		;RETURN VALUE IN BC
 146B C9        	RET
                
                ;POS: --> <INTEGER>
                	IF	NOT CAMAC
 146C 3A4940    POS:	LDA	COLUM
 146F C36814    	JMP	PEEK1		;RETURN CURRENT COLUMN IN BC
                	ENDIF
                
                ;TEST: <INTEGER> X <INTEGER> --> <INTEGER>
                	IF	NOT WILD
 1472 CD4B11    TEST:	CALL	STBT0		;SET BIT # (E) MOD 16 OF DE
 1475 CDAE13    	CALL	OPAND		;AND WITH (BC) -- RETURNS (C) IN A
 1478 B0        	ORA	B		;ZERO SET IFF (BC) = 0
 1479 010000    TEST1:	LXI	B,0		;RETURN 0 IF ZERO SET
 147C C8        	RZ
 147D 03        	INX	B		;RETURN 1 IF ZERO RESET
 147E C9        	RET
                	ENDIF
                
                ;SGN: {<INTEGER> | <FLOATING>} --> <INTEGER>
 147F CD1502    SGN:	CALL	FETBC		;FETCH ARG
                	IFTYP	FSGN,FCERF	;BRANCH IF NONINTEGER
 1482+C29614    	JNZ	FSGN
 1485+DAA012    	JC	FCERF
 1488 78        	MOV	A,B
 1489 B1        	ORA	C		;ZERO SET IFF (BC)=0
 148A C8        	RZ			;AND RESULT IS 0
 148B 78        	MOV	A,B
 148C F601      	ORI	1		;ZERO RESET, MINUS SET IFF (BC) < 0
 148E 01FFFF    SGN1:	LXI	B,-1
 1491 F8        	RM			;< 0, RETURN -1
 1492 03        	INX	B
 1493 C8        	RZ			;= 0, RETURN 0
 1494 03        	INX	B
 1495 C9        	RET			;ELSE > 0, RETURN 1
                	IF	FLOAT AND NOT F9511
 1496 CDD70D    FSGN:	CALL	FTEST		;SET STATUS BITS
 1499 C38E14    	JMP	SGN1		;AND RETURN AS ABOVE
                	ENDIF
                
                ;IN: <INTEGER> --> <INTEGER>
                	IF	NOT WILD
 149C CD4111    INP:	CALL	READP		;READ THE PORT
 149F 4F        	MOV	C,A		;AND RETURN VALUE READ IN BC
 14A0 C9        	RET
                	ENDIF
                
                ;SENSE: <INTEGER> X <INTEGER> --> <INTEGER>
                	IF	NOT WILD
 14A1 1607      SENSE:	MVI	D,7
 14A3 CD4D11    	CALL	STBIT		;SET BIT # (E) MOD 8 OF E
 14A6 CD4111    	CALL	READP		;READ PORT
 14A9 A3        	ANA	E
 14AA C37914    	JMP	TEST1		;RETURN ZERO IFF BIT RESET
                	ENDIF
                
                ;FRE, FRE$: --> <INTEGER>
                FREFN:	IF	STRNG
 14AD 1624      	MVI	D,'$'
 14AF CD6F17    	CALL	GTD		;LOOK FOR $
 14B2 DABB14    	JC	FRE		;NOT FRE$, JUST RETURN FRE
 14B5 CD5B27    	CALL	GARBG		;GARBAGE COLLECT TO COMPACT STRING SPACE
 14B8 C3C314    	JMP	FRE1		;AND CONTINUE AS BELOW
                	ENDIF
 14BB 2AC241    FRE:	LHLD	CSTKP
 14BE EB        	XCHG			;ADDRESS OF CONTROL STACK TOP TO DE
 14BF 13        	INX	D		;CSTKP + 1
 14C0 2AC641    	LHLD	SYMTA		;SYMBOL TABLE ADDRESS TO HL
 14C3 CD6502    FRE1:	CALL	CPLDE		;- CSTKP - 1
 14C6 19        FRE2:	DAD	D		;TOP - [BOTTOM + 1] = AVAILABLE
 14C7 44        	MOV	B,H		;NB 'SUBTRACTION', SO CARRY RESET IFF BORROW
 14C8 4D        	MOV	C,L		;RESULT TO BC
 14C9 C9        	RET
                
                ;LSHIFT: <INTEGER> X <INTEGER> --> <INTEGER>
                	IF	NOT WILD
 14CA 7B        LSHFT:	MOV	A,E		;SHIFT (BC) LEFT BY (E) MOD 16 PLACES
 14CB E60F      	ANI	0FH
 14CD 50        	MOV	D,B
 14CE 59        	MOV	E,C		;BC TO DE FOR STBI1
 14CF CD5211    	CALL	STBI1		;SHIFT (DE) LEFT (A) BITS
 14D2 42        	MOV	B,D
 14D3 4B        	MOV	C,E
 14D4 C9        	RET
                	ENDIF
                
                ;RSHIFT, ROTATE: <INTEGER> X <INTEGER> --> <INTEGER>
                	IF	NOT WILD
 14D5 1600      RSHFT:	MVI	D,0		;SHIFT (BC) RIGHT BY (E) MOD 16 PLACES
 14D7 21        	DB	21H		;LXI H, TO SKIP ENSUING TWO BYTES
 14D8 1680      ROTAT:	MVI	D,80H		;ROTATE / SHIFT (BC) RIGHT BY (E) MOD 16 PLACES
 14DA 7B        	MOV	A,E		;ENTRY POINT FOR RSHFT WITH (D) = 0
 14DB E60F      	ANI	0FH		;MASK E AND CLEAR CARRY
 14DD C8        	RZ			;DONE IF ZERO
 14DE 5F        	MOV	E,A		;(E) MOD 16 TO E
 14DF 78        ROTA1:	MOV	A,B
 14E0 D2E414    	JNC	ROTA2
 14E3 B2        	ORA	D		;TURN ON HIGH BIT IF ROTATING AND CARRY
 14E4 1F        ROTA2:	RAR
 14E5 47        	MOV	B,A		;CARRY NOW HAS HIGH BIT FOR C
 14E6 79        	MOV	A,C
 14E7 1F        	RAR			;CARRY NOW HAS HIGH BIT FOR B IF ROTATING
 14E8 4F        	MOV	C,A
 14E9 1D        	DCR	E
 14EA C2DF14    	JNZ	ROTA1		;KEEP ROTATING
 14ED D0        	RNC			;DONE UNLESS CARRY
 14EE 78        	MOV	A,B
 14EF B2        	ORA	D		;TURN ON HIGH BIT IF ROTATING
 14F0 47        	MOV	B,A
 14F1 C9        	RET
                	ENDIF			;END OF NOT WILD CONDITIONAL
                
                	IF	REALT
                ;TIME:  <INTEGER> --> <INTEGER>
                ;TIME (0) RETURNS CURRENT REAL TIME CLOCK TICKS IN 20THS,
                ;TIME (1) RETURNS CURRENT SECONDS,
                ;TIME (2) RETURNS CURRENT MINUTES, AND
                ;TIME (3) RETURNS CURRENT HOURS.
                ;TIME (N) FOR ANY OTHER N GIVES NONFATAL FC ERROR AND RETURNS 0.
                TIMEC:	DB	20, 60, 60, 24	;TIMEX OFFSETS
                TIME:	LXI	D,4
                	CALL	CMBDU
                	JNC	FCER0		;NONFATAL FC ERROR IF ARG NOT 0 - 3
                	LXI	H,TIMEX
                	DAD	B		;ADDRESS DESIRED TIMEX COMPONENT
                	MOV	A,M		;AND FETCH CURRENT VALUE
                	LXI	H,TIMEC
                	DAD	B		;ADDRESS OFFSET
                	ADD	M		;CURRENT VALUE + OFFSET = CORRECT CURRENT COUNT
                	MOV	C,A		;RESULT TO BC
                	RET
                	ENDIF
                
                ;RND: --> <INTEGER> [IF NONFLOATING VERSION]
                ;RND: <FLOATING> --> <FLOATING> [IF FLOATING VERSION]
                ;RND GENERATES THE NEXT PSEUDORANDOM 16-BIT INTEGER
                ;	RANDX = (RANDA * RANDX + RANDC) MOD 2 ^ 16, AND RETURNS THE 15-BIT
                ;	PSEUDORANDOM INTEGER RANDX / 2.  CF. KNUTH CH. 3, ESP. PP. 155-6.
                	IF	NOT WILD
                RND:	IF	FLOAT
 14F2 03        	INX	B
 14F3 C5        	PUSH	B		;SAVE POINTER TO ARG
                	IF	F9511
                	LDAX	B		;FETCH FIRST BYTE OF ARG
                	ORA	A		;ZERO SET IFF ARG IS 0
                	ELSE
 14F4 CDD70D    	CALL	FTEST
                	ENDIF
 14F7 C2FE14    	JNZ	RND1		;NONZERO ARG, TAKE IT FOR MULTIPLIER
 14FA 21B00B    	LXI	H,FPONE		;ZERO ARG, TAKE 1 INSTEAD
 14FD E3        	XTHL
                	ENDIF
 14FE 2A9740    RND1:	LHLD	RANDX
 1501 E5        	PUSH	H
 1502 EB        	XCHG			;(RANDX) TO DE
 1503 3E64      	MVI	A,RANDA SHR 8	;MS BITS OF RANDA TO A
 1505 CD7811    	CALL	MULT0		;MS(RANDA) * (RANDX) TO HL
 1508 65        	MOV	H,L
 1509 2E00      	MVI	L,0		;AND THEN * 2 ^ 8
 150B 11733A    	LXI	D,RANDC
 150E 19        	DAD	D		; + RANDC
 150F D1        	POP	D		;(RANDX) TO DE AGAIN
 1510 3EB5      	MVI	A,RANDA AND 255	;LS BITS OF RANDA TO A
 1512 CD7B11    	CALL	MULTY		;(RANDA) * (RANDX) + RANDC TO HL
 1515 229740    	SHLD	RANDX		;AND TO RANDX
                	IF	FLOAT
                	IF	F9511
                	MOV	A,L
                	OUT	D9511		;LOW ORDER TO 9511 STACK
                	MOV	A,H
                	OUT	D9511		;HIGH ORDER TO STACK
                	XRA	A
                	OUT	D9511
                	OUT	D9511		;TWO HIGH ORDER 0S TO STACK
                	MVI	A,FLD95
                	CALL	O9511		;FLOAT 32 BIT INTEGER
                	IN	D9511		;READ SIGN/EXPONENT BYTE
                	ORA	A		;CHECK IF 0
                	JZ	RND2
                	SUI	16		;FUDGE EXPONENT
                	ANI	7FH
                RND2:	OUT	D9511		;REPLACE FUDGED SIGN AND EXPONENT
                	POP	H
                	CALL	LOD95		;LOAD THE MULTIPLIER
                	JMP	FMUL		;MULTIPLY AND RETURN
                	ELSE			;NOT F9511
 1518 44        	MOV	B,H
 1519 4D        	MOV	C,L		;VALUE TO BC
                	IF	FPBCD
                	CALL	FFLOT		;FLOAT TO VALUE -32768 TO 32767
                	LXI	H,INTMN
                	CALL	FSUB		;SUBTRACT -32768, GIVING 0 TO 65535
                	LXI	H,UNSMAX
                	CALL	FDIV		;DIVIDE BY 65536, GIVING RANGE [0, 1)
                	ELSE			;NOT FPBCD
 151A 110800    	LXI	D,8		;0 TO D, SCALE FACTOR = 8 TO E
 151D 7A        	MOV	A,D		;0 TO A
 151E CD8C10    	CALL	FFLOT		;FLOAT TO RANDOM VALUE IN RANGE [0,1)
                	ENDIF			;END OF NOT FPBCD CONDITIONAL
 1521 E1        	POP	H		;ARG TO HL
 1522 C3080E    	JMP	FMUL		;RESULT = ARG * RND AND RETURN
                	ENDIF			;END OF F9511 CONDITIONAL
                	ELSE			;NOT FLOAT
                	ORA	A
                	MOV	A,H
                	RAR
                	MOV	B,A
                	MOV	A,L
                	RAR
                	MOV	C,A		;RETURN RANDX / 2
                	RET
                	ENDIF
                	ENDIF			;END OF NOT WILD CONDITIONAL
                
                
                ;END OF FNSOPS
                	PAGE
                
                ;INOUT 12/05/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;INPUT / OUTPUT & ERROR ROUTINES
                
                ;WRITC WRITES A CHARACTER FROM A.
                ;CALL:	A	CHAR TO BE WRITTEN
                ;RETN:	A,BC,DE,HL	PRESERVED
                ;THE CHARACTER IS SENT TO THE CON DEVICE IF (OMODE) = 0.
                ;THE CHAR IS ALSO SENT TO THE LST DEVICE IF (LMODE) <> 0.
                ;THE CHAR IS SENT TO THE DISK (IN CP/M NONCOMPL VERSION) IF (AMODE) <> 0.
                ;COLUM GIVES THE PRINT COLUMN OF THE LAST CHAR WRITTEN (LINE OF WIDTH WIDTH).
                ;A CRLF IS WRITTEN IF THE CURRENT CHAR CAUSES COLUM > WIDTH.
                ;A LINEFEED IS PRECEEDED BY (NULLS) NULLS.
                	IF	NOT WILD
                ;WRTS0 IS CALLED BY PRINT ROUTINES TO PRINT TRAILING SPACE AFTER NUMBERS.
 1525 2A4940    WRTS0:	LHLD	COLUM		;COLUMN TO L, WIDTH TO H
 1528 7D        	MOV	A,L
 1529 BC        	CMP	H
 152A C8        	RZ			;SUPPRESS TRAILING SPACE IF IN LAST COLUMN
                	ENDIF
 152B 3E20      WRTSP:	MVI	A,' '
                WRITC:	PUSH4			;SAVE REGISTERS
 152D+C5        	PUSH	B
 152E+D5        	PUSH	D
 152F+E5        	PUSH	H
 1530+F5        	PUSH	PSW
 1531 4F        	MOV	C,A		;CHAR PASSED IN C
 1532 2A4940    	LHLD	COLUM		;WIDTH TO H, COLUMN TO L
 1535 FE0D      	CPI	CR
 1537 C23C15    	JNZ	WRTC1
 153A 2E00      	MVI	L,0		;CR RESETS COLUMN COUNT
                WRTC1:	IF	NOT WILD
 153C FE0A      	CPI	LF
 153E CC7B15    	CZ	WNULS		;WRITE NULLS IF LINEFEED
                	ENDIF
                	IF	NOT EPSTN
 1541 FE08      	CPI	CNTLH
 1543 CC6215    	CZ	DECRC		;DECREMENT COLUMN IF <CONTROL-H>
                	ENDIF
 1546 FE20      	CPI	20H
 1548 D46815    	CNC	BUMPC		;BUMP COLUMN IF PRINTABLE
 154B 224940    	SHLD	COLUM
                	IF	CPM AND SDISK AND (NOT RTPAK)
                	LHLD	FILEP
                	MOV	A,H
                	ORA	L
                	JNZ	DWRIT		;WRITE CHAR TO DISK FILE
                	ENDIF
                	IF	BENDX AND SDISK
                	LDA	BFILP
                	ORA	A
                	JNZ	DWRIT		;WRITE CHAR TO DISK FILE
                	ENDIF
 154E 3A5440    	LDA	OMODE
                	IF	(CPM OR ISIS2 OR GENMC OR (BENDX AND SDISK)) AND NOT COMPL
                	CPI	80H		;CHECK IF DOING ASCII SAVE
                	JZ	DSAVE
                	ENDIF
                	IF	WILD
                	CPI	6
                	JNC	WRTC2		;>= 6, NOT PRINT @
                	ORA	A
                	JNZ	WWRIT		;1 <= OMODE <= 5, PRINT @ TO MONITOR
                	ENDIF
 1551 B7        WRTC2:	ORA	A		;CHECK IF OUTPUT TO BE SUPPRESSED
                	IF	(NOT WILD) OR (NOT RTPAK)	;NO CNOUT IN WILD RTPAK
 1552 C5        	PUSH	B
 1553 CC1A05    	CZ	CNOUT
 1556 C1        	POP	B
                	ENDIF
                	IF	(CPM OR ISIS2 OR GENMC) AND NOT COMPL
                	CPI	7FH		;CHECK IF DOING ASCII LOAD
                	JZ	POP4		;IGNORE REMAINING CHECKS IF SO
                	ENDIF
                	IF	CPM AND DEBUG AND NOT COMPL
                	LDA	AMODE
                	ORA	A
                	PUSH	B
                	CNZ	DKOUT		;WRITE TO DISK IF SAVING
                	POP	B
                	ENDIF
                	IF	NOT WILD
 1557 3A5340    	LDA	LMODE
 155A B7        	ORA	A		;CHECK LST WRITE MODE
 155B C42F05    	CNZ	LOUT
                	ENDIF
 155E F1        POP4:	POP	PSW		;COMMON RESTORE AND RETURNS
 155F C3A108    	JMP	POP3
 1562 2D        DECRC:	DCR	L		;DECREMENT COLUMN COUNT FOR BACKSPACE
 1563 F0        	RP			;DONE UNLESS WAS COLUMN 0
 1564 2C        	INR	L		;UNDECREMENT
 1565 C37615    	JMP	WLF		;WRITE LINEFEED AND RETURN
 1568 7D        BUMPC:	MOV	A,L
 1569 2C        	INR	L		;INCREMENT COLUMN
 156A BC        	CMP	H
 156B D8        	RC			;COLUMN < WIDTH -- OK
 156C 7C        	MOV	A,H		;FETCH WIDTH
 156D B7        	ORA	A
 156E C8        	RZ			;SUPPRESS AUTOMATIC CRLFS IF WIDTH IS 0
 156F 2E01      	MVI	L,1		;COLUMN >= WIDTH -- WRITE CRLF AND RETURN
                	IF	EPSTN
                	MOV	A,H
                	CPI	80
                	RZ			;EPSTEIN HARDWARE DOES CRLF AT COLUMN 80
                	ENDIF
 1571 3E0D      WCRLF:	MVI	A,CR
 1573 CD2D15    	CALL	WRITC
 1576 3E0A      WLF:	MVI	A,LF
 1578 C32D15    	JMP	WRITC
                	IF	NOT WILD
 157B 3A9940    WNULS:	LDA	NULLS		;FETCH NULL COUNT
 157E 47        	MOV	B,A		;SAVE IN B
 157F 04        	INR	B
 1580 AF        	XRA	A		;NULL CHAR TO A
 1581 05        WNUL1:	DCR	B
 1582 C8        	RZ			;DONE
 1583 CD2D15    	CALL	WRITC		;WRITE A NULL
 1586 C38115    	JMP	WNUL1		;AND TEST FOR MORE
                	ENDIF
                
                ;READC READS ONE CHAR FROM THE CONSOLE.
                ;THE PARITY BIT (I.E. BIT 7) IS RESET.
                ;THE USER IS RETURNED TO DIRECT MODE IF THE CHAR IS <CNTL-C>.
                ;THE SYSTEM IS BOOTED IF THE CHAR IS <CNTL-B>.
                ;THE LST MODE IS TOGGLED IF  THE CHAR IS <CNTL-P>.
                ;RETN:	A	CHAR READ, MASKED BY 7FH
                ;	BC,DE,HL	PRESERVED
                READC:	PUSH3			;SAVE REGISTERS
 1589+C5        	PUSH	B
 158A+D5        	PUSH	D
 158B+E5        	PUSH	H
                	IF	(CPM OR ISIS2 OR GENMC OR (BENDX AND SDISK)) AND NOT COMPL
                	LDA	OMODE
                	CPI	7FH		;CHECK IF ASCII LOAD
                	JZ	DLOAD		;YES
                	ENDIF
 158C CDF804    	CALL	CONIN		;READ THE CONSOLE
 158F E67F      	ANI	7FH		;MASK OFF PARITY
                	IF	(NOT WILD) OR (NOT RTPAK)	;NO ^B, ^C IN WILD RTPAK
 1591 FE02      	CPI	CNTLB
 1593 CCE22E    	CZ	ECHOC
                	IF	DEBUG
                	CZ	BOOT		;CALL MONITOR IF DEBUG AND CONTROL-B
                	ELSE
                	IF	CAMAC AND CPM
                	CZ	CDSAB		;DISABLE INTERRUPT BEFORE BOOTING IF CP/M CAMAC
                	ENDIF
 1596 CA6001    	JZ	BOOT		;JMP MONITOR IF NOT DEBUG AND CONTROL-B
                	ENDIF
 1599 FE03      	CPI	CNTLC
 159B CCE22E    	CZ	ECHOC
 159E CA3940    	JZ	DMODC		;BREAK TO DIRECT MODE IF CONTROL-C
                	ENDIF
                	IF	CPM AND DEBUG AND NOT COMPL
                	CPI	CNTLX
                	JZ	DSAV0
                	ENDIF
                	IF	NOT WILD 	;NO LST DEVICE
 15A1 FE10      	CPI	CNTLP
 15A3 C2A108    	JNZ	POP3
 15A6 CDE22E    	CALL	ECHOC
 15A9 3A5340    	LDA	LMODE		;TOGGLE LST MODE IF CONTROL-P
 15AC 2F        	CMA
 15AD 325340    	STA	LMODE
 15B0 3E10      	MVI	A,CNTLP		;RESTORE CHAR TO A
                	ENDIF
 15B2 C3A108    	JMP	POP3
                
                	IF	(CPM OR ISIS2 OR GENMC) AND NOT COMPL
                DSAVE:	CALL	DKOUT		;WRITE CHAR TO DISK FILE
                	JMP	POP4		;RESTORE AND RETURN
                	ENDIF
                
                ;REDYC DETERMINES WHETHER CHAR IS READY AT CONSOLE.
                ;RETN:	CARRY	SET IFF CHAR READY
                REDYC:	PUSH3			;SAVE REGISTERS
 15B5+C5        	PUSH	B
 15B6+D5        	PUSH	D
 15B7+E5        	PUSH	H
 15B8 CD0140    	CALL	CSTAT
 15BB 0F        	RRC
 15BC C3A108    	JMP	POP3		;RESTORE AND RETURN
                
                ;CTEST LOOKS FOR CHARACTER AT CONSOLE, AND READCS IT IF PRESENT.
                ;ALL CHARS ARE IGNORED EXCEPT THE FOLLOWING:
                ;	<CNTL-B>	REBOOTS (FROM READC)
                ;	<CNTL-C>	BREAKS (BRANCH TO DMODE, WITH MESSAGE)
                ;	<CNTL-O>	TOGGLES CONSOLE OUTPUT MODE
                ;	<CNTL-P>	TOGGLES LST MODE (FROM READC)
                ;	<CNTL-S>	SUSPENDS INTERPRETER EXECUTION UNTIL EITHER
                ;				<CNTL-X> (REBOOT) OR <CNTL-Q> (RESUME)
                ;RETN:	A	CLOBBERED
                ;	BC,DE,HL	PRESERVED
 15BF CDB515    CTEST:	CALL	REDYC		;CHECK IF CHAR READY
 15C2 D0        	RNC			;NO CHAR READY
 15C3 CD8915    CTST0:	CALL	READC		;READY, SO READ THE CHAR -- DRIVER ENTRY POINT
                	IF	(NOT WILD) OR (NOT RTPAK)
 15C6 FE0F      	CPI	CNTLO
 15C8 CCE22E    	CZ	ECHOC
 15CB CAE315    	JZ	CTST1		;TOGGLE OUTPUT MODE IF CNTL-O AND RETURN
                	ENDIF
                	IF	NOT WILD
 15CE FE13      	CPI	CNTLS
 15D0 CAD715    	JZ	CTST2		;WAIT FOR CNTL-Q IF CNTL-S
                	ENDIF
 15D3 329A40    	STA	GCHAR		;ELSE SAVE IT FOR GET
 15D6 C9        	RET
                	IF	NOT WILD
 15D7 CD8915    CTST2:	CALL	READC
 15DA FE11      	CPI	CNTLQ		;CHECK IF CNTL-Q
 15DC C8        	RZ			;RETURN IF SO
 15DD FE13      	CPI	CNTLS
 15DF C8        	RZ			;RETURN IF CNTL-S TOGGLED ALSO
 15E0 C3D715    	JMP	CTST2		;ELSE WAIT
                	ENDIF
                	IF	(NOT WILD) OR (NOT RTPAK)
 15E3 3A5440    CTST1:	LDA	OMODE
 15E6 2F        	CMA			;TOGGLE OMODE
 15E7 325440    	STA	OMODE
 15EA C37115    	JMP	WCRLF		;ECHO CRLF AND RETURN
                	ENDIF
                
                ;WRTBS PRINTS (BC) AS A SIGNED DECIMAL NUMBER, WITH LEADING '-' IF NEGATIVE.
                ;WRTBU PRINTS (BC) AS AN UNSIGNED DECIMAL NUMBER.
                ;THE CURRENT COLUMN & WIDTH ARE CHECKED TO AVOID BREAKING THE NUMBER WITH CRLF.
                ;WRTB1 IS AN ENTRY POINT FROM PRINT, TO PRINT NONNEGATIVES WITH LEADING SPACE.
                ;CALL:	BC	INTEGER
                ;RETN:	A	CLOBBERED
                ;	BC,DE,HL	PRESERVED
 15ED 78        WRTBS:	MOV	A,B
 15EE B7        	ORA	A
 15EF F2FB15    	JP	WRTBU		;WRITE UNSIGNED IF POSITIVE
 15F2 C5        	PUSH	B		;ELSE SAVE BC
 15F3 CD2B13    	CALL	IUMIN		;NEGATE BC (NB -32768 IS OK)
 15F6 3E2D      	MVI	A,'-'		;LEADING MINUS SIGN
 15F8 C3FD15    	JMP	WRTB2		;AND WRITE
 15FB AF        WRTBU:	XRA	A		;NO LEADING CHAR
 15FC C5        WRTB1:	PUSH	B		;SAVE BC
 15FD D5        WRTB2:	PUSH	D
 15FE E5        	PUSH	H		;AND DE, HL
 15FF CD2816    	CALL	CVTIS		;CONVERT INTEGER TO STRING
 1602 CD0816    	CALL	PRSTL		;PRINT STRING ON ONE LINE
 1605 C3A108    	JMP	POP3
                
                ;PRSTR PRINTS THE STRING ADDRESSED BY C,DE.
                ;PRSTL TRIES TO PRINT THE STRING ADDRESSED BY C,DE WITHOUT CRLF.
 1608 2A4940    PRSTL:	LHLD	COLUM		;WIDTH TO H, COLUMN TO L
 160B 7C        	MOV	A,H		;FETCH WIDTH
 160C B7        	ORA	A
 160D CA1D16    	JZ	PRSTR		;JUST PRINT THE STRING IF WIDTH IS 0
 1610 79        	MOV	A,C		;LENGTH TO A
 1611 85        	ADD	L		;COLUMN + LENGTH = LAST COLUMN NEEDED
 1612 3F        	CMC			;CARRY RESET IFF > 255
 1613 D21A16    	JNC	PRSL1		;MUCH TOO LONG, WRITE CRLF FIRST
 1616 BC        	CMP	H		;CARRY RESET IFF LAST NEEDED >= WIDTH
 1617 CA1D16    	JZ	PRSTR		;JUST FITS
 161A D47115    PRSL1:	CNC	WCRLF		;WRITE CRLF IF TOO LONG FOR CURRENT PRINTLINE
 161D 0C        PRSTR:	INR	C		;LENGTH+1
 161E 0D        PRST1:	DCR	C		;DECREMENT LENGTH
 161F C8        	RZ			;DONE
 1620 1A        	LDAX	D		;FETCH NEXT STRING CHAR
 1621 CD2D15    	CALL	WRITC		;PRINT IT
 1624 13        	INX	D
 1625 C31E16    	JMP	PRST1		;AND WRITE MORE
                
                ;CVTIS CONVERTS THE INTEGER IN BC TO A STRING OF ASCII DECIMAL DIGITS.
                ;THE RESULT IS LOADED INTO THE BUFFER AT BUFAD.
                ;CALL:	A	LEADING CHAR (ASCII SPACE OR MINUS SIGN, 0 FOR NONE)
                ;	BC	UNSIGNED INTEGER VALUE
                ;RETN:	A,C	LENGTH OF STRING RESULT
                ;	DE	LOCATION OF STRING RESULT, I.E. BUFAD
                ;	B,HL	CLOBBERED
 1628 60        CVTIS:	MOV	H,B
 1629 69        	MOV	L,C		;VALUE TO HL
 162A 01C841    	LXI	B,BUFAD		;DESTINATION TO BC
 162D C5        	PUSH	B		;AND SAVED
 162E B7        	ORA	A
 162F CA3516    	JZ	CVIS1		;NO LEADING CHAR DESIRED
 1632 02        	STAX	B		;STORE LEADING CHAR
 1633 03        	INX	B		;AND POINT TO NEXT AVAILABLE LOCATION
 1634 AF        	XRA	A		;CLEAR A FOR MOD10
 1635 11F0D8    CVIS1:	LXI	D,-10000
 1638 CD5616    	CALL	MOD10
 163B 1118FC    	LXI	D,-1000
 163E CD5616    	CALL	MOD10
 1641 119CFF    	LXI	D,-100
 1644 CD5616    	CALL	MOD10
 1647 11F6FF    	LXI	D,-10
 164A CD5616    	CALL	MOD10
 164D 7D        	MOV	A,L		;UNITS DIGIT TO A
 164E CD6916    	CALL	MOD1B		;AND TO STRING
 1651 D1        	POP	D		;LOCATION TO DE
 1652 79        	MOV	A,C		;LAST+1 TO A
 1653 93        	SUB	E		;LAST+1 - FIRST = LENGTH
 1654 4F        	MOV	C,A		;AND LENGTH TO C
 1655 C9        	RET
                
                ;MOD10 ADDS THE DECIMAL DIGIT N = (HL) DIV -(DE) TO THE STRING AT (BC)
                ;AND LEAVES HL WITH (HL) + N * (DE).  ZEROS SUPPRESSED IF (A) = 0 WHEN CALLED.
 1656 C5        MOD10:	PUSH	B
 1657 06FF      	MVI	B,255
 1659 22B941    MOD1A:	SHLD	TEMP
 165C 04        	INR	B
 165D 19        	DAD	D
 165E DA5916    	JC	MOD1A
 1661 2AB941    	LHLD	TEMP		;REMAINDER TO HL
 1664 50        	MOV	D,B		;RESULT TO D, TEMPORARILY
 1665 C1        	POP	B		;RESTORE BC
 1666 B2        	ORA	D		;ZERO SET IFF (A) > 0 OR (D) > 0
 1667 C8        	RZ
 1668 7A        	MOV	A,D		;RESULT TO A
 1669 C630      MOD1B:	ADI	'0'		;ENTRY POINT FOR FINAL DIGIT
 166B 02        	STAX	B		;ADD ASCII DIGIT TO STRING
 166C 03        	INX	B
 166D C9        	RET
                
                	IF	NOT COMPL
                ;PRNTL PRINTS LINE # (AS UNSIGNED DECIMAL, SUPPRESSED IF ZERO) AND SPACE
                ;AND A LINE OF USER SOURCE TEXT, EXPANDING TOKENS AS NECESSARY.
                ;CALL:	HL	ADDRESS OF LINE #
                ;RETN:	A,DE	CLOBBERED
                ;	BC	PRESERVED
                ;	HL	ADDRESS FOLLOWING LAST TEXT BYTE, I.E. AFTER <CR>
                ;PRTL0 PRINTS LINE WITH <LINEFEED> IF (DE) MATCHES LOCATION.
                ;PRTLC PRINTS LINE WITH <LINEFEED> AT TEXTP.
 166E 2A8242    PRTLC:	LHLD	TEXTP
 1671 EB        	XCHG			;CURRENT TEXTP TO DE
 1672 2A4B40    	LHLD	LNNUM		;CURRENT LNNUM TO HL
 1675 CD7E16    	CALL	PRTL0		;PRINT THE LINE
 1678 C37115    	JMP	WCRLF		;AND CRLF
 167B 110000    PRNTL:	LXI	D,0		;PRINT WITHOUT LINEFEED
 167E C5        PRTL0:	PUSH	B
 167F CD6601    	CALL	LINB1		;LINE # TO BC
 1682 CAA416    	JZ	PRTL3		;ZERO, I.E. DIRECT MODE
 1685 CDFB15    	CALL	WRTBU		;WRITE THE LINE #
 1688 23        	INX	H		;PAST BREAK BYTE
 1689 23        	INX	H		;TO FIRST TEXT BYTE
 168A 3E20      	MVI	A,' '
 168C BE        	CMP	M		;CHECK IF FIRST CHAR IS SPACE
 168D C42B15    	CNZ	WRTSP		;WRITE A SPACE IF NOT
 1690 C1        PRTL1:	POP	B		;RESTORE BC
 1691 CD8602    PRTL2:	CALL	CMDHU		;COMPARE TO TEXT POINTER
 1694 CC7615    	CZ	WLF		;WRITE LINEFEED IF EQUAL
 1697 7E        	MOV	A,M		;FETCH NEXT BYTE FROM TEXT
 1698 23        	INX	H
 1699 FE0D      	CPI	CR
 169B C8        	RZ			;CR, DONE
 169C E5        	PUSH	H
 169D CDAA16    	CALL	PRTCH		;PRINT CHAR OR TOKEN
 16A0 E1        	POP	H
 16A1 C39116    	JMP	PRTL2
 16A4 21D941    PRTL3:	LXI	H,TLNAD
 16A7 C39016    	JMP	PRTL1
                
                ;PRTCH PRINTS A CHAR OR TOKEN.
                ;CALL:	A	CHAR OR TOKEN
 16AA CD8C1A    PRTCH:	CALL	FNDTK		;LOOK UP THE TOKEN
 16AD D22D15    	JNC	WRITC		;CHAR, JUST PRINT IT
                	ENDIF			;ELSE FALL THROUGH TO PRTST TO PRINT TOKEN
                
                ;PRTST PRINTS A STRING WITH SUCCESSIVE CALLS TO WRITC.
                ;CALL:	HL	ADDRESS OF STRING'S FIRST TEXT CHAR
                ;RETN:	A	CLOBBERED
                ;	BC,DE	PRESERVED
                ;	HL	ADDRESS FOLLOWING STRING'S LAST TEXT CHAR
 16B0 7E        PRTST:	MOV	A,M		;FETCH A BYTE TO PRINT
 16B1 E67F      	ANI	7FH		;MASK OFF END OF ENTRY BIT
 16B3 CD2D15    	CALL	WRITC		;PRINT IT
 16B6 7E        	MOV	A,M		;CHECK END OF ENTRY BYTE AGAIN
 16B7 B7        	ORA	A
 16B8 23        	INX	H		;MOVE UP POINTER
 16B9 F2B016    	JP	PRTST		;KEEP PRINTING
 16BC C9        	RET			;END OF ENTRY, DONE
                
                ;PRNTM PRINTS THE MESSAGE WHICH DIRECTLY FOLLOWS THE CALL PRNTM.
                ;PRTM0 TURNS ON OMODE AND THEN PRINTS MESSAGE WITH PRNTM.
 16BD AF        PRTM0:	XRA	A
 16BE 325440    	STA	OMODE		;TURN ON OUTPUT MODE
                	IF	CPM AND SDISK	;RESET FILE POINTER
                	LXI	H,0
                	SHLD	FILEP
                	ENDIF
                	IF	BENDX AND SDISK
                	STA	BFILP
                	ENDIF
 16C1 E1        PRNTM:	POP	H		;ADDRESS FOLLOWING CALL TO HL
 16C2 CDB016    	CALL	PRTST		;PRINT THE MESSAGE
 16C5 E9        	PCHL			;AND RETURN TO THE NEXT ADDRESS
                
                	IF	WILD		;ERROR HANDLING
                ERROF:
                ERRON:
                ERROC:	XRA	A
                	STA	OMODE		;RESET OMODE IN CASE WITHIN PRINT @
                	POP	H		;RECOVER ADDRESS OF CALLER
                	MOV	D,M		;FIRST MESSAGE CHAR TO D
                	INX	H
                	MOV	A,M
                	ANI	7FH
                	MOV	E,A		;SECOND MESSAGE CHAR TO E
                	CALL	LINBC		;LINE NUMBER TO BC
                	MOV	H,B
                	MOV	L,C		;THEN TO HL
                	MVI	A,9		;ERROR CODE = 9 TO A
                	JMP	WMON		;AND PASS TO MONITOR
                	ELSE			;NOT WILD
                ;ERROF, ERRON AND ERROC ARE ERROR ROUTINE ENTRY POINTS FOR FATAL,
                ;NONFATAL AND CONTINUE ERRORS.  IN EACH CASE THE
                ;ERROR ROUTINE IS INVOKED WITH THE ERROR MACRO, E.G. WITH
                ;	ERROR	F, X, Y
                ;ISSUING A FATAL XY ERROR WITH THE CODE
                ;	CALL	ERROF
                ;	DB	'X', 'Y' OR 80H
                ;THE ERROR MESSAGE FOLLOWING THE CALL IS PRINTED, FOLLOWED BY THE
                ;USER SOURCE LINE # (IF ANY) AND USER SOURCE LINE.
                ;IF TRAP, ANY ERROR TERMINATES EXECUTION AND RETURNS THE USER TO DMODE, WITH
                ;A CONTINUE ENTRY ON THE CSTACK TO ALLOW CONTINUATION AT THE NEXT COMMAND.
                ;IF UNTRAP:
                ;FATAL ERRORS RETURN TO DMODE, AS IF TRAP.
                ;NONFATAL ERRORS CONTINUE EXECUTION WITH ALL REGISTERS PRESERVED.
                ;CONTINUE ERRORS CONTINUE EXECUTION WITH THE NEXT SOURCE TEXT COMMAND.
 16C6 E3        ERROF:	XTHL			;MESSAGE ADDRESS TO HL, HL TO STACK
 16C7 F5        	PUSH	PSW		;PSW TO STACK
 16C8 37        	STC			;CARRY SET FOR FATAL
 16C9 C3D616    	JMP	ERRO0
 16CC E3        ERROC:	XTHL
 16CD F5        	PUSH	PSW
 16CE AF        	XRA	A		;CARRY RESET, ZERO SET FOR CONTINUE
 16CF C3D616    	JMP	ERRO0
 16D2 E3        ERRON:	XTHL
 16D3 F5        	PUSH	PSW
 16D4 F601      	ORI	1		;CARRY RESET, ZERO RESET FOR NONFATAL
 16D6 D5        ERRO0:	PUSH	D		;SAVE DE
 16D7 EB        	XCHG			;MESSAGE ADDRESS TO DE
                	IF	CPM AND SDISK AND (NOT RTPAK)
                	LHLD	FILEP
                	ENDIF
                	IF	BENDX AND SDISK
                	LXI	H,BFILP
                	MOV	H,M
                	ENDIF
 16D8 E5        	PUSH	H		;SAVE CURRENT BFILP
 16D9 F5        	PUSH	PSW		;SAVE ERROR TYPE
 16DA CDBD16    	CALL	PRTM0		;TURN ON OMODE, PRINT CRLF
 16DD 0D8A      	DB	CR, LF OR 80H
 16DF EB        	XCHG			;MESSAGE ADDRESS TO HL
 16E0 CDB016    	CALL	PRTST		;PRINT MESSAGE
 16E3 F1        	POP	PSW
 16E4 E5        	PUSH	H		;SAVE RETURN ADDRESS IN CASE NONFATAL
 16E5 F5        	PUSH	PSW		;AND SAVE ERROR TYPE AGAIN
 16E6 CDC116    	CALL	PRNTM		;PRINT ERROR MESSAGE
                	IF	COMPL
                	DB	' ERROR IN LINE', ' ' OR 80H
                	PUSH	B
                	CALL	LINBC		;LINE # TO BC
                	CALL	WRTBU		;WRITE IT
                	CALL	WCRLF		;AND CRLF
                	POP	B
                	ELSE
 16E9 204552524F	DB	' ERROR:', ' ' OR 80H
 16F1 CD6E16    	CALL	PRTLC		;PRINT THE LINE
                	IF	EDITC
 16F4 C5        	PUSH	B
 16F5 CD6301    	CALL	LINBC		;LINE NUMBER TO BC
 16F8 CA0017    	JZ	ERRO1		;SKIP RESETTING ERRLN IF 0
 16FB 60        	MOV	H,B
 16FC 69        	MOV	L,C		;THEN TO HL
 16FD 224D40    	SHLD	ERRLN		;AND SAVE FOR EDIT
 1700 C1        ERRO1:	POP	B		;RESTORE BC
                	ENDIF
 1701 3A4F40    	LDA	TRAP		;0 TRAP, 255 UNTRAP
 1704 B7        	ORA	A
 1705 CA1817    	JZ	ERRO2		;TRAP, SO SCAN TO NEXT AND GO TO DMODE
                	ENDIF
 1708 F1        	POP	PSW		;RECOVER ERROR TYPE
 1709 DA1817    	JC	ERRO2		;FATAL, TO DMODE AS IF TRAP
 170C CA7306    	JZ	NEXTC		;CONTINUE WITH NEXT COMMAND
 170F D1        	POP	D		;RETURN ADDRESS TO DE
                	IF	CPM AND SDISK AND (NOT RTPAK)
                	POP	H
                	SHLD	FILEP		;RESTORE FILEP
                	ENDIF
                	IF	BENDX AND SDISK
                	POP	PSW
                	STA	BFILP
                	ENDIF
 1710 CDBF15    	CALL	CTEST		;TEST FOR CONSOLE BREAK CHAR
 1713 EB        	XCHG			;RETURN ADDRESS TO HL
 1714 D1        	POP	D		;RESTORE DE
 1715 F1        	POP	PSW		;RESTORE PSW
 1716 E3        	XTHL			;RESTORE HL, RETURN ADDRESS TO STACK
 1717 C9        	RET
                	IF	CAMAC
                ERRO2	EQU	DMOD2		;NO CONTINUATION AFTER ERRORS IN CAMAC VERSIONS
                	ELSE
                ;FATAL ERRORS:  BUILD CONTROL STACK ENTRY, SCAN TO DELIMITER, AND GOTO DMODE.
 1718 CD6301    ERRO2:	CALL	LINBC		;LNNUM TO HL, ZERO SET IFF DIRECT
 171B CA4B06    	JZ	DMOD2		;ERROR FROM DMODE, SKIP ENTRY BUILDING
 171E 2B        	DCX	H		;ADDRESS LENGTH BYTE OF CURRENT LINE
 171F E5        	PUSH	H		;AND SAVE
 1720 5E        	MOV	E,M
 1721 1600      	MVI	D,0		;LENGTH OF CURRENT LINE TO DE
 1723 19        	DAD	D		;ADDRESS OF FOLLOWING LINE
 1724 EB        	XCHG			;TO DE
 1725 2A8242    	LHLD	TEXTP
 1728 CD8602    	CALL	CMDHU		;CHECK IF WITHIN CURRENT TEXT LINE
 172B DA4B06    	JC	DMOD2		;AFTER CURRENT LINE, SKIP ENTRY BUILDING
 172E D1        	POP	D
 172F CD8602    	CALL	CMDHU
 1732 D24B06    	JNC	DMOD2		;BEFORE CURRENT LINE, SKIP ENTRY BUILDING
 1735 CD9817    	CALL	GTDEL		;ELSE SCAN TO DELIMITER
 1738 C37620    	JMP	ENDC1		;BUILD BREAK ENTRY AND GO TO DMODE
                	ENDIF			;END OF NOT CAMAC CONDITIONAL
                	ENDIF			;END OF NOT WILD CONDTIONAL
                
                
                ;END OF INOUT
                	PAGE
                
                ;PARSING 8/26/79
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979 BY MARK WILLIAMS COMPANY, CHICAGO
                ;PARSING ROUTINES
                
                ;REGISTER USE FOR ALL PARSING ROUTINES, EXCEPT AS NOTED.
                ;CALL:	(TEXTP)	ADDRESS OF NEXT TEXT CHAR
                ;RETN:	A	CLOBBERED
                ;	BC,DE	PRESERVED
                ;	HL	ADDRESS OF NEXT UNPARSED CHAR
                ;	(TEXTP)	DITTO
                ;	CARRY	SET IFF FAILURE
                
                ;GTCHA FETCHES THE NEXT NONSPACE CHARACTER.
 173B 2A8242    GTCHA:	LHLD	TEXTP
 173E 7E        GTCH1:	MOV	A,M		;FETCH CHARACTER
 173F 23        	INX	H		;POINT TO NEXT
 1740 FE20      	CPI	' '
 1742 CA3E17    	JZ	GTCH1		;TRY AGAIN IF SPACE
 1745 228242    	SHLD	TEXTP		;STORE NEW TEXT POINTER
 1748 C9        	RET
                
                ;GTCHO LOOKS AHEAD TO THE NEXT NONSPACE CHAR.
 1749 CD3B17    GTCHO:	CALL	GTCHA
 174C 2B        BAKUP:	DCX	H		;BACK UP TEXTP
 174D 228242    	SHLD	TEXTP
 1750 C9        	RET
                
                ;GTALP FETCHES THE NEXT CHAR IF ALPHABETIC, RETURNS CARRY IF NOT.
 1751 CD4917    GTALP:	CALL	GTCHO
 1754 CDDA17    	CALL	ISALP
 1757 D8        	RC			;NOT A LETTER
 1758 23        READ1:	INX	H
 1759 228242    	SHLD	TEXTP		;ELSE READ IT
 175C C9        	RET
                
                ;GTCOM GETS A COMMA.
 175D CD3B17    GTCOM:	CALL	GTCHA
 1760 FE2C      	CPI	','
 1762 C8        	RZ
 1763 C37417    	JMP	BKUPC		;BACK UP TEXTP AND RETURN CARRY
                
                ;GTCND GETS A COMMA NOT FOLLOWED BY A DELIMITER.
 1766 CD5D17    GTCND:	CALL	GTCOM
 1769 D8        	RC			;NO COMMA
 176A CD9C01    	CALL	DTST0		;LOOK FOR DELIMITER
 176D 3F        	CMC			;CARRY SET IFF DELIMITER FOLLOWS COMMA
 176E C9        	RET
                
                ;GTD RETURNS CARRY RESET AND MOVES UP TEXTP IF NEXT CHAR MATCHES (D), ELSE
                ;RETURNS CARRY SET AND LEAVES (TEXTP) UNCHANGED.
                ;GTDSN GETS A CHAR WHICH MUST MATCH (D), ELSE SN ERROR IS ISSUED.
                ;GTDTR DOES A GTDSN AND ECHOES THE CHAR IF TRACE PRINT IS DESIRED.
 176F CD3B17    GTD:	CALL	GTCHA
 1772 BA        	CMP	D
 1773 C8        	RZ
 1774 37        BKUPC:	STC			;RETURN CARRY SET IF NO MATCH
 1775 C34C17    	JMP	BAKUP		;BACK UP TEXTP AND RETURN
                	IF	NOT COMPL
 1778 3A5140    GTDTR:	LDA	INLHS
 177B B7        	ORA	A
 177C CA8717    	JZ	GTDSN		;DO NOT ECHO UNLESS INLHS
 177F 3A5240    	LDA	VTRAC
 1782 17        	RAL			;CARRY SET IFF TRACE PRINT DESIRED
 1783 7A        	MOV	A,D
 1784 DC2D15    	CC	WRITC		;WRITE IT IF SO
                	ENDIF			;AND FALL THROUGH TO GTDSN
 1787 CD6F17    GTDSN:	CALL	GTD
 178A D0        	RNC
 178B C39201    	JMP	SNERR
                	IF	COMPL
                GTDTR	EQU	GTDSN
                	ENDIF
 178E 1629      GTREQ:	MVI	D,')'
 1790 CD8717    	CALL	GTDSN		;SKIP ) AND FALL THROUGH TO SKIP =
 1793 16CD      GTEQU:	MVI	D,EQULT
 1795 C38717    	JMP	GTDSN		;SKIP = TOKEN
                
                ;GTDEL SCANS TEXT UNTIL DELIMITER IS FOUND.
 1798 CD9C01    GTDEL:	CALL	DTST0		;TEST IF CURRENT IS DELIMITER
 179B D0        	RNC			;DELIMITER, DONE
 179C CD5817    	CALL	READ1		;NO, READ THE CURRENT
 179F FE22      	CPI	'"'
 17A1 CCA717    	CZ	GTCLQ		;WATCH FOR QUOTED STRINGS
 17A4 C39817    	JMP	GTDEL		;AND TRY THE NEXT
                
                ;GTCLQ SCANS TO CLOSE QUOTE OR <CR>.
                ;CALL:	HL	NEXT CHAR ADDR
                ;RETN:	HL	ADDR OF " OR CR
                ;	TEXTP	RESET
 17A7 7E        GTCLQ:	MOV	A,M		;FETCH NEXT
 17A8 FE0D      	CPI	CR
 17AA C8        	RZ			;DONE IF CR
 17AB CD5817    	CALL	READ1		;ELSE READ IT
 17AE FE22      	CPI	'"'
 17B0 C2A717    	JNZ	GTCLQ		;AND KEEP READING IF NOT CLOSE "
 17B3 2B        	DCX	H		;POINT TO "
 17B4 C9        	RET
                
                ;ISDIG PRESRVES A AND RETURNS CARRY SET IFF (A) IS NOT ASCII DIGIT.
 17B5 FE30      ISDIG:	CPI	'0'
 17B7 D8        	RC			;TOO SMALL
 17B8 FE3A      	CPI	'9'+1
 17BA 3F        	CMC
 17BB C9        	RET
                
                ;ISHEX CONVERTS AN ASCII HEX DIGIT TO BINARY.
                ;BOTH UPPER AND LOWER CASE ALPHABETIC CHARACTERS ARE ALLOWED.
                ;CALL:	A	CHARACTER
                ;RETN:	CARRY	SET IFF NOT A HEX DIGIT
                ;	A	BINARY VALUE IF CARRY RESET, CLOBBERED IF CARRY
                ;	BCDEHL	PRESEVED
 17BC D630      ISHEX:	SUI	'0'		;SUBTRACT BIAS
 17BE FE37      	CPI	'G'+20H-'0'
 17C0 3F        	CMC
 17C1 D8        	RC			;RETURN CARRY SET IF < '0' OR > 'F'
 17C2 FE0A      	CPI	10
 17C4 3F        	CMC			;CARRY RESET FOR '0' TO '9'
 17C5 D0        	RNC			;DECIMAL DIGIT
 17C6 E61F      	ANI	1FH		;MASK TO CONVERT LOWER CASE TO UPPER
 17C8 D611      	SUI	'A'-'0'		;'A' BECOMES 0, 'B' BECOMES 1...
 17CA FE06      	CPI	6
 17CC 3F        	CMC
 17CD D8        	RC			;RETURN CARRY IF NOT LEGAL HEX DIGIT
 17CE C60A      	ADI	10		;'A' BECOMES 10, 'B' BECOMES 11...
 17D0 C9        	RET
                
                ;GTILD GETS THE NEXT LETTER OR DIGIT WITHOUT SKIPPING SPACES, AND IS
                ;CALLED BY GTNAM AND GTFIL TO BUILD A VARIABLE OR FILE NAME.
                ;CALL:	HL	ADDRESS OF NEXT CHAR TO PARSE
                ;RETN:	A	NEXT CHAR
                ;	BC,DE	PRESERVED
                ;	HL	INCREMENTED
                ;	(TEXTP)	VALUE OF HL WHEN CALLED
                ;	CARRY	SET IFF NEXT NOT LETTER OR DIGIT
 17D1 7E        GTILD:	MOV	A,M
 17D2 228242    	SHLD	TEXTP		;LEAVE TEXTP SET FOR FAILURE
 17D5 23        	INX	H
 17D6 CDB517    LDTST:	CALL	ISDIG
 17D9 D0        	RNC			;DIGIT
 17DA FE41      ISALP:	CPI	'A'
 17DC D8        	RC			;NEITHER
 17DD FE5B      	CPI	'Z'+1
 17DF 3F        	CMC			;CARRY IFF NOT LETTER
 17E0 C9        	RET
                
                ;GTDEC SCANS AN UNSIGNED DECIMAL INTEGER AND RETURNS ITS VALUE.
                ;AN UNSIGNED DECIMAL INTEGER IS A STRING OF DECIMAL DIGITS.
                ;THE DIGIT COUNT (NOT INCLUDING LEADING 0S) IS USED FOR OVERFLOW DETECTION.
                ;1-4 DIGITS INDICATES NO OVERFLOW.
                ;6+ DIGITS INDICATES OVERFLOW.
                ;5 DIGITS INDICATES OVERFLOW IFF (VALUE OF 4 DIGITS)*10 > 65535 OR
                ;	(VALUE OF 4 DIGITS)*10 + (VALUE OF DIGIT 5) > 65535.
                ;	NOTE THAT 9999*5 IS ALWAYS < 65535.
                ;RETN:	CARRY	SET IFF NO DECIMMAL DIGIT
                ;	ZERO	SET IF OVERFLOW, I.E. INTEGER > 65535
                ;	A	CLOBBERED
                ;	BC	PRESERVED
                ;	DE	INTEGER VALUE 0 <= N <= 65535 IF CARRY AND ZERO RESET
                ;	DE	0 IF CARRY OR ZERO
                ;	HL	ADDRESS OF NEXT NONDIGIT
                ;GTDE0 IS CALLED FROM GTDEC TO SCAN THROUGH LEADING 0S.
 17E1 23        GTDE0:	INX	H
 17E2 228242    	SHLD	TEXTP		;READ LEADING 0
 17E5 7E        	MOV	A,M		;FETCH NEXT CHAR
 17E6 D630      	SUI	'0'
 17E8 CAE117    	JZ	GTDE0		;ANOTHER LEADING 0
 17EB FE0A      	CPI	10		;CARRY SET IFF DECIMAL DIGIT
 17ED DA0618    	JC	GTDE1		;DIGIT FOLLOWS LEADING 0S
 17F0 B7        RETNC:	ORA	A		;NONDIGIT, RETURN C,Z RESET AND RESULT 0
 17F1 C9        	RET
 17F2 110000    GTDEC:	LXI	D,0		;DEFAULT VALUE TO DE
 17F5 CD4917    	CALL	GTCHO		;NEXT CHAR TO A, TEXTP TO HL
 17F8 D630      	SUI	'0'		;SUBTRACT ASCII BIAS
 17FA CAE117    	JZ	GTDE0		;STRIP OFF LEADING 0S
 17FD FE0A      	CPI	10
 17FF DA0618    	JC	GTDE1		;DIGIT
 1802 7E        	MOV	A,M		;REFETCH NEXT
 1803 B7        	ORA	A		;CLEAR ZERO
 1804 37        	STC			;AND SET CARRY
 1805 C9        	RET
 1806 5F        GTDE1:	MOV	E,A		;FIRST DIGIT VALUE TO DE
 1807 C5        	PUSH	B		;SAVE BC
 1808 06FA      	MVI	B,-6 AND 255	;-(MAX # DIGITS + 1) TO B
 180A 04        GTDE2:	INR	B		;# DIGITS READ - MAX # - 1
 180B 23        	INX	H
 180C 7E        	MOV	A,M		;FETCH NEXT CHAR
 180D D630      	SUI	'0'		;SUBTRACT ASCII BIAS
 180F FE0A      	CPI	10
 1811 D22318    	JNC	GTDE3		;NONDIGIT, DONE
 1814 E5        	PUSH	H		;SAVE TEXTP
 1815 62        	MOV	H,D
 1816 6B        	MOV	L,E		;COPY VALUE TO HL
 1817 CD3C14    	CALL	HL10A		;10 * OLD VALUE + CURRENT DIGIT = NEW VALUE
 181A EB        	XCHG			;TO DE
 181B E1        	POP	H		;RESTORE TEXTP
 181C D20A18    	JNC	GTDE2		;GET NEXT IF NO OVERFLOW
 181F 04        	INR	B		;BUMP DIGIT COUNT TO ASSURE > 5 ON OVERFLOW
 1820 C30A18    	JMP	GTDE2		;AND GET NEXT CHAR
 1823 228242    GTDE3:	SHLD	TEXTP		;UPDATE TEXTP
 1826 78        	MOV	A,B		;FETCH DIGIT COUNT - MAX - 1
 1827 C1        	POP	B		;RESTORE BC
 1828 B7        	ORA	A
 1829 F8        	RM			;COUNT <= MAX #, RETURN BOTH C AND Z RESET
 182A AF        	XRA	A		;OVERFLOW, RETURN C RESET AND Z SET
 182B 57        	MOV	D,A
 182C 5F        	MOV	E,A		;AND 0 IN DE
 182D C9        	RET
                
                ;GTLNO RETURNS A LEGAL LINE # IN DE, USING GTDEC.
                ;BRANCES TO FATAL US ERROR IF GTDEC RETURNS OVERFLOW OR 0.
                ;OTHERWISE 	(1) NONEXISTENT OR 	(2) 0 < N < 2 ^ 16.
                ;RETN:	A	NEXT NON-SPACE CHAR	CLOBBERED
                ;	BC	PRESERVED		PRESERVED
                ;	DE	0			N
                ;	HL	ADDR OF NEXT NONDIGIT	ADDRESS OF NEXT NONDIGIT
                ;	CARRY	SET			RESET
 182E CDF217    GTLNO:	CALL	GTDEC		;LOOK FOR DECIMAL INTEGER
 1831 D8        	RC			;NONE, RETURN CARRY
 1832 7A        	MOV	A,D
 1833 B3        	ORA	E
 1834 C0        	RNZ			;LEGAL LINE #, RETURN CARRY RESET
                USERR:	ERROR	F, U, S		;FATAL US ERROR -- ILLEGAL LINE #
 1835+CDC616    	CALL	ERROF
 1838+55D3      	DB	'U', 'S' OR 80H
                
                ;GTLIT GETS A LITERAL, AND IS CALLED BY EVAL, READ, INPUT AND VAL.
                ;THE LITERAL MAY BE PRECEEDED BY OPTIONAL SPACES AND UNTOKENIZED + AND - SIGNS.
                ;CALL:	HL	(TEXTP)
                ;RETN:	CARRY	SET IFF NO LITERAL FOUND
                ;	A	TYPE TOKEN
                ;	BC	VALUE IF INTEGER
                ;	C,DE	VALUE IF STRING
                ;	(TEMP)BCD	VALUE IF FLOATING
 183A 7E        GTLIT:	MOV	A,M		;FETCH NEXT
 183B 23        	INX	H		;AND POINT TO FOLLOWING
 183C F5        GTLT1:	PUSH	PSW
 183D AF        	XRA	A
 183E 32B941    	STA	TEMP		;SIGN = POSITIVE
 1841 F1        	POP	PSW
 1842 CDB517    GTLT2:	CALL	ISDIG		;CHECK IF CHAR IS DIGIT
 1845 D2DA18    	JNC	GTLID
                	IF	FLOAT
 1848 FE2E      	CPI	'.'
 184A CA0319    	JZ	GTLIF		;GET FLOATING LITERAL
                	ENDIF
 184D 228242    	SHLD	TEXTP		;ELSE READ THE CHAR
                	IF	STRNG
 1850 FE22      	CPI	'"'
 1852 CA7F18    	JZ	GTLIS		;GET STRING LITERAL
                	ENDIF
 1855 010001    	LXI	B,INTST SHL 8	;OVERFLOW FLAG TO B, 0 TO C
 1858 51        	MOV	D,C
 1859 59        	MOV	E,C		;EMBRYO VALUE 0 TO DE
 185A FE23      	CPI	'#'
 185C CAA218    	JZ	GTLIH		;GET HEX LITERAL
 185F FE26      	CPI	'&'
 1861 CA8B18    	JZ	GTLIB		;GET BINARY LITERAL
 1864 FE20      	CPI	' '
 1866 CA7A18    	JZ	GTLT3		;LEADING SPACE -- IGNORE
 1869 FE2B      	CPI	'+'
 186B CA7A18    	JZ	GTLT3		;UNARY +
 186E FE2D      	CPI	'-'		;CHECK FOR UNARY -
 1870 C27417    	JNZ	BKUPC		;ELSE BACK UP TEXTP AND RETURN CARRY
 1873 3AB941    	LDA	TEMP		;UNARY MINUS -- COMPLEMENT SIGN
 1876 2F        	CMA
 1877 32B941    	STA	TEMP
 187A 7E        GTLT3:	MOV	A,M
 187B 23        	INX	H		;POINT TO NEXT
 187C C34218    	JMP	GTLT2		;AND KEEP LOOKING
                ;GET A STRING LITERAL, I.E. QUOTED STRING
                	IF	STRNG
 187F E5        GTLIS:	PUSH	H		;SAVE STRING LOCATION
 1880 CDA717    	CALL	GTCLQ		;SCAN TO CLOSE " OR CR
 1883 D1        	POP	D		;LOCATION TO DE
 1884 7D        GTLS1:	MOV	A,L		;LAST+1 -- EVUNQ ENTRY POINT
 1885 93        	SUB	E		;LAST+1-FIRST = LENGTH
 1886 4F        	MOV	C,A		;TO C
 1887 3E03      	MVI	A,STRST		;TYPE = STRING
 1889 B7        	ORA	A		;RETURN CARRY RESET
 188A C9        	RET
                	ENDIF
                ;GET BINARY INTEGER LITERAL
 188B EB        GTLIB:	XCHG			;TEXTP TO DE, VALUE TO HL
 188C 1A        GTLB1:	LDAX	D		;FETCH CHAR
 188D D630      	SUI	'0'		;SUBTRACT ASCII BIAS
 188F FE02      	CPI	2
 1891 D2BD18    	JNC	OVTST		;NOT A BINARY DIGIT, DONE
 1894 13        	INX	D
 1895 0C        	INR	C		;BUMP COUNT
 1896 29        	DAD	H		;SHIFT VALUE LEFT ONE BIT
 1897 DCD818    	CC	OVSET		;SET OVERFLOW FLAG
 189A 1F        	RAR			;CURRENT DIGIT TO CARRY
 189B D28C18    	JNC	GTLB1		;TRY NEXT
 189E 23        	INX	H		;ADD CURRENT DIGIT TO VALUE
 189F C38C18    	JMP	GTLB1		;AND TRY NEXT
                ;GET HEX INTEGER LITERAL
 18A2 EB        GTLIH:	XCHG			;TEXTP TO DE, VALUE TO HL
 18A3 1A        GTLH1:	LDAX	D		;FETCH NEXT
 18A4 CDBC17    	CALL	ISHEX
 18A7 DABD18    	JC	OVTST		;NOT A HEX DIGIT, DONE
 18AA 13        	INX	D
 18AB 0C        	INR	C		;BUMP COUNT
 18AC F5        	PUSH	PSW
 18AD 7C        	MOV	A,H
 18AE E6F0      	ANI	0F0H		;ZERO RESET IF OVERFLOW WILL OCCUR
 18B0 C4D818    	CNZ	OVSET		;SET OVERFLOW FLAG
 18B3 F1        	POP	PSW		;RESTORE CURRENT NIBBLE
 18B4 29        	DAD	H
 18B5 29        	DAD	H
 18B6 29        	DAD	H
 18B7 29        	DAD	H		;VALUE LEFT FOUR BITS
 18B8 B5        	ORA	L
 18B9 6F        	MOV	L,A		;ADD IN CURRENT NIBBLE
 18BA C3A318    	JMP	GTLH1
                ;COMMON EXIT FOR BINARY AND HEX INTEGER LITERALS
 18BD EB        OVTST:	XCHG			;TEXTP TO HL
 18BE 228242    	SHLD	TEXTP		;AND RESET
 18C1 79        	MOV	A,C		;DIGIT COUNT TO A
 18C2 B7        	ORA	A
 18C3 CA7417    	JZ	BKUPC		;NO DIGITS AFTER # OR &, RETURN CARRY
 18C6 78        	MOV	A,B		;FETCH RESULT TYPE
 18C7 42        	MOV	B,D
 18C8 4B        	MOV	C,E		;RESULT TO DE
 18C9 FE01      	CPI	INTST
 18CB C8        	RZ			;RETURN TYPE INTEGER IF NO OVERFLOW
                ;ISSUE NONFATAL OV ERROR AND RETURN MAX INTEGER VALUE IN BC
                IOVER:	ERROR	N, O, V		;ELSE ISSUE NONFATAL OV ERROR
 18CC+CDD216    	CALL	ERRON
 18CF+4FD6      	DB	'O', 'V' OR 80H
 18D1 01FF7F    	LXI	B,7FFFH		;MAX POSITIVE VALUE TO BC
 18D4 3E01      	MVI	A,INTST		;RESULT IS INTEGER
 18D6 B7        	ORA	A		;CARRY RESET
 18D7 C9        	RET
 18D8 05        OVSET:	DCR	B
 18D9 C9        	RET
                ;GET NUMERIC LITERAL WITH FIRST CHAR DIGIT
 18DA E5        GTLID:	PUSH	H		;SAVE TEXTP
 18DB CDF217    	CALL	GTDEC		;GET DECIMAL NUMBER
 18DE 7E        	MOV	A,M		;FETCH NEXT CHAR
 18DF E1        	POP	H		;OLD TEXTP TO HL
                	IF	FLOAT
 18E0 CA0319    	JZ	GTLIF		;GET FLOATING LITERAL IF TOO BIG
 18E3 FE2E      	CPI	'.'
 18E5 CA0319    	JZ	GTLIF		;OR IF NEXT IS .
 18E8 FE45      	CPI	'E'
 18EA CA0319    	JZ	GTLIF		;OR IF NEXT IS E
 18ED FE65      	CPI	'E'+20H
 18EF CA0319    	JZ	GTLIF		;ALSO ALLOW LOWER CASE E IN CASE UNTOKENIZED
 18F2 7A        	MOV	A,D
 18F3 B7        	ORA	A
 18F4 FA0319    	JM	GTLIF		;OR IF VALUE IS > 32767 BUT < 65536
                	ELSE
                	JZ	IOVER		;OV ERROR IF TOO BIG IN NONFLOATING VERSION
                	ENDIF
 18F7 3AB941    	LDA	TEMP		;FETCH SIGN
 18FA B7        	ORA	A
 18FB C46502    	CNZ	CPLDE		;COMPLEMENT VALUE IF NEGATIVE DESIRED
 18FE 42        	MOV	B,D
 18FF 4B        	MOV	C,E		;VALUE TO BC
 1900 3E01      	MVI	A,INTST
 1902 D0        	RNC			;RETURN UNLESS CANNOT COMPLEMENT
                	IF	FLOAT
 1903 2B        GTLIF:	DCX	H
 1904 CDBC0B    	CALL	FINP		;GET FLOATING LITERAL
 1907 32B941    	STA	TEMP		;SAVE A
 190A 3E02      	MVI	A,SNGST
 190C B7        	ORA	A		;RETURN CARRY RESET
 190D C9        	RET
                	ELSE
                	JMP	IOVER
                	ENDIF
                
                ;GTNAM GETS A VARIABLE NAME INTO BUFFER AT BUFAD, ITS TYPE INTO VARTY,
                ;	AND ITS LENGTH INTO A.
                ;A NAME IS <LETTER> [<LETTER> | <DIGIT>]* [$ | <EXCLAM> | %] WITHOUT SPACES.
                ;AFTER MAXNL CHARACTERS, ADDITIONAL CHARS ARE SCANNED BUT IGNORED.
                ;THE FIRST LETTER DETERMINES THE VARIABLE TYPE ACCORDING TO TYBUF,
                ;	UNLESS THE TRAILING CHARACTER $ | <EXCLAM> | % IS SPECIFIED.
                ;CALL:	(TEXTP)	CURRENT TEXT POINTER
                ;RETN:	A	LENGTH OF VARIABLE NAME
                ;	HL	ADDRESS OF FIRST CHAR AFTER NAME
                ;	(BUFAD)	SYMBOL NAME STRING
                ;	(VARTY)	VARIABLE TYPE
                ;	CARRY	SET IFF NO NAME, I.E. FIRST CHAR NOT LETTER
 190E CD5117    GTNAM:	CALL	GTALP		;GET LETTER
 1911 D8        	RC
 1912 C5        	PUSH	B
 1913 D5        	PUSH	D
 1914 47        	MOV	B,A		;SAVE FIRST CHAR
                	IF	STRNG OR FLOAT	;MUST FIND VAR TYPE IF NONINTEGER VERSION
 1915 EB        	XCHG			;SAVE HL IN DE
 1916 215E41    	LXI	H,TYBUF-'A'
 1919 CD7202    	CALL	ADAHL		;ADDRESS DEFAULT TYPE BYTE
 191C 7E        	MOV	A,M		;FETCH IT
 191D EB        	XCHG			;RESTORE HL
                	ELSE
                	MVI	A,INTST		;ELSE TYPE IS INTEGER
                	ENDIF
 191E 329E41    	STA	VARTY		;STORE TYPE IN VARTY
 1921 78        	MOV	A,B		;RESTORE CHAR
 1922 01C841    	LXI	B,BUFAD
 1925 1601      	MVI	D,1		;CHAR COUNT TO D
 1927 02        GTNM1:	STAX	B		;STORE A CHAR
 1928 CDD117    GTNM2:	CALL	GTILD		;GET NEXT CHAR
 192B DA3B19    	JC	GTNM3		;NO MORE
 192E 5F        	MOV	E,A		;SAVE NEW CHAR
 192F 7A        	MOV	A,D
 1930 FE08      	CPI	MAXNL		;COMPARE COUNT TO MAX NAME LENGTH
 1932 D22819    	JNC	GTNM2		;COUNT >= LENGTH, SO DON'T INSERT
 1935 7B        	MOV	A,E		;RESTORE CHAR
 1936 03        	INX	B
 1937 14        	INR	D		;BUMP COUNT AND POINTER
 1938 C32719    	JMP	GTNM1		;AND INSERT
 193B FE25      GTNM3:	CPI	'%'
 193D CC5219    	CZ	GTNM4		;TYPE IS INTEGER
                	IF	FLOAT
 1940 FE21      	CPI	'!'
 1942 CC5D19    	CZ	GTNM6		;TYPE IS FLOATING
                	ENDIF
                	IF	STRNG
 1945 FE24      	CPI	'$'
 1947 CC6219    	CZ	GTNM7		;TYPE IS STRING
                	ENDIF
                	IF	CAMAC
                	CPI	'#'
                	CZ	GTNM8
                	ENDIF
 194A 0A        	LDAX	B
 194B F680      	ORI	80H
 194D 02        	STAX	B		;END OF STRING BIT ON
 194E 7A        	MOV	A,D
 194F D1        	POP	D
 1950 C1        	POP	B
 1951 C9        	RET
 1952 3E01      GTNM4:	MVI	A,INTST		;INTEGER TOKEN TO A
 1954 228242    GTNM5:	SHLD	TEXTP		;MOVE TEXTP PAST TRAILING CHAR
 1957 23        	INX	H
 1958 329E41    	STA	VARTY		;RESET VARTY TO SPECIFIED TYPE
 195B AF        	XRA	A		;CLEAR A FOR FOLLOWING COMPARES
 195C C9        	RET
                	IF	FLOAT
 195D 3E02      GTNM6:	MVI	A,SNGST		;SINGLE PRECISION TOKEN TO A
 195F C35419    	JMP	GTNM5
                	ENDIF
                	IF	STRNG
 1962 3E03      GTNM7:	MVI	A,STRST		;STRING TOKEN TO A
 1964 C35419    	JMP	GTNM5
                	ENDIF
                	IF	CAMAC
                GTNM8:	MVI	A,CAMST
                	JMP	GTNM5
                	ENDIF
                
                ;FDVAR LOOKS FOR VARIABLE NAME, RETURNS CARRY SET IF NONE.
                ;IF VAR NOT FOUND IN SYMBOL TABLE, ASSUMES ITS TYPE TO BE SIMPLE AND
                ;BUILDS A NEW SYMBOL TABLE ENTRY FOR IT.
                ;RETN:	DE	ENTRY TYPE ADDRESS
                ;	HL	ADDRESS FOLLOWING NAME IN ENTRY
 1967 CD0E19    FDVAR:	CALL	GTNAM
 196A D8        	RC
 196B 4F        	MOV	C,A		;SAVE LENGTH
 196C CD1C1B    	CALL	STLKU		;LOOK UP SYMBOL IN SYMBOL TABLE
 196F D0        	RNC			;FOUND IT
 1970 3A9E41    FDVA1:	LDA	VARTY		;FETCH VAR TYPE -- UNARY USER FN ENTRY POINT
                	IF	CAMAC
                	CPI	CAMST		;CHECK IF CAMVAR
                	JZ	SNERR		;SN ERROR IF UNDEFINED CAMVAR
                	ENDIF
 1973 CD0902    	CALL	BYTSD		;# BYTES PER ENTRY TO DE
 1976 EB        	XCHG			;AND TO HL
 1977 0600      	MVI	B,0		;LENGTH TO BC
 1979 23        	INX	H		;+LENGTH
 197A 23        	INX	H		;+TYPE
 197B 23        	INX	H		;+DIMS
 197C 09        	DAD	B		;ENTRY LENGTH TO HL
 197D CDB51A    	CALL	STPSH		;BUILD THE ENTRY
 1980 1B        	DCX	D		;DE POINTS TO TYPE BYTE
 1981 3600      	MVI	M,0		;ZERO THE DIM BYTE
 1983 C9        	RET
                
                ;GTVAR PERFORMS A VARIABLE REFERENCE.
                ;GETS A VARIABLE NAME FROM TEXT, RETURNS WITH CARRY SET IF NONE.
                ;IF VARIABLE NAME NOT FOUND IN SYMBOL TABLE, ASSUMES ITS TYPE TO BE SIMPLE
                ;AND BUILDS A NEW SYMBOL TABLE ENTRY FOR IT.
                ;PRINTS TRACE INFO IF INLHS AND EITHER TRACE OR VARIABLE BREAK BIT ON,
                ;AND SETS VTRAC ACCORDINGLY.
                ;ISSUES BS ERROR IF SUBSCRIPT OUT OF BOUNDS.
                ;RETN:	A	TYPE TOKEN OF REFERENCED VARIABLE
                ;	DE	TYPE BYTE ADDRESS OF REFERENCED VAR
                ;	HL	ADDRESS OF REFERENCED VARIABLE
                ;	CARRY	SET IFF NO NAME FOUND
                ;	(VTRAC)	BIT 7 SET IFF TRACE DESIRED
 1984 CD6719    GTVAR:	CALL	FDVAR
 1987 D8        	RC			;NO NAME FOUND
                	IF	NOT COMPL
 1988 3A5140    	LDA	INLHS
 198B B7        	ORA	A
 198C C4371A    	CNZ	TRSET		;SET VTRAC IF IN LHS
                	ENDIF
 198F 7E        	MOV	A,M		;FETCH # DIMS
 1990 4F        	MOV	C,A		;AND SAVE IN C
 1991 23        	INX	H
 1992 B7        	ORA	A		;ZERO SET IFF SIMPLE VAR
 1993 3A9E41    	LDA	VARTY		;VALUE TO RETURN TO A
 1996 C8        	RZ			;SIMPLE VAR
                	IF	CAMAC
                	CPI	CAMST		;CHECK IF CAMVAR REFERENCE
                	JNZ	GTVA0		;NO
                	MVI	A,INTST		;YES, VALUE OF CAMVAR REF IS INTEGER
                GTVA0:	ORA	A		;RESET CARRY FOR RETURN
                	ENDIF
 1997 F5        	PUSH	PSW		;SAVE VALUE TO RETURN
 1998 D5        	PUSH	D
 1999 CD0902    	CALL	BYTSD		;FIND BYTES PER ENTRY
 199C 43        	MOV	B,E		;AND SAVE IN B
 199D C5        	PUSH	B		;SAVE BYTES PER ENTRY AND # DIMS
 199E 010100    	LXI	B,1		;PRODUCT TO BC
 19A1 110000    	LXI	D,0		;SUM TO DE
 19A4 D5        	PUSH	D		;AND SAVED
 19A5 1628      	MVI	D,'('
                ;GTVA1 IS EXECUTED FOR EACH SUBSCRIPT OF THE VARIABLE.  THE STACK CONTAINS
                ;THE RESULT TYPE, TYPE BYTE ADDRESS, BYTES PER ENTRY/# DIMENSIONS, AND SUM
                ;OF SUBSCRIPTS THUS FAR.  BC CONTAINS THE PRODUCT OF BOUNDS THUS FAR, AND
                ;HL POINTS TO THE NEXT BOUND.
 19A7 E5        GTVA1:	PUSH	H		;SAVE POINTER
 19A8 CD7817    	CALL	GTDTR		;SKIP (
 19AB E1        	POP	H		;RESTORE POINTER
 19AC 5E        	MOV	E,M
 19AD 23        	INX	H
 19AE 56        	MOV	D,M		;NEXT BOUND TO DE
 19AF 23        	INX	H		;POINT TO NEXT
 19B0 E3        	XTHL			;SAVE POINTER, SUM TO HL
 19B1 C5        	PUSH	B		;SAVE PRODUCT
 19B2 D5        	PUSH	D		;SAVE DIM
 19B3 E5        	PUSH	H		;SAVE SUM
 19B4 C5        	PUSH	B		;SAVE PRODUCT
 19B5 CDE519    	CALL	GTSUB		;GET SUBSCRIPT TO BC
 19B8 D1        	POP	D		;PRODUCT TO DE
 19B9 CD6D11    	CALL	MULBD		;SUBSCRIPT * PRODUCT TO HL
 19BC D1        	POP	D		;SUM TO DE
 19BD 19        	DAD	D		;NEW SUM = SUM + SUBSCRIPT * PRODUCT TO HL
 19BE D1        	POP	D		;BOUND TO DE
 19BF C1        	POP	B		;PRODUCT TO BC
 19C0 13        	INX	D		;BOUND+1
 19C1 E5        	PUSH	H		;SAVE SUM
 19C2 CD6D11    	CALL	MULBD		;NEW PRODUCT = PRODUCT * (BOUND+1) TO HL
 19C5 D1        	POP	D		;SUM TO DE
 19C6 E3        	XTHL			;PRODUCT TO STACK, POINTER TO HL
 19C7 C1        	POP	B		;PRODUCT TO BC
 19C8 E3        	XTHL			;POINTER TO STACK, COUNTS TO HL
 19C9 2D        	DCR	L		;DECREMENT # DIMS COUNT
 19CA CAD419    	JZ	GTVA2		;DONE
 19CD E3        	XTHL			;SAVE COUNTS, RESTORE POINTER
 19CE D5        	PUSH	D		;SAVE SUM
 19CF 162C      	MVI	D,','
 19D1 C3A719    	JMP	GTVA1		;AND DO SOME MORE DIMENSIONS
 19D4 7C        GTVA2:	MOV	A,H		;BYTES PER ENTRY TO A
 19D5 E1        	POP	H		;POINTER TO HL
 19D6 19        GTVA3:	DAD	D		;ADD SUM ONCE FOR EACH VALUE BYTE
 19D7 3D        	DCR	A
 19D8 C2D619    	JNZ	GTVA3		;POINTER * SUM = LOCATION
 19DB E5        	PUSH	H
 19DC 1629      	MVI	D,')'
 19DE CD7817    	CALL	GTDTR		;SKIP )
 19E1 E1        	POP	H
 19E2 D1        	POP	D		;RESTORE TYPE BYTE ADDRESS
 19E3 F1        	POP	PSW		;AND VALUE TO RETURN
 19E4 C9        	RET
                
                ;GTSUB GETS A SUBSCRIPT EXPRESSION, ISSUING NONFATAL BS ERROR IF OUT OF BOUNDS.
                ;THE SUBSCRIPT VALUE IS PRINTED IF VTRAC IS NEGATIVE.
                ;CALL:	DE	BOUND
                ;RETN:	BC	SUBSCRIPT, 0 <= (BC) <= (DE)
                GTSUB:	IF	NOT COMPL
 19E5 3A5140    	LDA	INLHS
 19E8 B7        	ORA	A		;CHECK IF INLHS
 19E9 FA101A    	JM	GTSU2		;YES -- FIX SO NO EXTRANEOUS TRACING
                	ENDIF
 19EC D5        GTSU0:	PUSH	D		;SAVE BOUND
 19ED 114141    	LXI	D,STACK+STAKM+10-STAKL
 19F0 CD6502    	CALL	CPLDE
 19F3 EB        	XCHG
 19F4 39        	DAD	SP		;NUMBER OF BYTES LEFT TO HL
 19F5 D2241A    	JNC	BSERR		;FATAL BS ERROR IF TOO LITTLE ROOM LEFT
 19F8 CD9D0B    	CALL	GTEXP		;EXPR TO BC
 19FB 110000    	LXI	D,0
 19FE 78        	MOV	A,B
 19FF B7        	ORA	A		;CHECK SIGN OF SUBSCRIPT
 1A00 FC091A    	CM	GTSU1		;NEGATIVE
 1A03 D1        	POP	D		;RESTORE BOUND
 1A04 CD8C02    	CALL	CMBDS
 1A07 D8        	RC			;< BOUND
 1A08 C8        	RZ			;= BOUND
 1A09 42        GTSU1:	MOV	B,D
 1A0A 4B        	MOV	C,E		;REPLACE EXPR WITH BOUND
                	ERROR	N, B, S		;NONFATAL BS ERROR AND RETURN
 1A0B+CDD216    	CALL	ERRON
 1A0E+42D3      	DB	'B', 'S' OR 80H
                	IF	NOT COMPL
 1A10 AF        GTSU2:	XRA	A
 1A11 325140    	STA	INLHS		;RESET INLHS
 1A14 CDEC19    	CALL	GTSU0		;GET THE SUBSCRIPT
 1A17 3EFF      	MVI	A,255
 1A19 325140    	STA	INLHS		;TURN INLHS BACK ON
 1A1C 3A5240    	LDA	VTRAC
 1A1F B7        	ORA	A
 1A20 F0        	RP
 1A21 C3FB15    	JMP	WRTBU		;PRINT SUBSCRIPT VAL IF TRACING
                	ENDIF
                BSERR:	ERROR	F, B, S		;FATAL BS ERROR
 1A24+CDC616    	CALL	ERROF
 1A27+42D3      	DB	'B', 'S' OR 80H
                
                ;GTIVA IS CALLED FROM SCALL TO PERFORM AN INTEGER VARIABLE REFERENCE.
                ;RETN:	CARRY	SET IF NOT INTEGER VAR REF
                ;	BC	VALUE OF INTEGER VAR
                ;	DE	PRESERVED
 1A29 D5        GTIVA:	PUSH	D
 1A2A CD8419    	CALL	GTVAR		;LOOK FOR VAR REF
 1A2D D1        	POP	D
 1A2E D8        	RC			;NOT FOUND
 1A2F 4E        	MOV	C,M
 1A30 23        	INX	H
 1A31 46        	MOV	B,M		;VALUE TO BC
                	IF	STRNG OR FLOAT
 1A32 FE01      	CPI	INTST
 1A34 C8        	RZ			;RETURN CARRY RESET IF INTEGER
 1A35 37        	STC			;AND CARRY SET IF NOT
                	ENDIF
 1A36 C9        	RET
                
                	IF	NOT COMPL
                ;TRSET DETERMINES IF TRACE PRINTING IS DESIRED, SETTING VTRAC ACCORDINGLY
                ;AND ECHOING THE VARIABLE NAME IF SO.
                ;A TRAILING TYPE CHAR IS PRINTED IF THE TYPE IS NOT THE DEFAULT TYPE.
                ;CALL:	DE	ADDR OF VAR TYPE BYTE
                ;RETN:	A	CLOBBERED
                ;	BC,DE,HL	PRESERVED
                ;	CARRY	RESET
                ;	(VTRAC)	MINUS IFF TRACE PRINTING DESIRED
 1A37 E5        TRSET:	PUSH	H
 1A38 2A5040    	LHLD	TRACE		;INLHS TO H, TRACE TO L
 1A3B 1A        	LDAX	D		;TYPE BYTE TO A -- A7 SET IFF VAR BREAK
 1A3C B5        	ORA	L		;MINUS IFF VAR BREAK OR TRACE ON
 1A3D A4        	ANA	H		;MINUS IFF TRACING DESIRED
 1A3E 325240    	STA	VTRAC
 1A41 F2661A    	JP	TRST1		;DONE IF NOT TRACING
 1A44 CD6507    	CALL	BPRNT		;ECHO LINE NUMBER IF NOT DONE ALREADY
 1A47 62        	MOV	H,D
 1A48 6B        	MOV	L,E
 1A49 23        	INX	H		;NAME ADDR TO HL
                	IF	STRNG OR FLOAT
 1A4A E5        	PUSH	H		;AND SAVED
 1A4B CDB016    	CALL	PRTST		;PRINT IT
 1A4E E1        	POP	H		;RESTORE ADDR
 1A4F 7E        	MOV	A,M		;REFETCH FIRST CHAR
 1A50 E67F      	ANI	7FH		;MASK OFF POSSIBLE HIGH BIT
 1A52 215E41    	LXI	H,TYBUF-'A'
 1A55 CD7202    	CALL	ADAHL		;ADDRESS DEFAULT TYPE BUFFER LOCATION
 1A58 1A        	LDAX	D		;FETCH TYPE BYTE
 1A59 E61F      	ANI	1FH		;MASK TO TYPE
 1A5B BE        	CMP	M		;COMPARE TO DEFAULT
 1A5C CA661A    	JZ	TRST1		;SAME AS DEFAULT, NO TRAILING CHAR
 1A5F CD681A    	CALL	TYCHA		;TYPE CHAR TO H
 1A62 7C        	MOV	A,H
 1A63 CD2D15    	CALL	WRITC		;AND PRINTED
                	ELSE			;NOT STRNG AND NOT FLOAT
                	CALL	PRTST		;JUST PRINT THE NAME
                	ENDIF
 1A66 E1        TRST1:	POP	H
 1A67 C9        	RET
                
                ;TYCHA RETURNS TYPE CHAR IN H FOR TYPE IN A.
                	IF	STRNG OR FLOAT
                TYCHA:	IF	STRNG
 1A68 2624      	MVI	H,'$'
 1A6A FE03      	CPI	STRST
 1A6C C8        	RZ			;STRING
                	ENDIF
                	IF	FLOAT
 1A6D 2621      	MVI	H,'!'
 1A6F FE02      	CPI	SNGST
 1A71 C8        	RZ			;FLOATING
                	ENDIF
                	IF	CAMAC
                	MVI	H,'#'
                	CPI	CAMST
                	RZ			;CAMVAR
                	ENDIF
 1A72 2625      	MVI	H,'%'
 1A74 C9        	RET			;INTEGER
                	ENDIF			;END OF STRNG OR FLOAT CONDITIONAL
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                
                ;CMPST COMPARES THE STRINGS AT (DE) AND M.  ZERO SET IFF MATCH.
 1A75 1A        CMPST:	LDAX	D
 1A76 BE        	CMP	M
 1A77 13        	INX	D
 1A78 23        	INX	H
 1A79 C0        	RNZ			;RETURN ZERO RESET IF NO MATCH
 1A7A B7        	ORA	A
 1A7B F2751A    	JP	CMPST		;KEEP COMPARING
 1A7E AF        	XRA	A		;MATCH -- SET ZERO AND RETURN
 1A7F C9        	RET
                
                ;CPYST COPIES A STRING FROM (DE) TO M.
 1A80 11C841    CPYS0:	LXI	D,BUFAD
 1A83 1A        CPYST:	LDAX	D
 1A84 77        	MOV	M,A
 1A85 13        	INX	D
 1A86 23        	INX	H
 1A87 B7        	ORA	A
 1A88 F2831A    	JP	CPYST
 1A8B C9        	RET
                
                
                ;END OF PARSING
                	PAGE
                
                ;SDISK 1/12/81
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980, 1981 BY MARK WILLIAMS COMPANY, CHICAGO
                ;STATEMENT ROUTINES FOR CP/M SDISK VERSION
                
                
                	IF	CPM AND SDISK
                
                ;THE SEQUENTIAL DISK FILE BLOCK WORKING SPACE IS LOCATED AT THE
                ;TOP OF RAM, BETWEEN (STRT) AND (FILET).  LOCATION FILES CONTAINS THE
                ;NUMBER OF FILE BLOCKS CURRENTLY ALLOCATED.
                
                ;EACH POTENTIAL SEQUENTIAL DISK FILE HAS A 166 BYTE FILE BLOCK, CONTAINING:
                ;1	FILE #, 0 IF UNUSED AND NONZERO IF OPEN
                ;2	MODE, 0 FOR OUTPUT AND NONZERO FOR INPUT
                ;3	COUNT, 0-7FH INDICATING LAST POSITION WRITTEN/READ IN CURRENT BUFFER
                ;4	COLUMN, INITIALLY 0, IGNORED FOR INPUT
                ;5	WIDTH, INITIALLY 72, IGNORED FOR INPUT
                ;6-38	FILE CONTROL BLOCK (33 BYTES)
                ;39-166	BUFFER (128 BYTES)
                
                
                	IF	RTPAK		;EQUATES FOR C3885 RTPAK VERSION
                DCLR0	EQU	UFERR
                CLOSE	EQU	UFERR
                DINP0	EQU	UFERR
                OPEN	EQU	UFERR
                DPRIN	EQU	UFERR
                EOFFN	EQU	UFERR
                	ELSE			;NOT RTPAK
                
                ;CLEAR @<EXPR>
                DCLR0:	INR	A		;CLEAR @0 MEANS FILES=1, ETC.
                	JZ	BFERR		;CLEAR @ 255 NOT ALLOWED
                	MOV	C,A		;DESIRED # FILES TO C
                	CALL	CLOSN		;CLOSE ANY OPEN FILES
                	LDA	FILES		;CURRENT #
                	SUB	C
                	JP	DCLR2		;NEED FEWER, SO SKIP MEMORY CHECK
                	LXI	D,-FILEN
                	LHLD	SYMTA
                DCLR1:	DAD	D
                	INR	A
                	JNZ	DCLR1		;LEAVE ROOM FOR ADDITIONAL FILE
                	XCHG			;NEW SYMTA TO DE
                	LHLD	EOFAD
                	CALL	CMDHU
                	JC	OMERR		;NOT ENOUGH SPACE, FATAL OM ERROR
                DCLR2:	LHLD	STRT
                	XCHG
                	CALL	CPLDE		;- TOP OF STRING SPACE TO DE
                	LHLD	MEMT
                	DAD	D		;-CURRENT AMOUNT OF STRING SPACE TO HL
                	PUSH	H		;AND SAVED
                	MOV	A,C
                	STA	FILES		;SAVE NEW FILE MAX
                	LHLD	FILET		;TOP OF FILE SPACE TO HL
                	LXI	D,-FILEN	;SPACE PER FILE TO DE
                DCLR3:	DCR	A
                	JZ	DCLR4
                	MVI	M,0		;INITIALIZE EMPTY FILE SPACE
                	DAD	D
                	JMP	DCLR3
                DCLR4:	SHLD	STRT		;STORE NEW TOP OF STRING SPACE
                	POP	D
                	DAD	D		;SUBTRACT STRING SPACE NEEDED
                	JMP	CLE0A		;AND INITIALIZE SYMBOL TABLE, ETC.
                
                ;CLOSE [@<EXPR>, ...]
                CLOSE:	CALL	GTSFN		;LOOK FOR FILE #
                	JC	CLOSN		;NONE, CLOSE ALL
                	JZ	BFERR		;DK ERROR IF @0 CLOSED
                	MOV	H,B
                	MOV	L,C
                CLOS1:	ORA	A
                	JNZ	CLOSI		;CLOSE FILE OPEN FOR INPUT
                	MOV	A,M		;FETCH COUNT
                	SUI	80H
                	MOV	B,A		;EOF COUNT TO B
                	MVI	C,CNTLZ
                CLOS2:	PUSH	B
                	PUSH	H
                	CALL	DWRTC		;WRITE AN EOF
                	POP	H
                	POP	B
                	INR	B
                	JNZ	CLOS2		;WRITE MORE EOFS
                CLOSI:	INX	H
                	INX	H		;POINT TO FILE NUMBER
                	MVI	M,0		;RESET TO 0
                	LXI	D,-37
                	DAD	D
                	XCHG			;FCB ADDRESS TO DE
                	MVI	C,DKCLF
                	IF	C3885 AND NOT DEBUG
                	CALL	BDOS1		;BDOS CALL WITH INTERRUPTS DISABLED
                	ELSE
                	CALL	BDOS
                	ENDIF
                	CPI	255
                	RNZ
                	JMP	DKERR		;CLOSE ERROR
                CLOSN:	CALL	SFILS
                CLON1:	DCR	B
                	RZ			;ALL CLOSED
                	PUSH	B
                	PUSH	D
                	PUSH	H		;SAVE ALL
                	MOV	A,M		;FETCH FILE NUMBER
                	ORA	A
                	DCX	H
                	MOV	A,M		;FETCH TYPE
                	DCX	H		;POINT TO COUNT
                	CNZ	CLOS1		;CLOSE A FILE
                	POP	H
                	POP	D
                	POP	B		;RESTORE
                	DAD	D		;POINT TO NEXT
                	JMP	CLON1		;AND SEE IF MORE TO CLOSE
                
                ;DIR [<AMBIGUOUS FILENAME>]
                	IF	NOT C3885
                DIRCM:	CALL	GTAF5		;SET FILENAME TO *.*
                	XRA	A
                	STA	FCBAD		;SET DISK TO @
                	STA	FCBCR
                	CALL	DTST0		;LOOK FOR DELIMITER
                	CC	GTAFN		;GET DESIRED AMBIGUOUS FILENAME IF PRESENT
                	MVI	C,17
                DIRC1:	CALL	CTEST		;LOOK FOR CONSOLE BREAK CHAR
                	CALL	WCRLF		;WRITE CRLF
                	CALL	BDOSF		;SEARCH FOR NEXT OCCURRENCE OF FILENAME
                	CPI	255
                	RZ			;NO MORE
                	ANI	3
                	RRC
                	RRC
                	RRC
                	ADI	81H
                	MOV	E,A
                	MVI	D,0		;ADDRESS OF FILENAME TO DE
                	MVI	C,8
                	CALL	PRSTR		;PRINT THE FILENAME
                	CALL	WRTSP		;AND PRINT A SPACE
                	MVI	C,3
                	CALL	PRSTR		;AND PRINT FILETYPE
                	MVI	C,18		;LOOK FOR NEXT
                	JMP	DIRC1
                	ENDIF
                
                ;INPUT @<EXPR>, <VAR LIST>
                DINP0:	PUSH	PSW
                	CALL	GTCOM		;SKIP TRAILING COMMA
                	POP	PSW
                	JZ	INPU1		;INPUT @0, NORMAL INPUT WITH NO QUOTED STRING
                	ORA	A
                	JZ	FMERR		;FM ERROR IF FILE OPEN FOR OUTPUT
                	PUSH	B		;SAVE FILE COUNT POINTER
                DINP1:	CALL	GTLHS		;GET DESTINATION
                	POP	H		;FILE COUNT POINTER TO HL
                	CPI	STRST
                	PUSH	PSW		;SAVE TYPE (ZERO SET IFF STRING)
                	LXI	D,NLNAD		;INPUT BUFFER ADDRESS TO DE
                	MVI	C,0		;CHAR COUNT TO C
                DINP2:	CALL	DREAD		;READ A DISK FILE CHAR
                	CPI	' '+1
                	JC	DINP2		;IGNORE LEADING SPACES OR CONTROL CHARS
                	CPI	','
                	JZ	DINP2		;AND IGNORE LEADING COMMAS
                DINP3:	CPI	' '
                	JNZ	DINP4		;NEXT NOT SPACE
                	POP	PSW
                	PUSH	PSW		;ZERO SET IFF STRING
                	MVI	A,' '
                	JNZ	DINP6		;DONE IF SPACE AND NUMERIC
                DINP4:	CPI	','
                	JZ	DINP6		;DONE IF COMMA
                	CPI	CR
                	JZ	DINP5		;DONE IF <CR>
                	STAX	D		;ELSE STORE THE CHAR
                	INX	D
                	INR	C		;BUMP THE COUNT
                	JZ	DINP8		;256 CHARS
                	CALL	DREA0		;ELSE LOOK AT NEXT CHAR
                	JZ	DINP6		;DONE IF EOF
                	INR	M		;ELSE READ IT
                	JMP	DINP3		;AND REPEAT
                DINP5:	CALL	DINLF		;IGNORE TRAILING <LINEFEED> IF PRESENT
                DINP6:	POP	PSW
                	PUSH	H
                	LXI	H,NLNAD
                	JNZ	DINP9		;NUMERIC VALUE
                	XCHG			;LOCATION TO DE
                	MVI	A,STRST
                DINP7:	CALL	ASIGV		;ASSIGN VALUE TO DESTINATION
                	CALL	GTCND		;LOOK FOR COMMA AND MORE VARS
                	JNC	DINP1
                	POP	H		;POP SAVED FILE COUNT POINTER
                DIN10:	CALL	DREA0		;LOOK AT FIRST UNREAD CHAR
                	RZ			;EOF, DONE
                	CPI	' '		
                	JZ	DIN11		;IGNORE TRAILING SPACES
                	CPI	CR	
                	RNZ			;DONE IF NEXT CHAR NOT SPACE OR <CR>
                	INR	M		;IGNORE THE TRAILING <CR>
                ;DINLF IGNORES NEXT CHARACTER IFF <LINEFEED>
                DINLF:	CALL	DREA0		;LOOK AT NEXT CHAR
                	RZ			;EOF
                	CPI	LF
                	RNZ			;NOT <LF>, RETURN
                	INR	M		;READ THE <LF>
                	RET			;AND RETURN
                DIN11:	INR	M		;READ THE TRAILING SPACE
                	JMP	DIN10		;AND LOOK FOR MORE TRAILING SPACES OR <CR>
                DINP8:	DCR	M		;UNREAD THE 256TH CHAR
                	DCR	C		;CORRECT THE COUNT
                	JMP	DINP6		;AND ASSIGN IT
                DINP9:	MVI	A,CR
                	STAX	D		;PUT <CR> AFTER VALUE
                	SHLD	TXTP2
                	CALL	FLIP		;TO READ THE INPUT BUFFER
                	CALL	GTLIT		;EVALUATE THE NUMERIC VALUE
                	JC	FIERR		;BAD VALUE
                	CPI	STRST
                	JZ	FIERR		;STRING VALUE IS ALSO BAD
                	PUSH	D
                	PUSH	PSW
                	CALL	FLIP		;TO READ AS BEFORE
                	LDAX	D		;FETCH NEXT CHAR FROM INPUT BUFFER
                	CPI	CR
                	JNZ	FIERR		;FI ERROR IF NOT <CR>, VALUE IS BAD
                	POP	PSW
                	POP	D
                	JMP	DINP7		;ELSE ASSIGN VALUE TO DESTINATION AS ABOVE
                FIERR:	ERROR	F, F, I		;FATAL FI ERROR
                FMERR:	ERROR	F, F, M		;FATAL FM ERROR
                
                ;LINPUT [@<EXPR>] <STRING VAR>
                	IF	NOT C3885
                LINPT:	CALL	IDTST		;LINPUT IS ILLEGAL IN DIRECT MODE
                	CALL	GTSFN		;LOOK FOR FILE #
                	PUSH	PSW
                	PUSH	B
                	CALL	GTCOM		;SKIP COMMA, IF ANY
                	CALL	GTLHS		;GET DESTINATION
                	CPI	STRST
                	JNZ	SNERR		;MUST BE STRING
                	POP	H		;COUNT POINTER TO HL
                	POP	PSW
                	JC	LINP0
                	JZ	LINP0		;NORMAL LINPUT
                	ORA	A
                	JZ	FMERR		;FM ERROR IF OPEN FOR OUTPUT
                	LXI	D,NLNAD
                	PUSH	D		;SAVE INPUT BUFFER ADDRESS
                	MVI	C,0
                	JMP	LINF1
                LINF0:	INR	C		;CHAR COUNT TO C
                	JZ	LINF2		;256 CHARS READ
                LINF1:	CALL	DREAD		;READ A DISK CHAR
                	STAX	D		;STORE IT
                	INX	D
                	CPI	CR
                	JNZ	LINF0		;READ ANOTHER UNLESS AT CR
                	POP	D		;LOCATION = INPUT BUFFER TO DE
                	CALL	DINLF		;SKIP TRAILING <LF> IF PRESENT
                	JMP	LINP2		;ASSIGN VALUE TO DESTINATION
                LINF2:	DCR	M		;UNREAD THE 256TH CHAR
                	DCR	C		;CORRECT THE COUNT
                	POP	D		;RESTORE LOCATION
                	JMP	LINP2		;ASSIGN VALUE TO DESINATION
                ;LINPUT FROM THE CONSOLE
                LINP0:	LHLD	TEXTP
                	PUSH	H		;SAVE TEXTP
                	CALL	GTLIN		;GET INPUT LINE
                	XTHL			;RECOVER OLD TEXTP
                	SHLD	TEXTP
                	POP	H
                	MOV	D,H
                	MOV	E,L		;COPY FIRST CHAR ADDRESS TO DE
                	MVI	A,CR
                	MVI	C,0		;CHAR COUNT TO C
                LINP1:	CMP	M
                	JZ	LINP2		;DONE IF CHAR IS CR
                	INR	C
                	INX	H
                	JMP	LINP1
                LINP2:	MVI	A,STRST
                	JMP	ASIGV		;ASSIGN STRING VALUE TO DESTINATION
                	ENDIF
                
                ;MARGIN [@<EXPR>,] <EXPR>
                	IF	NOT C3885
                MARGN:	CALL	GTSFN		;FIND FILE
                	JC	MARG0		;NONE, CHANGE WIDTH
                	PUSH	PSW		;SAVE ZERO STATUS
                	PUSH	B		;AND POINTER
                	MVI	D,','
                	CALL	GTDSN		;SKIP ,
                	CALL	GTBEX		;GET BYTE VALUE
                	POP	H		;POINTER TO HL
                	POP	PSW		;RESTORE ZERO
                	JZ	MARG1		;@0, CHANGE WIDTH
                	DCX	H
                	DCX	H		;POINT TO FILE WIDTH FIELD
                	MOV	M,C		;AND CHANGE IT
                	RET
                MARG0:	CALL	GTBEX		;GET BYTE VALUE
                MARG1:	MOV	A,C
                	STA	WIDTH		;VALUE TO WIDTH
                	RET
                	ENDIF
                
                ;OPEN {I | O | U} @<EXPR>, <FILENAME>
                OPEN:	CALL	GTCHA		;GET DESIRED MODE
                	PUSH	PSW		;AND SAVE
                	CALL	GTCOM		;ALLOW COMMA AFTER MODE
                	CALL	GTATN		;GET DESIRED FILE NUMBER
                	JC	BFERR
                	JZ	BFERR		;0 NOT ALLOWED
                	CALL	SFILS		;SET UP B, DE, HL FOR SEARCH
                	MOV	C,B		;MAX # FILES TO C ALSO
                	PUSH	D
                	PUSH	H		;AND SAVE
                ;FIRST CHECK IF NUMBER ALREADY ASSOCIATED WITH OPEN FILE
                OPEN1:	DCR	C
                	JZ	OPEN2
                	CMP	M
                	JZ	FOERR		;DESIRED NUMBER ALREADY OPEN, FO ERROR
                	DAD	D
                	JMP	OPEN1		;ELSE TRY NEXT
                OPEN2:	MOV	C,A		;DESIRED NUMBER TO C
                	PUSH	B
                	MVI	D,','
                	CALL	GTDSN		;SKIP ,
                	CALL	GTFNM		;GET DESIRED FILENAME
                ;CHECK IF FILE OF SAME NAME IS ALREADY OPEN
                	POP	B
                	POP	H
                	PUSH	H
                	PUSH	B
                OPN2A:	DCR	B
                	JZ	OPN2C		;CHECKED ALL FILES, OK
                	MOV	A,M		;FETCH FILE #
                	LXI	D,-37
                	DAD	D		;ADDRESS THE FILE FCB
                	ORA	A
                	JZ	OPN2B		;NO FILE, SKIP THE TEST
                	PUSH	B
                	PUSH	H
                	LXI	D,FCBAD
                	LXI	B,(12 SHL 8) OR 12	;COUNT = 12 CHARS TO B AND C
                	CALL	CMSTR		;COMPARE FILE FCB WITH NEW FCB
                	JZ	FOERR		;ALREADY OPEN, FO ERROR
                	POP	H
                	POP	B
                OPN2B:	LXI	D,-129
                	DAD	D		;ADDRESS THE NEXT FILE #
                	JMP	OPN2A		;AND TEST IT
                OPN2C:	POP	B
                	POP	H
                	POP	D
                ;THEN CHECK IF SPACE AVAILABLE FOR FILE
                OPEN3:	DCR	B
                	JZ	OPERR		;ALL AVAILABLE FILE AREAS FULL
                	MOV	A,M
                	ORA	A
                	JZ	OPEN4		;AVAILABLE
                	DAD	D
                	JMP	OPEN3		;ELSE TRY NEXT
                OPEN4:	MOV	M,C
                	DCX	H
                	POP	PSW		;RECOVER DESIRED MODE
                	CPI	'O'
                	JZ	OPENO
                	CPI	'U'
                	JZ	OPENU
                ;ELSE OPEN FOR INPUT
                	CPI	'I'
                	JNZ	SNERR		;SN ERROR IF NOT I
                	INX	H
                	MVI	M,0		;RESET FILE # TO 0 IN CASE NOT FOUND
                	PUSH	B
                	PUSH	H
                	CALL	CDKOP		;OPEN THE FILE
                	POP	H
                	POP	B
                	MOV	M,C		;SET THE FILE #
                	DCX	H
                	MVI	M,255		;MODE = INPUT
                	DCX	H
                	MVI	M,7FH		;COUNT = 7FH SO NEXT READ GETS NEW BUFFER
                	LXI	D,-35
                	DAD	D		;HL ADDRESSES FILE FCB
                	JMP	OPEN6
                ;OPEN FOR OUTPUT
                OPENO:	XRA	A
                	MOV	M,A		;MODE = OUTPUT
                	DCX	H
                	MOV	M,A		;BUFFER ADDRESS = 0
                	DCX	H
                	MOV	M,A		;COLUMN = 0
                	DCX	H
                	MVI	M,72		;DEFAULT WIDTH = 72
                	LXI	D,-33
                	DAD	D		;HL ADDRESSES FILE FCB
                	PUSH	H
                	CALL	CDKMK		;DELETE OLD, MAKE NEW
                	POP	H
                OPEN6:	LXI	B,FCBAD
                	LXI	D,33
                	JMP	MOVED		;COPY DEFAULT FCB TO FCB AND RETURN
                ;OPEN FOR UPDATE
                OPENU:	MVI	M,0		;MODE = OUTPUT
                	DCX	H
                	PUSH	H		;SAVE COUNT ADDRESS
                	DCX	H
                	MVI	M,72		;COLUMN = 72
                	DCX	H
                	MVI	M,72		;DEFAULT WIDTH = 72
                	LXI	D,-161
                	DAD	D		;ADDRESS BUFFER BASE
                	XTHL			;SAVE
                	PUSH	H		;AND SAVE COUNT ADDRESS
                	CALL	CDKOP		;OPEN THE FILE
                OPNU1:	CALL	CDKRD		;READ A RECORD
                	MVI	A,0		;COUNT ZERO IN CASE EOF
                	JZ	OPNU4		;EOF
                	LXI	H,DMAAD		;DEFAULT DMA ADDRESS TO HL
                	MVI	A,CNTLZ		;EOF TO A
                OPNU2:	CMP	M		;CHECK IF NEXT CHAR IS EOF
                	JZ	OPNU3		;YUP
                	INR	L		;ELSE TRY NEXT
                	JNZ	OPNU2
                	JMP	OPNU1		;READING ANOTHER BUFFER IF NECESSARY
                OPNU3:	MOV	A,L
                	SUI	80H		;COMPUTE THE NEW COUNT
                OPNU4:	POP	H
                	MOV	M,A		;STORE THE NEW COUNT
                	POP	H
                	LXI	B,DMAAD
                	LXI	D,80H
                	CALL	MOVED		;COPY THE BUFFER TO FILE ENTRY BUFFER
                	LDA	FCBCR
                	DCR	A
                	STA	FCBCR		;UPDATE THE CR FIELD TO REWRITE THE SAME RECORD
                	JMP	OPEN6		;AND COPY THE FCB TO THE FILE ENTRY
                FOERR:	ERROR	F, F, O		;FATAL FO ERROR
                OPERR:	ERROR	F, O, P		;FATAL OP ERROR
                
                ;PRINT @<EXPR>, <PRINT LIST>
                DPRIN:	PUSH	PSW
                	MVI	D,','
                	CALL	GTD		;SKIP COMMA IF PRESENT
                	POP	PSW
                	JZ	PRIN0		;NORMAL PRINT IF @0
                	ORA	A
                	JNZ	FMERR		;FM ERROR IF FILE IS OPEN FOR INPUT
                	LXI	H,NULLS
                	MOV	A,M		;FETCH CURRENT NULLS VALUE
                	PUSH	PSW		;AND SAVE
                	MVI	M,0		;AND RESET TO 0 FOR DISK PRINT
                	LHLD	COLUM
                	PUSH	H		;SAVE CURRENT COLUMN AND WIDTH
                	MOV	H,B
                	MOV	L,C
                	SHLD	FILEP		;SET FILE POINTER SO PRINT GOES TO FILE
                	DCX	H
                	MOV	E,M		;COLUMN TO E
                	PUSH	H
                	DCX	H
                	MOV	D,M		;WIDTH TO D
                	XCHG
                	SHLD	COLUM		;SET FILE COLUMN AND WIDTH
                	CALL	PRIN0		;PRINT THE LINE
                	LDA	COLUM
                	POP	H
                	MOV	M,A		;RESET FILE COLUMN
                	POP	H
                	SHLD	COLUM		;RESTORE COLUMN AND WIDTH
                	POP	PSW		;RECOVER ORIGINAL NULLS VALUE
                	STA	NULLS		;AND RESTORE IT
                	LXI	H,0
                	SHLD	FILEP		;RESET FILE POINTER
                	RET
                
                ;SCRATCH [<AMBIGUOUS FILENAME>]
                	IF	NOT C3885
                SCRAT:	CALL	GTAFN		;GET AMBIGUOUS FILENAME
                	MVI	C,DKDLF
                	JMP	BDOSF		;DELETE IT
                	ENDIF
                
                
                ;FUNCTIONS
                
                ;EOF: <INTEGER> --> <INTEGER>
                EOFFN:	MOV	A,B
                	ORA	A
                	JNZ	BFERR		;ARG TOO LARGE, CANNOT BE FILE #
                	MOV	A,C
                	CALL	GTSF0		;FIND ARG VALUE
                	ORA	A
                	JZ	FMERR		;FM ERROR IF OPEN FOR OUTPUT
                	MOV	H,B
                	MOV	L,C
                EOFF0:	CALL	DREA0		;LOOK AT NEXT CHAR
                	LXI	B,-1
                	RZ			;EOF, RETURN -1
                	INX	B
                	RET			;NO EOF, RETURN 0
                
                
                ;ROUTINES
                
                ;DREAD READS A CHAR FROM A DISK FILE, ISSUES DK ERROR IF CHAR IS EOF.
                DREAD:	CALL	DREA0		;READ A CHAR
                	JZ	EFERR		;EF ERROR IF READ THROUGH EOF
                	INR	M		;ELSE READ THE CHAR
                	RET
                EFERR:	ERROR	F, E, F		;FATAL EF ERROR
                
                ;DREA0 LOOKS AT THE NEXT CHARACTER FROM A DISK FILE.
                ;CALL:	HL	POINTER TO COUNT OF FILE ENTRY
                ;RETN:	A	NEXT CHARACTER
                ;	BC,DE,HL	PRESERVED
                ;	ZERO	SET IFF EOF
                DREA0:	PUSH	H
                	PUSH	D
                	MOV	A,M		;FETCH COUNT
                	INR	A		;AND BUMP IT
                	JP	DREA1		;OK UNLESS 80H
                ;MUST READ A NEW BUFFER OF CHARACTERS AND RESET COUNT
                	MVI	M,255		;RESET COUNT OF LAST CHAR READ
                	PUSH	H
                	PUSH	B
                	LXI	D,-35
                	DAD	D
                	PUSH	H		;SAVE FCB ADDRESS
                	LXI	D,-128
                	DAD	D		;ADDRESS BUFFER
                	XCHG
                	CALL	STDMA		;SET DMA ADDRESS TO BUFFER
                	POP	D
                	MVI	C,DKRDF
                	IF	C3885 AND NOT DEBUG
                	CALL	BDOS1		;BDOS CALL WITH INTERRUPTS DISABLED
                	ELSE
                	CALL	BDOS
                	ENDIF
                	PUSH	PSW		;SAVE STATUS
                	CALL	RTDMA		;AND RESET THE DMA ADDRESS TO 80H
                	POP	PSW		;RESTORE STATUS
                	POP	B
                	POP	H
                	CPI	2
                	JZ	DKERR		;READ ERROR
                	CPI	1
                	MVI	A,CNTLZ
                	JZ	DREA2		;RETURN IF EOF
                	XRA	A		;RESET COUNT
                DREA1:	LXI	D,-163
                	DAD	D
                	CALL	ADAHL		;ADDRESS DESIRED CHAR
                	MOV	A,M		;FETCH IT
                DREA2:	CPI	CNTLZ		;ZERO SET IFF EOF
                	POP	D
                	POP	H
                	RET
                
                DWRIT:	CALL	DWRTC		;WRITE CHAR TO DISK FILE
                	JMP	POP4		;RESTORE AND RETURN
                DWRTC:	MOV	A,M		;FETCH COUNT
                	INR	M		;UPDATE COUNT
                	PUSH	PSW
                	XCHG			;COUNT POINTER TO DE
                	LXI	H,-163
                	DAD	D		;POINT TO BUFFER BASE
                	CALL	ADAHL		;ADD COUNT+BASE = DESTINATION
                	MOV	M,C		;CHAR TO DESTINATION
                	POP	PSW
                	RP			;RETURN UNLESS COUNT IS 80H
                	XRA	A
                	STAX	D		;STORE NEW COUNT = 0
                	INX	H		;POINT TO FCB
                	PUSH	H		;SAVE FCB ADDRESS
                	LXI	D,-128
                	DAD	D
                	XCHG
                	CALL	STDMA		;SET DMA ADDRESS TO BUFFER
                	POP	D		;RECOVER FCB ADDRESS
                	PUSH	D		;AND SAVE AGAIN
                	MVI	C,DKWTF
                	IF	C3885 AND NOT DEBUG
                	CALL	BDOS1		;BDOS CALL WITH INTERRUPTS DISABLED
                	ELSE
                	CALL	BDOS
                	ENDIF
                	PUSH	PSW
                	CALL	RTDMA		;RESET DMA ADDRESS
                	POP	PSW
                	POP	D		;FCB ADDRESS TO DE
                	ORA	A
                	RZ			;SUCCESSFUL WRITE, RETURN
                	LXI	H,37		;OTHERWISE DISK IS FULL
                	DAD	D
                	MVI	M,0		;RESET THE FILE # TO 0, NOW INACTIVE
                	MVI	C,DKDLF
                	IF	C3885 AND NOT DEBUG
                	CALL	BDOS1		;BDOS CALL WITH INTERRUPTS DISABLED
                	ELSE
                	CALL	BDOS
                	ENDIF
                	ERROR	F, D, F		;FATAL DF ERROR
                
                	ENDIF			;END OF NOT RTPAK CONDITIONAL
                
                ;@ <EXPR>
                ;GTATN GETS @ FOLLOWED BY A NUMBER FOR SEQUENTIAL DISK ROUTINES.
                ;A FATAL DK ERROR OCCURS IF THE <EXPR> IS NOT IN THE RANGE 0 TO 255.
                ;RETN:	CARRY	SET IFF NO @ FOUND
                ;	ZERO	SET IFF <EXPR> IS 0
                ;	A	VALUE OF <EXPR>
                GTATN:	MVI	D,'@'
                	CALL	GTD		;LOOK FOR @
                	RC			;NOT FOUND
                	CALL	GTEXP		;EVALUATE THE <EXPR>
                	MOV	A,B
                	ORA	A
                	JNZ	BFERR		;FATAL BF ERROR IF NOT BETWEEN 0 AND 255
                	ORA	C		;VALUE TO A
                	RET
                BFERR:	ERROR	F, B, F		;FATAL BF ERROR
                
                ;GTSFN FINDS AN OPEN SEQUENTIAL DISK FILE.  A DK ERROR OCCURS
                ;IF A NONZERO FILE # IS GIVEN BUT NO CORRESPONDING OPEN FILE EXISTS.
                ;RETN:	CARRY	SET IFF NO @ FOUND
                ;	ZERO	SET IFF FILE @0 IS SPECIFIED
                ;	A	MODE OF FILE (0 OUTPUT, NONZERO INPUT)
                ;	BC	POINTER TO COUNT FIELD OF FILE ENTRY
                ;	HL	POINTER TO BYTE PRECEDING FILE BUFFER
                GTSFN:	CALL	GTATN		;LOOK FOR @<EXPR>
                	RC			;NO @
                	RZ			;@ 0
                	IF	RTPAK
                	JMP	UFERR		;ISSUE UF ERROR IF NONZERO FILE # IN RTPAK
                	ELSE			;NOT RTPAK
                GTSF0:	CALL	SFILS		;SET UP REGISTERS FOR SEARCH -- EOF ENTRY POINT
                GTSF1:	DCR	B
                	JZ	BFERR		;NOT FOUND, BF ERROR
                	CMP	M		;COMPARE DESIRED TO ACTUAL
                	JZ	GTSF2		;GOTCHA
                	DAD	D		;ELSE TRY NEXT
                	JMP	GTSF1
                GTSF2:	MOV	B,H
                	MOV	C,L		;FILE POINTER TO BC
                	DAD	D		;HL POINTS BELOW BUFFER
                	ORI	1		;CARRY AND ZERO RESET
                	DCX	B
                	LDAX	B		;FETCH MODE
                	DCX	B		;POINT TO COUNT WITH BC
                	RET
                
                SFILS:	LXI	H,FILES
                	MOV	B,M		;MAX # FILES TO B
                	LHLD	FILET
                	LXI	D,-FILEN
                	RET
                
                	ENDIF			;END OF NOT RTPAK CONDITIONAL
                	ENDIF			;END OF SDISK CONDITIONAL
                
                ;END OF SDISK
                	PAGE
                
                ;STACKS 5/23/79
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979 BY MARK WILLIAMS COMPANY, CHICAGO
                ;SYMBOL TABLE AND CONTROL STACK MANIPULATION ROUTINES
                
                
                ;FNDTK FINDS THE LOCATION OF A TOKEN IN THE KEYWORD TABLE.
                ;CALL:	A	CHARACTER OR TOKEN
                ;RETN:	CARRY	RESET IF CHARACTER, SET IF TOKEN
                ;	A	PRESERVED IF CHARACTER, 0 IF TOKEN
                ;	BC,DE	PRESERVED
                ;	HL	PRESERVED IF CHARACTER, ADDRESS OF TABLE ENTRY IF TOKEN
                	IF	NOT COMPL
 1A8C B7        FNDTK:	ORA	A
                	IF	KEY80
 1A8D FA9F1A    	JM	FNDT1		;COMMAND OR FUNCTION TOKEN
 1A90 FE20      	CPI	20H
 1A92 D0        	RNC			;PRINTABLE CHAR, RETURN CARRY RESET
 1A93 FE0E      	CPI	RWDTK
 1A95 3F        	CMC
 1A96 D0        	RNC			;<CR> OR <BELL>, RETURN CARRY RESET
 1A97 21B42D    	LXI	H,RWDTA		;ELESE RESERVED WORD TOKEN
 1A9A D60D      	SUI	(RWDTK-1) AND 0FFH	;TOKEN BIAS
 1A9C C3A41A    	JMP	FNDT2
                	ELSE			;NOT KEY80
                	RP			;RETURN CARRY RESET IF POSITIVE
                	ENDIF
 1A9F 21172C    FNDT1:	LXI	H,KEYTA
 1AA2 C672      	ADI	NKEYS+1		;TOKEN BIAS
 1AA4 3D        FNDT2:	DCR	A		;DECEMENT TOKEN COUNT
 1AA5 C2AA1A    	JNZ	FNDT3		;NOT THERE YET
 1AA8 37        	STC			;ELSE SET CARRY
 1AA9 C9        	RET			;AND RETURN
 1AAA F5        FNDT3:	PUSH	PSW		;SAVE TOKEN COUNT
 1AAB 7E        FNDT4:	MOV	A,M		;FETCH CHAR
 1AAC 23        	INX	H
 1AAD B7        	ORA	A
 1AAE F2AB1A    	JP	FNDT4		;SKIP MORE CHARS IN SAME KEYWORD
 1AB1 F1        	POP	PSW		;RESTORE TOKEN COUNT
 1AB2 C3A41A    	JMP	FNDT2		;AND KEEP LOOKING
                	ENDIF
                
                ;STPSH BUILDS A NEW SYMBOL TABLE ENTRY.
                ;CALL:	A	TOKEN
                ;	HL	ENTRY LENGTH
                ;	(BUFAD)	SYMBOL NAME
                ;RETN:	(SYMTA)	(SYMTA) - LENGTH
                ;	((SYMTA))	LENGTH
                ;	((SYMTA)+1)	TOKEN
                ;	((SYMTA)+2...)	NAME
                ;OTHER BYTES IN THE ENTRY ARE ZEROED
                ;	A	TOKEN
                ;	BC	PRESERVED
                ;	DE	ADDRESS OF NAME
                ;	HL	ADDRESS FOLLOWING NAME
 1AB5 C5        STPSH:	PUSH	B
 1AB6 F5        	PUSH	PSW		;SAVE TOKEN
 1AB7 EB        	XCHG			;LENGTH TO DE
 1AB8 3EFE      	MVI	A,254
 1ABA BB        	CMP	E		;CARRY SET IFF (E) IS 255
 1ABB 9F        	SBB	A		;A IS 255 IF (E) IS 255, 0 OTHERWISE
 1ABC B2        	ORA	D		;ZERO SET IFF (DE) <= 254
 1ABD CAC21A    	JZ	STPS1
 1AC0 13        	INX	D
 1AC1 13        	INX	D
 1AC2 D5        STPS1:	PUSH	D		;SAVE LENGTH
 1AC3 CD6502    	CALL	CPLDE		;- LENGTH TO DE
 1AC6 2AC641    	LHLD	SYMTA
 1AC9 19        	DAD	D		;OLD - LENGTH = NEW SYMBOL TABLE ADDRESS
 1ACA D2011B    	JNC	OMERR		;MUCH TOO BIG, OM ERROR
 1ACD EB        	XCHG
 1ACE 2AC241    	LHLD	CSTKP
 1AD1 EB        	XCHG			;CSTKP TO DE
 1AD2 CD8602    	CALL	CMDHU		;COMPARE TO NEW SYMTA
 1AD5 D2011B    	JNC	OMERR		;CSTKP >= NEW SYMTA, OM ERROR
 1AD8 22C641    	SHLD	SYMTA		;STORE NEW SYMTA
 1ADB D1        	POP	D		;RESTORE LENGTH
 1ADC D5        	PUSH	D		;AND SAVE
 1ADD E5        	PUSH	H		;AND SAVE SYMTA
 1ADE 3600      STPS2:	MVI	M,0		;ZERO A BYTE
 1AE0 23        	INX	H
 1AE1 1B        	DCX	D
 1AE2 7A        	MOV	A,D
 1AE3 B3        	ORA	E
 1AE4 C2DE1A    	JNZ	STPS2		;ZERO MORE BYTES
 1AE7 E1        	POP	H		;RESTORE POINTER
 1AE8 D1        	POP	D		;AND LENGTH
 1AE9 7A        	MOV	A,D
 1AEA B7        	ORA	A
 1AEB CAF31A    	JZ	STPS3
 1AEE 36FF      	MVI	M,255		;LONG ENTRY
 1AF0 23        	INX	H
 1AF1 72        	MOV	M,D
 1AF2 23        	INX	H
 1AF3 73        STPS3:	MOV	M,E		;STORE LENGTH
 1AF4 23        	INX	H
 1AF5 F1        	POP	PSW		;RECOVER TOKEN
 1AF6 F5        	PUSH	PSW
 1AF7 77        	MOV	M,A		;STORE TOKEN
 1AF8 23        	INX	H
 1AF9 E5        	PUSH	H		;SAVE NAME POINTER
 1AFA CD801A    	CALL	CPYS0		;COPY NAME FROM BUFAD
 1AFD D1        	POP	D		;RETURN NAME POINTER IN DE
 1AFE F1        	POP	PSW		;RESTORE TOKEN TO A
 1AFF C1        	POP	B
 1B00 C9        	RET
                OMERR:	ERROR	F, O, M		;FATAL OM ERROR
 1B01+CDC616    	CALL	ERROF
 1B04+4FCD      	DB	'O', 'M' OR 80H
                
                ;STNXT GETS THE ADDRESS OF THE NEXT SYMBOL TABLE ENTRY.
                ;CALL:	HL	ADDRESS OF CURRENT SYMBOL TABLE ENTRY LENGTH BYTE
                ;RETN:	CARRY	SET IFF NO MORE ENTRIES
                ;	BC	PRESERVED
                ;	DE	CURRENT ENTRY TYPE BYTE ADDRESS
                ;	HL	NEXT ENTRY ADDRESS
 1B06 7E        STNXT:	MOV	A,M		;FETCH LENGTH BYTE
 1B07 B7        	ORA	A
 1B08 37        	STC
 1B09 C8        	RZ			;RETURN CARRY SET IF AT END OF TABLE
 1B0A 54        	MOV	D,H
 1B0B 5D        	MOV	E,L
 1B0C 13        	INX	D		;POINT TO TYPE BYTE
 1B0D FEFF      	CPI	255		;CHECK IF LONG ENTRY
 1B0F C27202    	JNZ	ADAHL		;NO, SO LENGTH + CURRENT = NEXT AND RETURN
 1B12 EB        	XCHG			;CURRENT TO DE, LENGTH BYTE ADDR TO HL
 1B13 7E        	MOV	A,M
 1B14 23        	INX	H
 1B15 E5        	PUSH	H		;SAVE TYPE BYTE ADDR - 1
 1B16 6E        	MOV	L,M
 1B17 67        	MOV	H,A		;LENGTH TO HL
 1B18 19        	DAD	D		;CURRENT + LENGTH = NEXT
 1B19 D1        	POP	D		;TYPE BYTE ADDR TO DE
 1B1A 13        	INX	D
 1B1B C9        	RET
                
                ;STLKU LOOKS UP A SYMBOL IN THE SYMBOL TABLE.
                ;CALL:	(BUFAD)	SYMBOL NAME STRING
                ;	(VARTY)	SYMBOL TYPE TOKEN
                ;RETN:	CARRY	SET IFF NOT FOUND, OTHERWISE:
                ;	DE	ENTRY TYPE ADDRESS
                ;	HL	ADDRESS FOLLOWING NAME IN ENTRY
 1B1C 3A9E41    STLKU:	LDA	VARTY
 1B1F 2AC641    STLK0:	LHLD	SYMTA
 1B22 47        	MOV	B,A		;DESIRED TYPE TO B
 1B23 CD061B    STLK1:	CALL	STNXT		;ADDRESS NEXT ENTRY
 1B26 D8        	RC			;RETURN CARRY SET IFF NOT FOUND
 1B27 1A        	LDAX	D		;FETCH ENTRY TYPE
 1B28 E61F      	ANI	1FH		;MASK TO TYPE
 1B2A B8        	CMP	B
 1B2B C2231B    	JNZ	STLK1		;NOT THE RIGHT TYPE, TRY NEXT
 1B2E E5        	PUSH	H		;SAVE NEXT
 1B2F D5        	PUSH	D		;SAVE TYPE BYTE ADDR
 1B30 EB        	XCHG
 1B31 23        	INX	H		;POINT TO NAME
 1B32 11C841    	LXI	D,BUFAD
 1B35 CD751A    	CALL	CMPST		;COMPARE TO DESIRED NAME
 1B38 D1        	POP	D		;RESTORE TYPE ADDR TO DE
 1B39 CAA308    	JZ	POP1		;MATCHED, POP NEXT TO BC AND RETN CARRY RESET
 1B3C E1        	POP	H		;ELSE NEXT TO HL
 1B3D C3231B    	JMP	STLK1		;AND TRY NEXT
                
                ;STZAP RESETS BREAK AND FN ENTRIES IN THE SYMBOL TABLE.
                ;RETN:	BC	PRESERVED
                ;	A,DE,HL	CLOBBERED
 1B40 2AC641    STZAP:	LHLD	SYMTA
 1B43 CD061B    STZA1:	CALL	STNXT
                	IF	COMPL
                	RC			;END OF TABLE, DONE IF NO LINE BREAKS TO ZAP
                	ELSE
 1B46 DA5B1B    	JC	UNBKL		;UNBREAK LINES IF NOT COMPL
                	ENDIF
 1B49 1A        	LDAX	D
 1B4A E61F      	ANI	1FH		;MASK TO TYPE
                	IF	NOT COMPL
 1B4C FE05      	CPI	BRKST
 1B4E CA561B    	JZ	STZA2		;BREAK
                	ENDIF
 1B51 FE04      	CPI	UFNST		;CHECK IF USER-DEFINED FN
 1B53 C2431B    	JNZ	STZA1		;NEITHER FN NOR BREAK, TRY NEXT
 1B56 AF        STZA2:	XRA	A
 1B57 12        	STAX	D		;STORE 0 TYPE BYTE
 1B58 C3431B    	JMP	STZA1
                
                	IF	NOT COMPL
                ;UNBKL REMOVES ALL LINE BREAKPOINTS.
                UNBKL:	IF	ROMSQ		;FIRST LOC TO TEST TO HL
                	LHLD	SOURC
                	CALL	RTEST
                	RNZ			;DONE IF ROM
                	ELSE
 1B5B 218B42    	LXI	H,SRCAD
                	ENDIF
 1B5E 7E        UNBL1:	MOV	A,M
 1B5F B7        	ORA	A
 1B60 C8        	RZ			;DONE
 1B61 E5        	PUSH	H
 1B62 CD9726    	CALL	UNBR1		;UNBREAK A LINE
 1B65 E1        	POP	H
 1B66 CD7202    	CALL	ADAHL		;POINT TO NEXT LINE
 1B69 C35E1B    	JMP	UNBL1		;AND KEEP GOING
                	ENDIF
                
                ;CPUSH CHECKS THAT SUFFICIENT FREE MEMORY REMAINS TO BUILD A CONTROL STACK
                ;ENTRY AND IF NOT ISSUES AN OM ERROR.  OTHERWISE IT PUSHES A TOKEN, (TEXTP) AND
                ;(LNNUM) TO THE CONTROL STACK, AND UPDATES THE STACK POINTER.
                ;CALL:	A	TOKEN (L.S. 5 BITS GIVE ENTRY LENGTH)
                ;RETN:	A,BC	CLOBBERED
                ;	DE	RETURN TEXT POINTER
                ;	HL	(CSTKP) - 4
                ;	(CSTKP)	(CSTKP) + (A4-A0)
                ;	((CSTKP))	TOKEN
                ;	((CSTKP)-1:(CSTKP)-2)	LINE # ADDRESS
                ;	((CSTKP)-3:(CSTKP)-4)	RETURN TEXT POINTER
 1B6C 2A8242    CPUSH:	LHLD	TEXTP
 1B6F E5        	PUSH	H
 1B70 47        CPSH1:	MOV	B,A		;SAVE TOKEN
 1B71 2AC241    	LHLD	CSTKP
 1B74 E61F      CPSH2:	ANI	1FH		;MASK TO LENGTH
 1B76 CD7202    	CALL	ADAHL
 1B79 DA9A1B    	JC	CPSH3		;NEW STACKTOP > 64K, OM ERROR
 1B7C CD4622    	CALL	CSPST		;STORE NEW CONTROL STACK POINTER
 1B7F EB        	XCHG			;CSTACK POINTER TO DE
 1B80 2AC641    	LHLD	SYMTA		;SYMBOL TABLE POINTER TO HL
 1B83 CD8602    	CALL	CMDHU		;COMPARE
 1B86 D29A1B    	JNC	CPSH3		;OM -- FLUSH AND CONTINUE
 1B89 2A4B40    	LHLD	LNNUM
                	IF	NOT COMPL
 1B8C 7C        	MOV	A,H
 1B8D B5        	ORA	L
 1B8E CCFA1B    	CZ	ICSTD		;INCREMENT CSTACK DIRECT COUNT IF DIRECT
                	ENDIF
 1B91 EB        	XCHG			;CURRENT LINE # ADDRESS TO DE
 1B92 70        	MOV	M,B		;TOKEN TO CONTROL STACK
 1B93 CD5002    	CALL	MVMDE		;RETURN LINE # ADDRESS TO CONTROL STACK
 1B96 D1        	POP	D
 1B97 C35002    	JMP	MVMDE		;RETURN TEXT POINTER TO CONTROL STACK & RETURN
 1B9A CD811D    CPSH3:	CALL	CLEA2		;RESET CSTACK POINTER
                	ERROR	N, O, M		;NONFATAL OM ERROR
 1B9D+CDD216    	CALL	ERRON
 1BA0+4FCD      	DB	'O', 'M' OR 80H
 1BA2 78        	MOV	A,B		;RESTORE TOKEN
 1BA3 C3741B    	JMP	CPSH2		;TRY AGAIN
                
                ;CSPOP IS USED TO POP INFORMATION FROM THE CONTROL STACK FOR RETURNS FROM
                ;GOSUBS AND INTERRUPTS, FOR CONTINUES, AND FOR NEXTS.
                ;IF THE ENTRY WAS MADE FROM DIRECT MODE, THE DMODE COUNT CSTKD IS
                ;DECREMENTED AND AN ID ERROR ISSUED IF < 0.
                ;CALL:	HL	ADDRESS OF CONTROL STACK ENTRY TYPE/LENGTH BYTE
                ;RETN:	(LNNUM)	CONTROL STACK ENTRY LINE # BYTES
                ;	(TEXTP)	CONTROL STACK ENTRY RETURN ADDRESS
                ;	PSW,BC	PRESERVED
                ;	DE	NEW TEXTP
                ;	HL	(HL) - 5
                CSPOP:	IF	COMPL
                	DCX	H
                	CALL	MVDEM		;LINE # TO DE
                	ELSE			;NON COMPL VERSION MUST UPDATE CSTKD
 1BA6 F5        	PUSH	PSW
 1BA7 E5        	PUSH	H		;SAVE TYPE BYTE ADDR
 1BA8 2B        	DCX	H
 1BA9 CD4B02    	CALL	MVDEM		;LINE # OF ENTRY TO DE
 1BAC E3        	XTHL			;SAVE ENTRY POINTER, TYPE BYTE ADDR TO HL
                	IF	NOT COMPL
 1BAD 7A        	MOV	A,D
 1BAE B3        	ORA	E		;TEST IF DIRECT MODE ENTRY
 1BAF C2BB1B    	JNZ	CSPO1		;NO -- RESTORE AND RETURN
 1BB2 CD011C    	CALL	DCSTD		;YES -- DECREMENT CSTACK DIRECT COUNT
 1BB5 7E        	MOV	A,M		;FETCH TYPE BYTE
 1BB6 FE4F      	CPI	CSFOR		;CHECK IF DOING A NEXT
 1BB8 CCFA1B    	CZ	ICSTD		;UNDECREMENT COUNT IF SO
                	ENDIF
 1BBB E1        CSPO1:	POP	H		;RESTORE ENTRY PTR
 1BBC F1        	POP	PSW
                	ENDIF
 1BBD EB        	XCHG
 1BBE 224B40    	SHLD	LNNUM		;STORE NEW LNNUM
 1BC1 EB        	XCHG
 1BC2 CD4B02    	CALL	MVDEM
 1BC5 EB        	XCHG
 1BC6 228242    	SHLD	TEXTP		;STORE NEW TEXTP
 1BC9 EB        	XCHG
 1BCA C9        	RET			;AND CONTINUE FROM THERE
                
                ;CSDIG DIGS IN THE CONTROL STACK FOR AN ENTRY WITH TYPE MATCHING B OR C.
                ;CALL:	B,C	DESIRED TYPE/LENGTH BYTES
                ;RETN:	A	TYPE/LENGTH BYTE FOUND, 0 IF NONE
                ;	BC,DE	PRESERVED
                ;	HL	ADDR OF TYPE/LENGTH BYTE, EOFAD IF NOT FOUND
                ;	CARRY	SET IFF NOT FOUND
 1BCB 2AC241    CSDIG:	LHLD	CSTKP
 1BCE 7E        CSDI1:	MOV	A,M		;FETCH TYPE/LENGTH BYTE
 1BCF B8        	CMP	B
 1BD0 C8        	RZ			;FOUND
 1BD1 B9        	CMP	C
 1BD2 C8        	RZ			;FOUND
 1BD3 E61F      	ANI	1FH		;MASK TO LENGTH
 1BD5 37        	STC
 1BD6 C8        	RZ			;NOT FOUND
 1BD7 CD7902    	CALL	SBAHL		;ADDRESS NEXT
 1BDA C3CE1B    	JMP	CSDI1		;AND TRY IT
                
                ;CSRST RESETS THE CONTROL STACK AFTER PURGING AN ENTRY.
                ;CALL:	A	TYPE/LENGTH BYTE OF ENTRY TO BE PURGED
                ;	HL	ADDRESS OF NEXT ENTRY IN STACK
                ;RETN:	BC	PRESERVED
                ;	HL	NEW CSTKP
 1BDD C5        CSRST:	PUSH	B
 1BDE 23        	INX	H		;POINT TO DESTINATION
 1BDF E5        	PUSH	H		;AND SAVE IT
 1BE0 E61F      	ANI	1FH		;MASK A TO LENGTH
 1BE2 CD7202    	CALL	ADAHL		;DESTINATION + OFFSET = SOURCE
 1BE5 E5        	PUSH	H		;SAVED
 1BE6 EB        	XCHG
 1BE7 CD6502    	CALL	CPLDE
 1BEA 2AC241    	LHLD	CSTKP
 1BED 19        	DAD	D		;# OF BYTES TO MOVE -1 TO HL
 1BEE 23        	INX	H
 1BEF EB        	XCHG			;AND THEN TO DE
 1BF0 C1        	POP	B		;SOURCE TO BC
 1BF1 E1        	POP	H		;DESTINATION TO HL
 1BF2 DCB631    	CC	MOVED		;MOVE REST  OF STACK
 1BF5 C1        	POP	B		;RESTORE BC
 1BF6 2B        	DCX	H		;READDRESS CSTKP
 1BF7 C34622    	JMP	CSPST		;AND RESET IT
                
                ;ICSTD INCREMENTS THE CSTACK DIRECT COUNT CSTKD.  DCSTD DECREMENTS CSTKD AND
                ;ISSUES AN ID ERROR IF NEGATIVE.  CSTKD COUNTS HOW MANY CSTACK ENTRIES
                ;HAVE BEEN BUILT FROM DIRECT MODE, AND CATCHES ERRORS SUCH AS ATTEMPTING TO
                ;RETURN OR NEXT WHEN THE GOSUB OR FOR CONTEXT HAS BEEN LOST.
                ;STATUS BITS AFFECTED, ALL REGISTERS PRESERVED.
                	IF	NOT COMPL
 1BFA E5        ICSTD:	PUSH	H
 1BFB 218042    	LXI	H,CSTKD
 1BFE 34        	INR	M		;INCREMENT CSTACK DIRECT COUNT
 1BFF E1        	POP	H
 1C00 C9        	RET
 1C01 E5        DCSTD:	PUSH	H
 1C02 218042    	LXI	H,CSTKD
 1C05 35        	DCR	M		;DECREMENT CSTACK DIRECT COUNT
 1C06 E1        	POP	H
 1C07 F0        	RP			;OK IF NONNEGATIVE
 1C08 C37601    	JMP	IDERR		;FATAL ID ERROR IF NEGATIVE
                	ENDIF
                
                
                ;END OF STACKS
                	PAGE
                
                ;STATES1 12/02/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;STATEMENT ROUTINES FOR STATEMENTS ASSIGN THROUGH EXEC
                
                
                ;ASSIGN {LST# | PUN# | RDR# | CON#} <EXPR>
                	IF	(NOT CAMAC) AND (NOT WILD)
                ;ASSIGN CHANGES THE VALUE OF THE SPECIFIED FIELD OF IOBYTE.
 1C0B CD3B17    ASSIG:	CALL	GTCHA		;FETCH TOKEN
 1C0E D613      	SUI	CONTK		;SUBTRACT CON# TOKEN BIAS
 1C10 DA9201    	JC	SNERR		;TOO SMALL
 1C13 FE04      	CPI	4
 1C15 D29201    	JNC	SNERR		;TOO BIG
 1C18 07        	RLC			;*2 BITS  = SHIFT COUNT (0, 2, 4, 6)
 1C19 5F        	MOV	E,A		;SHIFT COUNT TO E
 1C1A CD9D0B    	CALL	GTEXP		;ARG TO BC
 1C1D 79        	MOV	A,C
 1C1E E6FC      	ANI	0FCH
 1C20 B0        	ORA	B		;CHECK IF ARG > 3
 1C21 C49A12    	CNZ	FCERN		;YES, NONFATAL FC ERROR
 1C24 3E03      	MVI	A,3
 1C26 47        	MOV	B,A		;MASK TO B
 1C27 A1        	ANA	C
 1C28 4F        	MOV	C,A		;MASKED NEW BITS TO C1-0
                	IF	NONST
 1C29 7B        	MOV	A,E
 1C2A B7        	ORA	A		;CHECK IF CON#
 1C2B C23A1C    	JNZ	ASSI1		;NO, JUST UPDATE IOBYTE
 1C2E 47        	MOV	B,A		;0 TO B
 1C2F 215401    	LXI	H,JMPTA+60	;BASE OF CONSOLE STATUS JUMP VECTOR TO HL
 1C32 09        	DAD	B
 1C33 09        	DAD	B
 1C34 09        	DAD	B		;+3 BYTES * DESIRED CON#
 1C35 220240    	SHLD	CSTAT+1		;BECOMES NEW CONSOLE STATUS JUMP
 1C38 0603      	MVI	B,3		;RESTORE MASK TO B
                	ENDIF
 1C3A CDCA14    ASSI1:	CALL	LSHFT		;SHIFT MASK AND BITS TO DESIRED POSITION
 1C3D 78        	MOV	A,B
 1C3E 2F        	CMA
 1C3F 210040    	LXI	H,IOBYT
 1C42 A6        	ANA	M		;MASK OUT OLD FIELD
 1C43 B1        	ORA	C		;OR IN THE NEW FIELD
 1C44 77        	MOV	M,A		;STORE THE NEW IOBYTE
 1C45 C9        	RET
                	ENDIF
                
                ;AUTO [<LINE #> [, <LINE #>]]
                	IF	EDITC
                	IF	COMPL
                AUTO	EQU	UFERR
                	ELSE
                AUTO:	IF	ROMSQ
                	CALL	ISSRC		;MUST BE ADDRESSING WORKING SPACE
                	ENDIF
 1C46 210A00    	LXI	H,10
 1C49 E5        	PUSH	H		;DEFAULT INCREMENT = 10
 1C4A E5        	PUSH	H		;DEFAULT FIRST LINE # = 10
 1C4B CD2E18    	CALL	GTLNO		;LOOK FOR <LINE #>
 1C4E DA631C    	JC	AUTO1		;NO ARGS, TAKE DEFAULTS
 1C51 EB        	XCHG			;<LINE #> TO HL
 1C52 E3        	XTHL			;AND REPLACES DEFAULT <LINE #>
 1C53 CD6617    	CALL	GTCND		;LOOK FOR COMMA
 1C56 DA631C    	JC	AUTO1		;NO SECOND ARG
 1C59 CD2E18    	CALL	GTLNO		;LOOK FOR INCREMENT ARG
 1C5C DA9201    	JC	SNERR		;NOT FOUND
 1C5F EB        	XCHG			;INCREMENT TO HL
 1C60 D1        	POP	D
 1C61 E3        	XTHL			;AND REPLACES DEFAULT INCRMENT
 1C62 D5        	PUSH	D
 1C63 CD7B01    AUTO1:	CALL	IITST		;AUTO ILLEGAL INDIRECT
                ;AT AUTO2 THE NEXT DESIRED LINE # AND THE INCREMENT ARE ON THE STACK.
 1C66 C1        AUTO2:	POP	B		;NEXT LINE # TO BC
 1C67 C5        	PUSH	B
 1C68 CDFB15    	CALL	WRTBU		;WRITE THE LINE #
 1C6B 50        	MOV	D,B
 1C6C 59        	MOV	E,C		;LINE # TO DE
 1C6D CDC131    	CALL	FINDL		;LOOK FOR IT IN CURRENT SOURCE TEXT
 1C70 3E20      	MVI	A,' '
 1C72 DA771C    	JC	AUTO3		;WRITE A SPACE IF NO SUCH LINE EXISTS
 1C75 3E2A      	MVI	A,'*'		;ELSE WRITE A *
 1C77 CD2D15    AUTO3:	CALL	WRITC
 1C7A CDAB31    	CALL	LNNU0		;RESET LNNUM TO 0 IN CASE ^C TYPED
 1C7D CD342E    	CALL	GTLIN		;GET LINE FROM USER
 1C80 CD2730    	CALL	TKIZE		;TOKENIZE IT
 1C83 CA4B06    	JZ	DMOD2		;RETURN TO DMODE IF USER TYPES <CR>
 1C86 D4AB31    	CNC	LNNU0
 1C89 D29201    	JNC	SNERR		;SN ERROR IF <LINE #> TYPED
 1C8C E1        	POP	H
 1C8D E5        	PUSH	H
 1C8E 224B40    	SHLD	LNNUM		;SET LNNUM TO DESIRED LINE
 1C91 CD2431    	CALL	ADDLN		;ADD NEW LINE TO SOURCE TEXT
 1C94 E1        	POP	H
 1C95 D1        	POP	D
 1C96 19        	DAD	D		;NEW LINE # IS LINE # + INCREMENT
 1C97 DA9F1C    	JC	AUTO4		;OV ERROR IF > 65535
 1C9A D5        	PUSH	D
 1C9B E5        	PUSH	H
 1C9C C3661C    	JMP	AUTO2		;ELSE GET NEXT LINE
 1C9F CDAB31    AUTO4:	CALL	LNNU0
 1CA2 3E0D      	MVI	A,CR
 1CA4 322C42    	STA	NLNAD		;RESET INPUT BUFFER FOR ERROR MESSAGE
 1CA7 CDCC18    	CALL	IOVER		;ISSUE OV ERROR
 1CAA C34B06    	JMP	DMOD2		;AND RETURN TO DIRECT MODE
                	ENDIF
                	ELSE
                AUTO	EQU	EXERR		;EX ERROR IN NON-EDITC VERSIONS
                	ENDIF
                
                ;BREAK {<VAR LIST> | <LINE #> [,<EXPR>] [;<VAR LIST>] [;$]}
                ;BREAK <VAR LIST> CREATES VARIABLE BREAKS BY SETTING SYMBOL TABLE ENTRY BITS.
                ;BREAK <LINE #>... CREATES LINE BREAKPOINTS BY SETTING THE LINE BREAK BYTE,
                ;AND ALSO BUILDING A SYMBOL TABLE LINE BREAK ENTRY IF NECESSARY.
                	IF	COMPL
                BREAK	EQU	UFERR		;UF ERROR IN COMPL VERSION
                	ELSE
 1CAD CD2E18    BREAK:	CALL	GTLNO		;LOOK FOR LINE #
 1CB0 DA241D    	JC	BKVAR		;NO LINE #, MUST BE VAR BREAK
                	IF	ROMSQ
                	CALL	ISROM		;LINE BREAKS ONLY IF RUNNING IN RAM
                	ENDIF
 1CB3 CDE331    	CALL	FDLNO		;FIND THE LINE
 1CB6 23        	INX	H
 1CB7 23        	INX	H
 1CB8 23        	INX	H		;ADDRESS BREAK BYTE
 1CB9 E5        	PUSH	H		;SAVE BREAK BYTE ADDR
 1CBA CD5D17    	CALL	GTCOM		;LOOK FOR COMMA
 1CBD 010100    	LXI	B,1		;DEFAULT COUNT = 1 TO BC
 1CC0 D49D0B    	CNC	GTEXP		;GET COUNT IF COMMA
 1CC3 C5        	PUSH	B		;SAVE COUNT
 1CC4 0B        	DCX	B
 1CC5 78        	MOV	A,B
 1CC6 B1        	ORA	C		;ZERO SET IFF COUNT = 1
 1CC7 3E01      	MVI	A,1		;BREAK BYTE VALUE TO A
 1CC9 CACE1C    	JZ	BRKL1
 1CCC F602      	ORI	2		;BIT 1 ON IFF COUNT <> 1
                ;AT BRKL1 THE BREAK BYTE ADDR AND COUNT ARE PUSHED, THE BREAK BYTE IS IN A.
 1CCE 5F        BRKL1:	MOV	E,A		;SAVE THE BREAK BYTE
 1CCF 163B      	MVI	D,SEMIC
 1CD1 CD6F17    	CALL	GTD		;LOOK FOR ;
 1CD4 22BB41    	SHLD	TXTP2		;SAVE VARLIST ADDRESS
 1CD7 C2FE1C    	JNZ	BRKL4		;NO ; PRESENT
 1CDA D5        BRKL2:	PUSH	D
 1CDB CD8419    	CALL	GTVAR		;LOOK FOR VAR REF
 1CDE D1        	POP	D
 1CDF DAF51C    	JC	BRKL3		;NONE, MUST BE $
 1CE2 CD7201    	CALL	IDTST		;BREAK ILLEGAL DIRECT IF <VAR LIST> PRESENT
 1CE5 7B        	MOV	A,E
 1CE6 F606      	ORI	6		;SET VARLIST BITS IN BREAK BYTE
 1CE8 5F        	MOV	E,A
 1CE9 CD5D17    	CALL	GTCOM		;LOOK FOR COMMA
 1CEC D2DA1C    	JNC	BRKL2		;MORE VARS
 1CEF CD6F17    	CALL	GTD		;LOOK FOR ;
 1CF2 C2FE1C    	JNZ	BRKL4
 1CF5 1624      BRKL3:	MVI	D,'$'
 1CF7 CD8717    	CALL	GTDSN		;SKIP $
 1CFA 7B        	MOV	A,E
 1CFB F608      	ORI	8		;SET BIT 3 TO INDICATE BREAK TO DMODE
 1CFD 5F        	MOV	E,A
 1CFE 7B        BRKL4:	MOV	A,E		;BREAK BYTE VALUE TO A
 1CFF C1        	POP	B		;COUNT TO BC
 1D00 E1        	POP	H		;RESTORE BREAK BYTE ADDR
 1D01 77        	MOV	M,A		;STORE BREAK BYTE
 1D02 E606      	ANI	6		;CHECK IF MUST BUILD SYMBOL TABLE ENTRY
 1D04 C8        	RZ			;NO, DONE
                ;NOW A SYMBOL TABLE LINE BREAK ENTRY IS BUILT.  THE ENTRY CONTAINS
                ;A LENGTH BYTE, TYPE BYTE, THREE 'NAME' BYTES WITH THE ENCODED LINE #,
                ;TWO COUNT BYTES (HOW MANY PASSES UNTIL NEXT BREAK), TWO RESET BYTES (THE
                ;VALUE FOR RESETTING COUNT WHEN IT REACHES ZERO), AND TWO VARLIST ADDR BYTES.
 1D05 C5        	PUSH	B		;SAVE COUNT
 1D06 2B        	DCX	H
 1D07 2B        	DCX	H		;HL CONTAINS LINE # ADDR
 1D08 CD6B04    	CALL	BKNAM		;FORM BREAK ENTRY NAME IN BUFAD
 1D0B 210B00    	LXI	H,11		;ENTRY LENGTH = 11
 1D0E 3E05      	MVI	A,BRKST		;TOKEN TO A
 1D10 CDB51A    	CALL	STPSH		;BUILD THE ENTRY
 1D13 D1        	POP	D		;COUNT TO DE
 1D14 73        	MOV	M,E
 1D15 23        	INX	H
 1D16 72        	MOV	M,D		;COUNT TO ENTRY
 1D17 CD1F1D    	CALL	MOMDE		;RESET TO ENTRY
 1D1A EB        	XCHG
 1D1B 2ABB41    	LHLD	TXTP2
 1D1E EB        	XCHG			;VARLIST ADDRESS TO DE
                	ENDIF
 1D1F 23        MOMDE:	INX	H
 1D20 73        	MOV	M,E
 1D21 23        	INX	H
 1D22 72        	MOV	M,D		;VARLIST ADDRESS TO ENTRY
 1D23 C9        	RET			;AND RETURN
                	IF	NOT COMPL
                ;BKVAR SETS TYPE BYTE BITS IN SYMBOL TABLE ENTRIES TO INDICATE VARIABLE BREAKS.
 1D24 CD6719    BKVAR:	CALL	FDVAR		;FIND VARIABLE NAME
 1D27 DA9201    	JC	SNERR		;NO VAR
 1D2A 1A        	LDAX	D
 1D2B F680      	ORI	80H		;SET BREAK BIT IN TYPE BYTE
 1D2D 12        	STAX	D
 1D2E CD6617    	CALL	GTCND		;LOOK FOR COMMA
 1D31 D2241D    	JNC	BKVAR		;BREAK ANOTHER VAR
 1D34 C9        	RET
                	ENDIF
                
                ;CALL <EXPR> [, {<VAR REF> | * <VAR NAME>}]*
 1D35 217306    CALCM:	LXI	H,NEXTC
 1D38 E5        	PUSH	H		;PUSH RETURN ADDRESS TO SCAN TO NEXT STATEMENT
 1D39 CD9D0B    	CALL	GTEXP		;GET LOCATION
 1D3C C5        	PUSH	B
 1D3D C9        	RET			;BRANCH TO USER ROUTINE
                
                ;CAMAC COMMANDS ARE IN MODULE CAMAC.
                
                ;CLEAR
                ;CLEAR <EXPR>		[IN STRNG VERSIONS]
                ;CLEAR @ <EXPR>		[IN CPM SDISK VERSIONS]
                ;DCLR0 IS IN MODULE SDISK.
                CLEAR:	IF	STRNG
 1D3E CD9C01    	CALL	DTST0		;CHECK IF DELIMITER FOLLOWS
 1D41 D2691D    	JNC	CLEA1		;YES, KEEP SAME STRING SPACE
                	IF	CPM AND SDISK
                	CALL	GTATN		;LOOK FOR @ <EXPR>
                	JNC	DCLR0		;CHANGE MAX NUMBER OF DISK FILES
                	ENDIF
 1D44 CD9D0B    	CALL	GTEXP		;OTHERWISE GET ARGUMENT
 1D47 78        	MOV	A,B
 1D48 B7        	ORA	A
 1D49 FAA012    	JM	FCERF		;FATAL FC ERROR IF NEGATIVE STRING SPACE GIVEN
 1D4C 50        	MOV	D,B
 1D4D 59        	MOV	E,C		;TO DE
 1D4E CD6502    	CALL	CPLDE		;COMPLEMENT DESIRED AMOUNT OF STRING SPACE
 1D51 2A8642    	LHLD	EOFAD
 1D54 010900    	LXI	B,9
 1D57 09        	DAD	B		;LEAVE ENOUGH ROOM TO COMPUTE TRIVIAL EXPRS
 1D58 E5        	PUSH	H		;SAVE EOF TOP POINTER
 1D59 2AA440    	LHLD	STRT		;TOP OF STRING SPACE TO HL
 1D5C 19        	DAD	D		;NEW MEMT VALUE TO HL
 1D5D D1        	POP	D		;EOF POINTER TO DE
 1D5E CD8602    	CALL	CMDHU		;MAKE SURE SUFFICIENT SPACE AVAILABLE
 1D61 D2011B    	JNC	OMERR		;NO -- FATAL OM ERROR
 1D64 228842    CLE0A:	SHLD	MEMT		;YES -- STORE NEW MEMT VALUE
 1D67 3600      	MVI	M,0		;AND INITIALIZE SYMBOL TABLE
                	ENDIF
                CLEA1:	IF	NOT COMPL
 1D69 CD5B1B    	CALL	UNBKL		;UNBREAK LINE BREAKS
                	ENDIF
 1D6C 2A8842    	LHLD	MEMT
                	IF	STRNG
 1D6F 22A640    	SHLD	STRPT		;INITIALIZE STRING POINTER
 1D72 22A840    	SHLD	STRP2		;AND STRING TEMP POINTER
                	ENDIF
 1D75 22C641    	SHLD	SYMTA		;AND SYMBOL TABLE
                	IF	STRNG OR FLOAT	;RESET DEFAULT TYPE BUFFER ENTRIES
                	IF	FLOAT		;DEFAULT TOKEN TO B, BUFFER LENGTH 26 TO C
 1D78 011A02    	LXI	B,(SNGST SHL 8) OR 26
                	ELSE
                	LXI	B,(INTST SHL 8) OR 26
                	ENDIF
 1D7B 219F41    	LXI	H,TYBUF		;DEFAULT TYPE BUFFER ADDRESS TO HL
 1D7E CD351E    	CALL	FILLM		;RESET DEFAULT TYPE BUFFER
                	ENDIF			;END OF STRNG OR FLOAT CONDITIONAL
                	IF	CAMAC AND C3908	;RESET BKSET PARAMETERS IF CAMAC ON 3908
                	LXI	B,7		;0 TO B, 7 TO C
                	LXI	H,CMBLK
                	CALL	FILLM		;RESET BKSET PARAMETERS TO 0
                	ENDIF
                	IF	PACKI
                	CALL	PINIT		;RESET PACKARD FIELD AND DATA BUFFER
                	STA	PAONL		;AND RESET MODE TO OFFLINE
                	ENDIF
 1D81 2A8642    CLEA2:	LHLD	EOFAD
 1D84 C34622    	JMP	CSPST		;RESET THE CONTROL STACK
                
                ;CONT
                	IF	COMPL
                CONT	EQU	UFERR		;UF ERROR IN COMPL VERSION
                	ELSE
 1D87 CD7B01    CONT:	CALL	IITST		;CONT ILLEGAL INDIRECT
 1D8A 2AC241    	LHLD	CSTKP
 1D8D 7E        	MOV	A,M
 1D8E FE65      	CPI	CSBRK		;SEE IF BREAK ENTRY ATOP CONTROL STACK
 1D90 CA9F1D    	JZ	CONT1		;YES -- POP IT
 1D93 FEA5      	CPI	CSLBK		;SEE IF LINE BREAK ENTRY
 1D95 C2A51D    	JNZ	CNERR		;NO -- CN ERROR
 1D98 CD9F1D    	CALL	CONT1		;POP ENTRY
 1D9B C1        	POP	B		;POP CONT RETURN ADDRESS
 1D9C C3C006    	JMP	XSTAT		;CONTINUE AT XSTAT, SKIPPING BREAK TEST
 1D9F CDA61B    CONT1:	CALL	CSPOP		;YES -- POP IT
 1DA2 C34622    	JMP	CSPST		;RESET CONTROL STACK POINTER AND RETURN
                CNERR:	ERROR	F, C, N		;FATAL CN ERROR
 1DA5+CDC616    	CALL	ERROF
 1DA8+43CE      	DB	'C', 'N' OR 80H
                	ENDIF
                
                ;DATA [<EXPR>] [,<EXPR>]*
                ;DATA IS IGNORED WHEN ENCOUNTERED, SO THE COMMAND DISPATCH TABLE BRANCHES
                ;TO GTDEL TO SCAN TO NEXT COMMAND FOR DATA.
                
                ;DEF FN <VAR NAME> [(<VAR NAME> [, <VAR NAME>]* )] = <EXPR>
                ;DEF {INT | STR | SNG | CAMVAR} <LETTER> [- <LETTER>]
 1DAA CD3B17    DEF:	CALL	GTCHA		;GET FOLLOWING TOKEN
 1DAD FEC0      	CPI	UDFNT
 1DAF C2101E    	JNZ	DEFVT		;NOT A USER-DEF FN, MUST BE VAR DECLARATION
                ;DEF FN BUILDS A SYMBOL TABLE ENTRY FOR A USER-DEFINED FUNCTION.  THE ENTRY
                ;CONTAINS A LENGTH BYTE, TYPE TOKEN, NAME BYTES, AND TWO ADDRESS BYTES.
                ;THE ADDR BYTES CONTAIN THE FN BODY ADDR IF 0-ARY, OR BOUND VAR ADDR OTHERWISE.
                ;THE TYPE TOKEN IS UFNST IF 0-ARY AND (UFNST OR 20H) OTHERWISE.
 1DB2 CD7201    	CALL	IDTST		;DEF FN ILLEGAL DIRECT
 1DB5 CD0E19    	CALL	GTNAM		;GET FN NAME
 1DB8 210400    	LXI	H,4
 1DBB CD7202    	CALL	ADAHL		;NAME LENGTH + OVERHEAD = ENTRY LENGTH TO HL
 1DBE E5        	PUSH	H		;AND SAVED
 1DBF 3E04      	MVI	A,UFNST
 1DC1 CD1F1B    	CALL	STLK0		;LOOK UP THE FN NAME 
 1DC4 D2F81E    	JNC	DDERR		;ALREADY DEFINED -- FATAL DD ERROR
 1DC7 1628      	MVI	D,'('
 1DC9 CD6F17    	CALL	GTD		;LOOK FOR (
 1DCC DAEB1D    	JC	DEF1		;0-ARY FN
 1DCF E3        	XTHL			;SAVE BOUND VAR ADDR, ENTRY LENGTH TO HL
 1DD0 3E04      	MVI	A,UFNST
 1DD2 F620      	ORI	20H		;SET UNARY BIT
 1DD4 CDB51A    	CALL	STPSH		;BUILD SYMBOL TABLE ENTRY
 1DD7 E5        	PUSH	H
 1DD8 CD6719    DEF0:	CALL	FDVAR		;LOOK FOR NONSUBSCRIPTED VARIABLE
 1DDB DA9201    	JC	SNERR
 1DDE CD5D17    	CALL	GTCOM		;LOOK FOR COMMA
 1DE1 D2D81D    	JNC	DEF0		;COMMA MUST BE FOLLOWED BY ANOTHER BOUND VAR
 1DE4 CD8E17    	CALL	GTREQ		;SKIP ) =
 1DE7 E1        	POP	H
 1DE8 C3F41D    	JMP	DEF2
 1DEB CD9317    DEF1:	CALL	GTEQU		;SKIP = TOKEN
 1DEE 3E04      	MVI	A,UFNST		;TOKEN TO A
 1DF0 E3        	XTHL			;SAVE ADDR, GET ENTRY LENGTH
 1DF1 CDB51A    	CALL	STPSH		;BUILD SYMBOL TABLE ENTRY
 1DF4 D1        DEF2:	POP	D		;BODY ADDRESS TO DE
 1DF5 73        	MOV	M,E
 1DF6 23        	INX	H
 1DF7 72        	MOV	M,D		;BODY ADDRESS TO ENTRY
 1DF8 C39817    	JMP	GTDEL		;SCAN FUNCTION BODY AND RETURN
                
                	IF	STRNG OR FLOAT
                ;DEFVT SETS THE DEFAULT TYPE FOR VARIABLES WITH GIVEN INITIAL LETTER(S).
                ;THE 26 BYTE BUFFER TYBUF CONTAINS THE DEFAULT VARIABLE TYPES.
                ;DEFTY RETURNS THE TYPE TOKEN IN B CORRESPONDING TO KEYWORD TOKEN IN A.
 1DFB 0601      DEFTY:	MVI	B,INTST
 1DFD FEDC      	CPI	INTT
 1DFF C8        	RZ			;INTEGER TYPE
                	IF	FLOAT
 1E00 0602      	MVI	B,SNGST
 1E02 FE17      	CPI	SNGT
 1E04 C8        	RZ			;FLOATING TYPE
                	ENDIF
                	IF	STRNG
 1E05 0603      	MVI	B,STRST
 1E07 FE18      	CPI	STRGT
 1E09 C8        	RZ			;STRING TYPE
                	ENDIF
                	IF	CAMAC
                	MVI	B,CAMST
                	CPI	CAMT
                	RZ
                	ENDIF
 1E0A CD4C17    	CALL	BAKUP		;ELSE BACK UP TEXTP
 1E0D C39201    	JMP	SNERR		;AND ISSUE SN ERROR
 1E10 CDFB1D    DEFVT:	CALL	DEFTY		;DESIRED TYPE TO B
 1E13 CD5117    	CALL	GTALP		;FIRST LETTER TO A
 1E16 DA9201    	JC	SNERR		;SN ERROR IF NONE
 1E19 5F        	MOV	E,A		;AND FIRST SAVED IN E
 1E1A 16C3      	MVI	D,MINT
 1E1C CD6F17    	CALL	GTD		;LOOK FOR -
 1E1F 7B        	MOV	A,E		;DEFAULT LAST = SAME AS FIRST
 1E20 DA291E    	JC	DEFV1		;NO SECOND LETTER SPECIFIED
 1E23 CD5117    	CALL	GTALP		;ELSE GET SECOND
 1E26 DA9201    	JC	SNERR
 1E29 93        DEFV1:	SUB	E		;SECOND - FIRST
 1E2A FA9201    	JM	SNERR		;SECOND PRECEDES FIRST
 1E2D 3C        	INR	A		;# OF ENTRIES TO CHANGE
 1E2E 4F        	MOV	C,A		;COUNT TO C
 1E2F 1600      	MVI	D,0		;DE NOW HAS FIRST LETTER IN ASCII
 1E31 215E41    	LXI	H,TYBUF-'A'
 1E34 19        	DAD	D		;ADDRESS FIRST ENTRY TO CHANGE
                	ELSE
                DEFVT	EQU	SNERR		;ISSUE SN ERROR IF INTEGER VERSION
                	ENDIF
                	IF	STRNG OR FLOAT OR ROM
                ;FILLM FILLS (C) BYTES OF MEMORY STARTING AT (HL) WITH (B).
 1E35 70        FILLM:	MOV	M,B		;CHANGE TO DESIRED VALUE
 1E36 23        	INX	H
 1E37 0D        	DCR	C
 1E38 C2351E    	JNZ	FILLM		;AND FILL MORE
 1E3B C9        	RET
                	ENDIF
                
                ;DELAY <EXPR> [ , <EXPR> [ , <EXPR> ]]
                	IF	NOT CAMAC	;CAMAC DELAY IS IN MODULE CAMAC
                	IF	REALT		;HARDWARE REAL TIME CLOCK DELAY
                ;DELAY WAITS FOR THE REAL TIME CLOCK TO TICK THE SPECIFIED NUMBER OF TIMES.
                ;THE ARGUMENTS ARE ASSUMED TO BE MINUTES, SECONDS AND TENTHS OF SECONDS.
                ;TYPING ANY CHARACTER ABORTS THE DELAY.
                ;THE IMPLEMENTATION COUNTS CLOCK TICKS RATHER THAN ADDING THE ARG TO
                ;THE CURRENT TIME AND WAITING UNTIL THE RESULTING TIME.  THE
                ;LATTER BLOWS UP IF A USER INTERRUPT SERVICE ROUTINE RENABLES
                ;(SO THE CLOCK TICKS) BUT LASTS UNTIL AFTER THE SPECIFIED TIME.
                DELAY:	ORA	A		;RESET CARRY FOR GTEXP
                	CALL	DELA5		;MINUTES TO BC
                	PUSH	B		;AND SAVED
                	CALL	DELA4		;SECONDS TO BC
                	PUSH	B		;AND SAVED
                	CALL	DELA4		;TENTHS OF SECONDS TO BC
                	MOV	H,B
                	MOV	L,C		;TENTHS TO HL
                	DAD	H		;* 2 = 20THS TO HL
                	POP	D		;SECONDS TO DE
                ;AT DELA1 MINUTES COUNT IS PUSHED, SECONDS COUNT IN DE, 20THS COUNT IN HL.
                DELA1:	LDA	TIMEX		;FETCH LOW ORDER CLOCK COUNT
                	MOV	B,A		;LOW ORDER CLOCK TO B
                DELA2:	MOV	A,H
                	ORA	L
                	JNZ	DELA3		;20THS COUNT IS NONZERO, ENTER DELAY LOOP
                	LXI	H,20		;RESET 20THS COUNT
                	MOV	A,D
                	ORA	E
                	DCX	D		;DECREMENT SECONDS COUNT
                	JNZ	DELA1		;SECONDS COUNT WAS NONZERO, ENTER LOOP
                	POP	B		;MINUTES COUNT TO BC
                	MOV	A,B
                	ORA	C
                	RZ			;MINUTES ALSO ZERO, FINISHED
                	LXI	D,59		;RESET SECONDS COUNT
                	DCX	B
                	PUSH	B		;SAVE UPDATED MINUTES COUNT
                	JMP	DELA1		;AND REENTER LOOP
                DELA3:	CALL	REDYC		;LOOK FOR CONSOLE CHAR
                	JC	POP1		;CHAR TYPED, POP MINUTES AND ABORT DELAY
                	LDA	TIMEX		;FETCH CURRENT LOW ORDER CLOCK
                	CMP	B		;CHECK IF CLOCK HAS TICKED
                	JZ	DELA3		;NO, KEEP WAITING
                	DCX	H		;YES, DECREMENT TICK COUNT
                	JMP	DELA1		;AND CHECK AGAIN
                ;DELA4 GETS [, <EXPR>] ARGUMENT TO BC, 0 IF OMITTED, OR ERROR IF NEGATIVE.
                DELA4:	LXI	B,0
                	CALL	GTCND		;LOOK FOR COMMA
                DELA5:	CNC	GTEXP		;GET ARG
                	MOV	A,B
                	ORA	A
                	RP			;OK
                	JMP	FCER0		;NEGATIVE ARG, NONFATAL FC ERROR AND RETURN 0
                	ELSE			;SOFTWARE REAL TIME CLOCK DELAY
 1E3C 2A0440    DELAY:	LHLD	TIMEX
 1E3F CD841E    	CALL	DELA1		;DELAY MINUTES
 1E42 2A0640    	LHLD	TIMEX+2
 1E45 CD841E    	CALL	DELA1		;DELAY SECONDS
 1E48 CD9D0B    	CALL	GTEXP		;GET HUNDREDTHS COUNT
 1E4B 78        	MOV	A,B
 1E4C B1        	ORA	C
 1E4D C8        	RZ			;DONE IF HUNDREDTHS COUNT IS ZERO
 1E4E 50        	MOV	D,B
 1E4F 59        	MOV	E,C		;TO DE
 1E50 219CFF    DELH1:	LXI	H,-100
 1E53 19        	DAD	D		;CARRY RESET IFF HUNDREDTHS COUNT < 100
 1E54 D2611E    	JNC	DELH2		;DELAY HUNDREDTHS
 1E57 EB        	XCHG			;HUNDREDTHS=HUNDREDTHS-100 TO DE
 1E58 2A0640    	LHLD	TIMEX+2		;SECONDS COUNT TO HL
 1E5B CD741E    	CALL	TIMER		;DELAY ONE SECOND
 1E5E C3501E    	JMP	DELH1		;AND TRY AGAIN
 1E61 3A0840    DELH2:	LDA	TIMEX+4		;MINUTES / 256 TO A
 1E64 CD7811    	CALL	MULT0		;* HUNDREDTHS COUNT
 1E67 44        	MOV	B,H
 1E68 4D        	MOV	C,L
 1E69 111800    	LXI	D,24
 1E6C CD9811    	CALL	DIVD0		;DIVIDE BY 24 TO PUT HUNDREDTH COUNT IN HL
 1E6F EB        	XCHG
 1E70 CD6602    	CALL	CPLD1
 1E73 EB        	XCHG			;COMPLEMENT IT AND FALL THROUGH TO TIMER
                ;TIMER IS THE BASIC TIMING LOOP SHARED BY TIME AND DELAY.  AFTER A DELAY OF
                ;15*256 CYCLES IT INCREMENTS THE COUNT IN HL, LOOKS FOR A CONSOLE CHAR, AND
                ;CONTINUES.  RETURNS CARRY SET IF CHAR TYPED, RESET IF HL COUNTS TO 0.
 1E74 CDB515    TIMER:	CALL	REDYC		;LOOK FOR CHAR
 1E77 D8        	RC			;RETURN CARRY SET IF CHAR TYPED
 1E78 AF        	XRA	A
 1E79 3D        TIME1:	DCR	A
 1E7A C2791E    	JNZ	TIME1		;WAIT A WHILE
 1E7D 23        	INX	H		;INCREMENT THE COUNT
 1E7E 7C        	MOV	A,H
 1E7F B5        	ORA	L
 1E80 C2741E    	JNZ	TIMER		;KEEP COUNTING UNTIL COUNT HITS ZERO
 1E83 C9        	RET			;RETURN CARRY RESET IF COUNTED OUT
                ;DELA1 IS CALLED FROM DELAY TO DELAY FOR <EXPR> MINUTES OR SECONDS
                ;BY EXECUTING TIMER (BC)*(HL) TIMES.
 1E84 CD9D0B    DELA1:	CALL	GTEXP		;GET THE ARGUMENT
 1E87 78        DELA2:	MOV	A,B
 1E88 B1        	ORA	C
 1E89 CA951E    	JZ	DELA3		;COUNT IS ZERO -- DONE
 1E8C E5        	PUSH	H
 1E8D CD741E    	CALL	TIMER
 1E90 E1        	POP	H
 1E91 0B        	DCX	B		;DECREMENT THE COUNT
 1E92 C3871E    	JMP	DELA2		;AND KEEP WAITING
 1E95 162C      DELA3:	MVI	D,','
 1E97 CD6F17    	CALL	GTD		;LOOK FOR COMMA
 1E9A D0        	RNC			;COMMA -- CONTINUE WITH DELAY
 1E9B E1        	POP	H		;ELSE POP THE DELA1 RETURN
 1E9C C9        	RET			;AND RETURN FROM DELAY
                	ENDIF			;END OF NOT REALT CONDITIONAL
                	ENDIF			;END OF NOT CAMAC CONDITIONAL
                
                ;DELETE <LINE #> [, <LINE #>]
                	IF	EDITC
                	IF	COMPL
                DELET	EQU	UFERR
                	ELSE
                DELET:	IF	ROMSQ
                	CALL	ISSRC		;MUST BE ADDRESSING WORKING SPACE
                	ENDIF
 1E9D CD2E18    	CALL	GTLNO		;LOOK FOR <LINE #>
 1EA0 DA9201    	JC	SNERR		;SN ERROR IF NONE
 1EA3 CDC131    	CALL	FINDL		;FIND THE LINE
 1EA6 E5        	PUSH	H
 1EA7 F5        	PUSH	PSW
 1EA8 CD6617    	CALL	GTCND		;LOOK FOR COMMA
 1EAB D2B71E    	JNC	DELE1		;FOUND COMMA
 1EAE F1        	POP	PSW
 1EAF DA3518    	JC	USERR		;US ERROR IF NOT FOUND
 1EB2 E1        	POP	H		;LOCATION TO HL
 1EB3 E5        	PUSH	H
 1EB4 C3C41E    	JMP	DELE2
 1EB7 F1        DELE1:	POP	PSW
 1EB8 CD2E18    	CALL	GTLNO		;LOOK FOR SECOND <LINE #>
 1EBB DA9201    	JC	SNERR		;SN ERROR IF NONE
 1EBE CDC131    	CALL	FINDL		;FIND IT
 1EC1 DAC81E    	JC	DELE3		;NOT FOUND, HL POINTS TO NEXT
 1EC4 5E        DELE2:	MOV	E,M
 1EC5 1600      	MVI	D,0		;LENGTH TO DE
 1EC7 19        	DAD	D		;HL POINTS TO NEXT
 1EC8 D1        DELE3:	POP	D		;FIRST LINE LOCATION TO DE
 1EC9 CD8602    	CALL	CMDHU		;COMPARE
 1ECC D0        	RNC			;FIRST LOC >= SECOND LOC, IGNORE
 1ECD E5        	PUSH	H		;SAVE SECOND LOC
 1ECE D5        	PUSH	D		;SAVE FIRST LOC
 1ECF EB        	XCHG			;SECOND LOC TO DE
 1ED0 CD6502    	CALL	CPLDE		;COMPLEMENTED
 1ED3 CD7B01    	CALL	IITST		;DELETE ILLEGAL INDIRECT
 1ED6 2A8642    	LHLD	EOFAD		;EOF ADDRESS TO HL
 1ED9 19        	DAD	D
 1EDA 23        	INX	H		;EOF - SECOND + 1 = BYTE COUNT TO HL
 1EDB E3        	XTHL			;DESTINATION = FIRST LOC TO HL
 1EDC D1        	POP	D		;COUNT TO DE
 1EDD C1        	POP	B		;SOURCE = SECOND LOC TO BC
 1EDE CDB631    	CALL	MOVED		;BLOCK MOVE REMAINDER OF PROGRAM
 1EE1 2B        	DCX	H		;POINT TO NEW LAST BYTE
 1EE2 C33822    	JMP	NEW1		;RESET STACKS
                	ENDIF
                	ELSE
                DELET	EQU	EXERR		;EX ERROR IN NON-EDITC VERSIONS
                	ENDIF
                
                ;DIM <VAR NAME> (<EXPR>[,<EXPR>]*) [,<VAR NAME> (<EXPR> [,<EXPR>]*)]*
 1EE5 CD0E19    DIM:	CALL	GTNAM		;LOOK FOR NAME
 1EE8 DA9201    DIM0:	JC	SNERR		;SN ERROR IF NONE
 1EEB F5        	PUSH	PSW		;SAVE SYMBOL LENGTH
 1EEC 21D041    	LXI	H,BUFAD+MAXNL	;SAVING ADDRESS TO HL
 1EEF CD801A    	CALL	CPYS0		;COPY VAR NAME TO SAVE IT
 1EF2 CD1C1B    	CALL	STLKU		;LOOK IT UP
 1EF5 DAFD1E    	JC	DIMS0
                DDERR:	ERROR	F, D, D		;FATAL DD ERROR IF DEFINED ALREADY
 1EF8+CDC616    	CALL	ERROF
 1EFB+44C4      	DB	'D', 'D' OR 80H
 1EFD 1628      DIMS0:	MVI	D,'('
 1EFF CD8717    	CALL	GTDSN		;SKIP (
 1F02 F1        	POP	PSW
 1F03 6F        	MOV	L,A		;NAME LENGTH TO L
 1F04 3A9E41    	LDA	VARTY
 1F07 67        	MOV	H,A		;TYPE TOKEN TO H
 1F08 22BD41    	SHLD	SAVTP		;AND HL SAVED
 1F0B CD0902    	CALL	BYTSD		;BYTES PER ENTRY TO E, # DIMS SO FAR TO D
 1F0E D5        	PUSH	D		;AND SAVED
 1F0F 110100    	LXI	D,1		;FIND # ELEMENTS IN DE
 1F10 =         INONE	EQU	$-2		;ADDRESS OF INTEGER 1 FOR FOR STEP DEFAULT
 1F12 D5        	PUSH	D
                ;DIMS1 IS REPEATED FOR EACH DIMENSION OF AN ARRAY.  EACH DIMENSION BOUND
                ;IS PUSHED, AS WELL AS BYTES PER ENTRY/#DIMS AND #ELEMENTS THUS FAR.
 1F13 D1        DIMS1:	POP	D		;# ELEMENTS TO DE
 1F14 E1        	POP	H		;#DIMS TO H, BYTES PER ENTRY TO L
 1F15 24        	INR	H		;INCREMENT # DIMS COUNT
 1F16 CD9D0B    	CALL	GTEXP		;GET DIM
 1F19 78        	MOV	A,B
 1F1A B7        	ORA	A
 1F1B FAA012    	JM	FCERF		;FATAL FC ERROR IF NEGATIVE
 1F1E C5        	PUSH	B		;AND SAVE IT
 1F1F E5        	PUSH	H		;SAVE COUNT
 1F20 03        	INX	B		;DIM + 1 (TO ALLOW SUBSCRIPT 0)
 1F21 CD6D11    	CALL	MULBD		;NEW # ELEMENTS = BC * DE TO HL
 1F24 DA011B    	JC	OMERR		;TOO MANY
 1F27 E5        	PUSH	H		;SAVE # ELEMENTS
 1F28 162C      	MVI	D,','
 1F2A CD6F17    	CALL	GTD		;LOOK FOR ,
 1F2D D2131F    	JNC	DIMS1		;GET MORE DIMENSIONS
 1F30 1629      	MVI	D,')'
 1F32 CD8717    	CALL	GTDSN		;SKIP )
 1F35 11D041    	LXI	D,BUFAD+MAXNL
 1F38 21C841    	LXI	H,BUFAD
 1F3B CD831A    	CALL	CPYST		;RESTORE SYMBOL NAME TO BUFAD
                ;NOW THE NEW SYMBOL TABLE ENTRY FOR THE ARRAY IS BUILT, CONTAINING LENGTH
                ;BYTE, TYPE BYTE, NAME, #DIMS, BOUNDS (2 BYTES * #DIMS) AND ELEMENTS.
 1F3E D1        	POP	D		;RESTORE # ELEMENTS TO DE
 1F3F C1        	POP	B		;BYTES PER ENTRY TO C, # DIMS TO B
                	IF	CAMAC
                	LHLD	SAVTP
                	MOV	A,H		;FETCH TYPE TOKEN IN CASE CAMVAR
                	CPI	CAMST
                	JNZ	DIM1A		;NOT A CAMVAR
                	MOV	A,B
                	CPI	1		;MAKE SURE CAMVAR IS 1-D
                	JNZ	SNERR		;SN ERROR IF NOT
                	ENDIF
 1F40 68        DIM1A:	MOV	L,B
 1F41 2600      	MVI	H,0		;NOW FIND ENTRY LENGTH TO BUILD ENTRY
 1F43 29        	DAD	H		;# DIMS * 2 BYTES PER DIM
 1F44 23        	INX	H		;+ LENGTH BYTE
 1F45 23        	INX	H		;+ TYPE BYTE
 1F46 23        	INX	H		;+ #DIMS BYTE
 1F47 79        	MOV	A,C		;BYTES PER ENTRY TO A
 1F48 19        DIMS2:	DAD	D
 1F49 DA011B    	JC	OMERR		;TOO BIG
 1F4C 3D        	DCR	A
 1F4D C2481F    	JNZ	DIMS2		;# ELEMENTS * BYTES PER ENTRY
 1F50 EB        	XCHG			;LENGTH SO FAR TO DE
 1F51 2ABD41    	LHLD	SAVTP	
 1F54 7C        	MOV	A,H		;SYMBOL TYPE TOKEN TO A
 1F55 2600      	MVI	H,0		;HL NOW HAS NAME LENGTH
 1F57 19        	DAD	D		;ENTRY LENGTH IN HL
 1F58 DA011B    	JC	OMERR
 1F5B CDB51A    	CALL	STPSH		;BUILD TABLE ENTRY
 1F5E 70        	MOV	M,B		;# DIMS TO TABLE
 1F5F 48        	MOV	C,B
 1F60 0600      	MVI	B,0		;BC NOW HAS # DIMS
 1F62 09        	DAD	B
 1F63 09        	DAD	B
 1F64 23        	INX	H		;HL POINTS PAST LAST DIM
                	IF	CAMAC
                	CPI	CAMST		;CHECK IF CAMVAR
                	JNZ	DIMS3		;NO
                	XTHL			;COMPONENT COUNT TO HL
                	INX	H		;ACTUAL COUNT = DIMENSION + 1
                	SHLD	CVCNT		;AND SAVED, IN CASE DECLARE WITH VALUES
                	DCX	H
                	XTHL			;RESTORE COUNT, RECOVER LOCATION
                	SHLD	CVLOC		;AND SAVE LOCATION
                	ENDIF
 1F65 D1        DIMS3:	POP	D		;DIM TO DE
 1F66 CD5002    	CALL	MVMDE		;AND THEN TO TABLE
 1F69 0D        	DCR	C		;COUNT DOWN DIMS
 1F6A C2651F    	JNZ	DIMS3
 1F6D CD6617    	CALL	GTCND		;LOOK FOR COMMA
 1F70 D2E51E    	JNC	DIM		;DIMENSION ANOTHER
 1F73 C9        	RET
                
                ;DISABLE [<LINE #>]
                	IF	NOT WILD
 1F74 CD2E18    DSABL:	CALL	GTLNO		;LINE # TO DE, CARRY SET IF NONE
 1F77 215640    	LXI	H,INTAD
 1F7A 3A5540    	LDA	INTTC
 1F7D D2921F    	JNC	DSAB2		;LINE # PRESENT
 1F80 32B941    	STA	TEMP		;SAVE OLD # ENTRIES
 1F83 AF        	XRA	A
 1F84 325540    	STA	INTTC		;SET ENTRY COUNT TO 0
 1F87 77        	MOV	M,A		;STORE TABLE EOF
 1F88 3AB941    DSAB1:	LDA	TEMP
 1F8B B7        	ORA	A		;CHECK IF ANY DISABLED
 1F8C C0        	RNZ
                ENERR:	ERROR	F, E, N		;FATAL EN ERROR
 1F8D+CDC616    	CALL	ERROF
 1F90+45CE      	DB	'E', 'N' OR 80H
 1F92 AF        DSAB2:	XRA	A
 1F93 32B941    	STA	TEMP		;SET FLAG TO TELL IF ANY DISABLED
 1F96 7E        DSAB3:	MOV	A,M
 1F97 B7        	ORA	A		;CHECK CURRENT ENTRY TYPE BYTE
 1F98 CA881F    	JZ	DSAB1		;EOF
 1F9B E5        	PUSH	H		;SAVE CURRENT ADDR
 1F9C 010800    	LXI	B,8
 1F9F 09        	DAD	B
 1FA0 E5        	PUSH	H		;SAVE NEXT ADDR
 1FA1 2B        	DCX	H
 1FA2 46        	MOV	B,M
 1FA3 2B        	DCX	H
 1FA4 4E        	MOV	C,M		;ENABLE LINE # TO BC
 1FA5 CD8002    	CALL	CMBDU		;COMPARE TO DESIRE LINE #
 1FA8 CAB01F    	JZ	DSAB4		;MATCH -- PURGE IT
 1FAB E1        	POP	H
 1FAC C1        	POP	B
 1FAD C3961F    	JMP	DSAB3		;NO MATCH -- TRY NEXT
 1FB0 C1        DSAB4:	POP	B		;NEXT TO BC -- SOURCE
 1FB1 E1        	POP	H		;CURRENT TO HL -- DESTINATION
 1FB2 C5        	PUSH	B		;SAVE NEXT
 1FB3 D5        	PUSH	D		;SAVE LINE #
 1FB4 50        	MOV	D,B
 1FB5 59        	MOV	E,C		;CURRENT TO DE
 1FB6 E5        	PUSH	H		;SAVE DESTINATION
 1FB7 219740    	LXI	H,INTAD+INTTL	;LAST LOCATION + 1 TO HL
 1FBA CD6502    	CALL	CPLDE		;- CURRENT TO DE
 1FBD 19        	DAD	D		;COUNT TO HL
 1FBE EB        	XCHG			;THEN TO DE
 1FBF E1        	POP	H		;RESTORE DESTINATION
 1FC0 CDB631    	CALL	MOVED		;MOVE REMAINDER OF TABLE
 1FC3 215540    	LXI	H,INTTC		;ADDRESS TABLE COUNT
 1FC6 7E        	MOV	A,M		;FETCH COUNT
 1FC7 32B941    	STA	TEMP		;SET FLAG TO TRUE (NONZERO)
 1FCA 35        	DCR	M		;UPDATE COUNT
 1FCB D1        	POP	D		;RESTORE LINE #
 1FCC E1        	POP	H		;NEXT TO HL
 1FCD C3961F    	JMP	DSAB3		;KEEP TRYING
                	ENDIF			;END OF NOT WILD CONDITIONAL
                
                ;EDIT [<LINE #>]
                	IF	EDITC
                	IF	COMPL
                EDIT	EQU	UFERR
                	ELSE
                EDIT:	IF	ROMSQ
                	CALL	ISSRC		;MUST BE ADDRESSING WORKING SPACE
                	ENDIF
 1FD0 CD2E18    	CALL	GTLNO		;LOOK FOR <LINE #>
 1FD3 D2DA1F    	JNC	EDIT0
 1FD6 2A4D40    	LHLD	ERRLN		;EDIT MOST RECENT ERROR LINE IF NONE
 1FD9 EB        	XCHG			;TO DE
 1FDA CD7B01    EDIT0:	CALL	IITST		;EDIT ILLEGAL INDIRECT
 1FDD CDE331    	CALL	FDLNO		;FIND THE LINE
 1FE0 23        	INX	H
 1FE1 4E        	MOV	C,M
 1FE2 23        	INX	H
 1FE3 46        	MOV	B,M		;LINE NUMBER TO BC
 1FE4 23        	INX	H
 1FE5 23        	INX	H
 1FE6 E5        	PUSH	H		;SAVE POINTER TO FIRST BYTE OF LINE
 1FE7 AF        	XRA	A
 1FE8 CD2816    	CALL	CVTIS		;CONVERT LINE NUMBER TO STRING
 1FEB F5        	PUSH	PSW		;SAVE LENGTH
 1FEC CD3113    	CALL	BCDE		;STRING LOC TO BC, LENGTH TO E
 1FEF 212C42    	LXI	H,NLNAD		;DESTINATION TO HL
 1FF2 CDB431    	CALL	MOVD0		;COPY LINE NUMBER STRING TO INPUT BUFFER
 1FF5 EB        	XCHG			;NEXT INPUT BUFFER LOCATION TO DE
 1FF6 F1        	POP	PSW
 1FF7 2F        	CMA			;-LENGTH-1
 1FF8 C654      	ADI	NLMAX+4		;MAX # CHARS + 3 - LENGTH
 1FFA 4F        	MOV	C,A		;TO C TO AVOID LINE OVERFLOW
 1FFB 3E20      	MVI	A,' '
 1FFD E1        	POP	H		;FIRST CHAR ADDRESS TO HL
 1FFE E5        	PUSH	H
 1FFF BE        	CMP	M		;CHECK IF FIRST CHAR OF LINE IS <SPACE>
 2000 C43620    	CNZ	EDIT4		;ADD A SPACE IF NOT
 2003 E1        EDIT2:	POP	H		;LINE POINTER TO HL
 2004 7E        	MOV	A,M		;FETCH NEXT CHAR OR TOKEN IN LINE
 2005 23        	INX	H
 2006 E5        	PUSH	H		;AND SAVE POINTER TO NEXT
 2007 CD8C1A    	CALL	FNDTK		;CHECK IF CHAR OR TOKEN
 200A DA2720    	JC	EDIT3		;TOKEN
 200D CD3620    	CALL	EDIT4		;STORE THE CHAR
 2010 FE0D      	CPI	CR		;CHECK IF CR
 2012 C20320    	JNZ	EDIT2		;NO, CONTINUE
 2015 319E41    	LXI	SP,STACK	;RESET SP IN CASE DIRECT LINE RESULTS
 2018 CDF12E    	CALL	LEDIT		;EDIT THE LINE
 201B CD2730    	CALL	TKIZE		;TOKENIZE THE LINE
 201E DACA06    	JC	XSTA1		;EXECUTE IF NO LINE NUMBER
 2021 C42431    	CNZ	ADDLN		;ADD LINE TO CURRENT SOURCE
 2024 C34B06    	JMP	DMOD2		;AND RETURN TO OK PROMPT
 2027 7E        EDIT3:	MOV	A,M		;FETCH CHAR OF TOKEN
 2028 E67F      	ANI	7FH		;MASK OFF POSSIBLE HIGH BIT
 202A CD3620    	CALL	EDIT4		;STORE THE CHAR
 202D 7E        	MOV	A,M		;REFETCH
 202E 23        	INX	H
 202F B7        	ORA	A
 2030 F22720    	JP	EDIT3		;NOT END OF TOKEN, GET NEXT CHAR
 2033 C30320    	JMP	EDIT2		;END OF TOKEN, GET NEXT CHAR OF LINE
 2036 12        EDIT4:	STAX	D		;STORE THE CHAR
 2037 13        	INX	D		;POINT TO NEXT LOCATION
 2038 0D        	DCR	C		;DECREMENT REMAINING CHAR COUNT
 2039 C0        	RNZ			;RETURN IF ENOUGH ROOM
 203A 3E0D      	MVI	A,CR		;TOO LITTLE ROOM IN BUFFER, EX ERROR
 203C 322C42    	STA	NLNAD		;CR TO INPUT BUFFER
 203F C39701    	JMP	EXERR		;AND ISSUE EX ERROR
                	ENDIF
                	ELSE
                EDIT	EQU	EXERR		;EX ERROR IN NON-EDITC VERSIONS
                	ENDIF
                
                ;ENABLE <LINE #> , <BYTE EXPR> , <BYTE EXPR> [, <BYTE EXPR>] [,$]
                	IF	NOT WILD
 2042 CD7201    ENABL:	CALL	IDTST		;ENABLE ILLEGAL DIRECT
 2045 C5        	PUSH	B		;SAVE CURRENT LINE #
 2046 CD2E18    	CALL	GTLNO
 2049 D5        	PUSH	D		;SAVE SUBROUTINE LINE #
 204A 162C      	MVI	D,','
 204C CD8717    	CALL	GTDSN		;SKIP COMMA
 204F CDBE04    	CALL	IINFO		;GET INTERRUPT INFO
 2052 D5        	PUSH	D
 2053 C5        	PUSH	B		;AND SAVE IT
 2054 215540    	LXI	H,INTTC
 2057 7E        	MOV	A,M		;# ENTRIES TO A
 2058 FE08      	CPI	INTTN		;COMPARED TO MAX
 205A D28D1F    	JNC	ENERR		;TOO MANY -- EN ERROR
 205D 34        	INR	M		;STORE NEW # ENTRIES
 205E B7        	ORA	A
 205F 17        	RAL
 2060 17        	RAL
 2061 17        	RAL			;*8 BYTES PER ENTRY
 2062 215540    	LXI	H,INTAD-1
 2065 CD7202    	CALL	ADAHL		;+ ADDRESS - 1 = ADDRESS OF NEW ENTRY - 1
 2068 3E04      	MVI	A,4
 206A D1        ENAB1:	POP	D
 206B CD1F1D    	CALL	MOMDE		;TWO BYTES TO ENTRY
 206E 3D        	DCR	A		;FOUR TIMES
 206F C26A20    	JNZ	ENAB1
 2072 23        	INX	H
 2073 3600      	MVI	M,0		;AND NEW EOF
 2075 C9        	RET
                	ENDIF			;END OF NOT WILD CONDITIONAL
                
                ;END
                ENDCM:	IF	SDISK AND (NOT RTPAK)
                	CALL	CLOSN		;CLOSE ANY OPEN FILES
                	ENDIF
                	IF	CAMAC AND FALSE	;NORTHSTAR VERSION
                	CALL	CLOSE		;CLOSE ANY OPEN FILES
                	ENDIF
                ENDC1:	IF	COMPL		;ERROR ENTRY POINT
                	JMP	BOOT		;BOOT IN COMPL VERSION
                	ELSE
 2076 3E65      	MVI	A,CSBRK		;BREAK TOKEN TO A
 2078 C34B26    	JMP	STOP2		;SAVE BREAK INFO AND RETURN TO DMODE
                	ENDIF
                
                ;EXEC [<EXPR> [,G] ]
                	IF	ROMSQ
                	IF	COMPL
                EXEC	EQU	UFERR
                	ELSE
                EXEC:	CALL	IEVAL		;LOOK FOR LOCATION
                	LXI	H,SRCAD
                	JC	EXEC1		;NO LOC, RESTORE SOURC TO SRCAD
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                	IF	WILD
                EXECW:	DCX	B		;ARG-1 SHOULD BE 0-8 -- INITIAL ENTRY POINT
                	LXI	D,9
                	CALL	CMBDU
                	JNC	ROERR		;RO ERROR IF ARG WAS NOT 1-9
                	LXI	H,WEXEC		;ADDRESS BASE OF EXEC BUFFER
                	DAD	B
                	DAD	B		;ADDRESS SELECTED EXEC BUFFER POINTER
                	MOV	A,M		;FETCH LOW ORDER ADDRESS
                	INX	H
                	MOV	H,M		;HIGH ORDER ADDRESS TO H
                	MOV	L,A		;AND LOW ORDER TO L
                	ORA	H
                	JZ	ROERR		;RO ERROR IF BUFFER ENTRY IS 0
                	ENDIF			;END OF WILD CONDITIONAL
                	IF	WILD OR NOT COMPL
                	IF	NOT WILD
                	MOV	H,B
                	MOV	L,C		;LOCATION TO HL
                	ENDIF			;END OF NOT WILD CONDITIONAL
                EXEC0:	MOV	A,M		;FETCH FIRST CHAR OF PROG
                	CPI	CR
                	JNZ	ROERR		;NOT A PROGRAM, FATAL RO ERROR
                	INX	H		;ELSE POINT TO FIRST LENGTH BYTE
                EXEC1:	SHLD	SOURC		;RESET SOURC
                	IF	NOT COMPL
                	CALL	GTCOM		;LOOK FOR COMMA
                	LHLD	EOFAD		;EOF ADDRESS TO HL
                	JC	DMODX		;NO COMMA, RESET STACKS AND RETURN TO DMODE
                	CALL	NEW1		;RESET CONTROL STACK
                	MVI	D,'G'
                	CALL	GTDSN		;SKIP G AFTER COMMA
                	LHLD	SOURC		;NEW PROGRAM ADDRESS TO HL
                	ENDIF
                	JMP	BAKUP		;RESET TEXTP AND CONTINUE EXECUTION AT NEW PROG
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                	ELSE
 0197 =         EXEC	EQU	EXERR		;EX ERROR IN NON-ROMSQ VERSIONS
                	ENDIF			;END OF ROMSQ CONDITIONAL
                
                
                ;END OF STATES1
                	PAGE
                
                ;STATES2 05/21/81
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980, 1981 BY MARK WILLIAMS COMPANY, CHICAGO
                ;STATEMENT ROUTINES FOR STATEMENTS FOR THROUGH NULL
                
                
                ;FOR <VAR NAME> = <EXPR> TO <EXPR> [STEP <EXPR>]
 207B CDAA01    FOR:	CALL	GTLHS		;GET DESTINATION FOR ASIGN
                	IF	STRNG
 207E FE03      	CPI	STRST
 2080 CA9201    	JZ	SNERR		;SN ERROR IF FOR <STRING VAR>
                	ENDIF
 2083 21101F    	LXI	H,INONE		;INTEGER 1 ADDR TO HL
                	IF	FLOAT
 2086 FE02      	CPI	SNGST
 2088 C28E20    	JNZ	FOR1		;INTEGER FOR
 208B 21B00B    	LXI	H,FPONE		;FLOATING 1. ADDR TO HL
                	ENDIF
                ;AT FOR1 THE FOR VAR ADDR IS IN LHSAD, THE DEFAULT INCR POINTER IN HL.
                ;THE CSTACK IS EXAMINED FOR A PREVIOUS FOR ENTRY WITH THE SAME VARIABLE,
                ;AND THE ENTRY IS FLUSHED IF FOUND.
 208E E5        FOR1:	PUSH	H		;SAVE DEFAULT INCR POINTER
 208F 014F4F    	LXI	B,(CSFOR SHL 8) OR CSFOR
 2092 2AC241    	LHLD	CSTKP		;SET BC, HL FOR CSDIG
 2095 CDCE1B    FOR1A:	CALL	CSDI1		;LOOK FOR OLD FOR ENTRY
 2098 DAB820    	JC	FOR2		;NOT FOUND
 209B E5        	PUSH	H		;SAVE CURRENT ENTRY ADDR
 209C 7E        	MOV	A,M
 209D E61F      	ANI	1FH
 209F CD7902    	CALL	SBAHL		;ADDRESS NEXT CSTACK ENTRY
 20A2 E3        	XTHL			;SAVE NEXT ADDR, CURRENT ADDR TO HL
 20A3 11FBFF    	LXI	D,-5
 20A6 19        	DAD	D		;ADDRESS VAR ADDR BYTES
 20A7 CD4B02    	CALL	MVDEM		;FETCH FOR ENTRY VAR ADDR TO DE
 20AA 2AC041    	LHLD	LHSAD		;FOR VAR ADDR TO HL
 20AD CD8602    	CALL	CMDHU		;CHECK IF SAME VARIABLE
 20B0 E1        	POP	H		;NEXT ENTRY ADDR TO HL
 20B1 C29520    	JNZ	FOR1A		;NO MATCH, TRY NEXT
 20B4 78        	MOV	A,B		;MATCH, ENTRY TYPE TO A
 20B5 CDDD1B    	CALL	CSRST		;AND PURGE THE ENTRY
                ;FOR2 BUILDS A NEW CSTACK FOR ENTRY.  THE ENTRY CONSISTS OF A TYPE/LENGTH BYTE
                ;(1 BYTE), LINE # ADDRESS, RETURN TEXTP AND VARIABLE ADDRESS (2 BYTES EACH),
                ;AND BOUND AND INCREMENT VALUES (2 OR 4 BYTES EACH).  AFTER CPUSH ALLOCATES
                ;SPACE FOR THE ENTRY, THE CSTACK POINTER IS RESET TO IGNORE THE PROTOENTRY
                ;IN CASE FOR ABORTS, E.G. WITH A SN ERROR.  ANOTHER CPUSH COMPLETES THE ENTRY.
 20B8 78        FOR2:	MOV	A,B
 20B9 CD6C1B    	CALL	CPUSH		;ALLOCATE NEW CSTACK FOR ENTRY
 20BC EB        	XCHG
                	IF	NOT COMPL
 20BD CD6301    	CALL	LINBC
 20C0 CC011C    	CZ	DCSTD		;UNINCREMENT CSTACK DIRECT COUNT IF DIRECT
                	ENDIF
 20C3 2AC041    	LHLD	LHSAD
 20C6 EB        	XCHG
 20C7 CD5002    	CALL	MVMDE		;VARIABLE ADDR TO ENTRY
 20CA 3E09      	MVI	A,2*FBYTS+1	;SKIP TWO VALUES
 20CC CD7902    	CALL	SBAHL		;ADDRESS NEXT CSTACK ENTRY
 20CF 22C241    	SHLD	CSTKP		;RESET CSTACK IN CASE SN ERROR IN FOR
 20D2 23        	INX	H		;ADDRESS BOTTOM OF NEW FOR ENTRY
 20D3 E5        	PUSH	H		;AND SAVE POINTER FOR BOUND/INCR INSERTION
 20D4 CDF021    	CALL	LET1		;GET INITIAL VALUE AND ASSIGN TO VAR
 20D7 160F      	MVI	D,TOT
 20D9 CD8717    	CALL	GTDSN		;SKIP TO TOKEN
 20DC CDD30A    	CALL	EVALT		;GET BOUND OF DESIRED TYPE
 20DF 23        	INX	H		;POINT TO BOUND VALUE
 20E0 E3        	XTHL			;FOR ENTRY POINTER TO HL
 20E1 C1        	POP	B		;BOUND POINTER TO BC
 20E2 CDB231    	CALL	MOVEB		;COPY BOUND TO ENTRY
 20E5 E3        	XTHL			;SAVE ENTRY ADDR FOR INCREMENT
 20E6 E5        	PUSH	H		;AND DEFAULT INCR
 20E7 1610      	MVI	D,STEPT
 20E9 CD6F17    	CALL	GTD		;LOOK FOR STEP
 20EC E1        	POP	H		;DEFAULT INCREMENT POINTER TO HL
 20ED DAF420    	JC	FOR2A		;NO STEP, TAKE DEFAULT VALUE
 20F0 CDD30A    	CALL	EVALT		;GET INCREMENT VALUE
 20F3 23        	INX	H		;AND POINT TO VALUE
 20F4 E3        FOR2A:	XTHL			;ENTRY POINTER TO HL
 20F5 C1        	POP	B		;INCR POINTER TO BC
                	IF	FOR0
 20F6 E5        	PUSH	H		;SAVE POINTER TO INCR FOR FOR0 TEST
                	ENDIF
 20F7 CDB231    	CALL	MOVEB		;COPY INCREMENT TO ENTRY AND RETURN
 20FA 3E4F      	MVI	A,CSFOR
                	IF	NOT FOR0
                	JMP	CPUSH		;BUILD THE NEW CSTACK ENTRY
                	ELSE
 20FC CD6C1B    	CALL	CPUSH
                ;MUST NOW CHECK FOR VACUOUS CONDITION (E.G. FOR I=1 TO 0) IN FOR0 VERSION
 20FF 2AC041    	LHLD	LHSAD
                	IF	FLOAT
 2102 3ABF41    	LDA	LHSTY
 2105 FE02      	CPI	SNGST
                	IF	F9511
                	CZ	LOD95		;LOAD FLOATING VALUE TO 9511 STACK
                	ELSE
 2107 CCEB0D    	CZ	FLOAD		;LOAD FLOATING VALUE TO FACC
                	ENDIF
                	ENDIF
 210A 4E        	MOV	C,M
 210B 23        	INX	H
 210C 46        	MOV	B,M		;FETCH INTEGER VALUE TO BC
 210D D1        	POP	D		;INCR POINTER TO DE
 210E 21FCFF    	LXI	H,-FBYTS
 2111 19        	DAD	D		;BOUND POINTER TO HL
 2112 CDAD02    	CALL	BDTST		;TEST FOR CONDITION
 2115 D0        	RNC			;OK, JUST RETURN
 2116 2AC241    	LHLD	CSTKP
 2119 CDF822    	CALL	NEXT6		;PURGE THE CSTACK ENTRY JUST BUILT
 211C CD8E01    	CALL	EOS
 211F 0692      	MVI	B,NEXTT
 2121 CDD102    	CALL	FNDST		;FIND MATCHING NEXT
 2124 D20823    	JNC	NEXT7		;LOOK FOR FOLLOWING COMMA, RETURN OR DO ANOTHER
                	ERROR	F, F, R		;NOT FOUND, FATAL FR ERROR
 2127+CDC616    	CALL	ERROF
 212A+46D2      	DB	'F', 'R' OR 80H
                	ENDIF
                
                ;GOSUB <LINE #>
 212C CD3521    GOSUB:	CALL	GOTO		;FIND NEW TEXTP AND LNNUM
 212F 3E25      GOSU1:	MVI	A,CSGOS		;ON ENTRY POINT
 2131 C5        	PUSH	B		;SAVE RETURN TEXT POINTER
 2132 C3701B    	JMP	CPSH1		;BUILD CONTROL STACK ENTRY AND RETURN
                
                ;GOTO <LINE #>
                ;GOTO IS CALLED BY GOSUB TO READ A LINE #, LOOK FOR IT AND
                ;CHECK FOR END OF STATEMENT GARBAGE.  BRANCHES TO US ERROR IF ILLEGAL
                ;OR NO SUCH LINE #, OTHERWISE:
                ;RETN:	A	CLOBBERED
                ;	BC	RETURN TEXT POINTER, I.E. DELIMITER ADDRESS
                ;	DE	LINE #
                ;	HL	ADDRESS OF <CR> PRECEDING DESIRED LINE IN TEXT
                ;	(TEXTP)	SAME AS HL
 2135 CD2E18    GOTO:	CALL	GTLNO		;LINE # TO DE
 2138 DA9201    	JC	SNERR		;NO LINE #
 213B CD8E01    GOTO1:	CALL	EOS		;END OF STATEMENT TEST -- IF ENTRY POINT
 213E CDE331    GOTO2:	CALL	FDLNO		;FIND LINE # -- INTERRUPT, ON ENTRY POINT
 2141 C34C17    	JMP	BAKUP		;BACK UP TEXTP AND RETURN
                
                ;IF <EXPR> THEN {<LINE #> | <STATEMENT>}
 2144 CD9D0B    IFCOM:	CALL	GTEXP		;EVALUATE THE IF EXPRESSION
 2147 160E      	MVI	D,THENT
 2149 CD8717    	CALL	GTDSN		;SKIP THEN TOKEN
 214C 78        	MOV	A,B
 214D B1        	ORA	C
 214E CAA824    	JZ	REM		;FALSE -- SCAN TO CR AND RETURN
 2151 CD2E18    	CALL	GTLNO		;LOOK FOR LINE #
 2154 DACE06    	JC	XSTA2		;NONE -- EXECUTE <STATEMENT> THENPART
 2157 C33B21    	JMP	GOTO1		;GOTO LINE # AND RETURN
                
                ;INPUT [<QUOTED STRING>] [;] <VAR LIST>
                ;INPUT @<EXPR>, <VAR LIST>	[IN SDISK VERSIONS]
                ;INPUT @ <VAR LIST>		[IN PACKI VERSIONS]
                ;INPUT MUST SCAN TWO LINES, THE COMMAND LINE INPUT <VARLIST> AND THE LINE
                ;OF DATA TYPED BY THE USER.  THE TWO TEXT POINTERS ARE KEPT IN TEXTP
                ;AND TXTP2, AND EXCHANGED BY FLIP.  THE ORIGINAL <VARLIST> TEXTP
                ;IS ALSO PUSHED, TO BE AVAILABLE WHEN REDOING.  IF THE DATA IS OF
                ;INCORRECT TYPE OR THERE ARE FEWER DATA THAN VARIABLES, REDO.  IF THERE ARE
                ;FEWER VARIABLES THAN DATA, EXCESS IGNORED.
                ;DINP0 IS IN MODULE SDISK.
                ;PAINP IS IN MODULE PACKARD.
 215A CD7201    INPUT:	CALL	IDTST		;INPUT ILLEGAL DIRECT MODE
                	IF	SDISK
                	CALL	GTSFN		;LOOK FOR DISK FILE SPECIFICATION
                	JNC	DINP0		;DISK INPUT
                	ENDIF			;END OF SDISK CONDITIONAL
                	IF	PACKI
                	MVI	D,'@'
                	CALL	GTD		;LOOK FOR @
                	JNC	PAINP		;FOUND @, MUST BE PACKARD INPUT @
                	ENDIF
 215D AF        	XRA	A
 215E 325440    	STA	OMODE		;TURN ON OUTPUT MODE
 2161 1622      	MVI	D,'"'
 2163 CD6F17    	CALL	GTD		;LOOK FOR QUOTED STRING
 2166 D42D24    	CNC	PRQUO		;PRINT IT IF PRESENT
 2169 163B      	MVI	D,SEMIC
 216B CD6F17    	CALL	GTD		;LOOK FOR ; AND IGNORE IF PRESENT
                ;INPU1 SETS UP POINTERS, AND IS ENTRY POINT FOR RETRIES AFTER REDO MESSAGE.
 216E E5        INPU1:	PUSH	H		;SAVE TEXTP TO REDO
 216F 22BB41    	SHLD	TXTP2		;SAVE TEXTP TO SCAN VARLIST
 2172 3E3F      	MVI	A,'?'
 2174 CD2D15    	CALL	WRITC		;WRITE A ?
 2177 CD2B15    	CALL	WRTSP		;AND A SPACE
 217A 2ABD41    	LHLD	SAVTP
 217D 228242    	SHLD	TEXTP		;RESET TEXT POINTER IN CASE ^C TYPED
 2180 CD342E    	CALL	GTLIN		;GET INPUT LINE
 2183 CD9402    	CALL	FLIP		;TO SCAN VARLIST
                ;INPU2 GETS THE NEXT VARIABLE AND CHECKS ITS TYPE (STRING OR NONSTRING).
 2186 CDAA01    INPU2:	CALL	GTLHS		;GET DESTINATION
 2189 CD9402    	CALL	FLIP		;TO SCAN DATA
                	IF	STRNG
 218C FE03      	CPI	STRST
 218E C29A21    	JNZ	INPU3		;NONSTRING VARIABLE
 2191 CD6228    	CALL	EVUNQ		;GET STRING VALUE, PERHAPS UNQUOTED
 2194 DADB21    	JC	INPU7		;NO STRING, REDO
 2197 C3A521    	JMP	INPU4		;ASSIGN STRING VALUE TO DESTINATION
                	ENDIF
                ;INPU3 GETS A NONSTRING VALUE.
 219A CD3A18    INPU3:	CALL	GTLIT		;GET VALUE
 219D DADB21    	JC	INPU7		;REDO IF NONE
                	IF	STRNG
 21A0 FE03      	CPI	STRST		;CHECK IF STRING VALUE
 21A2 CADB21    	JZ	INPU7		;REDO IF SO
                	ENDIF
                ;INPU4 ASSIGNS A VALUE TO THE DESTINATION VARIABLE.
 21A5 CDC201    INPU4:	CALL	ASIGV		;ASSIGN VALUE TO DESTINATION
 21A8 CD6617    	CALL	GTCND		;LOOK FOR COMMA NOT FOLLOWED BY DELIMITER
 21AB DACC21    	JC	INPU6		;NO MORE DATA OR BAD ITEM
 21AE CD9402    	CALL	FLIP		;TO SCAN VARLIST
 21B1 CD5D17    	CALL	GTCOM		;LOOK FOR COMMA
 21B4 D28621    	JNC	INPU2		;CONTINUE WITH NEXT VAR IN VARLIST
 21B7 CDC116    	CALL	PRNTM		;ELSE PRINT EXCESS IGNORED
 21BA 4558434553	DB	'EXCESS IGNORED', CR, LF OR 80H
                ;INPU5 IS THE EXIT FROM A SUCCESSFUL INPUT.
 21CA E1        INPU5:	POP	H		;POP REDO POINTER
 21CB C9        	RET			;AND DONE
 21CC CD9C01    INPU6:	CALL	DTST0		;CHECK IF DELIMITER
 21CF DADB21    	JC	INPU7		;NO, REDO
 21D2 CD9402    	CALL	FLIP		;ELSE SCAN VARLIST
 21D5 CD5D17    	CALL	GTCOM		;SEE IF MORE VARS
 21D8 DACA21    	JC	INPU5		;NO, DONE
                ;INPU7 PRINTS REDO MESSAGE AND RETRIES AFTER BAD DATA.
 21DB CDC116    INPU7:	CALL	PRNTM		;MORE VARS THAN DATA, PRINT REDO MESSAGE
 21DE 524544CF  	DB	'RED', 'O' OR 80H
 21E2 E1        	POP	H
 21E3 C36E21    	JMP	INPU1		;RESET VARLIST POINTER AND TRY AGAIN
                
                ;[LET] <VAR REF> = <EXPR>
 21E6 CD4C17    LET0:	CALL	BAKUP		;BACK UP TEXTP TO GET CURRENT CHAR AGAIN
 21E9 CD9F01    	CALL	DTEST		;TEST IF DELIMITER
 21EC D0        	RNC			;NULL STATEMENT
                LET:	IF	CAMAC
                	CALL	GTCAM		;LOOK FOR CAMAC VARIABLE
                	JNC	LETCV		;PERFORM CAMAC LET
                	ENDIF
                	IF	WILD
                	MVI	D,WBUFT
                	CALL	GTD
                	JNC	WLETB		;BUFFER LEGAL LHS IN WILD VERSION
                	ENDIF
 21ED CDAA01    	CALL	GTLHS		;GET DESTINATION FOR ASSGN
 21F0 CD9317    LET1:	CALL	GTEQU		;SKIP = TOKEN -- FOR ENTRY POINT
 21F3 CD850B    	CALL	EVALS		;EVALUATE THE RHS
 21F6 C3C901    	JMP	ASIGN		;AND ASSIGN RHS TO LHS
                ;LETCV IS IN MODULE CAMAC
                
                ;LIST [<LINE #>] [, <LINE #>]
                	IF	COMPL
                LIST	EQU	UFERR		;UF ERROR IN COMPL VERSION
                	ELSE
 21F9 CD2E18    LIST:	CALL	GTLNO		;MIN LINE # TO DE, 0 IF NONE
 21FC CDC131    	CALL	FINDL		;LOOK FOR IT
 21FF E5        	PUSH	H		;SAVE MIN LINE LENGTH BYTE ADDRESS
 2200 CD5D17    	CALL	GTCOM		;SKIP THE COMMA, IF ANY
 2203 CD2E18    	CALL	GTLNO		;MAX LINE # TO DE, 0 IF NONE
 2206 DC6602    	CC	CPLD1		;COMPLEMENT TO GIVE DEFAULT MAX = 0FFFFH
 2209 CD8E01    	CALL	EOS		;CHECK FOR GARBAGE
 220C 42        	MOV	B,D
 220D 4B        	MOV	C,E		;MAX TO BC
 220E E1        	POP	H		;MIN LENGTH BYTE ADDRESS TO HL
 220F 7E        LIST1:	MOV	A,M		;FETCH LENGTH BYTE
 2210 B7        	ORA	A
 2211 C8        	RZ			;EOF -- DONE
 2212 23        	INX	H
 2213 5E        	MOV	E,M
 2214 23        	INX	H
 2215 56        	MOV	D,M		;LINE # OF CURRENT LINE TO DE
 2216 CD8002    	CALL	CMBDU		;COMPARE UNSIGNED TO MAX
 2219 D8        	RC			;MAX < (DE) -- RETURN
 221A 2B        	DCX	H		;POINT TO LINE #
 221B CDBF15    	CALL	CTEST		;LOOK FOR BREAK CHAR
 221E CD7B16    	CALL	PRNTL		;PRINT THE LINE
 2221 CD7115    	CALL	WCRLF		;AND CRLF
 2224 C30F22    	JMP	LIST1		;AND TRY NEXT
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                
                ;LOAD IS IN SECTION STATES4.
                
                ;MOVE {TO | FROM} <EXPR>
                ;MOVE PERFORMS A BLOCK MOVE OF A ROMSQ VERSION USER PROGRAM TO OR FROM RAM.
                ;THE SPECIFIED LOCATION MUST NOT OVERLAP EITHER BASIC OR USER RAM.
                	IF	ROMSQ AND (NOT WILD)
                	IF	COMPL
                MOVE	EQU	UFERR
                	ELSE
                MOVE:	CALL	GTCHA
                	PUSH	PSW		;SAVE TO | FROM TOKEN
                	CALL	GTEXP		;GET LOCATION
                	IF	CAMAC		;RAM TEST ONLY IN SEGMENTED CAMAC VERSIONS
                	LXI	D,RAMORG
                	ELSE
                	LXI	D,ROMORG	;BASE OF BASIC TO DE
                	IF	ROM		;CHECK IF WITHIN BASIC IN ROM VERSIONS
                	LXI	H,EORAM+1	;TOP OF BASIC + 1 TO HL
                	CALL	MVTST		;CHECK IF LOC WITHIN BASIC
                	LXI	D,RAMORG	;BASE OF USER RAM TO DE
                	ENDIF			;END OF ROM CONDITIONAL
                	ENDIF			;END OF NOT CAMAC CONDITIONAL
                	IF	CPM AND SDISK
                	LHLD	FILET		;TOP OF RAM IS (FILET) IN CP/M SDISK VERSIONS
                	ELSE
                	IF	STRNG
                	LHLD	STRT		;TOP OF RAM IS (STRT) IN STRNG VERSIONS
                	ELSE
                	LHLD	MEMT		;TOP OF RAM IS (MEMT) OTHERWISE
                	ENDIF
                	ENDIF
                	INX	H		;TOP OF USER RAM + 1 TO HL
                	MOV	A,H
                	ORA	L
                	CNZ	MVTST		;CHECK FOR LOC WITHIN USER RAM
                	POP	PSW		;RESTORE TOKEN
                	CPI	TOT
                	JNZ	MOVEF		;MUST BE FROM
                	PUSH	B		;SAVE DESTINATION
                	LXI	D,SRCAD-2
                	CALL	CPLDE		;2-SRCAD TO DE
                	LHLD	EOFAD
                	DAD	D		;LAST - FIRST + 1 = LENGTH
                	XCHG			;TO DE
                	POP	H		;DESTINATION TO HL
                	PUSH	H
                	PUSH	D		;SAVE DEST, LENGTH
                MOVE1:	CALL	RTEST		;CHECK IF RAM
                	JNZ	ROERR		;ROM, RO ERROR
                	INX	H
                	DCX	D
                	MOV	A,D
                	ORA	E
                	JNZ	MOVE1		;CHECK NEXT
                	LXI	B,SRCAD-1	;SOURCE TO BC
                	POP	D		;LENGTH TO DE
                	POP	H		;DESTINATION TO HL
                	JMP	MOVED		;BLOCK MOVE AND RETURN
                MOVEF:	CPI	FROMT
                	JNZ	SNERR		;NEITHER TO NOR FROM, SN ERROR
                	LDAX	B		;FETCH FIRST PROG CHAR
                	CPI	CR
                	JNZ	ROERR		;NOT A PROG, RO ERROR
                	PUSH	B
                	PUSH	B
                	PUSH	B
                	LHLD	SOURC
                	XTHL			;SAVE SOURC VALUE
                	INX	H		;POINT TO FIRST LENGTH BYTE
                	SHLD	SOURC
                	CALL	LAST		;LAST LOC TO BC
                	POP	H
                	SHLD	SOURC		;RESTORE SOURC
                	POP	D
                	CALL	CPLDE		;-FIRST TO DE
                	LHLD	SYMTA
                	XCHG			;-FIRST TO HL, SYMTA TO DE
                	DAD	B		;LAST-FIRST=LENGTH-1 TO HL
                	PUSH	H		;SAVE LENGTH FOR BLOCK MOVE
                	LXI	B,SRCAD
                	PUSH	B		;SAVE DESTINATION FOR BLOCK MOVE
                	DAD	B		;LAST NEEDED + 1 TO HL
                	CALL	CMDHU
                	JC	OMERR		;TOO BIG, OM ERROR
                	POP	H		;DESTINATION
                	POP	D		;LENGTH
                	POP	B
                	INX	B		;SOURCE
                	CALL	MOVED		;BLOCK MOVE INTO WORKING SPACE
                	DCX	H		;POINT TO NEW EOF
                	JMP	NEW1		;RESET STACKS AND EOFAD
                ;MVTST IS CALLED FROM MOVE TO ASSURE LOCATION SPECIFIED DOES NOT OVERLAP
                ;WITH XYBASIC OR WITH USER RAM.  ISSUES FATAL RO ERROR IF MIN <= LOC <= MAX.
                ;CALL:	BC	SPECIFIED LOCATION
                ;	DE	MIN
                ;	HL	MAX+1
                MVTST:	CALL	CMBDU
                	RC			;LOC < MIN
                	XCHG			;MAX+1 TO DE
                	CALL	CMBDU
                	RNC			;LOC >= MAX+1
                	JMP	ROERR		;ELSE FATAL RO ERROR
                
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                	ELSE
 0197 =         MOVE	EQU	EXERR		;EX ERROR IN NON-ROMSQ VERSIONS
                	ENDIF			;END OF ROMSQ CONDITIONAL
                
                ;NEW
                	IF	COMPL
                NEWCM	EQU	UFERR		;UF ERROR IN COMPL VERSION
                	ELSE
                NEWCM:	IF	ROMSQ
                	CALL	ISSRC		;CHECK IF ADDRESSING WORKING SPACE
                	ENDIF
 2227 CD7B01    	CALL	IITST		;NEW IS ILLEGAL INDIRECT
                	IF	SDISK
                	CALL	CLOSN		;CLOSE ANY OPEN FILES
                	ENDIF
 222A CD691D    NEW:	CALL	CLEA1		;CLEAR SYMBOL TABLE -- LOAD, INIT ENTRY POINT
 222D AF        	XRA	A
 222E 325040    	STA	TRACE		;TRACEOFF
 2231 324F40    	STA	TRAP		;TRAPON
 2234 218B42    	LXI	H,SRCAD
 2237 77        	MOV	M,A		;SOURCE TEXT EMPTY
 2238 E5        NEW1:	PUSH	H		;ADDLN, DMODX, MOVE FROM ENTRY POINT
 2239 CD401B    	CALL	STZAP		;RESET BREAK AND FN SYMBOL TABLE ENTRIES
 223C CD8D25    	CALL	RSTOR		;RESTORE THE READ POINTER
                	IF	NOT WILD
 223F CDB604    	CALL	DISAB		;DISABLE INTERRUPTS
                	ENDIF
 2242 E1        	POP	H
 2243 228642    	SHLD	EOFAD		;SET EOF ADDRESS -- LOAD ENTRY POINT
                	ENDIF			;END OF NOT COMPL CONDITIONAL
 2246 22C241    CSPST:	SHLD	CSTKP		;CLEAR CONTROL STACK -- CALL TO RESET IT
 2249 22C441    	SHLD	ESTKP		;RESET EXPR STACK POINTER
 224C C9        	RET
                
                ;NEXT [<VAR NAME> [, <VAR NAME>]* ]
                ;FIRST THE MOST RECENT CSTACK FOR ENTRY IS FOUND.
 224D 014F4F    NEXT:	LXI	B,(CSFOR SHL 8) OR CSFOR
 2250 CDCB1B    	CALL	CSDIG		;LOOK FOR CSTACK FOR ENTRY
 2253 DA0F23    	JC	NFERR		;NOT FOUND -- FATAL NF ERROR
 2256 E5        	PUSH	H		;SAVE FOR ENTRY ADDRESS
 2257 11FBFF    	LXI	D,-5
 225A 19        	DAD	D		;POINT TO VAR ADDRESS BYTES
 225B 46        	MOV	B,M
 225C 2B        	DCX	H
 225D 4E        	MOV	C,M		;FETCH VAR ADDR TO BC
 225E E5        	PUSH	H		;AND SAVE VAR ADDR POINTER
 225F 2A8242    	LHLD	TEXTP
 2262 22BD41    	SHLD	SAVTP		;SAVE TEXTP IN CASE RETRY NECESSARY
 2265 C5        	PUSH	B
 2266 CD6719    	CALL	FDVAR		;LOOK FOR VAR NAME AFTER NEXT
 2269 23        	INX	H
 226A C1        	POP	B
 226B DA8B22    	JC	NEXT1		;NO NAME
                ;NEXT <VAR NAME> SPECIFIED, SO THE FOR <VAR NAME> IS COMPARED TO IT.
 226E EB        	XCHG			;NEXT VAR ADDR DE, TYPE ADDR HL
 226F CD8002    	CALL	CMBDU		;COMPARE FOR AND NEXT <VAR NAME>S
 2272 CA9A22    	JZ	NEXT3		;FOR AND NEXT <VAR NAME>S MATCH
                ;<VAR NAME>S DO NOT MATCH, SO CSTACK FOR ENTRY IS POPED.
 2275 2ABD41    	LHLD	SAVTP
 2278 228242    	SHLD	TEXTP		;RESTORE TEXTP TO GET VAR NAME AGAIN
 227B E1        	POP	H
 227C E1        	POP	H		;FOR ENTRY ADDRESS TO HL
 227D 7E        	MOV	A,M		;TYPE/LENGTH BYTE TO  A
 227E 47        	MOV	B,A		;SAVED IN B
 227F E61F      	ANI	1FH		;MASK TO LENGTH
 2281 CD7902    	CALL	SBAHL		;ADDRESS NEXT ENTRY
 2284 78        	MOV	A,B		;TYPE/LENGTH RESTORED
 2285 CDDD1B    	CALL	CSRST		;PURGE THE FOR ENTRY FROM CSTACK
 2288 C34D22    	JMP	NEXT		;AND TRY AGAIN
                ;WHEN NO <VAR NAME> IS SPECIFIED AFTER NEXT, THE LAST CSTACK FOR ENTRY
                ;<VAR NAME> IS ASSUMED.  THE TYPE BYTE MUST BE FOUND FOR CORRECT TRACING.
 228B 2AC641    NEXT1:	LHLD	SYMTA
 228E CD061B    NEXT2:	CALL	STNXT		;ADDRESS NEXT SYMBOL TABLE ENTRY
 2291 EB        	XCHG
 2292 CD8002    	CALL	CMBDU		;COMPARE TO DESIRED VALUE ADDR
 2295 EB        	XCHG
 2296 D28E22    	JNC	NEXT2		;VAR ADDR >= NEXT ENTRY, TRY ANOTHER
 2299 EB        	XCHG			;TYPE BYTE ADDR TO HL
                ;AT NEXT3 THE DESIRED <VAR NAME> IS KNOWN.  THE STACK CONTAINS THE FOR ENTRY
                ;ADDR AND THE FOR ENTRY VAR ADDR, BC CONTAINS THE VAR ADDR, AND HL
                ;CONTAINS THE TYPE BYTE POINTER FOR THE SPECIFIED <VAR NAME>.
                ;THE TRACE INFO [<LINE #>]<VAR NAME> IS PRINTED IF DESIRED.
                NEXT3:	IF	FLOAT
 229A 7E        	MOV	A,M
 229B E61F      	ANI	1FH		;MASK TO TYPE
 229D 32BF41    	STA	LHSTY		;SAVE DESTINATION TYPE
                	ENDIF
                	IF	NOT COMPL
 22A0 3A5040    	LDA	TRACE
 22A3 B6        	ORA	M		;SIGN SET IFF TRACING
 22A4 325240    	STA	VTRAC		;SET VTRAC FOR ASSGN
 22A7 23        	INX	H		;POINT TO NAME
 22A8 F2B122    	JP	NEXT4		;NO TRACING DESIRED
 22AB CD6507    	CALL	BPRNT		;PRINT TRACE LINE #
 22AE CDB016    	CALL	PRTST		;PRINT VAR NAME
                	ENDIF
                ;AT NEXT4 THE BOUND & INCR POINTERS ARE FOUND IN PREPARATION FOR INCREMENTING,
                ;AND THE OLD VALUE IS REPLACE BY VALUE+INCREMENT.
 22B1 E1        NEXT4:	POP	H		;FOR ENTRY VAR ADDR POINTER TO HL
 22B2 11FCFF    	LXI	D,-FBYTS
 22B5 19        	DAD	D
 22B6 E5        	PUSH	H		;SAVE INCR POINTER
 22B7 E5        	PUSH	H
 22B8 19        	DAD	D
 22B9 E3        	XTHL			;SAVE BOUND POINTER, INCR POINTER TO HL
 22BA C5        	PUSH	B		;AND SAVE VAR ADDR
                	IF	FLOAT
 22BB 3ABF41    	LDA	LHSTY
 22BE FE01      	CPI	INTST
 22C0 CADD22    	JZ	NXT4I		;INTEGER FOR
                ;NOW FLOATING VALUE IS REPLACED BY OLD VALUE PLUS INCREMENT.
 22C3 C5        	PUSH	B
                	IF	F9511
                	CALL	LOD95		;INCR TO 9511 STACK
                	POP	H
                	CALL	LOD95		;VAR VALUE TO 9511 STACK
                	CALL	FADD		;ADD INCREMENT TO VAR VALUE
                	MVI	A,PTO95
                	CALL	O9511		;COPY STACKTOP
                	CALL	FET95		;FETCH RESULT FROM 9511 STACK
                	ELSE
 22C4 E3        	XTHL			;SAVE INCR ADDRESS, VAR ADDRESS TO HL
 22C5 CDEB0D    	CALL	FLOAD
 22C8 E1        	POP	H		;INCR ADDRESS TO HL
                	IF	FPBCD
                	CALL	FADD		;ADD VAR VALUE TO INCREMENT
                	ELSE
 22C9 CDEC10    	CALL	FINCR		;INSTEAD OF CALL FADD
 22CC CD1512    	CALL	ETEST		;PERFORM SIGNIFICANCE TEST
                	ENDIF
                	ENDIF
 22CF E1        	POP	H		;RESTORE VAR ADDR
                	IF	COMPL
                	IF	F9511
                	CALL	STO95		;RESULT TO VAR ADDR
                	ELSE
                	CALL	FSTOR		;RESULT TO VAR ADDR
                	ENDIF
                	ELSE			;NOT COMPL
 22D0 E5        	PUSH	H
                	IF	F9511
                	CALL	STO95		;RESULT TO VAR ADDR
                	ELSE
 22D1 CDBE0D    	CALL	FSTOR		;RESULT TO VAR ADDR
                	ENDIF
 22D4 E1        	POP	H		;RESTORE VAR ADDR FOR TRACING
 22D5 0602      	MVI	B,SNGST		;TYPE TO B
 22D7 CDE401    	CALL	TRVAL		;PRINT TRACE INFO IF DESIRED
                	ENDIF
 22DA C3EF22    	JMP	NEXT5
                	ENDIF
                ;INTEGER VALUE IS REPLACED BY OLD VALUE PLUS INCREMENT.
 22DD 4E        NXT4I:	MOV	C,M
 22DE 23        	INX	H
 22DF 46        	MOV	B,M		;INCR TO BC
 22E0 E1        	POP	H
 22E1 5E        	MOV	E,M
 22E2 23        	INX	H
 22E3 56        	MOV	D,M		;VALUE TO DE
 22E4 E5        	PUSH	H
 22E5 CD3A13    	CALL	IADD		;INTEGER ADD INCR+VALUE
 22E8 DCCC18    	CC	IOVER		;OVERFLOW, NONFATAL OV ERROR
 22EB E1        	POP	H
 22EC CDFE01    	CALL	ASIGI		;ASSIGN AND PRINT TRACE INFO IF DESIRED
                ;AT NEXT5 THE BOUND IS COMPARED TO THE VALUE TO TEST FOR LOOP TERMINATION.
 22EF E1        NEXT5:	POP	H		;BOUND POINTER TO HL
 22F0 D1        	POP	D		;INCR POINTER TO DE
 22F1 CDAD02    	CALL	BDTST		;TEST FOR COMPLETION CONDITION
 22F4 E1        	POP	H		;FOR ENTRY ADDR TO HL
 22F5 D2A61B    	JNC	CSPOP		;DON'T EXIT LOOP -- GET NEW TEXT ADDR & RETURN
                NEXT6:	IF	COMPL
                	LXI	D,-(2*FBYTS+7)	;- ENTRY LENGTH TO DE
                	ELSE
                ;BEFORE PURGING THE FOR-ENTRY THE CSTACK DIRECT COUNT MUST BE UPDATED.
 22F8 2B        	DCX	H
 22F9 7E        	MOV	A,M
 22FA 2B        	DCX	H
 22FB B6        	ORA	M		;CHECK LINE # OF FOR
 22FC CC011C    	CZ	DCSTD		;DECREMENT CSTKD IF DIRECT
 22FF 11F3FF    	LXI	D,-(2*FBYTS+5)
                	ENDIF
 2302 19        	DAD	D		;POINT TO NEXT ENTRY
 2303 3E4F      	MVI	A,CSFOR
 2305 CDDD1B    	CALL	CSRST		;RESET STACK POINTER
 2308 CD6617    NEXT7:	CALL	GTCND		;LOOK FOR COMMA
 230B D24D22    	JNC	NEXT		;DO ANOTHER NEXT IF COMMA
 230E C9        	RET
                NFERR:	ERROR	F, N, F		;FATAL NF ERROR
 230F+CDC616    	CALL	ERROF
 2312+4EC6      	DB	'N', 'F' OR 80H
                
                ;NULL <EXPR>
                	IF	NOT WILD
 2314 CDAA0B    NULL:	CALL	GTBEX		;GET BYTE-VALUE EXPR
 2317 79        	MOV	A,C
 2318 329940    	STA	NULLS		;VALUE TO NULLS
 231B C9        	RET
                	ENDIF			;END OF NOT WILD CONDITIONAL
                
                ;END OF STATES2
                	PAGE
                
                ;STATES3 12/05/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;STATEMENT ROUTINES FOR STATEMENTS ON THROUGH WAIT
                
                
                ;ON <EXPR> {GOTO | GOSUB} <LINE #> [, <LINE #>]*
 231C CD9D0B    ON:	CALL	GTEXP		;VALUE TO BC
 231F CD3B17    	CALL	GTCHA
 2322 FE93      	CPI	GOTOT
 2324 CA2D23    	JZ	ONGOT
 2327 FE94      	CPI	GSUBT
 2329 C29201    	JNZ	SNERR		;SN ERROR IF NOT GOTO OR GOSUB
 232C 37        	STC
 232D F5        ONGOT:	PUSH	PSW		;CARRY SET FOR GOSUB, RESET FOR GOTO
 232E 0B        	DCX	B		;VALUE - 1 TO BC
 232F 78        	MOV	A,B
 2330 B7        	ORA	A
 2331 03        	INX	B
 2332 C45023    	CNZ	ON3		;COUNT NEGATIVE OR BIG
 2335 CD2E18    ON1:	CALL	GTLNO		;LINE # TO DE
 2338 0D        	DCR	C		;DECREMENT COUNT
 2339 CA4523    	JZ	ON2		;DO CURRENT LINE #
 233C CD5D17    	CALL	GTCOM		;LOOK FOR COMMA
 233F D23523    	JNC	ON1		;KEEP GOING
 2342 CD5723    	CALL	ONERR		;NONFATAL ON ERROR IF LINE # LIST EXHAUSTED
 2345 CD9817    ON2:	CALL	GTDEL		;SCAN TO END OF STATEMENT
 2348 CD3E21    	CALL	GOTO2		;SET TEXTP AND LNNUM
 234B F1        	POP	PSW
 234C D0        	RNC			;DONE IF GOTO
 234D C32F21    	JMP	GOSU1		;ELSE BUILD GOSUB CONTROL STACK ENTRY
 2350 0E01      ON3:	MVI	C,1
 2352 FA5723    	JM	ONERR		;REPLACE NEGATIVE VALUES BY 1
 2355 0EFF      	MVI	C,255		;AND POSITIVE BY 255
                ONERR:	ERROR	N, O, N		;NONFATAL ON ERROR
 2357+CDD216    	CALL	ERRON
 235A+4FCE      	DB	'O', 'N' OR 80H
 235C C9        	RET			;AND RETURN
                
                ;OUT <EXPR>, <EXPR>
                	IF	NOT WILD
 235D CDAA0B    PUT:	CALL	GTBEX		;GET BYTE EXPRESSION
 2360 79        	MOV	A,C
 2361 320D40    	STA	WPORT + 1	;SET PORT #
 2364 CDA40B    	CALL	GTCBE		;GET COMMA, BYTE EXPR
 2367 79        	MOV	A,C
 2368 C30C40    	JMP	WPORT		;OUT IT AND RETURN
                	ENDIF			;END OF NOT WILD CONDITIONAL
                
                	IF	EPSTN
                ;PLOT <EXPR> [, <EXPR>]*
                PLOT:	LDA	COLUM		;FIND CURRENT COLUMN
                	PUSH	PSW		;AND SAVE
                PLOT1:	XRA	A
                	STA	COLUM		;CLEAR COLUMN COUNT
                	CALL	GTBEX		;GET BYTE VALUED EXPR
                	MOV	A,C
                	CALL	WRITC		;WRITE THE CHAR
                	CALL	GTCOM		;LOOK FOR COMMA
                	JNC	PLOT1		;MORE
                	POP	PSW
                	STA	COLUM		;RESTORE COLUMN COUNT
                	RET
                	ENDIF
                
                ;POKE <EXPR>, <EXPR>
                	IF	NOT WILD
 236B CD9D0B    POKE:	CALL	GTEXP
 236E C5        	PUSH	B		;SAVE LOCATION
 236F CDA40B    	CALL	GTCBE		;GET COMMA, BYTE EXPR
 2372 79        	MOV	A,C
 2373 C1        	POP	B
 2374 02        	STAX	B		;STORE DATA IN LOCATION
 2375 C9        	RET
                	ENDIF			;END OF NOT WILD CONDITIONAL
                
                ;{PRINT | ?} [@<EXPR>] [[<PRINT ITEM>] {, | ;}]* [<PRINT ITEM>]
                ;<PRINT ITEM> ::= [UNS | TAB | SPC] <EXPR> | <STRING> | <CAMVAR NAME>
                ;PRINT FIRST PUSHES A RETURN TO ITSELF, SO THE PRINT ROUTINES MAY BE CALLED
                ;AND SIMPLY RETURN.  THE ROUTINES FOR COMMA AND SEMICOLON CHECK FOR FOLLOWING
                ;DELIMITER, SO A DELIMITER FOUND AFTER ANY OTHER ITEM PRODUCES A CRLF.
                ;DPRIN IS IN MODULE SDISK.
                ;WILD PRINT IS IN MODULE WILD, AND CALLS PRIN0.
                	IF	NOT WILD
                PRINT:	IF	SDISK
                	CALL	GTSFN		;LOOK FOR FILE NUMBER
                	JNC	DPRIN		;PRINT TO FILE
                	ENDIF
                	ENDIF
 2376 017623    PRIN0:	LXI	B,PRIN0
 2379 C5        	PUSH	B		;PUSH COMMON RETURN TO PRINT MORE
 237A CD4917    	CALL	GTCHO		;LOOK AT NEXT CHAR
 237D FE22      	CPI	'"'		;LOOK FOR QUOTED STRING FIRST TO AVOID EVAL
 237F CA2A24    	JZ	PRQU0		;QUOTED STRING
                	IF	CAMAC
                	CPI	DRIVT
                	JZ	PRDRI		;PRINT DRIVER
                	CALL	GTCAM		;LOOK FOR CAMVAR NAME
                	JNC	PRCAM		;PRINT THE CAMVAR VALUE
                	ENDIF
 2382 CDE307    	CALL	EVAL		;LOOK FOR EXPRESSION
 2385 D2AC23    	JNC	PRVAL		;EXPRESSION FOUND, PRINT ITS VALUE
 2388 CD9F01    	CALL	DTEST
 238B CAA823    	JZ	PRDEL		;DELIMITER, PRINT CRLF AND EXIT
                	IF	NOT WILD	;ONLY ONE PRINT ITEM ALLOWED IN WILD VERSIONS
 238E CD5817    	CALL	READ1		;READ THE CHAR
 2391 FE2C      	CPI	','
 2393 CAC823    	JZ	PRCOM		;COMMA
 2396 FE3B      	CPI	SEMIC
 2398 CACB23    	JZ	PRSEM		;SEMICOLON
 239B FE11      	CPI	TABT
 239D CAF423    	JZ	PRTAB		;TAB
                	IF	NOT CAMAC
 23A0 FE12      	CPI	SPCT
 23A2 CA1D24    	JZ	PRSPC		;SPC
                	ENDIF
                	IF	NOT FLOAT	;UNS ALLOWED AS PRINT FN IN NONFLOAT VERSIONS
                	CPI	UNST
                	JZ	PRUNS
                	ENDIF
                	IF	NOT STRNG	;CHR$ ALLOWED AS PRINT FN IN NONSTRING VERSIONS
                	CPI	CHRST
                	JZ	PRCHR
                	ENDIF
                	ENDIF			;END OF NOT WILD CONDITIONAL
 23A5 C39201    	JMP	SNERR		;ELSE SN ERROR
                ;PRINT DELIMITER
 23A8 C1        PRDEL:	POP	B		;POP THE PRINT RETURN
 23A9 C37115    	JMP	WCRLF		;WRITE CRLF AND EXIT
                ;PRINT THE VALUE OF AN EVALUATED EXPRESSION
 23AC CD1802    PRVAL:	CALL	FETC1		;FETCH THE VALUE
                	IFTYP	PRSNG,PRSTR	;BRANCH IF NONINTEGER
 23AF+C23824    	JNZ	PRSNG
 23B2+DA1D16    	JC	PRSTR
 23B5 78        PRINV:	MOV	A,B
 23B6 B7        	ORA	A		;CHECK SIGN OF INTEGER VALUE
 23B7 F2C023    	JP	PRIV1		;PRINT UNSIGNED IF POSITIVE
                	IF	WILD
                	JMP	WRTBS
                	ELSE
 23BA CDED15    	CALL	WRTBS		;OTHERWISE WRITE SIGNED
 23BD C32515    	JMP	WRTS0		;WRITE TRAILING SPACE AND RETURN
                	ENDIF
 23C0 3E20      PRIV1:	MVI	A,' '		;LEADING SPACE TO A
                	IF	WILD
                	JMP	WRTB1
                	ELSE
 23C2 CDFC15    	CALL	WRTB1		;WRITE UNSIGNED WITH LEADING SPACE
 23C5 C32515    	JMP	WRTS0		;WRITE TRAILING SPACE AND RETURN
                	ENDIF
                	IF	NOT WILD
                ;COMMA, SPACE TO THE NEXT TAB STOP
 23C8 CDD123    PRCOM:	CALL	PRCO1		;DO THE COMMA
                				;AND FALL THROUGH TO PRSEM FOR DELIMITER TEST
                ;SEMICOLON
 23CB CD9C01    PRSEM:	CALL	DTST0		;CHECK IF NEXT CHAR IS DELIMITER
 23CE D8        	RC			;NONDELIMITER, CONTINUE PRINTING
 23CF C1        	POP	B		;ELSE POP THE PRINT RETURN
 23D0 C9        	RET			;AND EXIT FROM PRINT
 23D1 2A4940    PRCO1:	LHLD	COLUM
 23D4 7D        	MOV	A,L		;FETCH CURRENT COLUMN
 23D5 B7        	ORA	A
 23D6 C8        	RZ
                	IF	FLOAT		;COMMA COLUMN WIDTH IS 14 IF FLOATING
 23D7 010E00    	LXI	B,14		;COMMA COLUMN WIDTH TO BC
 23DA 68        	MOV	L,B		;0 TO L
 23DB F2E123    	JP	PRCO2		;COLUMN IS < 128 CURRENTLY
 23DE 2E7E      	MVI	L,126		;ELSE MAKE L 14*9
 23E0 95        	SUB	L		;AND REDUCE COLUMN ACCORDINGLY
 23E1 09        PRCO2:	DAD	B		;ADD COMMA WIDTH
 23E2 91        	SUB	C		;SUBTRACT COMMA WIDTH FROM COLUMN
 23E3 F2E123    	JP	PRCO2		;REPEAT UNTIL NEGATIVE
                	ELSE			;COMMA COLUMN WIDTH IS 8 IF NONFLOATING
                	ORI	7
                	INR	A		;COMPUTE DESIRED COLUMN
                	MOV	L,A		;SAVE COLUMN IN L
                	ENDIF
 23E6 7C        	MOV	A,H
 23E7 B7        	ORA	A
 23E8 7D        	MOV	A,L		;FETCH DESIRED COLUMN
 23E9 CAF023    	JZ	PRCO3		;WIDTH 0, SUPPRESS CR CHECK
 23EC BC        	CMP	H		;COMPARE TO WIDTH
 23ED D27115    	JNC	WCRLF		;WRITE CRLF IF >= WIDTH
 23F0 4F        PRCO3:	MOV	C,A
 23F1 C3F723    	JMP	PRTA1		;ELSE TAB TO COLUMN DESIRED
                ;UNS
                	IF	NOT FLOAT
                PRUNS:	CALL	GTEXP		;GET ARGUMENT
                	JMP	PRIV1
                	ENDIF
                ;TAB
 23F4 CD0824    PRTAB:	CALL	PRTA0		;GET ARG MOD WIDTH
 23F7 3A4940    PRTA1:	LDA	COLUM
 23FA B9        	CMP	C
 23FB C8        	RZ			;FOUND DESIRED COLUMN
 23FC CD0224    	CALL	PRTA2		;ELSE WRITE SPACES UNTIL THERE
 23FF C3F723    	JMP	PRTA1
 2402 DA2B15    PRTA2:	JC	WRTSP		;WRITE A SPACE IF LEFT OF DESIRED COLUMN
 2405 C37115    	JMP	WCRLF		;ELSE WRITE A CRLF
                ;PRTA0 EVALUATES <EXPR> MOD WIDTH FOR TAB AND SPC
 2408 CD9D0B    PRTA0:	CALL	GTEXP		;GET ARGUMENT
 240B 3A4A40    	LDA	WIDTH
 240E B7        	ORA	A		;ZERO SET IFF WIDTH 0
 240F 5F        	MOV	E,A
 2410 1600      	MVI	D,0
 2412 D5        	PUSH	D
 2413 C46613    	CNZ	OPMOD		;EVALUATE ARG MOD WIDTH UNLESS WIDTH 0
 2416 D1        	POP	D		;RESTORE WIDTH TO DE
 2417 78        	MOV	A,B
 2418 B7        	ORA	A		;CHECK IF ARG WAS NEGATIVE
 2419 FC3A13    	CM	IADD		;YES, ADD WIDTH TO RESULT TO MAKE POSITIVE
 241C C9        	RET
                ;SPC
                	IF	NOT CAMAC
 241D CD0824    PRSPC:	CALL	PRTA0		;GET ARG MOD WIDTH
 2420 79        	MOV	A,C
 2421 B7        	ORA	A
 2422 C8        PRSP1:	RZ			;DONE
 2423 CD2B15    	CALL	WRTSP		;ELSE WRITE A SPACE
 2426 0D        	DCR	C		;DECREMENT SPACE COUNT
 2427 C32224    	JMP	PRSP1		;AND REPEAT
                	ENDIF
                	ENDIF			;END OF NOT WILD CONDTIONAL
                ;QUOTED STRING
 242A CD5817    PRQU0:	CALL	READ1		;READ THE "
 242D 54        PRQUO:	MOV	D,H
 242E 5D        	MOV	E,L		;ADDRESS OF FIRST CHAR TO DE
 242F CDA717    	CALL	GTCLQ		;SCAN TO CLOSE QUOTE OR CR
 2432 7D        	MOV	A,L		;FETCH LAST+1 ADDRESS
 2433 93        	SUB	E		;LAST+1 - FIRST = # CHARS
 2434 4F        PRST0:	MOV	C,A		;TO C
 2435 C31D16    	JMP	PRSTR		;AND PRINT THE STRING
                	IF	NOT STRNG	;ALLOW CHR$ AS PRINT FN
                PRCHR:	CALL	GTBEX		;GET BYTE-VALUE EXPR
                	MOV	A,C
                	JMP	WRITC		;WRITE VALUE AND RETURN
                	ENDIF
                ;FLOATING POINT VALUE
                	IF	FLOAT
 2438 CDB60C    PRSNG:	CALL	FOUT		;CONVERT FACC TO STRING
                	IF	WILD
                	JMP	PRSTL
                	ELSE
 243B CD0816    	CALL	PRSTL		;WRITE THE STRING
 243E C32515    	JMP	WRTS0		;WRITE TRAILING SPACE AND RETURN
                	ENDIF
                	ENDIF
                ;PRCAM IS IN MODULE CAMAC.
                
                ;RANDOMIZE <EXPR>
                	IF	NOT WILD
 2441 CD9D0B    RNDIZ:	CALL	GTEXP
 2444 60        	MOV	H,B
 2445 69        	MOV	L,C		;VALUE TO HL
 2446 229740    	SHLD	RANDX		;AND IT BECOMES NEW SEED
 2449 C9        	RET
                	ENDIF			;END OF NOT WILD CONDITIONAL
                
                ;READ <VAR LIST>
                ;READ MUST SCAN THE COMMAND LINE READ <VAR LIST> AND LINES OF DATA [<EXPR>,]*.
                ;THE TEXT POINTERS ARE KEPT IN TEXTP AND TXTP2 AND EXCHANGED BY FLIP.
 244A 2A8442    READ:	LHLD	RDPTR
 244D 22BB41    	SHLD	TXTP2		;READ POINTER TO TXTP2
 2450 CDAA01    READA:	CALL	GTLHS		;GET DESTINATION FOR ASSGN
                	IF	STRNG
 2453 F5        	PUSH	PSW		;SAVE VAR TYPE IN STRING VERSION
                	ENDIF
 2454 CD9402    	CALL	FLIP		;TO SCAN DATA
 2457 CD6617    	CALL	GTCND		;SEE IF COMMA (IN DATA <LIT>,<LIT>...) NEXT
 245A DC8224    	CC	READE		;NO, FIND NEXT DATA STATEMENT
                	IF	STRNG
 245D F1        	POP	PSW		;RESTORE VAR TYPE
 245E FE03      	CPI	STRST
 2460 C26924    	JNZ	READB		;NOT A STRING VAR
 2463 CD6228    	CALL	EVUNQ		;STRING VAR, GET VALUE (POSSIBLY UNQUOTED)
 2466 C36F24    	JMP	READD
                	ENDIF
 2469 CD3A18    READB:	CALL	GTLIT		;LOOK FOR VALUE
 246C DA9C24    	JC	READF		;NO VALUE FOUND
 246F CDC201    READD:	CALL	ASIGV		;ASSIGN VALUE TO VARIABLE
 2472 CD9402    	CALL	FLIP		;TO SCAN VARLIST
 2475 CD5D17    	CALL	GTCOM		;LOOK FOR COMMA
 2478 D25024    	JNC	READA		;READ ANOTHER
 247B 2ABB41    	LHLD	TXTP2		;ELSE RECOVER NEW RDPTR
 247E 228442    	SHLD	RDPTR		;AND STORE IT
 2481 C9        	RET			;AND DONE
                ;READE FINDS THE NEXT DATA STATEMENT.
                ;ISSUES NONFATAL OD ERROR AND RETRIES IF NO MORE DATA.
                ;ISSUES FATAL SN ERROR IF SN ERROR IN DATA.
 2482 CD9C01    READE:	CALL	DTST0		;CHECK IF AT DELIMITER
 2485 DA9C24    	JC	READF		;NO -- SN ERROR IN DATA
 2488 069B      	MVI	B,DATAT
 248A CDD102    	CALL	FNDST		;FIND NEXT DATA
 248D D0        	RNC			;OK IF FOUND
                	ERROR	N, O, D		;NONFATAL OD ERROR
 248E+CDD216    	CALL	ERRON
 2491+4FC4      	DB	'O', 'D' OR 80H
 2493 CD8D25    	CALL	RSTOR		;DO A RESTORE
 2496 228242    	SHLD	TEXTP
 2499 C38224    	JMP	READE		;AND TRY AGAIN
                ;READF ISSUES FATAL SN ERROR FOR BAD DATA ITEMS.
 249C EB        READF:	XCHG			;DATA TEXTP TO DE
 249D CD2003    	CALL	FNDLN		;FIND ITS LINE NUMBER
 24A0 224B40    	SHLD	LNNUM		;RESET LINE # FOR ERROR MESSAGE
                	ERROR	F, S, N		;FATAL SN ERROR
 24A3+CDC616    	CALL	ERROF
 24A6+53CE      	DB	'S', 'N' OR 80H
                
                ;REM <UNQUOTED STRING>
 24A8 CD3B17    REM:	CALL	GTCHA
 24AB FE0D      	CPI	CR
 24AD C2A824    	JNZ	REM		;SCAN TO <CR>
 24B0 CD4C17    	CALL	BAKUP		;BACK UP TEXT POINTER
 24B3 23        	INX	H		;LET HL POINT TO NEXT BYTE IN CASE ON-LINE
 24B4 C9        	RET
                
                ;RENUM [<LINE #> [, <LINE #> [, <LINE #>]]]
                	IF	EDITC
                	IF	COMPL
                RENUM	EQU	UFERR
                	ELSE
                ;RENU0 GETS AN OPTIONAL COMMA FOLLOWED BY <LINE #>, DEFAULT VALUE FROM DE.
 24B5 CD6617    RENU0:	CALL	GTCND		;LOOK FOR COMMA
 24B8 D42E18    	CNC	GTLNO		;IF COMMA LOOK FOR <LINE #>
 24BB EB        	XCHG			;TO HL
 24BC C9        	RET			;AND RETURN
                ;FIRST RENUM MUST GET ARGUMENTS.
                ;RNOLD GETS THE OLD LINE # OF FIRST RENUMBERED LINE,
                ;RNNEW GETS THE NEW LINE # OF FIRST RENUMBERED LINE, AND
                ;RNINC GETS THE RENUMBERING INCREMENT.
                RENUM:	IF	ROMSQ
                	CALL	ISSRC		;MUST BE ADDRESSING WORKING SPACE
                	ENDIF
 24BD CD2E18    	CALL	GTLNO		;LOOK FOR <LINE #>
 24C0 D2C724    	JNC	RENU1		;<LINE #> GIVEN
 24C3 CDC131    	CALL	FINDL		;NONE GIVEN -- LOOK FOR LINE 0
 24C6 37        	STC			;TO SKIP FOLLOWING FDLNO
 24C7 D4E331    RENU1:	CNC	FDLNO		;FIND THE SPECIFIED LINE #
 24CA E5        	PUSH	H		;SAVE FIRST RENUMBERED LINE LOCATION
 24CB CD5502    	CALL	MODEM		;LINE # OF FIRST RENUMBERED LINE TO DE
 24CE D5        	PUSH	D		;AND SAVED
 24CF EB        	XCHG
 24D0 22AE40    	SHLD	RNOLD		;AND SAVED IN RNOLD
 24D3 110A00    	LXI	D,10		;DEFAULT ARG2 IS 10
 24D6 CDB524    	CALL	RENU0		;GET INCREMENT
 24D9 7C        	MOV	A,H
 24DA B5        	ORA	L
 24DB CA3518    	JZ	USERR		;FATAL US ERROR IF 0 (E.G., RENUM 10,,)
 24DE 22AC40    	SHLD	RNINC		;INCREMENT SAVED IN RNINC
 24E1 E3        	XTHL			;SAVE INCREMENT, FIRST LINE LINE # TO HL
 24E2 EB        	XCHG			;AND THEN TO DE AS DEFAULT ARG3
 24E3 CDB524    	CALL	RENU0		;GET DESTINATION <LINE #>
 24E6 22AA40    	SHLD	RNNEW		;AND SAVED IN RNNEW
 24E9 EB        	XCHG			;DESTINATION TO DE
 24EA CD7B01    	CALL	IITST		;RENUM ILLEGAL INDIRECT
                ;NOW TEST IF THE SPECIFIED ARGS GIVE TOO LARGE A MAX <LINE #>.
 24ED C1        	POP	B		;INCREMENT TO BC
 24EE E1        	POP	H		;LOCATION TO HL
 24EF C5        	PUSH	B
 24F0 D5        	PUSH	D
 24F1 E5        	PUSH	H		;SAVE ARGS
 24F2 7E        	MOV	A,M		;FETCH LENGTH
 24F3 CD7202    	CALL	ADAHL		;ADDRESS SECOND LINE
 24F6 7E        RENU2:	MOV	A,M		;FETCH LENGTH
 24F7 B7        	ORA	A
 24F8 CA0725    	JZ	RENU3		;EOF
 24FB CD7202    	CALL	ADAHL		;ADDRESS NEXT LINE
 24FE EB        	XCHG
 24FF 09        	DAD	B		;COMPUTE ITS EVENTUAL LINE #
 2500 EB        	XCHG
 2501 D2F624    	JNC	RENU2		;CONTINUE IF NO OVERFLOW
 2504 C33518    	JMP	USERR		;TOO LARGE, US ERROR
                ;NOW TEST IF LAST LINE # BEFORE FIRST IS < NEW FIRST.
 2507 010000    RENU3:	LXI	B,0		;LAST LINE BEFORE FIRST INITIALLY 0
 250A D1        	POP	D		;FIRST LINE # LENGTH BYTE ADDRESS TO DE
 250B 218B42    	LXI	H,SRCAD		;START AT BEGINNING OF SOURCE TEXT
 250E CD8602    RENU4:	CALL	CMDHU		;COMPARE FIRST TO CURRENT
 2511 CA2125    	JZ	RENU5		;MATCHED, BC NOW HAS LAST
 2514 23        	INX	H
 2515 4E        	MOV	C,M
 2516 23        	INX	H
 2517 46        	MOV	B,M		;LINE NUMBER TO BC
 2518 2B        	DCX	H
 2519 2B        	DCX	H
 251A 7E        	MOV	A,M		;FETCH LENGTH BYTE
 251B CD7202    	CALL	ADAHL		;ADDRESS NEXT
 251E C30E25    	JMP	RENU4		;AND TRY IT
 2521 D1        RENU5:	POP	D		;NEW FIRST LINE # TO DE
 2522 D5        	PUSH	D		;AND RESAVE
 2523 CD8002    	CALL	CMBDU		;COMPARE TO LINE # BEFORE FIRST
 2526 D23518    	JNC	USERR		;US ERROR IF PREVIOUS IS LARGER
 2529 2A8242    	LHLD	TEXTP
 252C E5        	PUSH	H		;SAVE TEXTP
 252D CD3503    	CALL	LNREF		;CHANGE <LINE #> REFERENCES IN SOURCE TEXT
 2530 E1        	POP	H
 2531 228242    	SHLD	TEXTP
                ;NOW CHANGE THE ACTUAL <LINE #>S.
 2534 2AAE40    	LHLD	RNOLD
 2537 EB        	XCHG			;RNOLD TO DE
 2538 CDC131    	CALL	FINDL		;FIND (POSSIBLY NEW) LOCATION OF FIRST CHANGED
 253B D1        	POP	D		;RNNEW TO DE
 253C C1        	POP	B		;RNINC TO BC
 253D 7E        RENU6:	MOV	A,M		;FETCH LENGTH OF NEXT LINE
 253E B7        	ORA	A
 253F CA5225    	JZ	RENU7		;ALL LINE NUMBERS CHANGED
 2542 E5        	PUSH	H		;SAVE CURRENT LENGTH BYTE ADDRESS
 2543 CD7202    	CALL	ADAHL		;ADDRESS NEXT LINE
 2546 E3        	XTHL			;SAVE NEXT, RECOVER CURRENT
 2547 23        	INX	H
 2548 73        	MOV	M,E
 2549 23        	INX	H
 254A 72        	MOV	M,D		;CHANGE THE LINE NUMBER
 254B E1        	POP	H		;NEXT LINE LENGTH BYTE ADDRESS TO HL
 254C EB        	XCHG
 254D 09        	DAD	B
 254E EB        	XCHG			;UPDATE LINE NUMBER
 254F C33D25    	JMP	RENU6		;AND RENUMBER MORE
                ;CHECK BREAK BYTES FOR FLAG INDICATING ILLEGAL <LINE #> IN LINE.
 2552 0600      RENU7:	MVI	B,0		;CLEAR BAD LINE FLAG
 2554 218B42    	LXI	H,SRCAD		;BEGIN AT THE BEGINNING
 2557 7E        RENU8:	MOV	A,M
 2558 B7        	ORA	A
 2559 CA7725    	JZ	RENUX		;EOF, DONE
 255C E5        	PUSH	H		;SAVE LENGTH BYTE LOC
 255D 23        	INX	H
 255E 23        	INX	H		;SKIP LINE # BYTES
 255F 23        	INX	H		;AND ADDRESS BREAK BYTE
 2560 7E        	MOV	A,M		;FETCH IT
 2561 B7        	ORA	A		;CHECK BIT 7
 2562 F26F25    	JP	RENU9		;OK IF NOT SET
 2565 2B        	DCX	H
 2566 2B        	DCX	H		;ADDRESS LINE # BYTE
 2567 CD7B16    	CALL	PRNTL		;PRINT THE BAD LINE
 256A CD7115    	CALL	WCRLF		;AND CRLF
 256D 06FF      	MVI	B,255		;AND SET BAD LINE FLAG
 256F E1        RENU9:	POP	H
 2570 7E        	MOV	A,M		;REFETCH LENGTH
 2571 CD7202    	CALL	ADAHL		;ADDRESS NEXT LINE
 2574 C35725    	JMP	RENU8		;AND TRY NEXT LINE
 2577 C5        RENUX:	PUSH	B		;SAVE BAD LINE FLAG
 2578 CD9431    	CALL	ADDL3		;TEXT MAY HAVE MOVED, RESET STACKS
 257B F1        	POP	PSW		;RECOVER BAD LINE FLAG
 257C B7        	ORA	A
 257D C8        	RZ			;SUCCESSFUL RENUM
 257E C33518    	JMP	USERR		;ELSE US ERROR MESSAGE
                	ENDIF
                	ELSE
                RENUM	EQU	EXERR		;EX ERROR IN NON-EDITC VERSIONS
                	ENDIF
                
                ;RESTORE [<LINE #>]
 2581 CD2E18    RESTR:	CALL	GTLNO		;LOOK FOR LINE #
 2584 DA8D25    	JC	RSTOR		;NONE, TAKE LEAST
 2587 CDE331    	CALL	FDLNO		;FIND THE LINE
 258A C39025    	JMP	RSTO1		;AND RESET THE READ POINTER
                RSTOR:	IF	ROMSQ
                	LHLD	SOURC
                	ELSE
 258D 218B42    	LXI	H,SRCAD
                	ENDIF
 2590 2B        RSTO1:	DCX	H		;POINT TO <CR> PRECEDING LINE
 2591 228442    	SHLD	RDPTR		;LET READ POINTER ADDRESS <CR>
 2594 C9        	RET
                
                ;RETURN
 2595 CD8E01    RETRN:	CALL	EOS		;END OF STATEMENT TEST
 2598 018725    	LXI	B,(CSGOS SHL 8) OR CSINT
 259B CDCB1B    	CALL	CSDIG		;LOOK FOR GOSUB OR INTERRUPT CSTACK ENTRY
 259E DAB425    	JC	RGERR		;NOT FOUND -- RG ERROR
 25A1 CDA61B    	CALL	CSPOP		;POP CSTACK INFORMATION
 25A4 B8        	CMP	B		;ZERO SET IF GOSUB, RESET INTERRUPT
 25A5 CADD1B    	JZ	CSRST		;GOSUB ENTRY -- RESET STACK & RETURN
 25A8 F5        	PUSH	PSW
 25A9 CD4B02    	CALL	MVDEM		;INTERRUPT TABLE BYTE ADDR TO DE
 25AC 1A        	LDAX	D
 25AD F640      	ORI	40H		;RESUME INTERRUPT
 25AF 12        	STAX	D
 25B0 F1        	POP	PSW
 25B1 C3DD1B    	JMP	CSRST		;RESET CONTROL STACK AND RETURN
                RGERR:	ERROR	F, R, G		;FATAL RG ERROR
 25B4+CDC616    	CALL	ERROF
 25B7+52C7      	DB	'R', 'G' OR 80H
                
                ;RUN [<LINE #>]
                	IF	COMPL
                RUN	EQU	UFERR		;UF ERROR IF COMPL VERSION
                	ELSE
                RUN:	IF	SDISK
                	CALL	CLOSN		;CLOSE ANY OPEN FILES
                	ENDIF
                	IF	CAMAC AND FALSE	;NORTHSTAR VERSION
                	CALL	CLOSE		;CLOSE ANY OPEN FILES
                	ENDIF
 25B9 CD2E18    	CALL	GTLNO		;LOOK FOR LINE #
 25BC F5        	PUSH	PSW
 25BD D5        	PUSH	D
 25BE CD7B01    	CALL	IITST		;RUN ILLEGAL INDIRECT
 25C1 CD691D    	CALL	CLEA1		;CLEAR CSTACK, SYMBOL TABLE, STRING SPACE
                	IF	NOT WILD
 25C4 CDB604    	CALL	DISAB		;DISABLE INTERRUPTS
                	ENDIF
 25C7 CD8D25    	CALL	RSTOR		;RESTORE READ POINTER
 25CA D1        	POP	D
 25CB F1        	POP	PSW
 25CC D23E21    	JNC	GOTO2		;LINE # SPECIFIED, EXECUTE FROM THERE
 25CF 228242    	SHLD	TEXTP		;ELSE POINT TO <CR> BEFORE SOURCE TEXT
 25D2 C9        	RET			;AND EXECUTE FROM THERE
                	ENDIF
                
                ;SAVE IS IN SECTION STATES4.
                
                ;SCALL <EXPR> [, <INTEGER VAR REF>]*
                ;SCALL LOADS BC, DE AND HL WITH THE VALUES OF THE <INTEGER VAR REF>S, IF ANY,
                ;AND BRANCHES TO THE <EXPR> ADDRESS.  WHEN THE USER ROUTINE RETURNS,
                ;THE VALUES IN BC, DE AND HL ARE ASSIGNED TO THE <INTEGER VAR REF>S.
 25D3 CD9D0B    SCALL:	CALL	GTEXP
 25D6 2A8242    	LHLD	TEXTP
 25D9 22BD41    	SHLD	SAVTP		;SAVE TEXTP FOR RESCAN ON RETURN
 25DC 210526    	LXI	H,SRETN
 25DF E5        	PUSH	H		;RETURN ADDRESS TO STACK
 25E0 C5        	PUSH	B		;BRANCH ADDRESS TO STACK
 25E1 110300    	LXI	D,3		;MAXIMUM PARAMETER COUNT TO DE
 25E4 CD6617    SCAL1:	CALL	GTCND		;LOOK FOR COMMA NOT FOLLOWED BY DELIMITER
 25E7 DA0026    	JC	SCAL2		;NONE, SET UP REGISTERS AND BRANCH TO USER
 25EA CD291A    	CALL	GTIVA		;PERFORM INTEGER VAR REF
 25ED DA9B04    	JC	MCERR		;NOT A VAR REF
 25F0 C5        	PUSH	B		;SAVE PARAMETER VALUE
 25F1 1D        	DCR	E		;DECREMENT PARAMETER COUNT
 25F2 C2E425    	JNZ	SCAL1		;GET MORE PARAMETERS IF NOT THREE ALREADY
 25F5 CD6617    	CALL	GTCND		;CHECK IF MORE PARAMETERS
 25F8 DA0026    	JC	SCAL2		;NO MORE
                	ERROR	N, M, C		;NONFATAL MC ERROR IF TOO MANY
 25FB+CDD216    	CALL	ERRON
 25FE+4DC3      	DB	'M', 'C' OR 80H
                ;AT SCAL2, DE CONTAINS 3 - # PARAMETERS SPECIFIED, AND THE PARAMETER VALUES
                ;ARE PUSHED.  BY ADDING DE TO THE ADDRESS POP3, THE BRANCH ADDRESS
                ;IS COMPUTED TO POP 3, 2, 1 OR 0 VALUES BEFORE BRANCHING TO THE USER ROUTINE.
 2600 21A108    SCAL2:	LXI	H,POP3
 2603 19        	DAD	D		;COMPUTE POP ADDRESS
 2604 E9        	PCHL			;BRANCH TO IT
                ;SRETN IS THE ENTRY POINT FROM THE USER ROUTINE'S RETURN.
 2605 E5        SRETN:	PUSH	H
 2606 D5        	PUSH	D
 2607 C5        	PUSH	B		;SAVE REGISTERS
 2608 2ABD41    	LHLD	SAVTP
 260B 228242    	SHLD	TEXTP		;RESTORE TEXTP
 260E 110000    	LXI	D,0		;# OF POPED REGISTERS TO DE
 2611 CD6617    SRET1:	CALL	GTCND		;LOOK FOR COMMA
 2614 DA0026    	JC	SCAL2		;DONE, POP EXTRAS AND RETURN
 2617 1C        	INR	E		;INCREMENT POPED COUNT
 2618 3E03      	MVI	A,3
 261A BB        	CMP	E
 261B DA7306    	JC	NEXTC		;TOO MANY, SCAN TO END AND RETURN
 261E D5        	PUSH	D
 261F CDAA01    	CALL	GTLHS		;GET DESTINATION
 2622 23        	INX	H		;POINT TO HIGH ORDER DESTINATION
 2623 D1        	POP	D
 2624 C1        	POP	B		;VALUE TO BC
 2625 CDFE01    	CALL	ASIGI		;ASSIGN INTEGER VALUE, TRACED
 2628 C31126    	JMP	SRET1		;AND  REPEAT
                
                ;SETTIME <EXPR> [, <EXPR>] [, <EXPR>]
                	IF	REALT AND NOT CAMAC	;SETTIME IN REALT VERSIONS ONLY
                STTIM:	LXI	H,TIMEX+3	;HL ADDRESSES HOUR COUNT
                	LXI	D,24		;MAX # HOURS
                	ORA	A		;RESET CARRY
                	CALL	STTI2		;GET HOURS COUNT AND SET CLOCK
                	LXI	D,60		;MAX # MINUTES OR SECONDS
                	CALL	STTI1		;GET MINUTES COUNT AND SET CLOCK
                	CALL	STTI1		;GET SECONDS COUNT AND SET CLOCK
                	DCX	H
                	MVI	M,255 AND -20	;RESET 20THS COUNT
                	RET
                STTI1:	DCX	H		;POINT TO NEXT TIME COMPONENT
                	PUSH	H
                	CALL	GTCND		;LOOK FOR COMMA
                	POP	H
                	LXI	B,0		;DEFAULT TO 0 IF UNSPECIFIED
                STTI2:	CNC	GTEXP		;GET DESIRED COUNT
                	CALL	CMBDU		;COMPARE TO MAX
                	CNC	FCER0		;TOO BIG, NONFATAL FC ERROR AND RETURN 0
                	MOV	A,C		;FETCH COUNT
                	SUB	E		;SUBTRACT BIAS
                	MOV	M,A		;AND STORE TO SET CLOCK
                	RET
                	ENDIF
                
                ;STOP
                	IF	COMPL		;STOP BOOTS IN COMPL VERSION
                	IF	WILD
                STOP	EQU	UFERR		;UF ERROR IN WILD RTPAK
                	ELSE
                STOP	EQU	BOOT
                	ENDIF
                	ELSE
 262B 3E65      STOP:	MVI	A,CSBRK		;BREAK TOKEN TO A
 262D F5        STOP1:	PUSH	PSW		;LINE BREAK ENTRY POINT
 262E CD6301    	CALL	LINBC		;LINE # TO BC
 2631 CA4B06    	JZ	DMOD2		;DIRECT MODE -- DO NOT SAVE INFO
 2634 CDBD16    	CALL	PRTM0		;TURN ON OMODE, PRINT BREAK MESSAGE
 2637 0D0A425245	DB	CR, LF, 'BREAK AT LINE', ' ' OR 80H
 2647 CDFB15    	CALL	WRTBU		;PRINT LINE # UNSIGNED
 264A F1        	POP	PSW
 264B CD6C1B    STOP2:	CALL	CPUSH		;BREAK INFO TO CONTROL STACK -- END ENTRY POINT
 264E C34B06    	JMP	DMOD2		;AND CONTINUE IN DMODE
                	ENDIF			;END OF COMPL CONDITIONAL
                
                ;TIME
                	IF	(NOT CAMAC) AND (NOT REALT)
 2651 3E07      TIME:	MVI	A,CNTLG
 2653 CD2D15    	CALL	WRITC		;RING A BELL
 2656 210000    	LXI	H,0
 2659 CD8915    	CALL	READC		;GET AND IGNORE FIRST CHAR
 265C CD741E    	CALL	TIMER
 265F D29701    	JNC	EXERR		;COUNTED TO 0 -- EX ERROR
 2662 CDBF15    	CALL	CTEST		;READ THE CHAR TIMER SAW
 2665 E5        	PUSH	H		;SAVE MINUTE COUNT
 2666 7C        	MOV	A,H
 2667 320840    	STA	TIMEX+4		;MINUTE COUNT / 256 TO TIMEX+4
 266A 44        	MOV	B,H
 266B 4D        	MOV	C,L
 266C 113C00    	LXI	D,60
 266F CD9811    	CALL	DIVD0		;MIN COUNT / 60 = SEC COUNT TO HL
 2672 D1        	POP	D
 2673 CD6502    	CALL	CPLDE		;COMPLEMENT MINUTE COUNT
 2676 EB        	XCHG
 2677 220440    	SHLD	TIMEX		;COMPLMENTED MINUTE COUNT TO TIMEX
 267A CD6502    	CALL	CPLDE		;COMPLEMENT SECOND COUNT
 267D EB        	XCHG
 267E 220640    	SHLD	TIMEX+2		;COMPLEMENTED SECOND COUNT TO TIMEX+2
 2681 C9        	RET
                	ENDIF
                
                ;TRACE | UNTRACE
                ;TRAP | UNTRAP
                	IF	COMPL
                TCON	EQU	UFERR		;UF ERROR IF COMPL VERSION
                TCOFF	EQU	UFERR
                TPON	EQU	UFERR
                TPOFF	EQU	UFERR
                	ELSE
 2682 37        TCON:	STC
 2683 9F        TCOFF:	SBB	A		;A GETS 0 IF NO CARRY, 255 IF CARRY
 2684 325040    	STA	TRACE
 2687 C9        	RET
 2688 37        TPOFF:	STC
 2689 9F        TPON:	SBB	A
 268A 324F40    	STA	TRAP
 268D C9        	RET
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                
                ;UNBREAK [<LINE #> | <VAR LIST>]
                ;UNBREAK REMOVES ALL BREAKPOINTS.
                ;UNBREAK <LINE #> REMOVES THE BREAKPOINT (IF ANY) ON THE SPECIFIED LINE.
                ;UNBREAK <VAR LIST> REMOVES BREAKPOINTS ON THE SPECIFIED VARIABLES.
                	IF	COMPL
                UNBRK	EQU	UFERR		;UF ERROR IF COMPL VERSION
                	ELSE
 268E CD2E18    UNBRK:	CALL	GTLNO		;SEE IF LINE # PRESENT
 2691 DA9D26    	JC	UNBR2		;NO
                ;REMOVE BREAKPOINT FROM LINE # IN DE.
                	IF	ROMSQ
                	CALL	ISROM		;MUST BE RUNNING IN RAM
                	ENDIF
 2694 CDE331    	CALL	FDLNO		;FIND THE LINE
                ;UNBR1 REMOVES THE BREAKPOINT ON LINE ADDRESSED BY HL.
 2697 23        UNBR1:	INX	H		;MOVE POINTER FROM LENGTH BYTE
 2698 23        	INX	H		;   PAST LINE #
 2699 23        	INX	H		;   TO BREAK BYTE
 269A 3600      	MVI	M,0		;AND ZERO IT
 269C C9        	RET
 269D CD9F01    UNBR2:	CALL	DTEST		;SEE IF VAR LIST PRESENT
 26A0 DAB326    	JC	UBVAR		;YES
 26A3 2AC641    	LHLD	SYMTA		;NO, UNBREAK ALL LINES AND VARIABLES
                ;UNBR3 REMOVES ALL VARIABLE BREAKPOINTS.
 26A6 CD061B    UNBR3:	CALL	STNXT		;GET NEXT SYMBOL TABLE ENTRY
 26A9 DA5B1B    	JC	UNBKL		;END OF TABLE -- UNBREAK LINES AND RETURN
 26AC 1A        	LDAX	D
 26AD E67F      	ANI	7FH
 26AF 12        	STAX	D		;UNBREAK ONE ENTRY
 26B0 C3A626    	JMP	UNBR3
                ;UBVAR REMOVES BREAKPOINTS ON THE SPECIFIED <VAR LIST> VARIABLES.
 26B3 CD6719    UBVAR:	CALL	FDVAR		;FIND VAR REF
 26B6 DA9201    	JC	SNERR
 26B9 1A        	LDAX	D
 26BA E67F      	ANI	7FH
 26BC 12        	STAX	D		;UNBREAK IT
 26BD CD6617    	CALL	GTCND		;LOOK FOR COMMA
 26C0 D2B326    	JNC	UBVAR		;UNBREAK ANOTHER VAR
 26C3 C9        	RET
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                
                ;UNTRACE AND UNTRAP ARE UNDER TRACE AND TRAP ABOVE.
                
                ;WAIT <BYTE EXPR> , <BYTE EXPR> [, <BYTE EXPR>] [,$]
                	IF	NOT WILD
 26C4 CDBE04    WAIT:	CALL	IINFO		;GET INTERRUPT INFO
 26C7 79        	MOV	A,C
 26C8 17        	RAL
 26C9 17        	RAL
 26CA 4F        	MOV	C,A		;$ BIT TO C7
 26CB 78        	MOV	A,B		;PORT # TO A
 26CC CD4511    	CALL	RDP1		;READ
 26CF B3        	ORA	E		;MASK
 26D0 AA        	XRA	D		;COMPARE
 26D1 CAD526    	JZ	WAIT1
 26D4 37        	STC			;CARRY SET IFF COMPARE NONZERO
 26D5 1F        WAIT1:	RAR			;A7 SET IFF COMPARE NONZERO
 26D6 A9        	XRA	C		;SIGN SET IFF KEEP WAITING
 26D7 F0        	RP			;CONDITION FULFILLED -- RETURN
 26D8 2ABD41    	LHLD	SAVTP
 26DB 228242    	SHLD	TEXTP		;RESET TEXT POINTER TO PARSE WAIT AGAIN
 26DE C9        	RET
                	ENDIF			;END OF NOT WILD CONDITIONAL
                
                
                ;END OF STATES3
                	PAGE
                
                ;STRINGS 11/1/79
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979 BY MARK WILLIAMS COMPANY, CHICAGO
                ;STRING ROUTINES AND FUNCTIONS
                
                	IF	STRNG
                
                ;STRING SPACE CONSISTS OF RAM FROM (MEMT)+1 TO (STRT).  STRING VARIABLES ARE
                ;STORED FROM (MEMT)+1 TO (STRPT), AND (STRPT)+1 TO (STRP2) IS USED FOR
                ;TEMPORARY STRING STORAGE.  THE STRING TEMPORARIES AT STEMP CONTAIN THE
                ;ADDRESSES OF ESTACK STRING ENTRIES, AS THE STRINGS MAY MOVE DURING GARBAGE
                ;COLLECTION.
                
                ;ATEMP ASSIGNS THE ESTACK LOCATION IN HL TO A STRING TEMPORARY.
                ;THE TEMPORARY IS FREED WHEN THE STRING VALUE IS FETCHED.
                ;RETN:	A	CLOBBERED
                ;	BCDEHL	PRESERVED
 26DF D5        ATEMP:	PUSH	D
 26E0 EB        	XCHG			;LOCATION TO DE
 26E1 219B40    	LXI	H,STEMP		;TEMP BASE ADDR TO HL
 26E4 7E        	MOV	A,M		;FETCH # TEMPS IN USE
 26E5 3C        	INR	A		;AND BUMP
 26E6 FE04      	CPI	STMAX		;COMPARE TO # AVAILABLE
 26E8 D2F626    	JNC	STERR		;TOO MANY, FATAL ST ERROR
 26EB 77        	MOV	M,A		;STORE NEW # IN USE
 26EC 87        	ADD	A		;# * 2 BYTES PER TEMP
 26ED CD7202    	CALL	ADAHL		;+ BASE = BOTTOM OF NEW TEMP
 26F0 72        	MOV	M,D
 26F1 2B        	DCX	H
 26F2 73        	MOV	M,E		;LOCATION TO TEMP
 26F3 EB        	XCHG			;RESTORE LOC TO HL
 26F4 D1        	POP	D		;AND RESTORE DE
 26F5 C9        	RET
                STERR:	ERROR	F, S, T		;FATAL ST ERROR
 26F6+CDC616    	CALL	ERROF
 26F9+53D4      	DB	'S', 'T' OR 80H
                
                ;SCOPY COPIES A NEW STRING TO STRING TEMP SPACE FOR GET$, CHR$, AND STR$.
                ;CALL:	C	STRING LENGTH
                ;	DE	STRING LOCATION
                ;RETN:	B	PRESERVED
                ;	C	STRING LENGTH
                ;	DE	STRING LOCATION (IN STRING SPACE)
                ;	HL	TOP OF STRING TEMP SPACE USED
                ;SCOP0 IS CALLED FROM CONCATENATION (SADD) AND ASSIGNMENT (SCOPV) TO
                ;FETCH THE STRING VALUE ADDRESSED BY HL AND THEN COPY TO STRING SPACE.
 26FB CD2F02    SCOP0:	CALL	FETCS		;FETCH STRING ARG
 26FE 79        SCOPY:	MOV	A,C
 26FF CD3327    	CALL	STFRE		;ASSURE SUFFICIENT FREE SPACE
 2702 79        	MOV	A,C
 2703 B7        	ORA	A
 2704 C8        	RZ			;NULL STRING, JUST RETURN
 2705 C5        	PUSH	B		;SAVE LENGTH
 2706 CD3113    	CALL	BCDE		;LENGTH TO E, LOCATION TO BC
 2709 23        	INX	H		;NEXT AVAILABLE LOCATION TO HL
 270A E5        	PUSH	H		;SAVE LOCATION
 270B CDB431    	CALL	MOVD0		;COPY STRING TO STRING SPACE
 270E 2B        	DCX	H
 270F 22A840    	SHLD	STRP2		;NEW TOP OF STRING TEMP SPACE USED
 2712 D1        	POP	D		;RESTORE LOCATION
 2713 C1        	POP	B		;AND LENGTH
 2714 C9        	RET
                
                ;SCOPV COPIES THE VALUE ADDRESSED BY HL TO STRING SPACE FOR STRING ASSIGNMENT.
 2715 E5        SCOPV:	PUSH	H
 2716 23        	INX	H
 2717 7E        	MOV	A,M		;FETCH LENGTH
 2718 2AA640    	LHLD	STRPT
 271B 22A840    	SHLD	STRP2		;CLEAR STRING TEMP SPACCE
 271E CD3327    	CALL	STFRE		;ASSURE SUFFICIENT FREE SPACE
 2721 E1        	POP	H		;RESTORE VALUE POINTER
 2722 E5        	PUSH	H
 2723 CDFB26    	CALL	SCOP0		;FETCH THE VALUE AND COPY TO STRING SPACE
 2726 22A640    	SHLD	STRPT		;AND RESET STRING SPACE VAR POINTER
 2729 E1        	POP	H		;RESTORE THE VALUE POINTER
 272A E5        	PUSH	H
 272B 23        	INX	H
 272C 23        	INX	H
 272D 73        	MOV	M,E
 272E 23        	INX	H
 272F 72        	MOV	M,D		;NEW LOCATION TO VALUE ENTRY
 2730 E1        	POP	H		;RESTORE HL
 2731 7E        	MOV	A,M		;AND RESTORE TYPE
 2732 C9        	RET
                
                ;STFRE ASSURES THAT (A) BYTES OF STRING SPACE IS AVAILFABLE.
                ;GARBAGE COLLECTION IS PERFORMED IF REQUIRED, AND AN OS ERROR IF INSUFFICIENT.
                ;CALL:	A	AMOUNT OF STRING SPACE NEEDED
                ;RETN:	BC,DE	PRESERVED
                ;	HL	TOP OF USED STRING SPACE (STRP2)
 2733 C5        STFRE:	PUSH	B
 2734 D5        	PUSH	D
 2735 4F        	MOV	C,A
 2736 0600      	MVI	B,0		;DESIRED SPACE TO BC
 2738 2AA440    	LHLD	STRT
 273B EB        	XCHG			;TOP OF STRING SPACE TO DE
 273C 2AA840    	LHLD	STRP2		;CURRENT USED STRING SPACE TOP TO HL
 273F E5        	PUSH	H		;AND SAVED
 2740 09        	DAD	B		;CURRENT TOP + DESIRED AMOUNT TO HL
 2741 D48602    	CNC	CMDHU		;COMPARE TOP TO NEEDED
 2744 D2A108    	JNC	POP3		;TOP >= NEEDED, RESTORE AND RETURN
 2747 E1        	POP	H
 2748 C5        	PUSH	B		;SAVE DESIRED
 2749 CD5B27    	CALL	GARBG		;GARBAGE COLLECT
 274C EB        	XCHG
 274D C1        	POP	B
 274E E5        	PUSH	H		;SAVE USED TOP
 274F 09        	DAD	B
 2750 D48602    	CNC	CMDHU		;COMPARE TOP TO NEEDED
 2753 D2A108    	JNC	POP3		;OK AFTER GARBAGE COLLECTION
                	ERROR	F, O, S		;FATAL OS ERROR
 2756+CDC616    	CALL	ERROF
 2759+4FD3      	DB	'O', 'S' OR 80H
                
                ;GARBG IS THE STRING SPACE GARBAGE COLLECTOR.  ALL STRINGS REFERENCED BY
                ;STRING VARIABLES OR TEMPORARIES ARE COMPACTED TO THE BASE OF STRING SPACE.
                ;RETN:	DE	TOP OF USED STRING SPACE (STRPT)
                ;	HL	TOP OF STRING SPACE (STRT)
 275B 2A8842    GARBG:	LHLD	MEMT
 275E 23        	INX	H		;POINT TO FIRST BYTE OF STRING SPACE
 275F 22AA40    	SHLD	GCMIN		;MIN VALUE TO ACCEPT
                ;FIRST THE STRING WITH THE MINIMUM LOCATION >= GCMIN IS FOUND.
                ;GCLST CONTAINS THE LEAST SO FAR, AND GCLOC THE LOCATION OF THE LEAST.
 2762 21FFFF    GARB1:	LXI	H,-1
 2765 22AC40    	SHLD	GCLST		;STRING SPACE LOC OF LEAST STRING FOUND
 2768 2AC641    	LHLD	SYMTA
 276B E5        	PUSH	H
 276C D1        GARB2:	POP	D		;SET INITIAL VALUES FOR NXTST
 276D CD3928    	CALL	NXTST		;FIND NEXT SYMBOL TABLE STRING VAR
 2770 DA8927    	JC	GARB4		;NO MORE STRING ENTRIES
 2773 D5        	PUSH	D
 2774 E5        	PUSH	H
 2775 50        	MOV	D,B
 2776 59        	MOV	E,C		;NEXT STRING LOCATION TO DE
 2777 CDD827    	CALL	GCCMP		;COMPARE TO MIN AND LEAST
 277A E1        	POP	H		;RESTORE NEXT ENTRY POINTER TO HL
 277B DA6C27    	JC	GARB2		;< MIN OR >= LEAST, TRY NEXT
 277E EB        	XCHG
 277F 22AC40    	SHLD	GCLST		;ELSE CURRENT BECOMES NEW LEAST
 2782 EB        	XCHG
 2783 22AE40    	SHLD	GCLOC		;AND GCLOC STORES ITS ADDRESS
 2786 C36C27    	JMP	GARB2		;AND TRY NEXT
                ;ALL STRINGS CHECKED, MUST CHECK IF LEAST WAS FOUND.
 2789 2AAC40    GARB4:	LHLD	GCLST
 278C 7C        	MOV	A,H
 278D A5        	ANA	L
 278E 3C        	INR	A
 278F CAA127    	JZ	GARB5		;NO LEAST FOUND, STRING VAR COMPACTING DONE
                ;MOVE THE LEAST STRING TO THE TOP OF AVAILABLE STRING SPACE.
 2792 2AAE40    	LHLD	GCLOC
 2795 2B        	DCX	H
 2796 2B        	DCX	H
 2797 2B        	DCX	H		;POINT TO LENGTH BYTE
 2798 CDFD27    	CALL	TPMOV		;MOVE STRING TEMPS POINTING WITHIN STRING
 279B CDE727    	CALL	STMOV		;MOVE THE STRING
 279E C36227    	JMP	GARB1		;AND CONTINUE COMPACTING
                ;STRING VARS COMPACTED, NOW COMPACT THE STRING TEMPS.
 27A1 2AAA40    GARB5:	LHLD	GCMIN
 27A4 2B        	DCX	H
 27A5 22A640    	SHLD	STRPT		;STORE NEW STRING VAR POINTER
 27A8 2AA440    	LHLD	STRT
 27AB 22AC40    	SHLD	GCLST		;SET GCLST FOR GCCMP
 27AE 219B40    	LXI	H,STEMP
 27B1 7E        	MOV	A,M		;FETCH # TEMPS IN USE
 27B2 3D        GARB6:	DCR	A
 27B3 FACC27    	JM	GARB7		;ALL TEMPS MOVED, GARBAGE COLLECTION DONE
 27B6 F5        	PUSH	PSW		;SAVE # TEMPS STILL TO MOVE
 27B7 CD5502    	CALL	MODEM		;FETCH TEMP LOC TO DE
 27BA E5        	PUSH	H
 27BB D5        	PUSH	D		;SAVE TEMP LOC
 27BC EB        	XCHG
 27BD CD5502    	CALL	MODEM		;FETCH LOC OF TEMPORARY TO DE
 27C0 CDD827    	CALL	GCCMP		;COMPARE TO MIN AND LEAST
 27C3 E1        	POP	H		;TEMP LOC TO HL
 27C4 D4E727    	CNC	STMOV		;MOVE TEMP TO BASE OF AVAIL SPACE
 27C7 E1        	POP	H
 27C8 F1        	POP	PSW
 27C9 C3B227    	JMP	GARB6		;AND LOOK FOR MORE TEMPS
 27CC 2AAA40    GARB7:	LHLD	GCMIN
 27CF 2B        	DCX	H
 27D0 22A840    	SHLD	STRP2		;STORE NEW TOP OF STRING TEMP SPACE
 27D3 EB        	XCHG
 27D4 2AA440    	LHLD	STRT		;AND RETURN STRING SPACE TOP IN HL
 27D7 C9        	RET
 27D8 2AAA40    GCCMP:	LHLD	GCMIN
 27DB CD8602    	CALL	CMDHU
 27DE D8        	RC			;LOCATION < MIN, TRY NEXT
 27DF 2AAC40    	LHLD	GCLST
 27E2 CD8602    	CALL	CMDHU
 27E5 3F        	CMC			;LOCATION >= LEAST, TRY NEXT
 27E6 C9        	RET
                
                ;STMOV MOVES A STRING DURING GARBAGE COLLECTION.
                ;CALL:	HL	POINTER TO STRING LENGTH BYTE
                ;	(GCMIN)	DESTINATION
                ;RETN:	(GCMIN)	NEXT UNUSED LOCATION IN STRING SPACE
 27E7 5E        STMOV:	MOV	E,M		;LENGTH TO E
 27E8 23        	INX	H
 27E9 E5        	PUSH	H		;SAVE LOCATION ADDRESS
 27EA 4E        	MOV	C,M
 27EB 23        	INX	H
 27EC 46        	MOV	B,M		;LOCATION TO BC
 27ED 2AAA40    	LHLD	GCMIN		;DESTINATION TO HL
 27F0 E5        	PUSH	H		;AND SAVED
 27F1 CDB431    	CALL	MOVD0		;MOVE STRING IN STRING SPACE
 27F4 22AA40    	SHLD	GCMIN		;AND STORE NEW MIN
 27F7 D1        	POP	D
 27F8 E1        	POP	H
 27F9 73        	MOV	M,E
 27FA 23        	INX	H
 27FB 72        	MOV	M,D		;AND COPY NEW LOC TO VALUE
 27FC C9        	RET
                
                ;TPMOV MOVES TEMPORARIES DURING GARBAGE COLLECTION.
 27FD 119B40    TPMOV:	LXI	D,STEMP
 2800 1A        	LDAX	D		;FETCH # TEMPS IN USE
 2801 3D        TPMO1:	DCR	A
 2802 F8        	RM			;NO MORE TEMPS TO CHECK
 2803 E5        	PUSH	H		;SAVE STRING VALUE LOCATION
 2804 E5        	PUSH	H
 2805 EB        	XCHG
 2806 CD5502    	CALL	MODEM		;FETCH ESTACK LOCATION OF TEMP TO DE
 2809 E3        	XTHL			;SAVE STEMP POINTER, STRING VALUE PTR TO HL
 280A F5        	PUSH	PSW		;SAVE # TEMPS STILL TO CHECK
 280B E5        	PUSH	H		;AND STRING VALUE PTR
 280C EB        	XCHG			;ESTACK TEMP LOC TO HL
 280D CD5502    	CALL	MODEM		;FETCH TEMP LOC TO DE
 2810 E3        	XTHL			;SAVE STRING TEMP POINTER, VALUE PTR TO HL
 2811 D5        	PUSH	D		;AND SAVE TEMP LOC
 2812 4E        	MOV	C,M		;LENGTH TO C
 2813 CD5502    	CALL	MODEM		;LOCATION TO DE
 2816 0600      	MVI	B,0
 2818 CD6502    	CALL	CPLDE		;- LOC TO DE
 281B E1        	POP	H		;TEMP LOC TO HL
 281C 19        	DAD	D		;TEMP LOC - SOURCE LOC
 281D D23228    	JNC	TPMO2		;TEMP LOC < SOURCE
 2820 EB        	XCHG			;OFFSET TO DE
 2821 0B        	DCX	B		;LENGTH - 1 TO BC
 2822 CD8002    	CALL	CMBDU
 2825 DA3228    	JC	TPMO2		;LENGTH <= OFFSET
 2828 2AAA40    	LHLD	GCMIN
 282B 19        	DAD	D		;DESTINATION + OFFSET = NEW LOC
 282C EB        	XCHG			;TO DE
 282D E1        	POP	H
 282E 72        	MOV	M,D
 282F 2B        	DCX	H
 2830 73        	MOV	M,E		;AND TO TEMP
 2831 E5        	PUSH	H
 2832 E1        TPMO2:	POP	H
 2833 F1        	POP	PSW		;# TEMPS STILL UNCHECKED
 2834 D1        	POP	D		;TEMP POINTER
 2835 E1        	POP	H		;VALUE POINTER
 2836 C30128    	JMP	TPMO1		;AND CHECK THE NEXT TEMP
                
                ;NXTST IS USED DURING GARBAGE COLLECTION TO FIND LOCATIONS OF NONNULL STRINGS.
                ;CALL:	DE	NEXT SYMBOL TABLE ENTRY ADDR (INITIALLY SYMTA)
                ;	HL	NEXT LENGTH BYTE IN CURRENT ENTRY (INITIALLY SYMTA)
                ;RETN:	CARRY	SET IFF NO MORE NONNULL STRINGS
                ;	A	LENGTH OF NEXT NONNULL STRING
                ;	BC	LOCATION OF STRING
                ;	DE	NEXT ENTRY ADDR
                ;	HL	NEXT LENGTH BYTE
 2839 CD8602    NXTST:	CALL	CMDHU
 283C C25828    	JNZ	NXTS3		;MORE IN CURRENT ENTRY
 283F CD061B    NXTS1:	CALL	STNXT		;ADDRESS NEXT SYMBOL TABLE ENTRY
 2842 D8        	RC			;NO MORE
 2843 1A        	LDAX	D		;FETCH TYPE BYTE
 2844 E61F      	ANI	1FH		;MASK TO TYPE
 2846 FE03      	CPI	STRST
 2848 C23F28    	JNZ	NXTS1		;NOT A STRING
 284B EB        	XCHG			;NEXT ENTRY ADDR TO DE
 284C 23        NXTS2:	INX	H		;POINT TO NEXT NAME BYTE
 284D B6        	ORA	M
 284E F24C28    	JP	NXTS2		;SCAN PAST NAME
 2851 23        	INX	H		;POINT TO # DIMS
 2852 4E        	MOV	C,M		;# DIMS TO C
 2853 0600      	MVI	B,0
 2855 23        	INX	H
 2856 09        	DAD	B
 2857 09        	DAD	B		;POINT TO FIRST LENGTH BYTE
 2858 7E        NXTS3:	MOV	A,M		;FETCH LENGTH
 2859 CD2A02    	CALL	MOBCM		;FETCH LOCATION TO BC
 285C 23        	INX	H		;POINT TO NEXT
 285D B7        	ORA	A
 285E C0        	RNZ			;RETURN UNLESS NULL
 285F C33928    	JMP	NXTST		;ELSE TRY NEXT
                
                ;EVUNQ GETS A STRING VALUE FOR READ OR INPUT.  IF THE NEXT ITEM SCANNED
                ;EVALUATES TO A STRING VALUE, ITS VALUE IS PASSED.  OTHERWISE THE ITEM IS
                ;CONSIDERED TO BE AN UNQUOTED STRING STARTING AT THE FIRST NONBLANK AND
                ;DELIMITED BY THE NEXT COMMA OR CR, AND A POINTER TO IT IS RETURNED.
                ;RETN:	CARRY	SET IFF NEXT NONBLANK CHAR IS DELIMITER
                ;	C, DE	LENGTH, LOCATION OF STRING
 2862 CD3B17    EVUNQ:	CALL	GTCHA		;FETCH FIRST NONBLANK
 2865 FE22      	CPI	'"'
 2867 CA7F18    	JZ	GTLIS		;QUOTED STRING LITERAL
 286A CD4C17    	CALL	BAKUP		;LET HL AND TEXTP POINT TO FIRST
 286D CDA201    	CALL	DTST1
 2870 3F        	CMC
 2871 D8        	RC			;FIRST NONBLANK IS DELIMITER, RETURN CARRY
 2872 54        	MOV	D,H
 2873 5D        	MOV	E,L		;FIRST NONBLANK LOC TO DE
 2874 FE2C      EVUN1:	CPI	','
 2876 CA8418    	JZ	GTLS1		;DONE IF NEXT IS COMMA
 2879 CDA201    	CALL	DTST1
 287C D28418    	JNC	GTLS1		;OR IF NEXT IS CR OR '
 287F CD5817    	CALL	READ1		;ELSE READ THE CURRENT
 2882 7E        	MOV	A,M		;AND FETCH NEXT
 2883 C37428    	JMP	EVUN1		;AND CONTINUE SCANNING
                
                ;CMSTR COMPARES TWO STRINGS.
                ;CALL:	B	LENGTH OF STRING 2
                ;	C	LENGTH OF STRING 1
                ;	DE	LOCATION OF STRING 1
                ;	HL	LOCATION OF STRING 2
                ;RETN:	CARRY	SET IFF STRING 1 < STRING 2
                ;	ZERO	SET IFF STRING 1 = STRING 2
 2886 79        CMSTR:	MOV	A,C
 2887 B7        	ORA	A
 2888 CA9A28    	JZ	CMST1		;END OF STRING 1
 288B 78        	MOV	A,B
 288C B7        	ORA	A
 288D CA9C28    	JZ	CMST2		;END OF STRING 2
 2890 1A        	LDAX	D		;ELSE FETCH STRING 1 CHAR
 2891 BE        	CMP	M		;COMPARE TO STRING 2
 2892 C0        	RNZ			;UNEQUAL
 2893 05        	DCR	B
 2894 0D        	DCR	C		;DECREMENT LENGTHS
 2895 13        	INX	D
 2896 23        	INX	H		;INCREMENT POINTERS
 2897 C38628    	JMP	CMSTR		;AND CONTINUE CHECKING
 289A B8        CMST1:	CMP	B
 289B C9        	RET
 289C F601      CMST2:	ORI	1		;CLEAR CARRY AND ZERO
 289E C9        	RET
                
                ;SIARG IS CALLED BY LEFT$, RIGHT$ AND MID$ TO MANIPULATE ARGUMENTS.
                ;CALL:	BC,DE	ARG1 (STRING), ARG2 (INTEGER) POINTERS
                ;RETN:	A	ARG2, 0 IF < 0 AND 255 IF > 255 (WITH NONFATAL FC ERROR)
                ;	C, DE	STRING LENGTH AND LOCATION
                ;SIAR0 IS CALLED BY INST3 AND MID3 TO FETCH INTEGER ARG 0 <= ARG <= 255.
 289F CD300B    SIAR0:	CALL	CNVBI		;FORCE TO INTEGER AND FETCH
 28A2 60        	MOV	H,B
 28A3 69        	MOV	L,C
 28A4 C3AF28    	JMP	SIAR1		;FORCE 0 <= ARG <= 255 TO A
 28A7 D5        SIARG:	PUSH	D		;SAVE INTEGER ARG2
 28A8 CD1502    	CALL	FETBC		;FETCH STRING ARG1 TO C, DE
 28AB D22B0B    	JNC	TMERR		;FATAL TM ERROR IF NONSTRING
 28AE E1        	POP	H		;ARG2 TO HL
 28AF 7C        SIAR1:	MOV	A,H		;MID3 ENTRY POINT
 28B0 B7        	ORA	A
 28B1 7D        	MOV	A,L		;LSBYTE OF ARG2 TO A
 28B2 C8        	RZ			;DONE IF 0 <= ARG2 <= 255
 28B3 CD9A12    	CALL	FCERN		;ELSE ISSUE NONFATAL FC ERROR
 28B6 7C        	MOV	A,H
 28B7 B7        	ORA	A
 28B8 3E00      	MVI	A,0
 28BA F8        	RM			;AND RETURN 0 IF < 0
 28BB 3D        	DCR	A		;ELSE RETURN 255
 28BC C9        	RET
                
                
                ;STRING FUNCTIONS FOLLOW
                
                ;CONCATENATION (+): <STRING> X <STRING> --> <STRING>
 28BD 78        SADD:	MOV	A,B
 28BE B7        	ORA	A
 28BF CAF628    	JZ	SADD3		;STRING 2 NULL, RETURN S1
 28C2 79        	MOV	A,C
 28C3 B7        	ORA	A
 28C4 CAF428    	JZ	SADD2		;STRING 1 NULL, RETURN S2
 28C7 80        	ADD	B		;ELSE FIND LENGTH OF CONCATENATION
 28C8 D2D428    	JNC	SADD1		;NOT TOO LONG
                	ERROR	N, L, S		;ISSUE NONFATAL LS ERROR
 28CB+CDD216    	CALL	ERRON
 28CE+4CD3      	DB	'L', 'S' OR 80H
 28D0 79        	MOV	A,C
 28D1 2F        	CMA
 28D2 47        	MOV	B,A		;USEABLE LENGTH OF S2 = 255 - LENGTH OF S1
 28D3 81        	ADD	C		;LENGTH OF CONCATENATION TO A
 28D4 F5        SADD1:	PUSH	PSW		;SAVE LENGTH
 28D5 219B40    	LXI	H,STEMP
 28D8 34        	INR	M
 28D9 34        	INR	M		;REASSIGN STRING TEMPORARIES
 28DA CD3327    	CALL	STFRE		;ASSURE SUFFICIENT SPACE AVAILABLE
 28DD 2AC441    	LHLD	ESTKP
 28E0 23        	INX	H		;ADDRESS S1 ESTACK ENTRY
 28E1 E5        	PUSH	H
 28E2 CDFB26    	CALL	SCOP0		;FETCH AND COPY TO STRING SPACE
 28E5 E1        	POP	H
 28E6 D5        	PUSH	D		;SAVE LOCATION OF COPIED S1
 28E7 110700    	LXI	D,VBYTS+2
 28EA 19        	DAD	D		;ADDRESS S2 ESTACK ENTRY
 28EB CDFB26    	CALL	SCOP0		;FETCH AND COPY TO STRING SPACE
 28EE D1        	POP	D		;RESULT LOCATION TO DE
 28EF F1        	POP	PSW
 28F0 4F        	MOV	C,A		;RESULT LENGTH TO C
 28F1 3E03      	MVI	A,STRST		;RESULT TYPE TO A
 28F3 C9        	RET
 28F4 48        SADD2:	MOV	C,B		;LENGTH OF S2 TO C
 28F5 EB        	XCHG			;AND LOC TO DE
 28F6 3E03      SADD3:	MVI	A,STRST
 28F8 C9        	RET
                
                ;INSTR: [<INTEGER> X] <STRING> X <STRING> --> <INTEGER>
 28F9 210100    INSTR:	LXI	H,1		;DEFAULT ARG0 VALUE TO HL
 28FC E5        INST0:	PUSH	H		;SAVE FIRST TO TEST -- INST3 ENTRY POINT
 28FD 2B        	DCX	H
 28FE E5        	PUSH	H		;SAVE FIRST-1
 28FF CDC311    	CALL	AMBOP		;FETCH MATCHING ARGS
 2902 D22B0B    	JNC	TMERR		;NONSTRINGS
 2905 E3        	XTHL			;SAVE S1 LOCATION, FIRST-1 TO HL
 2906 EB        	XCHG
 2907 19        	DAD	D		;S2 LOC + FIRST - 1 = S2 REMAINING LOC TO HL
 2908 79        	MOV	A,C
 2909 48        	MOV	C,B
 290A 93        	SUB	E		;S2 LENGTH + FIRST - 1 = S2 REMAINING LENGTH
 290B D1        	POP	D
 290C DA2D29    	JC	INST2		;S2 TOO SHORT, RETURN 0
 290F CA2D29    	JZ	INST2		;S2 REM NULL, RETURN 0
 2912 47        	MOV	B,A		;S2 REM LEN TO B
                ;AT INST1 B=S2 REM LEN, C=S1 LEN, DE=S1 LOC, HL=S2 REM LOC, STACK=RESULT
 2913 78        INST1:	MOV	A,B
 2914 B9        	CMP	C
 2915 DA2D29    	JC	INST2		;REMAINING PART OF S2 TOO SHORT, RETURN 0
 2918 C5        	PUSH	B
 2919 D5        	PUSH	D
 291A E5        	PUSH	H
 291B 41        	MOV	B,C		;SET LENGTHS EQUAL FOR STRING COMPARE
 291C CD8628    	CALL	CMSTR		;COMPARE S1 TO LEFT$(REM S2,LEN(S1))
 291F E1        	POP	H
 2920 D1        	POP	D
 2921 C1        	POP	B
 2922 CAA308    	JZ	POP1		;MATCHED, POP RESULT TO BC AND RETURN
 2925 05        	DCR	B		;ELSE DECR S2 REM LEN
 2926 23        	INX	H		;AND INCR S2 REM LOC
 2927 E3        	XTHL
 2928 23        	INX	H		;AND INCR PROTO RESULT
 2929 E3        	XTHL
 292A C31329    	JMP	INST1		;AND TRY AGAIN
 292D C1        INST2:	POP	B
 292E 010000    	LXI	B,0
 2931 C9        	RET
                ;INST3 EXECUTES TERNARY INSTR.
 2932 D5        INST3:	PUSH	D		;SAVE ARG2
 2933 E5        	PUSH	H		;AND ARG3
 2934 CD9F28    	CALL	SIAR0		;FORCE 0 <= ARG3 <= 255 TO A
 2937 6F        	MOV	L,A
 2938 2600      	MVI	H,0		;ARG3 TO HL
 293A B7        	ORA	A
 293B CCC111    	CZ	INXH		;FUDGE VALUE 0 TO 1
 293E D1        	POP	D
 293F C1        	POP	B		;RESTORE ARGS
 2940 CDFC28    	CALL	INST0		;PERFORM INSTR
 2943 3E01      	MVI	A,INTST		;AND RETURN TYPE INTEGER
 2945 C9        	RET
                
                ;BIN$:	<INTEGER> --> <STRING>
 2946 210110    BINFN:	LXI	H,(16 SHL 8) OR 1	;16 DIGITS, 1 BIT EACH
 2949 C34F29    	JMP	HEXF0
                
                ;HEX$:	<INTEGER> --> <STRING>
 294C 210404    HEXFN:	LXI	H,(4 SHL 8) OR 4	;4 DIGITS, 4 BITS EACH
                ;HEXF0 IS CALLED BY BIN$ AND OCT$ TO CONVERT TO STRING.
                ;	BC	INTEGER VALUE TO CONVERT
                ;	H	MAX DIGIT COUNT
                ;	L	NUMMBER OF BITS PER DIGIT
 294F 11C941    HEXF0:	LXI	D,BUFAD+1	;DESTINATION TO DE
 2952 C5        	PUSH	B		;SAVE ARG
 2953 44        	MOV	B,H		;REMAINING DIGIT COUNT TO B
 2954 2600      	MVI	H,0		;TO SUPPRESS LEADING 0S
 2956 4D        HEXF1:	MOV	C,L		;SHIFT COUNT TO C -- OCT$ ENTRY POINT
 2957 E3        	XTHL			;SAVE STATUS & COUNT, GET VALUE
 2958 AF        	XRA	A		;BUILD RESULT DIGIT IN A
 2959 29        HEXF2:	DAD	H		;SHIFT ARG LEFT
 295A 17        	RAL			;CARRY TO A0
 295B 0D        	DCR	C
 295C C25929    	JNZ	HEXF2		;SHIFT MORE BITS
 295F C690      	ADI	90H		;90H, ..., 99H, 9AH, ..., 9FH
 2961 27        	DAA			;90H, ..., 99H, 00H+C,...,05H+C
 2962 CE40      	ACI	40H		;D0H, ..., D9H, 41H, ..., 46H
 2964 27        	DAA			;30H, ..., 39H, 41H, ..., 46H
 2965 12        	STAX	D		;STORE ASCII DIGIT
 2966 13        	INX	D
 2967 05        	DCR	B
 2968 CA7729    	JZ	HEXF4		;DONE
 296B E3        	XTHL			;SAVE VALUE, GET STATUS
 296C D630      	SUI	'0'		;ZERO SET IFF DIGIT IS 0
 296E B4        	ORA	H		;ZERO SET IFF LEADING 0
 296F 67        	MOV	H,A		;SAVE LEADING 0 STATUS
 2970 C25629    	JNZ	HEXF1		;NOT A LEADING 0, DO NOT SUPPRESS
 2973 1B        	DCX	D		;SUPPRESS IT
 2974 C35629    	JMP	HEXF1
 2977 C1        HEXF4:	POP	B		;DISCARD SAVED STATUS
 2978 21C841    	LXI	H,BUFAD
 297B 3620      	MVI	M,' '		;STORE FIRST CHAR = <SPACE>
 297D EB        	XCHG			;FIRST LOC TO DE, LAST+1 TO HL
 297E 7D        	MOV	A,L
 297F 93        	SUB	E		;COMPUTE LENGTH
 2980 4F        	MOV	C,A		;LENGTH TO C
 2981 C3FE26    	JMP	SCOPY		;COPY TO STRING SPACE AND RETURN
                
                ;OCT$:	<INTEGER> --> <STRING>
 2984 60        OCTFN:	MOV	H,B
 2985 69        	MOV	L,C		;ARG TO HL
 2986 29        	DAD	H		;SHIFT LEFT ONE BIT, CARRY IFF LEADING 1
 2987 44        	MOV	B,H
 2988 4D        	MOV	C,L		;SHIFTED ARG TO BC
 2989 210305    	LXI	H,(5 SHL 8) OR 3	;5 DIGITS, 3 BITS EACH
 298C D24F29    	JNC	HEXF0		;HIGH BIT 0, SO JUST DO AS IN HEX$
 298F 11C941    	LXI	D,BUFAD+1
 2992 3E31      	MVI	A,'1'
 2994 12        	STAX	D		;STORE LEADING ASCII 1
 2995 13        	INX	D
 2996 C5        	PUSH	B		;SAVE ARG
 2997 44        	MOV	B,H		;REPEAT COUNT TO B
 2998 C35629    	JMP	HEXF1		;LEAVE H NONZERO TO RETAIN 0S
                
                ;STR$: {<INTEGER> | <FLOATING>} --> <STRING>
                STRS:	IF	FLOAT		;<FLOATING> --> <STRING>
 299B CDB60C    	CALL	FOUT		;CONVERT FLOATING VALUE TO STRING
                	ELSE			;<INTEGER> --> <STRING>
                	MOV	A,B
                	ORA	A
                	MVI	A,0
                	JP	STRS1		;CONVERT TO STRING WITH NO LEADING CHAR IF +
                	CALL	IUMIN		;ELSE NEGATE THE ARG
                	MVI	A,'-'
                STRS1:	CALL	CVTIS		;CONVERT INTEGER TO STRING
                	ENDIF
 299E C3FE26    	JMP	SCOPY		;COPY TO STRING SPACE AND RETURN
                
                ;VAL: <STRING> --> {<INTEGER> | <FLOATING>}
 29A1 CD1502    VAL:	CALL	FETBC		;FETCH THE ARG
 29A4 0C        	INR	C		;BUMP LENGTH
 29A5 C2A929    	JNZ	VAL1
 29A8 0D        	DCR	C		;LENGTH WAS 255, UNINCREMENT
 29A9 CDFE26    VAL1:	CALL	SCOPY		;MAKE NEW COPY WITH EXTRA CHAR
 29AC 360D      	MVI	M,CR		;LAST CHAR IS CR
 29AE EB        	XCHG			;LOCATION TO HL
 29AF 22BB41    	SHLD	TXTP2		;AND TO TXTP2 FOR FLIP
 29B2 CD9402    	CALL	FLIP		;LET TEXTP SCAN THE STRING
 29B5 CD3A18    	CALL	GTLIT		;LOOK FOR A LITERAL
 29B8 F5        	PUSH	PSW
 29B9 C5        	PUSH	B
 29BA D5        	PUSH	D		;AND SAVE RESULT OF GTLIT
 29BB CD3B17    	CALL	GTCHA		;GET FIRST CHAR AFTER LITERAL
 29BE CD9402    	CALL	FLIP		;RESTORE TEXTP
 29C1 67        	MOV	H,A		;FIRST CHAR AFTER LIT TO H
 29C2 D1        	POP	D
 29C3 C1        	POP	B
 29C4 F1        	POP	PSW		;RECOVER RESULT OF GTLIT
 29C5 6F        	MOV	L,A
 29C6 7C        	MOV	A,H
 29C7 FE0D      	CPI	CR		;CHECK IF NEXT AFTER LIT WAS CR
 29C9 7D        	MOV	A,L
 29CA C21414    	JNZ	FCER0		;FC ERROR IF NOT
 29CD FE01      	CPI	INTST		;CHECK IF TYPE INTEGER
 29CF C8        	RZ			;YES, RETURN
                	IF	FLOAT
 29D0 FE02      	CPI	SNGST
 29D2 C21414    	JNZ	FCER0		;NOT FLOATING NOR INTEGER, FC ERROR
 29D5 21B941    	LXI	H,TEMP
 29D8 5E        	MOV	E,M		;RESTORE SAVED VALUE FOR A TO E IF FLOATING
 29D9 C9        	RET
                	ENDIF
                
                ;ASC: <STRING> --> <INTEGER>
 29DA CDE529    ASC:	CALL	LEN		;FETCH STRING ARG, 0 TO B
 29DD 79        	MOV	A,C		;LENGTH TO A
 29DE B7        	ORA	A		;CHECK LENGTH
 29DF CA1414    	JZ	FCER0		;NULL, NONFATAL FC ERROR AND RETURN 0
 29E2 1A        	LDAX	D		;ELSE FETCH CHARACTER
 29E3 4F        	MOV	C,A
 29E4 C9        	RET
                
                ;LEN: <STRING> --> <INTEGER>
 29E5 CD1502    LEN:	CALL	FETBC		;FETCH STRING ARG
 29E8 0600      	MVI	B,0		;RETURN LENGTH IN BC
 29EA C9        	RET
                
                ;CHR$: <INTEGER> --> <STRING>
 29EB CD5A02    CHRS:	CALL	ISBYT		;ARG MUST BE BYTE EXPR
 29EE 79        	MOV	A,C		;VALUE TO A
 29EF 11B941    CHRS1:	LXI	D,TEMP
 29F2 12        	STAX	D		;SAVE IN TEMP
 29F3 0E01      	MVI	C,1		;LENGTH IS 1
 29F5 C3FE26    	JMP	SCOPY		;AND COPY TO STRING SPACE
                
                ;LEFT$: <STRING> X <INTEGER> --> <STRING>
 29F8 CDA728    LEFTS:	CALL	SIARG		;ARGS TO A, CDE
 29FB B9        LEFT1:	CMP	C
 29FC D0        	RNC			;ARG >= LENGTH, RETURN UNCHANGED
 29FD 4F        	MOV	C,A		;ELSE ARG BECOMES NEW LENGTH
 29FE C9        	RET
                
                ;RIGHT$: <STRING> X <INTEGER> --> <STRING>
 29FF CDA728    RIGHT:	CALL	SIARG
 2A02 B9        RIGH1:	CMP	C
 2A03 D0        	RNC			;ARG >= LENGTH, RETURN UNCHANGED
 2A04 0D        	DCR	C
 2A05 13        	INX	D		;ELSE CHOP OFF HEAD CHAR
 2A06 C3022A    	JMP	RIGH1		;AND TRY AGAIN
                
                ;MID$: <STRING> X <INTEGER> [X <INTEGER>] --> <STRING>
 2A09 3EFF      MIDS:	MVI	A,255		;DEFAULT ARG3 VALUE TO A
 2A0B F5        MID0:	PUSH	PSW		;MID3 ENTRY POINT
 2A0C CDA728    	CALL	SIARG
 2A0F E1        	POP	H		;ARG3 TO H
 2A10 B7        	ORA	A
 2A11 CA1D2A    	JZ	MID2		;ARG2 IS 0, JUST DO LEFT$
 2A14 0C        	INR	C
 2A15 1B        	DCX	D		;ADD BOGUS HEAD CHAR
 2A16 13        MID1:	INX	D
 2A17 0D        	DCR	C		;LOP OFF HEAD
 2A18 C8        	RZ			;RETURN IF NULL
 2A19 3D        	DCR	A		;AND DECREASE ARG2
 2A1A C2162A    	JNZ	MID1
 2A1D 7C        MID2:	MOV	A,H
 2A1E C3FB29    	JMP	LEFT1		;AND DO A LEFT$ WITH ARG3
 2A21 C5        MID3:	PUSH	B		;SAVE ARG1
 2A22 42        	MOV	B,D
 2A23 4B        	MOV	C,E		;ARG2 TO BC
 2A24 CD300B    	CALL	CNVBI		;CONVERT TO INTEGER AND FETCH
 2A27 C5        	PUSH	B		;AND SAVE ARG2
 2A28 44        	MOV	B,H
 2A29 4D        	MOV	C,L
 2A2A CD9F28    	CALL	SIAR0		;FORCE 0 <= ARG3 <= 255 TO A
 2A2D D1        	POP	D		;ARG2 VALUE TO DE
 2A2E C1        	POP	B		;AND ARG1 ADDR TO BC
 2A2F CD0B2A    	CALL	MID0		;DO THE MID$
 2A32 3E03      	MVI	A,STRST		;AND RETURN TYPE STRING
 2A34 C9        	RET
                
                	IF	REALT
                ;TIME$: --> <STRING>
                ;TIME$ RETURNS THE CURRENT TIME AS STRING "HH:MM:SS".
                TIMED:	LXI	D,TIMEX+3	;DE ADDRESSES HOURS COUNT
                	LXI	H,BUFAD		;HL ADDRESSES STRING BEING BUILT
                	PUSH	H		;SAVE FOR RESULT
                	DI			;DISABLE SO CLOCK DOES NOT TICK DURING FETCH
                	LDAX	D		;FETCH HOURS-24
                	ADI	24		;HOURS
                	CALL	TIME1		;CONVERT HOURS, FETCH MINUTES
                	CALL	TIME1		;CONVERT MINUTES, FETCH SECONDS
                	EI			;ALL FETCHED, RENABLE
                	CALL	TIME1		;CONVERT SECONDS
                	POP	D		;RECOVER STRING ADDRESS
                TIME0:	MVI	C,8		;LENGTH = 8 FOR HH:MM:SS
                	JMP	SCOPY		;COPY TO STRING SPACE AND RETURN
                ;TIME1 ADDS TWO ASCII DECIMAL DIGITS AND A COLON TO RESULT STRING.
                ;CALL:	A	DESIRED VALUE (HOURS, MINUTES OR SECONDS)
                ;	DE	COUNT LOCATION
                ;	HL	STRING DESTINATION
                ;RETN:	A	NEXT COUNT (FROM (DE)-1)
                ;	DE	DECREMENTED
                ;	HL	NEXT LOCATION = HL + 3
                TIME1:	MVI	M,'0'		;STORE TENS DIGIT
                TIME2:	CPI	10
                	JC	TIME3		;TENS DIGIT IS NOW CORRECT
                	INR	M		;ELSE BUMP TENS DIGIT
                	SUI	10		;AND SUBTRACT FROM COUNT
                	JMP	TIME2		;AND TRY AGAIN
                TIME3:	ADI	'0'		;MAKE REMAINDER ASCII
                	INX	H
                	MOV	M,A		;AND ADD TO STRING
                	INX	H
                	MVI	M,':'		;AND ADD COLON
                	INX	H		;POINT TO NEXT AVAILABLE
                	DCX	D
                	LDAX	D		;FETCH NEXT COUNT
                	ADI	60		;ADD NEGATIVE BIAS
                	RET
                	ENDIF			;END OF REALT CONDITIONAL
                
                
                	ENDIF			;END OF STRNG CONDITIONAL
                
                
                ;END OF STRINGS
                	PAGE
                
                ;TABLES 01/12/81
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980, 1981 BY MARK WILLIAMS COMPANY, CHICAGO
                ;TABLES
                
                
                ;SYMBOL TABLE TYPE TOKEN EQUATES
 0001 =         INTST	EQU	1		;INTEGER VARIABLE
 0002 =         SNGST	EQU	2		;SINGLE PRECISION FLOATING POINT VARIABLE
 0003 =         STRST	EQU	3		;STRING VARIABLE
 0004 =         UFNST	EQU	4		;USER-DEFINED FUNCTION
 0005 =         BRKST	EQU	5		;BREAK ENTRY
 0006 =         CAMST	EQU	6		;CAMAC VARIABLE
                
                ;CONTROL STACK TOKEN EQUATES
 0025 =         CSGOS	EQU	25H		;GOSUB
 004F =         CSFOR	EQU	47H+2*FBYTS	;FOR
 0065 =         CSBRK	EQU	65H		;BREAK (AND STOP)
 0087 =         CSINT	EQU	87H		;INTERRUPT
 00A5 =         CSLBK	EQU	0A5H		;LINE BREAK
                
                ;EXPR STACK TYPE BYTE EQUATES
 00F0 =         TMASK	EQU	0F0H		;TYPE MASK
 000F =         PMASK	EQU	00FH		;PRECEDENCE MASK
                ;FIRST CHARACTERS
 0010 =         ISDEL	EQU	10H		;DELIMITER
 0020 =         ISLP	EQU	20H		;LEFT PARENTHESIS
 0030 =         ISRP	EQU	30H		;RIGHT PARENTHESIS
 0040 =         ISCOM	EQU	40H		;COMMA
                ;THEN 0-ARY AND USER-DEFINED FUNCTIONS
 0050 =         ISFN0	EQU	50H		;0-ARY FUNCTION
 0060 =         ISUFN	EQU	60H		;USER-DEFINED FUNCTION
                ;THEN OPS AND FNS, OP1 FIRST
 0070 =         ISOP1	EQU	70H		;UNARY OP
 0080 =         ISOP2	EQU	80H		;BINARY OP
 0090 =         ISFN1	EQU	90H		;UNARY FUNCTION
 00A0 =         ISFN2	EQU	0A0H		;BINARY FUNCTION
                
                ;BRANCH ADDRESSES FOR COMMAND EXECUTION, IN ORDER OF TABLE POSITION
 2A35 ED21      CMDTA:	DW	LET
 2A37 4421      	DW	IFCOM
 2A39 7B20      	DW	FOR
 2A3B 4D22      	DW	NEXT
 2A3D 3521      	DW	GOTO
 2A3F 2C21      	DW	GOSUB
 2A41 7623      	DW	PRINT
 2A43 5A21      	DW	INPUT
 2A45 4A24      	DW	READ
 2A47 9525      	DW	RETRN
 2A49 AA1D      	DW	DEF
 2A4B E51E      	DW	DIM
 2A4D 9817      	DW	GTDEL
 2A4F 8125      	DW	RESTR
 2A51 2B26      	DW	STOP
 2A53 7620      	DW	ENDCM
                	IF	NOT WILD
 2A55 1423      	DW	NULL
                	ENDIF
 2A57 351D      	DW	CALCM
 2A59 D325      	DW	SCALL
                	IF	NOT WILD
 2A5B 5D23      	DW	PUT
 2A5D 6B23      	DW	POKE
 2A5F C426      	DW	WAIT
                	ENDIF
 2A61 8326      	DW	TCOFF
 2A63 8226      	DW	TCON
 2A65 8826      	DW	TPOFF
 2A67 8926      	DW	TPON
 2A69 AD1C      	DW	BREAK
 2A6B 8E26      	DW	UNBRK
                	IF	NOT WILD
 2A6D 4220      	DW	ENABL
 2A6F 741F      	DW	DSABL
 2A71 4124      	DW	RNDIZ
                	ENDIF
 2A73 A824      	DW	REM
 2A75 3C1E      	DW	DELAY
 2A77 3705      	DW	SAVE
 2A79 9B05      	DW	LOAD
 2A7B F921      	DW	LIST
 2A7D 3E1D      	DW	CLEAR
 2A7F 2722      	DW	NEWCM
 2A81 B925      	DW	RUN
 2A83 871D      	DW	CONT
                	IF	NOT CAMAC
 2A85 461C      	DW	AUTO
 2A87 9D1E      	DW	DELET
 2A89 D01F      	DW	EDIT
 2A8B BD24      	DW	RENUM
                	ENDIF
                	IF	NOT WILD
 2A8D 9701      	DW	MOVE
                	ENDIF
 2A8F 9701      	DW	EXEC
                	IF	EPSTN
                	DW	PLOT
                	ENDIF
                	IF	SDISK AND NOT C3885
                	DW	OPEN
                	DW	CLOSE
                	DW	LINPT
                	DW	MARGN
                	IF	BENDX
                	DW	BMSOS
                	DW	BNAME
                	DW	BZAP
                	ELSE
                	DW	DIRCM
                	DW	SCRAT
                	ENDIF
                	ENDIF
                	IF	BENDX
                	DW	BFILS
                	ENDIF
                	IF	CAMAC
                	DW	CAMCD
                	DW	DECLR
                	DW	DRIVR
                	DW	XENAB
                	DW	RSTAT
                	DW	CAMCL
                	DW	CINIT
                	DW	CINHI
                	DW	LOOPC
                	DW	BYPAS
                	DW	ONLIN
                	DW	PULSE
                	DW	OPEN
                	DW	CLOSE
                	IF	NOT C3885
                	DW	CREAT
                	ENDIF
                	DW	LAMPA
                	DW	BKSET
                	DW	BLOCK
                	DW	CENAB
                	DW	CDSAB
                	DW	STTIM
                	ELSE
                	IF	WILD
                	DW	WGBUF
                	ELSE
 2A91 0B1C      	DW	ASSIG
                	ENDIF
                	IF	REALT
                	DW	STTIM
                	ELSE
 2A93 5126      	DW	TIME
                	ENDIF
                	ENDIF
                	IF	PACKI
                	DW	ONLIN
                	DW	OFLIN
                	DW	FIELD
                	ENDIF
 2A95 1C23      	DW	ON			;MUST FOLLOW ONLINE
                
                ;TYPE / PRECEDENCE BYTES FOR FUNCTIONS AND OPS
                ;MS FOUR BITS TYPE, LS FOUR BITS PRECEDENCE
 2A97 60        TYPTA:	DB	ISUFN					;FN
 2A98 76        	DB	ISOP1 + 6				;NOT
 2A99 8888      	DB	ISOP2 + 8, ISOP2 + 8			;+, -
 2A9B 8989      	DB	ISOP2 + 9, ISOP2 + 9			;*, /
                	IF	FLOAT
 2A9D 898A      	DB	ISOP2 + 9, ISOP2 + 10			;\, ^
                	ENDIF
 2A9F 8787878787	DB	ISOP2 + 7, ISOP2 + 7, ISOP2 + 7, ISOP2 + 7, ISOP2 + 7
 2AA4 878787    	DB	ISOP2 + 7, ISOP2 + 7, ISOP2 + 7		;RELATIONS
 2AA7 858484    	DB	ISOP2 + 5, ISOP2 + 4, ISOP2 + 4		;AND, XOR, OR
 2AAA 89        	DB	ISOP2 + 9 				;MOD
                	IF	NOT WILD
 2AAB 8B        	DB	ISOP2 + 11				;JOIN
                	ENDIF
 2AAC 5050      	DB	ISFN0, ISFN0				;GET, FRE
                	IF	NOT WILD
                	IF	FLOAT
 2AAE 92        	DB	ISFN1+2					;RND
                	ELSE
                	DB	ISFN0
                	ENDIF
                	ENDIF
                	IF	WILD
                	DB	ISFN0					;BUFFER
                	ELSE
                	IF	NOT CAMAC
 2AAF 50        	DB	ISFN0					;POS
                	ENDIF
 2AB0 5050      	DB	ISFN0, ISFN0				;FIRST, LAST
                	ENDIF
                	IF	PACKI
                	DB	ISFN0					;FLAG
                	ENDIF
                	IF	SDISK AND NOT C3885
                	DB	ISFN1+2					;EOF
                	ENDIF
                	IF	FLOAT
                	IF	NOT WILD
 2AB2 92        	DB	ISFN1 + 2				;UNS
                	ENDIF
 2AB3 92929292  	DB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2, ISFN1 + 2
 2AB7 929292    	DB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2		;UNARY FUNCTIONS
                	IF	NOT CAMAC
 2ABA 92        	DB	ISFN1 + 2				;ATN
                	ENDIF
                	ENDIF
                	IF	STRNG
 2ABB 92929292  	DB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2, ISFN1 + 2
 2ABF 92929292  	DB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2, ISFN1 + 2
 2AC3 A2A2A2A2  	DB	ISFN2 + 2, ISFN2 + 2, ISFN2 + 2, ISFN2 + 2
                	ENDIF
                	IF	CAMAC
                	DB	ISFN0, ISFN0
                	IF	C3885
                	DB	ISFN1 + 2
                	ELSE
                	DB	ISFN0
                	ENDIF
                	ELSE
                	IF	NOT WILD
 2AC7 50        	DB	ISFN0					;IOBYTE
                	ENDIF
                	IF	REALT
                	DB	ISFN0					;TIME$
                	DB	ISFN1 + 2				;TIME
                	ENDIF
                	ENDIF
 2AC8 9292      	DB	ISFN1 + 2, ISFN1 + 2
                	IF	NOT WILD
 2ACA 9292      	DB	ISFN1 + 2, ISFN1 + 2
 2ACC 929292    	DB	ISFN1 + 2, ISFN1 + 2, ISFN1 + 2		;UNARY FUNCTIONS
 2ACF A2A2A2A2A2	DB	ISFN2 + 2, ISFN2 + 2, ISFN2 + 2, ISFN2 + 2, ISFN2 + 2
 2AD4 A2A2      	DB	ISFN2 + 2, ISFN2 + 2			;BINARY FUNCTIONS
 2AD6 92        	DB	ISFN1 + 2				;IN
                	ENDIF
                
                ;ARGUMENT AND RESULT TYPE INFORMATION TABLE FOR FNS AND OPS
                ;FN IS A MACRO BUILDING A FIVE-BYTE TABLE ENTRY FOR A FUNCTION.
                ;THE FIRST BYTE GIVES THE TYPE OF ARG2.
                ;THE SECOND BYTE GIVES THE TYPE OF ARG1.
                ;THE THIRD AND FOURTH BYTES GIVE THE FUNCTION ADDRESS.
                ;THE FIFTH BYTE GIVES THE TYPE OF THE RESULT.
                ;UNUSED ARGUMENTS ARE INDICATED BY 0, AMBIGUOUS ENTRIES BY AMBST.
                ;E.G.:	FN	SGN, AMBST, 0, INTST
                ;INDICATES THAT THE ROUTINE TO COMPUTE SGN IS AT LOCATION SGN, THE FIRST ARG
                ;AMBIGUOUS (INTEGER OR FLOAT), NO SECOND ARG, AND THE RESULT INTEGER.
 0000 =         AMBST	EQU	0
                FN	MACRO	ADDR, A1TYP, A2TYP, RTYPE
                	DB	A2TYP, A1TYP
                	DW	ADDR
                	DB	RTYPE
                	ENDM
                ;NB UNARY MINUS FIRST, IN PLACE OF FN
                FUNTA:	FN	AUMIN, AMBST, 0, AMBST
 2AD7+0000      	DB	0, AMBST
 2AD9+F612      	DW	AUMIN
 2ADB+00        	DB	AMBST
                	FN	OPNOT, INTST, 0, INTST
 2ADC+0001      	DB	0, INTST
 2ADE+9E13      	DW	OPNOT
 2AE0+01        	DB	INTST
                	FN	AADD, AMBST, AMBST, AMBST
 2AE1+0000      	DB	AMBST, AMBST
 2AE3+A512      	DW	AADD
 2AE5+00        	DB	AMBST
                	FN	ASUB, AMBST, AMBST, AMBST
 2AE6+0000      	DB	AMBST, AMBST
 2AE8+C112      	DW	ASUB
 2AEA+00        	DB	AMBST
                	FN	AMUL, AMBST, AMBST, AMBST
 2AEB+0000      	DB	AMBST, AMBST
 2AED+DD12      	DW	AMUL
 2AEF+00        	DB	AMBST
                	IF	FLOAT
                	FN	FDIVD, SNGST, SNGST, SNGST	;FLOATING /
 2AF0+0202      	DB	SNGST, SNGST
 2AF2+310E      	DW	FDIVD
 2AF4+02        	DB	SNGST
                	FN	IDIVD, INTST, INTST, INTST	;INTEGER \
 2AF5+0101      	DB	INTST, INTST
 2AF7+5A13      	DW	IDIVD
 2AF9+01        	DB	INTST
                	FN	FATOX, SNGST, SNGST, SNGST
 2AFA+0202      	DB	SNGST, SNGST
 2AFC+C035      	DW	FATOX
 2AFE+02        	DB	SNGST
                	ELSE
                	FN	IDIVD, INTST, INTST, INTST	;/ IS INTEGER DIVIDE IF NONFLOATING
                	ENDIF
                	FN	LEQ, AMBST, AMBST, INTST
 2AFF+0000      	DB	AMBST, AMBST
 2B01+8E13      	DW	LEQ
 2B03+01        	DB	INTST
                	FN	LEQ, AMBST, AMBST, INTST
 2B04+0000      	DB	AMBST, AMBST
 2B06+8E13      	DW	LEQ
 2B08+01        	DB	INTST
                	FN	GEQ, AMBST, AMBST, INTST
 2B09+0000      	DB	AMBST, AMBST
 2B0B+8813      	DW	GEQ
 2B0D+01        	DB	INTST
                	FN	GEQ, AMBST, AMBST, INTST
 2B0E+0000      	DB	AMBST, AMBST
 2B10+8813      	DW	GEQ
 2B12+01        	DB	INTST
                	FN	NEQ, AMBST, AMBST, INTST
 2B13+0000      	DB	AMBST, AMBST
 2B15+7C13      	DW	NEQ
 2B17+01        	DB	INTST
                	FN	EQUAL, AMBST, AMBST, INTST
 2B18+0000      	DB	AMBST, AMBST
 2B1A+7613      	DW	EQUAL
 2B1C+01        	DB	INTST
                	FN	LTHAN, AMBST, AMBST, INTST
 2B1D+0000      	DB	AMBST, AMBST
 2B1F+8213      	DW	LTHAN
 2B21+01        	DB	INTST
                	FN	GTHAN, AMBST, AMBST, INTST
 2B22+0000      	DB	AMBST, AMBST
 2B24+9713      	DW	GTHAN
 2B26+01        	DB	INTST
                	FN	OPAND, INTST, INTST, INTST
 2B27+0101      	DB	INTST, INTST
 2B29+AE13      	DW	OPAND
 2B2B+01        	DB	INTST
                	FN	OPXOR, INTST, INTST, INTST
 2B2C+0101      	DB	INTST, INTST
 2B2E+A113      	DW	OPXOR
 2B30+01        	DB	INTST
                	FN	OPOR, INTST, INTST, INTST
 2B31+0101      	DB	INTST, INTST
 2B33+B813      	DW	OPOR
 2B35+01        	DB	INTST
                	FN	OPMOD, INTST, INTST, INTST
 2B36+0101      	DB	INTST, INTST
 2B38+6613      	DW	OPMOD
 2B3A+01        	DB	INTST
                	IF	NOT WILD
                	FN	JOIN, INTST, INTST, INTST
 2B3B+0101      	DB	INTST, INTST
 2B3D+BF13      	DW	JOIN
 2B3F+01        	DB	INTST
                	ENDIF
                	FN	GET, 0, 0, AMBST
 2B40+0000      	DB	0, 0
 2B42+4614      	DW	GET
 2B44+00        	DB	AMBST
                	FN	FREFN, 0, 0, INTST
 2B45+0000      	DB	0, 0
 2B47+AD14      	DW	FREFN
 2B49+01        	DB	INTST
                	IF	NOT WILD
                	IF	FLOAT
                	FN	RND, SNGST, 0, SNGST
 2B4A+0002      	DB	0, SNGST
 2B4C+F214      	DW	RND
 2B4E+02        	DB	SNGST
                	ELSE
                	FN	RND, 0, 0, INTST
                	ENDIF
                	ENDIF
                	IF	WILD
                	FN	WBUFF, 0, 0, STRST
                	ELSE
                	IF	NOT CAMAC
                	FN	POS, 0, 0, INTST
 2B4F+0000      	DB	0, 0
 2B51+6C14      	DW	POS
 2B53+01        	DB	INTST
                	ENDIF
                	FN	FIRST, 0, 0, INTST
 2B54+0000      	DB	0, 0
 2B56+9701      	DW	FIRST
 2B58+01        	DB	INTST
                	FN	LAST, 0, 0, INTST
 2B59+0000      	DB	0, 0
 2B5B+9701      	DW	LAST
 2B5D+01        	DB	INTST
                	ENDIF
                	IF	PACKI
                	FN	FLAG, 0, 0, INTST
                	ENDIF
                	IF	SDISK AND NOT C3885
                	FN	EOFFN, INTST, 0, INTST
                	ENDIF
                	IF	FLOAT
                	IF	NOT WILD
                	FN	UNSFN, INTST, 0, SNGST
 2B5E+0001      	DB	0, INTST
 2B60+DF13      	DW	UNSFN
 2B62+02        	DB	SNGST
                	ENDIF
                	IF	F9511
                	FN	INT, SNGST, 0, SNGST
                	ELSE
                	FN	INT, SNGST, 0, AMBST
 2B63+0002      	DB	0, SNGST
 2B65+C913      	DW	INT
 2B67+00        	DB	AMBST
                	ENDIF
                	FN	FSQR, SNGST, 0, SNGST
 2B68+0002      	DB	0, SNGST
 2B6A+E232      	DW	FSQR
 2B6C+02        	DB	SNGST
                	FN	FEXP, SNGST, 0, SNGST
 2B6D+0002      	DB	0, SNGST
 2B6F+6033      	DW	FEXP
 2B71+02        	DB	SNGST
                	FN	FLN, SNGST, 0, SNGST
 2B72+0002      	DB	0, SNGST
 2B74+5A34      	DW	FLN
 2B76+02        	DB	SNGST
                	FN	FSIN, SNGST, 0, SNGST
 2B77+0002      	DB	0, SNGST
 2B79+0E35      	DW	FSIN
 2B7B+02        	DB	SNGST
                	FN	FCOS, SNGST, 0, SNGST
 2B7C+0002      	DB	0, SNGST
 2B7E+0F35      	DW	FCOS
 2B80+02        	DB	SNGST
                	FN	FTAN, SNGST, 0, SNGST
 2B81+0002      	DB	0, SNGST
 2B83+0536      	DW	FTAN
 2B85+02        	DB	SNGST
                	IF	NOT CAMAC
                	FN	FATAN, SNGST, 0, SNGST
 2B86+0002      	DB	0, SNGST
 2B88+2636      	DW	FATAN
 2B8A+02        	DB	SNGST
                	ENDIF
                	ENDIF
                	IF	STRNG
                	FN	BINFN, INTST, 0, STRST
 2B8B+0001      	DB	0, INTST
 2B8D+4629      	DW	BINFN
 2B8F+03        	DB	STRST
                	FN	HEXFN, INTST, 0, STRST
 2B90+0001      	DB	0, INTST
 2B92+4C29      	DW	HEXFN
 2B94+03        	DB	STRST
                	FN	OCTFN, INTST, 0, STRST
 2B95+0001      	DB	0, INTST
 2B97+8429      	DW	OCTFN
 2B99+03        	DB	STRST
                	FN	CHRS, INTST, 0, STRST
 2B9A+0001      	DB	0, INTST
 2B9C+EB29      	DW	CHRS
 2B9E+03        	DB	STRST
                	IF	FLOAT
                	FN	STRS, SNGST, 0, STRST
 2B9F+0002      	DB	0, SNGST
 2BA1+9B29      	DW	STRS
 2BA3+03        	DB	STRST
                	ELSE
                	FN	STRS, INTST, 0, STRST
                	ENDIF
                	FN	ASC, STRST, 0, INTST
 2BA4+0003      	DB	0, STRST
 2BA6+DA29      	DW	ASC
 2BA8+01        	DB	INTST
                	FN	LEN, STRST, 0, INTST
 2BA9+0003      	DB	0, STRST
 2BAB+E529      	DW	LEN
 2BAD+01        	DB	INTST
                	FN	VAL, STRST, 0, AMBST
 2BAE+0003      	DB	0, STRST
 2BB0+A129      	DW	VAL
 2BB2+00        	DB	AMBST
                	FN	LEFTS, STRST, INTST, STRST
 2BB3+0103      	DB	INTST, STRST
 2BB5+F829      	DW	LEFTS
 2BB7+03        	DB	STRST
                	FN	RIGHT, STRST, INTST, STRST
 2BB8+0103      	DB	INTST, STRST
 2BBA+FF29      	DW	RIGHT
 2BBC+03        	DB	STRST
                	FN	MIDS, STRST, INTST, STRST
 2BBD+0103      	DB	INTST, STRST
 2BBF+092A      	DW	MIDS
 2BC1+03        	DB	STRST
                	FN	INSTR, AMBST, STRST, INTST
 2BC2+0300      	DB	STRST, AMBST
 2BC4+F928      	DW	INSTR
 2BC6+01        	DB	INTST
                	ENDIF
                	IF	CAMAC
                	FN	CAMQF, 0, 0, INTST
                	FN	TIMED, 0, 0, STRST
                	IF	C3885
                	FN	EOFFN, INTST, 0, INTST
                	ELSE
                	FN	TYPFN, 0, 0, INTST
                	ENDIF
                	ELSE
                	IF	NOT WILD
                	FN	IOBYF, 0, 0, INTST
 2BC7+0000      	DB	0, 0
 2BC9+6114      	DW	IOBYF
 2BCB+01        	DB	INTST
                	ENDIF
                	IF	REALT
                	FN	TIMED, 0, 0, STRST			;TIME$
                	FN	TIME, INTST, 0, INTST			;TIME
                	ENDIF
                	ENDIF
                	FN	SGN, AMBST, 0, INTST
 2BCC+0000      	DB	0, AMBST
 2BCE+7F14      	DW	SGN
 2BD0+01        	DB	INTST
                	FN	AABS, AMBST, 0, AMBST
 2BD1+0000      	DB	0, AMBST
 2BD3+0F13      	DW	AABS
 2BD5+00        	DB	AMBST
                	IF	NOT WILD
                	FN	MSBYT, INTST, 0, INTST
 2BD6+0001      	DB	0, INTST
 2BD8+F313      	DW	MSBYT
 2BDA+01        	DB	INTST
                	FN	LSBYT, INTST, 0, INTST
 2BDB+0001      	DB	0, INTST
 2BDD+F413      	DW	LSBYT
 2BDF+01        	DB	INTST
                	FN	BCD, INTST, 0, INTST
 2BE0+0001      	DB	0, INTST
 2BE2+F713      	DW	BCD
 2BE4+01        	DB	INTST
                	FN	BIN, INTST, 0, INTST
 2BE5+0001      	DB	0, INTST
 2BE7+1D14      	DW	BIN
 2BE9+01        	DB	INTST
                	FN	PEEK, INTST, 0, INTST
 2BEA+0001      	DB	0, INTST
 2BEC+6714      	DW	PEEK
 2BEE+01        	DB	INTST
                	FN	ROTAT, INTST, INTST, INTST
 2BEF+0101      	DB	INTST, INTST
 2BF1+D814      	DW	ROTAT
 2BF3+01        	DB	INTST
                	FN	TEST, INTST, INTST, INTST
 2BF4+0101      	DB	INTST, INTST
 2BF6+7214      	DW	TEST
 2BF8+01        	DB	INTST
                	FN	SENSE, INTST, INTST, INTST
 2BF9+0101      	DB	INTST, INTST
 2BFB+A114      	DW	SENSE
 2BFD+01        	DB	INTST
                	FN	RSHFT, INTST, INTST, INTST
 2BFE+0101      	DB	INTST, INTST
 2C00+D514      	DW	RSHFT
 2C02+01        	DB	INTST
                	FN	LSHFT, INTST, INTST, INTST
 2C03+0101      	DB	INTST, INTST
 2C05+CA14      	DW	LSHFT
 2C07+01        	DB	INTST
                	FN	RESET, INTST, INTST, INTST
 2C08+0101      	DB	INTST, INTST
 2C0A+A813      	DW	RESET
 2C0C+01        	DB	INTST
                	FN	SETFN, INTST, INTST, INTST
 2C0D+0101      	DB	INTST, INTST
 2C0F+B513      	DW	SETFN
 2C11+01        	DB	INTST
                	FN	INP, INTST, 0, INTST
 2C12+0001      	DB	0, INTST
 2C14+9C14      	DW	INP
 2C16+01        	DB	INTST
                	ENDIF
                
                ;KEYWORD TABLE EQUATES
 0031 =         NCMDS	EQU	(TYPTA-CMDTA)/2		;NUMBER OF COMMANDS
 0040 =         NFUNS	EQU	FUNTA-TYPTA		;NUMBER OF FUNCTIONS
 0003 #         NRWDS	SET	3			;NUMBER OF RESERVED WORDS
                	IF	NOT WILD
 0004 #         NRWDS	SET	NRWDS+1
                	IF	NOT CAMAC
 0009 #         NRWDS	SET	NRWDS+5
                	ENDIF
                	ENDIF
                	IF	FLOAT
 000A #         NRWDS	SET	NRWDS+1
                	ELSE
                NRWDS	SET	NRWDS+1
                	IF	STRNG
                NRWDS	SET	NRWDS+1
                	ENDIF
                	ENDIF
                	IF	STRNG
 000B #         NRWDS	SET	NRWDS+1
                	ELSE
                NRWDS	SET	NRWDS+1
                	ENDIF
                	IF	NOT WILD
 000C #         NRWDS	SET	NRWDS+1
                	ENDIF
                	IF	KEY80
 0071 =         NKEYS	EQU	NCMDS+NFUNS		;NUMBER OF KEYWORDS
                	ELSE
                NKEYS	EQU	NCMDS+NFUNS+NRWDS
                	ENDIF
                
                ;KEYWORD TABLE
                ;ADDING OR DELETING A KEYWORD ALWAYS REQUIRES CHANGING THE KEYWORD TABLE.
                ;IN ADDITION, ADDING A COMMAND REQUIRES CHANGING THE BRANCH TABLE AT CMDTA.
                ;ADDING A FN/OP REQUIRES CHANGING THE TYPE/PREC TABLE AT TYPTA AND THE ARG/RESULT
                ;TABLE AT FUNTA.  ADDING A RESERVED WORD REQUIRES CHANGING THE NRWDS EQUATES.
                
                ;KEY IS A MACRO TO DEFINE KEYWORD TABLE ENTRIES AND CORRESPONDING TOKEN VALUES.
                KEY	MACRO	F, L, TVAL
                	IF	NOT NUL TVAL
                TVAL	EQU	TOKEN			;;EQUATE TOKEN VALUE IF DESIRED
                	ENDIF
                TOKEN	SET	TOKEN+1			;;INCREMENT TOKEN VALUE
                	IF	WILD OR NOT COMPL
                	DB	'&F', '&L' OR 80H	;;KEYWORD
                	ENDIF
                	ENDM
                ;NOKEY IS A MACRO TO LEAVE HOLES IN TABLE FOR COMMANDS NOT INCLUDED IN
                ;A NON-ROMSQ OR NON-EDITC VERSION, FOR TOKEN COMPATIBILITY.
                NOKEY	MACRO	N
                	IF	WILD OR NOT COMPL
                	REPT	N
                	DB	0FFH		;;TOKEN IS <RUBOUT> OR 80H
                	ENDM
                	ENDIF
                TOKEN	SET	TOKEN+N
                	ENDM
 008F #         TOKEN	SET	-NKEYS AND 0FFH	;FIRST TOKEN VALUE
                
                ;COMMANDS
                KEYTA:	KEY	LE, T, CMDTK
 008F+=         CMDTK	EQU	TOKEN
 2C17+4C45D4    	DB	'LE', 'T' OR 80H
                	KEY	I, F
 2C1A+49C6      	DB	'I', 'F' OR 80H
                	KEY	FO, R, FORT
 0091+=         FORT	EQU	TOKEN
 2C1C+464FD2    	DB	'FO', 'R' OR 80H
                	KEY	NEX, T, NEXTT
 0092+=         NEXTT	EQU	TOKEN
 2C1F+4E4558D4  	DB	'NEX', 'T' OR 80H
                	KEY	GOT, O, GOTOT
 0093+=         GOTOT	EQU	TOKEN
 2C23+474F54CF  	DB	'GOT', 'O' OR 80H
                	KEY	GOSU, B, GSUBT
 0094+=         GSUBT	EQU	TOKEN
 2C27+474F5355C2	DB	'GOSU', 'B' OR 80H
                	KEY	PRIN, T, PRNTT
 0095+=         PRNTT	EQU	TOKEN
 2C2C+5052494ED4	DB	'PRIN', 'T' OR 80H
                	KEY	INPU, T
 2C31+494E5055D4	DB	'INPU', 'T' OR 80H
                	KEY	REA, D
 2C36+524541C4  	DB	'REA', 'D' OR 80H
                	KEY	RETUR, N
 2C3A+5245545552	DB	'RETUR', 'N' OR 80H
                	KEY	DE, F
 2C40+4445C6    	DB	'DE', 'F' OR 80H
                	KEY	DI, M
 2C43+4449CD    	DB	'DI', 'M' OR 80H
                	KEY	DAT, A, DATAT
 009B+=         DATAT	EQU	TOKEN
 2C46+444154C1  	DB	'DAT', 'A' OR 80H
                	KEY	RESTOR, E, RSTRT
 009C+=         RSTRT	EQU	TOKEN
 2C4A+524553544F	DB	'RESTOR', 'E' OR 80H
                	KEY	STO, P
 2C51+53544FD0  	DB	'STO', 'P' OR 80H
                	KEY	EN, D
 2C55+454EC4    	DB	'EN', 'D' OR 80H
                	IF	NOT WILD
                	KEY	NUL, L
 2C58+4E554CCC  	DB	'NUL', 'L' OR 80H
                	ENDIF
                	KEY	CAL, L
 2C5C+43414CCC  	DB	'CAL', 'L' OR 80H
                	KEY	SCAL, L
 2C60+5343414CCC	DB	'SCAL', 'L' OR 80H
                	IF	NOT WILD
                	KEY	OU, T
 2C65+4F55D4    	DB	'OU', 'T' OR 80H
                	KEY	POK, E
 2C68+504F4BC5  	DB	'POK', 'E' OR 80H
                	KEY	WAI, T
 2C6C+574149D4  	DB	'WAI', 'T' OR 80H
                	ENDIF
                	KEY	UNTRAC, E
 2C70+554E545241	DB	'UNTRAC', 'E' OR 80H
                	KEY	TRAC, E
 2C77+54524143C5	DB	'TRAC', 'E' OR 80H
                	KEY	UNTRA, P
 2C7C+554E545241	DB	'UNTRA', 'P' OR 80H
                	KEY	TRA, P
 2C82+545241D0  	DB	'TRA', 'P' OR 80H
                	KEY	BREA, K, BRKT
 00A9+=         BRKT	EQU	TOKEN
 2C86+42524541CB	DB	'BREA', 'K' OR 80H
                	KEY	UNBREA, K, UNBKT
 00AA+=         UNBKT	EQU	TOKEN
 2C8B+554E425245	DB	'UNBREA', 'K' OR 80H
                	IF	NOT WILD
                	KEY	ENABL, E, ENABT
 00AB+=         ENABT	EQU	TOKEN
 2C92+454E41424C	DB	'ENABL', 'E' OR 80H
                	KEY	DISABL, E, DSABT
 00AC+=         DSABT	EQU	TOKEN
 2C98+4449534142	DB	'DISABL', 'E' OR 80H
                	KEY	RANDOMIZ, E
 2C9F+52414E444F	DB	'RANDOMIZ', 'E' OR 80H
                	ENDIF
                	KEY	RE, M, REMT
 00AE+=         REMT	EQU	TOKEN
 2CA8+5245CD    	DB	'RE', 'M' OR 80H
                	KEY	DELA, Y
 2CAB+44454C41D9	DB	'DELA', 'Y' OR 80H
                	KEY	SAV, E
 2CB0+534156C5  	DB	'SAV', 'E' OR 80H
                	KEY	LOA, D
 2CB4+4C4F41C4  	DB	'LOA', 'D' OR 80H
                	KEY	LIS, T, LISTT
 00B2+=         LISTT	EQU	TOKEN
 2CB8+4C4953D4  	DB	'LIS', 'T' OR 80H
                	KEY	CLEA, R
 2CBC+434C4541D2	DB	'CLEA', 'R' OR 80H
                	KEY	NE, W
 2CC1+4E45D7    	DB	'NE', 'W' OR 80H
                	KEY	RU, N, RUNT
 00B5+=         RUNT	EQU	TOKEN
 2CC4+5255CE    	DB	'RU', 'N' OR 80H
                	KEY	CON, T
 2CC7+434F4ED4  	DB	'CON', 'T' OR 80H
                	IF	NOT CAMAC
                	IF	EDITC
                	KEY	AUT, O
 2CCB+415554CF  	DB	'AUT', 'O' OR 80H
                	KEY	DELET, E
 2CCF+44454C4554	DB	'DELET', 'E' OR 80H
                	KEY	EDI, T
 2CD5+454449D4  	DB	'EDI', 'T' OR 80H
                	KEY	RENU, M
 2CD9+52454E55CD	DB	'RENU', 'M' OR 80H
                	ELSE
                	NOKEY	4
                	ENDIF
                	ENDIF
                	IF	ROMSQ
                	IF	NOT WILD
                	KEY	MOV, E
                	ENDIF
                	KEY	EXE, C
                	ELSE
                	NOKEY	2
 2CDE+FF        	DB	0FFH
 2CDF+FF        	DB	0FFH
                	ENDIF
                	IF	EPSTN
                	KEY	PLO, T
                	ENDIF
                	IF	SDISK AND NOT C3885
                	KEY	OPE, N
                	KEY	CLOS, E
                	KEY	LINPU, T
                	KEY	MARGI, N
                	IF	BENDX
                	KEY	MSO, S
                	KEY	NAM, E
                	KEY	ZA, P
                	ELSE
                	KEY	DI, R
                	KEY	SCRATC, H
                	ENDIF
                	ENDIF
                	IF	BENDX
                	KEY	FILE, S
                	ENDIF
                	IF	CAMAC
                	KEY	CAMA, C
                	KEY	DECLAR, E
                	KEY	DRIVE, R, DRIVT
                	KEY	XENABL, E
                	KEY	RSTATU, S
                	KEY	CAMCL, R
                	KEY	INI, T
                	KEY	INHIBI, T
                	KEY	LOOPCO, L
                	KEY	BYPAS, S
                	KEY	ONLIN, E
                	KEY	PULS, E
                	KEY	OPE, N
                	KEY	CLOS, E
                	IF	NOT C3885
                	KEY	CREAT, E
                	ENDIF
                	KEY	LAMPA, T
                	KEY	BKSE, T
                	KEY	BLOC, K
                	KEY	ENA, B
                	KEY	DISA, B
                	KEY	SETTIM, E
                	ELSE
                	IF	WILD
                	KEY	GETBU, F
                	ELSE
                	KEY	ASSIG, N
 2CE0+4153534947	DB	'ASSIG', 'N' OR 80H
                	ENDIF
                	IF	REALT
                	KEY	SETTIM, E
                	ELSE
                	KEY	TIM, E
 2CE6+54494DC5  	DB	'TIM', 'E' OR 80H
                	ENDIF
                	ENDIF
                	IF	PACKI
                	KEY	ONLIN, E
                	KEY	OFFLIN, E
                	KEY	FIEL, D
                	ENDIF
                	KEY	O, N
 2CEA+4FCE      	DB	'O', 'N' OR 80H
                
                ;FUNCTIONS AND OPS
                	KEY	F, N, UDFNT
 00C0+=         UDFNT	EQU	TOKEN
 2CEC+46CE      	DB	'F', 'N' OR 80H
                	KEY	NO, T
 2CEE+4E4FD4    	DB	'NO', 'T' OR 80H
                	KEY	, +, PLUST
 00C2+=         PLUST	EQU	TOKEN
 2CF1+AB        	DB	'', '+' OR 80H
                	KEY	, -, MINT
 00C3+=         MINT	EQU	TOKEN
 2CF2+AD        	DB	'', '-' OR 80H
                	KEY	, *, MULTT
 00C4+=         MULTT	EQU	TOKEN
 2CF3+AA        	DB	'', '*' OR 80H
                	KEY	, /
 2CF4+AF        	DB	'', '/' OR 80H
                	IF	FLOAT
                	KEY	, \
 2CF5+DC        	DB	'', '\' OR 80H
                	KEY	, ^^
 2CF6+DE        	DB	'', '^' OR 80H
                	ENDIF
                	KEY	^<, =
 2CF7+3CBD      	DB	'<', '=' OR 80H
                	KEY	=, ^<
 2CF9+3DBC      	DB	'=', '<' OR 80H
                	KEY	=, ^>
 2CFB+3DBE      	DB	'=', '>' OR 80H
                	KEY	^>, =
 2CFD+3EBD      	DB	'>', '=' OR 80H
                	KEY	^<, ^>
 2CFF+3CBE      	DB	'<', '>' OR 80H
                	KEY	, =, EQULT
 00CD+=         EQULT	EQU	TOKEN
 2D01+BD        	DB	'', '=' OR 80H
                	KEY	, ^<
 2D02+BC        	DB	'', '<' OR 80H
                	KEY	, ^>
 2D03+BE        	DB	'', '>' OR 80H
                	KEY	AN, D
 2D04+414EC4    	DB	'AN', 'D' OR 80H
                	KEY	XO, R
 2D07+584FD2    	DB	'XO', 'R' OR 80H
                	KEY	O, R
 2D0A+4FD2      	DB	'O', 'R' OR 80H
                	KEY	MO, D
 2D0C+4D4FC4    	DB	'MO', 'D' OR 80H
                	IF	NOT WILD
                	KEY	JOI, N
 2D0F+4A4F49CE  	DB	'JOI', 'N' OR 80H
                	ENDIF
                	KEY	GE, T
 2D13+4745D4    	DB	'GE', 'T' OR 80H
                	KEY	FR, E
 2D16+4652C5    	DB	'FR', 'E' OR 80H
                	IF	NOT WILD
                	KEY	RN, D
 2D19+524EC4    	DB	'RN', 'D' OR 80H
                	ENDIF
                	IF	WILD
                	KEY	BUFFE, R, WBUFT
                	ELSE
                	IF	NOT CAMAC
                	KEY	PO, S
 2D1C+504FD3    	DB	'PO', 'S' OR 80H
                	ENDIF
                	IF	ROMSQ
                	KEY	FIRS, T
                	KEY	LAS, T
                	ELSE
                	NOKEY	2
 2D1F+FF        	DB	0FFH
 2D20+FF        	DB	0FFH
                	ENDIF
                	ENDIF
                	IF	PACKI
                	KEY	FLA, G
                	ENDIF
                	IF	SDISK AND NOT C3885
                	KEY	EO, F
                	ENDIF
                	IF	FLOAT
                	IF	NOT WILD
                	KEY	UN, S
 2D21+554ED3    	DB	'UN', 'S' OR 80H
                	ENDIF
                	KEY	IN, T, INTT
 00DC+=         INTT	EQU	TOKEN
 2D24+494ED4    	DB	'IN', 'T' OR 80H
                	KEY	SQ, R
 2D27+5351D2    	DB	'SQ', 'R' OR 80H
                	KEY	EX, P
 2D2A+4558D0    	DB	'EX', 'P' OR 80H
                	KEY	LO, G
 2D2D+4C4FC7    	DB	'LO', 'G' OR 80H
                	KEY	SI, N
 2D30+5349CE    	DB	'SI', 'N' OR 80H
                	KEY	CO, S
 2D33+434FD3    	DB	'CO', 'S' OR 80H
                	KEY	TA, N
 2D36+5441CE    	DB	'TA', 'N' OR 80H
                	IF	NOT CAMAC
                	KEY	AT, N
 2D39+4154CE    	DB	'AT', 'N' OR 80H
                	ENDIF
                	ENDIF
                	IF	STRNG
                	KEY	BIN, $
 2D3C+42494EA4  	DB	'BIN', '$' OR 80H
                	KEY	HEX, $
 2D40+484558A4  	DB	'HEX', '$' OR 80H
                	KEY	OCT, $
 2D44+4F4354A4  	DB	'OCT', '$' OR 80H
                	KEY	CHR, $
 2D48+434852A4  	DB	'CHR', '$' OR 80H
                	KEY	STR, $
 2D4C+535452A4  	DB	'STR', '$' OR 80H
                	KEY	AS, C
 2D50+4153C3    	DB	'AS', 'C' OR 80H
                	KEY	LE, N
 2D53+4C45CE    	DB	'LE', 'N' OR 80H
                	KEY	VA, L
 2D56+5641CC    	DB	'VA', 'L' OR 80H
                	KEY	LEFT, $
 2D59+4C454654A4	DB	'LEFT', '$' OR 80H
                	KEY	RIGHT, $
 2D5E+5249474854	DB	'RIGHT', '$' OR 80H
                	KEY	MID, $, MIDST
 00EE+=         MIDST	EQU	TOKEN
 2D64+4D4944A4  	DB	'MID', '$' OR 80H
                	KEY	INST, R, INSTT
 00EF+=         INSTT	EQU	TOKEN
 2D68+494E5354D2	DB	'INST', 'R' OR 80H
                	ENDIF
                	IF	CAMAC
                	KEY	CA, M, CAMT
                	KEY	TIME, $
                	IF	C3885
                	KEY	EO, F
                	ELSE
                	KEY	TY, P
                	ENDIF
                	ELSE
                	IF	NOT WILD
                	KEY	IOBYT, E
 2D6D+494F425954	DB	'IOBYT', 'E' OR 80H
                	ENDIF
                	IF	REALT
                	KEY	TIME, $
                	KEY	TIM, E
                	ENDIF
                	ENDIF
                	KEY	SG, N
 2D73+5347CE    	DB	'SG', 'N' OR 80H
                	KEY	AB, S
 2D76+4142D3    	DB	'AB', 'S' OR 80H
                	IF	NOT WILD
                	KEY	MSBYT, E
 2D79+4D53425954	DB	'MSBYT', 'E' OR 80H
                	KEY	LSBYT, E
 2D7F+4C53425954	DB	'LSBYT', 'E' OR 80H
                	KEY	BC, D
 2D85+4243C4    	DB	'BC', 'D' OR 80H
                	KEY	BI, N
 2D88+4249CE    	DB	'BI', 'N' OR 80H
                	KEY	PEE, K
 2D8B+504545CB  	DB	'PEE', 'K' OR 80H
                	KEY	ROTAT, E
 2D8F+524F544154	DB	'ROTAT', 'E' OR 80H
                	KEY	TES, T
 2D95+544553D4  	DB	'TES', 'T' OR 80H
                	KEY	SENS, E
 2D99+53454E53C5	DB	'SENS', 'E' OR 80H
                	KEY	RSHIF, T
 2D9E+5253484946	DB	'RSHIF', 'T' OR 80H
                	KEY	LSHIF, T
 2DA4+4C53484946	DB	'LSHIF', 'T' OR 80H
                	KEY	RESE, T
 2DAA+52455345D4	DB	'RESE', 'T' OR 80H
                	KEY	SE, T
 2DAF+5345D4    	DB	'SE', 'T' OR 80H
                	KEY	I, N
 2DB2+49CE      	DB	'I', 'N' OR 80H
                	ENDIF
                
                ;RESERVED WORDS AND PRINT FUNCTIONS
                	IF	KEY80
 000E =         RWDTK	EQU	0EH		;FIRST RESERVED WORD TOKEN
 000E #         TOKEN	SET	RWDTK
                	ENDIF
                RWDTA:	KEY	THE, N, THENT
 000E+=         THENT	EQU	TOKEN
 2DB4+544845CE  	DB	'THE', 'N' OR 80H
                	KEY	T, O, TOT
 000F+=         TOT	EQU	TOKEN
 2DB8+54CF      	DB	'T', 'O' OR 80H
                	KEY	STE, P, STEPT
 0010+=         STEPT	EQU	TOKEN
 2DBA+535445D0  	DB	'STE', 'P' OR 80H
                	IF	NOT WILD
                	KEY	TA, B, TABT
 0011+=         TABT	EQU	TOKEN
 2DBE+5441C2    	DB	'TA', 'B' OR 80H
                	IF	NOT CAMAC		;NO DEVICES IN CAMAC VERSION
                	KEY	SP, C, SPCT
 0012+=         SPCT	EQU	TOKEN
 2DC1+5350C3    	DB	'SP', 'C' OR 80H
                	KEY	CON, #, CONTK
 0013+=         CONTK	EQU	TOKEN
 2DC4+434F4EA3  	DB	'CON', '#' OR 80H
                	KEY	RDR, #
 2DC8+524452A3  	DB	'RDR', '#' OR 80H
                	KEY	PUN, #
 2DCC+50554EA3  	DB	'PUN', '#' OR 80H
                	KEY	LST, #
 2DD0+4C5354A3  	DB	'LST', '#' OR 80H
                	ENDIF
                	ENDIF
                	IF	FLOAT
                	KEY	SN, G, SNGT		;FOR DEF SNG
 0017+=         SNGT	EQU	TOKEN
 2DD4+534EC7    	DB	'SN', 'G' OR 80H
                	ELSE
                	KEY	UN, S, UNST		;UNS IS PRINT FN IF NONFLOATING
                	IF	STRNG
                	KEY	IN, T, INTT		;FOR DEF INT
                	ENDIF
                	ENDIF
                	IF	STRNG
                	KEY	ST, R, STRGT		;FOR DEF STR
 0018+=         STRGT	EQU	TOKEN
 2DD7+5354D2    	DB	'ST', 'R' OR 80H
                	ELSE
                	KEY	CHR, $, CHRST		;CHR$ IS PRINT FN IF NONSTRING
                	ENDIF
                	IF	NOT WILD
                	IF	ROMSQ
                	KEY	FRO, M, FROMT		;FOR MOVE FROM
                	ELSE
                	NOKEY	1
 2DDA+FF        	DB	0FFH
                	ENDIF
                	ENDIF
                
                ;END OF KEYWORD TABLE
                
                ;TABLE OF KEYWORDS AFTER WHICH <LINE #>S MAY OCCUR, FOR RENUM
                	IF	EDITC AND NOT COMPL
 2DDB 93940EB59CKLNTA:	DB	GOTOT, GSUBT, THENT, RUNT, RSTRT
 2DE0 B2A9AA    	DB	LISTT, BRKT, UNBKT
                	IF	NOT WILD
 2DE3 ABAC      	DB	ENABT, DSABT
                	ENDIF
 000A =         KLNCT	EQU	$-KLNTA
                	ENDIF
                
                ;COPYRIGHT MESSAGE
                ;NOT IN MODULE INITIAL TO PREVENT OVERLAYING
 2DE5 434F505952MWCMA:	DB	'COPYRIGHT 1978, 1979, 1980, 1981'
                	IF	EPSTN
                	DB	13H
                	ENDIF
 2E05 204259204D	DB	' BY MARK WILLIAMS COMPANY, CHICAGO'
                	IF	EPSTN
                	DB	12H, CR, LF, LF, 'PREPARED FOR ', 16H
                	DB	'EPSTEIN & BERGHORN', 12H, ', NORTHBROOK IL', CR, LF
                	ENDIF
 2E27 0D8A      	DB	CR, LF OR 80H
                
                ;END OF TABLES
                	PAGE
                
                ;TOKENIZE 10/22/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;TOKENIZATION AND LINE EDITING
                
                	IF	(NOT WILD) OR (NOT RTPAK)	;WILD RTPAK USES GTLIN IN WILD
                ;GTLIN GETS A LINE OF SOURCE TEXT FROM THE USER AND SETS TEXTP.
                ;USES:	B	TEMP STORAGE
                ;	C	UNUSED
                ;	D	LS BYTE OF FIRST TEXT ADDRESS
                ;	E	LS BYTE OF MAX TEXT ADDRESS
                ;	HL	TEXT ADDRESS
                ;CHARS ARE READ WITH READC AND INSERTED STARTING AT NLNAD, EXCEPT:
                ;	<RUBOUT>	DELETES LAST CHARACTER
                ;	<CONTROL-R>	RETYPES CURRENT LINE
                ;	<CONTROL-U>	STARTS OVER
                ;	<CONTROL-H>	DELETES LAST CHAR, ECHOES <CNTL-H> TO BACKSPACE CURSOR
                ;	<CR>		ECHOES <LF> AND RETURNS
                ;	<CONTROL-G>	ACCEPTED
                ;	OTHER <CONTROL>S	IGNORED (ASCII 0-1FH)
                ;CHARS TYPED WHEN BUFFER IS FULL ECHO <CONTROL-G> AND ARE IGNORED.
                	IF	NOT WILD
                GTLI0:	IF	EPSTN
                	CALL	WRITC		;ECHO THE ^K
                	ELSE
 2E29 CDE22E    	CALL	ECHOC		;ECHO ^U
 2E2C CD7115    	CALL	WCRLF		;WRITE CRLF AFTER ^U
                	ENDIF
                	IF	EDITC
 2E2F 3E0D      	MVI	A,CR
 2E31 322C42    	STA	NLNAD		;CLOBBER OLD BUFFER CONTENTS IN CASE ^E
                	ENDIF
                	ENDIF			;END OF NOT WILD CONDITIONAL
 2E34 117C42    GTLIN:	LXI	D,NLNAD+NLMAX	;LSBYTE OF MAX ADDRESS TO E
 2E37 212C42    	LXI	H,NLNAD		;FIRST TEXT BYTE ADDRESS TO HL
 2E3A 55        	MOV	D,L		;LSBYTE OF TEXT ADDRESS TO D
                	IF	EDITC
 2E3B CD8915    	CALL	READC		;CHECK FIRST CHAR IN CASE ^E
 2E3E FE05      	CPI	CNTLE
                	IF	WILD
                	JNZ	GTLI2
                	ELSE
 2E40 C2492E    	JNZ	GTL1D		;FIRST CHAR NOT ^E
                	ENDIF
 2E43 C3F12E    	JMP	LEDIT		;ENTER LINE EDITOR
                	ENDIF
 2E46 CD8915    GTLI1:	CALL	READC		;GET A CHARACTER
                	IF	NOT WILD
 2E49 FE7F      GTL1D:	CPI	RBOUT
 2E4B C2742E    	JNZ	GTLI2
                	IF	EPSTN
                	CALL	WRITC		;ECHO THE <RUB> IN EPSTEIN VERSION
                	ENDIF
 2E4E 7D        	MOV	A,L		;RUBOUT
 2E4F BA        	CMP	D
 2E50 CA462E    	JZ	GTLI1		;START OVER IF LINE IS EMPTY
                	IF	EPSTN
                	DCX	H
                	JMP	GTLI1		;BACK UP POINTER AND GET NEXT
                	ELSE
 2E53 3E2F      	MVI	A,'/'
 2E55 CD2D15    	CALL	WRITC		;ECHO SLASH FIRST
 2E58 2B        GTL1A:	DCX	H
 2E59 7E        	MOV	A,M		;GET PREVIOUS CHAR
 2E5A CD2D15    	CALL	WRITC		;AND ECHO IT
 2E5D CD8915    GTL1B:	CALL	READC		;READ ANOTHER FROM CONSOLE
 2E60 FE7F      	CPI	RBOUT		;SEE IF STILL RUBBING OUT
 2E62 C26D2E    	JNZ	GTL1C		;NO, ECHO END SLASH AND CONTINUE
 2E65 7D        	MOV	A,L
 2E66 BA        	CMP	D
 2E67 CA5D2E    	JZ	GTL1B		;AT START OF LINE
 2E6A C3582E    	JMP	GTL1A
 2E6D 47        GTL1C:	MOV	B,A		;SAVE NEW CHAR
 2E6E 3E5C      	MVI	A,'\'
 2E70 CD2D15    	CALL	WRITC		;WRITE END SLASH
 2E73 78        	MOV	A,B		;RESTORE NEW CHAR
                	ENDIF			;END OF NOT EPSTN CONDITIONAL
                	ENDIF			;END OF NOT WILD CONDITIONAL
 2E74 77        GTLI2:	MOV	M,A		;INSERT THE CHAR
 2E75 FE0D      	CPI	CR
 2E77 CAAF2E    	JZ	GTLI5		;ECHO LF AND RETURN
                	IF	NOT WILD
 2E7A FE15      	CPI	CNTLU
 2E7C CA292E    	JZ	GTLI0		;CRLF AND START OVER IF ^U
                	ENDIF
                	IF	NOT EPSTN
                	IF	(NOT WILD) OR (NOT RTPAK)
 2E7F FE08      	CPI	CNTLH
 2E81 CACC2E    	JZ	GTLI7		;BACKSPACE IF CONTROL-H
                	ENDIF
                	IF	EDITC
 2E84 FE05      	CPI	CNTLE
 2E86 CADA2E    	JZ	GTLI8		;EDIT ALREADY TYPED LINE IF ^E
                	ENDIF
                	IF	NOT WILD
 2E89 FE12      	CPI	CNTLR
 2E8B CCE22E    	CZ	ECHOC		;ECHO ^R
 2E8E CABC2E    	JZ	GTLI6		;RETYPE LINE IF ^R
                	ENDIF
 2E91 FE07      	CPI	CNTLG
 2E93 CCE22E    	CZ	ECHOC		;ECHO ^G
 2E96 CA9E2E    	JZ	GTLI3		;ACCEPT BELL
 2E99 FE20      	CPI	20H
 2E9B DA462E    	JC	GTLI1		;IGNORE 0H - 1FH (CONTROLS)
                	ENDIF
 2E9E 7D        GTLI3:	MOV	A,L
 2E9F BB        	CMP	E		;CHECK FOR LINE OVERFLOW
 2EA0 7E        	MOV	A,M		;RESTORE CHAR TO A
 2EA1 CCAB2E    	CZ	GTLI4		;REPLACE WITH BELL IF LINE TOO LONG
                	IF	EPSTN
                	CPI	ESCAP
                	CZ	GTLI6		;ECHO ESCAPE AS $ IN EPSTEIN VERSION
                	ENDIF
 2EA4 CD2D15    	CALL	WRITC		;ECHO CHAR
 2EA7 23        	INX	H		;BUMP INSERTION POINTER
 2EA8 C3462E    	JMP	GTLI1		;AND GET NEXT
 2EAB 3E07      GTLI4:	MVI	A,CNTLG		;REPLACE CHAR WITH BELL
 2EAD 2B        	DCX	H		;LEAVE POINTER UNCHANGED
 2EAE C9        	RET
                GTLI5:	IF	NOT COMPL
 2EAF AF        	XRA	A
 2EB0 328042    	STA	CSTKD		;CLEAR CONTROL STACK DIRECT COUNT
                	ENDIF
 2EB3 212C42    	LXI	H,NLNAD
 2EB6 228242    	SHLD	TEXTP		;RESET TEXT POINTER
 2EB9 C37115    	JMP	WCRLF		;ECHO CRLF AND RETURN
                	IF	EPSTN
                GTLI6:	MVI	A,'$'
                	RET
                	ELSE
                	IF	NOT WILD
 2EBC CD7115    GTLI6:	CALL	WCRLF
 2EBF D5        	PUSH	D		;SAVE DE
 2EC0 112C42    	LXI	D,NLNAD		;FIRST ADDR TO DE
 2EC3 7D        	MOV	A,L
 2EC4 93        	SUB	E		;LAST+1 - FIRST = # CHARS TO A
 2EC5 CD3424    	CALL	PRST0		;AND PRINT THE LINE
 2EC8 D1        	POP	D		;RESTORE DE
 2EC9 C3462E    	JMP	GTLI1		;AND WAIT FOR NEXT CHAR
                	ENDIF
                	IF	(NOT WILD) OR (NOT RTPAK)
 2ECC 7D        GTLI7:	MOV	A,L
 2ECD BA        	CMP	D
 2ECE CA462E    	JZ	GTLI1		;IGNORE IF AT START OF LINE
 2ED1 3E08      	MVI	A,CNTLH		;RESTORE THE ^H
 2ED3 CD2D15    	CALL	WRITC		;AND ECHO THE ^H TO BACKSPACE
 2ED6 2B        	DCX	H		;DECREMENT POSITION
 2ED7 C3462E    	JMP	GTLI1
                	ENDIF
                	IF	EDITC
 2EDA CD7115    GTLI8:	CALL	WCRLF		;WRITE CRLF TO GET TO NEW LINE
 2EDD 360D      	MVI	M,CR		;STORE CR
 2EDF C3F12E    	JMP	LEDIT		;LINE EDIT THE LINE
                	ENDIF
                	ENDIF			;END OF NOT EPSTN CONDITIONAL
                
                ;ECHOC ECHOES MEANINGFUL CONTROL CHARS AS ^CHAR.
                ;CALL:	A	CONTROL CHAR VALUE IN ASCII
                ;RETN:	PSW,A,BC,DE,HL	PRESERVED
 2EE2 F5        ECHOC:	PUSH	PSW
 2EE3 3E5E      	MVI	A,'^'
 2EE5 CD2D15    	CALL	WRITC		;WRITE ^
 2EE8 F1        	POP	PSW		;RESTORE CONTROL CHAR VALUE
 2EE9 F5        	PUSH	PSW		;AND RESAVE
 2EEA C640      	ADI	40H		;ADD ASCII BIAS
 2EEC CD2D15    	CALL	WRITC		;WRITE THE CHAR
 2EEF F1        	POP	PSW		;RESTORE STATUS BITS AND A
 2EF0 C9        	RET
                	ENDIF			;END OF NOT WILD AND NOT RTPAK CONDITIONAL
                
                	IF	EDITC
                ;LEDIT DOES THE WORK OF LINE EDITING.
                ;USES:	B	CHARS LEFT OF CURSOR, INITIALLY 0
                ;	C	MAX # OF CHARS TO ADD WITHOUT OVERFLOWING BUFFER
                ;	HL	CURSOR POSITION, INITIALLY NLNAD
                ;	NLNAD	LINE CURRENTLY BEING EDITED
                ;	TLNAD	ORIGINAL CONTENTS OF LINE (IN CASE ^U TYPED)
                ;RETN:	NLNAD	CONTAINS EDITED LINE
                ;	TEXTP	RESET TO NLNAD
                ;	CSTKD	RESET TO 0
                ;	GCHAR	RESET TO 0
                ;	TLNAD	CLOBBERED
                ;	REGISTERS	CLOBBERED
 2EF1 212C42    LEDIT:	LXI	H,NLNAD		;INPUT BUFFER ADDRESS TO HL
 2EF4 228242    	SHLD	TEXTP		;RESET TEXTP
 2EF7 11D941    	LXI	D,TLNAD		;TOKENIZATION BUFFER ADDRESS TO DE
 2EFA 015300    LEDT0:	LXI	B,NLMAX+3	;0 TO B, NLMAX+3 TO C
 2EFD 7E        LEDT1:	MOV	A,M		;FETCH CHAR FROM INPUT BUFFER
 2EFE 12        	STAX	D		;AND SAVE IN TOKENIZATION BUFFER
 2EFF 0D        	DCR	C		;DECREMENT REMAINING CHAR COUNT
 2F00 13        	INX	D
 2F01 23        	INX	H
 2F02 D60D      	SUI	CR		;CHECK IF AT CR
 2F04 C2FD2E    	JNZ	LEDT1		;NO, KEEP COPYING
 2F07 328042    	STA	CSTKD		;CLEAR CSTACK DIRECT COUNT
 2F0A 329A40    	STA	GCHAR		;CLEAR GCHAR
 2F0D 212C42    	LXI	H,NLNAD		;INPUT BUFFER ADDRESS TO HL
 2F10 CDEB2F    	CALL	LEDI6		;TYPE LINE
 2F13 CD8915    LEDT2:	CALL	READC		;GET COMMAND CHARACTER
 2F16 FE0D      LEDT3:	CPI	CR
 2F18 CA2030    	JZ	LED11		;DONE IF <CR>
 2F1B FE15      	CPI	CNTLU
 2F1D CA1430    	JZ	LED10		;^U
 2F20 E5        	PUSH	H
 2F21 21132F    	LXI	H,LEDT2
 2F24 E3        	XTHL			;PUSH LEDT2 TO ALLOW RETURN FROM ROUTINES
 2F25 FE7F      	CPI	RBOUT
 2F27 CA782F    	JZ	LEDI1		;<RUBOUT>
 2F2A FE20      	CPI	20H
 2F2C D25D2F    	JNC	LEDI0		;PRINTABLE CHAR
 2F2F FE04      	CPI	CNTLD
 2F31 CA9D2F    	JZ	LEDI2		;^D
 2F34 FE06      	CPI	CNTLF
 2F36 CAB02F    	JZ	LEDI3		;^F
 2F39 FE07      	CPI	CNTLG
 2F3B CA5D2F    	JZ	LEDI0		;^G, TREAT AS PRINTABLE
 2F3E FE08      	CPI	CNTLH
 2F40 CAD42F    	JZ	LEDI4		;^H
 2F43 FE0B      	CPI	CNTLK
 2F45 CAE12F    	JZ	LEDI5		;^K
 2F48 FE0C      	CPI	CNTLL
 2F4A CAEB2F    	JZ	LEDI6		;^L
 2F4D FE0E      	CPI	CNTLN
 2F4F CAFD2F    	JZ	LEDI7		;^N
 2F52 FE12      	CPI	CNTLR
 2F54 CA0330    	JZ	LEDI8		;^R
 2F57 FE14      	CPI	CNTLT
 2F59 CA0B30    	JZ	LEDI9		;^T
 2F5C C9        	RET			;IGNORE ANY OTHER CHARS
                
                ;PRINTABLE CHAR OR ^G IS INSERTED.
 2F5D 0D        LEDI0:	DCR	C		;DECREMENT CHAR COUNT
 2F5E CA722F    	JZ	LED0B		;TOO MANY CHARS
 2F61 56        	MOV	D,M		;CHAR RIGHT OF CURSOR TO D
 2F62 77        	MOV	M,A		;INSERT NEW CHAR
 2F63 CD0F30    	CALL	LED9A		;INCR CHARS LEFT OF CURSOR AND ECHO CHAR
 2F66 E5        	PUSH	H		;AND SAVE
 2F67 7A        LED0A:	MOV	A,D		;FETCH SAVED CHAR
 2F68 56        	MOV	D,M		;SAVE NEXT CHAR
 2F69 77        	MOV	M,A		;STORE CURRENT CHAR
 2F6A 23        	INX	H
 2F6B FE0D      	CPI	CR
 2F6D C2672F    	JNZ	LED0A
 2F70 E1        	POP	H		;RESTORE CURSOR LOC
 2F71 C9        	RET
 2F72 0C        LED0B:	INR	C		;UNDECREMENT COUNT
 2F73 3E07      LED0C:	MVI	A,CNTLG
 2F75 C32D15    	JMP	WRITC		;AND WRITE A BELL
                
                ;<RUBOUT> ERASES THE CHAR LEFT OF CURSOR, ECHOING IT WITHIN SLASHES.
 2F78 78        LEDI1:	MOV	A,B
 2F79 B7        	ORA	A
 2F7A C8        	RZ			;IGNORE IF ALREADY AT LEFT MARGIN
 2F7B 3E2F      	MVI	A,'/'
 2F7D CD2D15    	CALL	WRITC		;WRITE INITIAL /
 2F80 2B        LED1A:	DCX	H
 2F81 7E        	MOV	A,M
 2F82 CDDA2F    	CALL	LED4A		;WRITE DELETED CHAR AND MOVE REMAINDER OF LINE
 2F85 CD8915    	CALL	READC		;READ NEXT CHAR
 2F88 FE7F      	CPI	RBOUT
 2F8A C2922F    	JNZ	LED1B		;NO ADDITIONAL <RUBOUT>S
 2F8D 78        	MOV	A,B
 2F8E B7        	ORA	A
 2F8F C2802F    	JNZ	LED1A		;<RUBOUT> ANOTHER
 2F92 57        LED1B:	MOV	D,A		;SAVE NEXT CHAR
 2F93 3E5C      	MVI	A,'\'
 2F95 CD2D15    	CALL	WRITC		;WRITE THE END \
 2F98 7A        	MOV	A,D		;RESTORE NEXT CHAR
 2F99 D1        	POP	D		;POP THE RETURN TO LEDIT
 2F9A C3162F    	JMP	LEDT3		;AND RETURN TO LEDT1 INSTEAD
                
                ;^D DELETES THE CHAR RIGHT OF CURSOR.
 2F9D 7E        LEDI2:	MOV	A,M		;FETCH CHAR RIGHT OF CURSOR
 2F9E FE0D      	CPI	CR
 2FA0 C8        	RZ			;LEAVE UNCHANGED IF AT END OF LINE
 2FA1 0C        	INR	C		;ONE MORE CHAR IS NOW AVAILABLE
 2FA2 E5        	PUSH	H		;SAVE CURSOR LOCATION
 2FA3 54        	MOV	D,H
 2FA4 5D        	MOV	E,L
 2FA5 23        LED2A:	INX	H
 2FA6 7E        	MOV	A,M		;FETCH NEXT CHAR
 2FA7 12        	STAX	D		;AND STORE
 2FA8 13        	INX	D
 2FA9 FE0D      	CPI	CR
 2FAB C2A52F    	JNZ	LED2A		;CONTINUE UNTIL CR
 2FAE E1        	POP	H		;RESTORE CURSOR
 2FAF C9        	RET
                
                ;^F <CHAR> SEARCHES FOR NEXT OCCURENCE OF <CHAR>.
 2FB0 CD8915    LEDI3:	CALL	READC		;GET SEARCH CHARACTER
 2FB3 329A40    	STA	GCHAR		;AND SAVE
 2FB6 57        LED3A:	MOV	D,A		;SEARCH CHAR TO D
 2FB7 E5        	PUSH	H		;SAVE CURSOR POSITION
 2FB8 7E        LED3B:	MOV	A,M		;FETCH NEXT CHAR
 2FB9 23        	INX	H
 2FBA FE0D      	CPI	CR		;CHECK IF AT CR
 2FBC CAD02F    	JZ	LED3D		;NOT FOUND
 2FBF BA        	CMP	D		;CHECK FOR MATCH
 2FC0 C2B82F    	JNZ	LED3B
 2FC3 EB        	XCHG			;MATCH LOCATION TO DE
 2FC4 E1        	POP	H		;RESTORE CURRENT LOC
 2FC5 CD8602    LED3C:	CALL	CMDHU		;COMPARE CURRENT TO DESIRED
 2FC8 C8        	RZ
 2FC9 7E        	MOV	A,M
 2FCA CD0F30    	CALL	LED9A		;MOVE RIGHT AND PRINT
 2FCD C3C52F    	JMP	LED3C
 2FD0 E1        LED3D:	POP	H		;RECOVER CURSOR LOCATION
 2FD1 C3732F    	JMP	LED0C		;BEEP AND CONTINUE
                
                ;^H DELETES CHAR LEFT OF CURSOR AND ECHOES ^H.
 2FD4 78        LEDI4:	MOV	A,B
 2FD5 B7        	ORA	A
 2FD6 C8        	RZ			;NO CHARS LEFT OF CURSOR
 2FD7 2B        	DCX	H
 2FD8 3E08      	MVI	A,CNTLH
 2FDA CD2D15    LED4A:	CALL	WRITC		;ECHO THE ^H
 2FDD 05        	DCR	B		;DECREMENT CHARS LEFT OF CURSOR
 2FDE C39D2F    	JMP	LEDI2		;MOVE REMAINDER OF CHARS
                
                ;^K KILLS THE CHARS RIGHT OF THE CURSOR.
 2FE1 7E        LEDI5:	MOV	A,M		;FETCH NEXT
 2FE2 FE0D      	CPI	CR
 2FE4 C8        	RZ			;DONE IF AT CR
 2FE5 CD9D2F    	CALL	LEDI2		;ELSE DELETE A CHAR
 2FE8 C3E12F    	JMP	LEDI5		;AND REPEAT
                
                ;^L PRINTS REMAINDER OF LINE AND MOVES CURSOR TO LEFT.
 2FEB 7E        LEDI6:	MOV	A,M
 2FEC 23        	INX	H
 2FED CD2D15    	CALL	WRITC		;WRITE NEXT CHAR
 2FF0 FE0D      	CPI	CR
 2FF2 C2EB2F    	JNZ	LEDI6		;NOT AT <CR> YET
 2FF5 212C42    	LXI	H,NLNAD		;CURSOR AT LEFT OF LINE
 2FF8 0600      	MVI	B,0		;0 CHARS LEFT OF CURSOR
 2FFA C37615    	JMP	WLF		;WRITE <LF> AFTER <CR>
                
                ;^N GETS NEXT OCCURENCE OF ^F <CHAR>.
 2FFD 3A9A40    LEDI7:	LDA	GCHAR		;GET PREVIOUS ^F CHARACTER
 3000 C3B62F    	JMP	LED3A		;AND CONTINUE AS FOR ^F
                
                ;^R RETYPES THE LINE, LEAVING CURSOR UNCHANGED.
 3003 54        LEDI8:	MOV	D,H
 3004 5D        	MOV	E,L		;CURSOR POSITION TO DE
 3005 CDEB2F    	CALL	LEDI6		;TYPE REMAINDER OF LINE
 3008 C3C52F    	JMP	LED3C
                
                ;^T MOVES THE CURSOR ONE CHAR RIGHT.
 300B 7E        LEDI9:	MOV	A,M		;FETCH NEXT
 300C FE0D      	CPI	CR
 300E C8        	RZ			;DONE IF NO CHARS RIGHT OF CURSOR
 300F 23        LED9A:	INX	H
 3010 04        	INR	B		;INCREMENT CHARS TO LEFT COUNT
 3011 C32D15    	JMP	WRITC		;ECHO CHAR AND RETURN
                
                ;^U RESTORES THE ORIGINAL CONTENTS OF THE BUFFER AND RETRIES.
 3014 CD7115    LED10:	CALL	WCRLF		;WRITE CRLF
 3017 21D941    	LXI	H,TLNAD		;TOKENIZATION BUFFER ADDRESS TO HL
 301A 112C42    	LXI	D,NLNAD		;INPUT BUFFER ADDRESS TO DE
 301D C3FA2E    	JMP	LEDT0		;AND CONTINUE AS ABOVE
                
                ;<CR> RESETS GCHAR, PRINTS THE EDITED LINE AND EXITS FROM LINE EDITOR.
 3020 AF        LED11:	XRA	A
 3021 329A40    	STA	GCHAR		;RESET GET CHARACTER
 3024 C3EB2F    	JMP	LEDI6		;PRINT LINE AND RETURN
                
                	ENDIF			;END OF EDITC CONDITIONAL
                
                	IF	WILD OR NOT COMPL
                ;TKIZE TOKENIZES A LINE OF TEXT AND COMPUTES ITS LENGTH.
                ;CALL:	(NEWLN)	ADDRESS OF FIRST TEXT BYTE
                ;USES:	BC	ADDRESS OF NEXT TOKENIZED TEXT LINE BYTE
                ;	HL	ADDRESS OF NEXT UNTOKENIZED TEXT LINE BYTE
                ;RETN:	A,BC,DE	CLOBBERED
                ;	HL	ADDRESS OF FIRST TOKENIZED TEXT LINE BYTE (I.E. (NEWLN))
                ;	(TEXTP)	DITTO
                ;	(LNNUM)	LINE #, 0 IF NONE
                ;	(LNLEN)	LENGTH OF TOKENIZED LINE + OVERHEAD, 0 TO DELETE
                ;			(I.E. IF LINE CONSISTS OF [<LINE #>] <CR>)
                ;	CARRY	SET IFF NO LINE # AND LINE NOT <CR>
                ;	ZERO	SET IF <CR>
                ;THE TOKENIZED LINE IS IDENTICAL TO THE ORIGINAL LINE, EXCEPT:
                ;(1)  THE LINE # (IF ANY) AND SPACES PRECEDING IT ARE REMOVED, AND
                ;(2)  INSTANCES OF KEYWORDS NOT INSIDE " " OR FOLLOWING # ARE REPLACED
                ;	BY THE CORREPONDING TOKENS.
                ;0 IS STORED IN THE BYTE AFTER <CR> AS A PSEUDO-EOF FOR DIRECT MODE EXECUTION.
                TKIZE:	IF	NOT (WILD AND RTPAK)
 3027 CDAB31    	CALL	LNNU0
                	ENDIF
 302A 212C42    	LXI	H,NLNAD		;STORE TEXT ADDRESS IN HL
 302D 01D941    	LXI	B,TLNAD		;TOKENIZED LINE ADDRESS TO BC
 3030 C5        	PUSH	B		;SAVE FOR EXIT
 3031 CDF217    	CALL	GTDEC		;LOOK FOR DECIMAL LINE #
 3034 DA3C30    	JC	TKIZ0		;NONE
 3037 7A        	MOV	A,D
 3038 B3        	ORA	E
 3039 CA9201    	JZ	SNERR		;SN ERROR IF ZERO OR TOO BIG
 303C F5        TKIZ0:	PUSH	PSW		;CARRY SET IFF NO LINE #
 303D EB        	XCHG
 303E 224B40    	SHLD	LNNUM		;LINE # TO LNNUM
 3041 EB        	XCHG
 3042 7E        	MOV	A,M		;NEXT TEXT CHAR TO A
 3043 D60D      	SUI	CR		;COMPARE WITH SUI (TO USE ZERO)
 3045 C25330    	JNZ	TKIZ1
 3048 23        	INX	H		;DELETE LINE BY LETTING LENGTH = 0
 3049 77        	MOV	M,A		;STORE PSEUDO-EOF
 304A 327F42    	STA	LNLEN
 304D F1        	POP	PSW
 304E 7A        	MOV	A,D
 304F B3        	ORA	E		;CARRY RESET, ZERO SET IFF <CR>
 3050 C36B30    	JMP	STTP1		;SET TEXTP AND RETURN
 3053 CD8B30    TKIZ1:	CALL	TKIZB		;TOKENIZE BODY OF INPUT LINE
 3056 AF        	XRA	A
 3057 02        	STAX	B		;PSEUDO-EOF FOR DIRECT MODE EXEC
 3058 21D941    	LXI	H,TLNAD
 305B 7D        	MOV	A,L		;LSBYTE OF FIRST ADDRESS TO A
 305C 2F        	CMA			;- FIRST TEXT ADDRESS - 1
 305D 81        	ADD	C		;+ LAST ADDRESS + 1 = ACTUAL LENGTH - 1
 305E C605      	ADI	5		;+ LINE OVERHEAD + 1 = LENGTH
 3060 327F42    	STA	LNLEN		;STORE TOKENIZED LINE LENGTH
 3063 F1        	POP	PSW		;CARRY SET IFF NO LINE #
 3064 D26B30    	JNC	STTP1
 3067 2B        	DCX	H
 3068 22BD41    	SHLD	SAVTP		;INITIALIZE SAVTP FOR DIRECT MODE COMMANDS
 306B E1        STTP1:	POP	H		;RETURN FIRST TEXT BYTE ADDR IN HL
 306C 228242    	SHLD	TEXTP		;INITIALIZE TEXT POINTER
 306F C9        	RET
                
 3070 3E95      COPYP:	MVI	A,PRNTT		;SUBSTITUTE PRINT TOKEN FOR ?
 3072 02        TKIZA:	STAX	B
 3073 03        	INX	B
 3074 23        	INX	H
 3075 163A      	MVI	D,':'
 3077 FE9B      	CPI	DATAT
 3079 CA8830    	JZ	TKZA2		;DO NOT TOKENIZE DATA
 307C FEAE      	CPI	REMT
                	IF	WILD AND RTPAK	;SUPPRESS COMMENTS IN WILD RTPAK TOKENIZATION
                	JZ	WREM
                	CPI	''''
                	JNZ	TKIZB
                WREM:	MVI	A,CR
                	STAX	B
                	INX	B
                	RET
                	ELSE
 307E CA8630    	JZ	TKZA1		;OR REMARKS (FOR ?)
 3081 FE27      	CPI	''''
 3083 C28B30    	JNZ	TKIZB		;OR ON-LINE COMMENTS
                	ENDIF			;END OF NOT (WILD AND RTPAK) CONDITIONAL
 3086 160D      TKZA1:	MVI	D,CR
 3088 CDC730    TKZA2:	CALL	CPYD1		;COPY WITHOUT TOKENIZING
 308B CDD230    TKIZB:	CALL	COPYS		;COPY SPACES
 308E FE22      	CPI	'"'
 3090 CCC330    	CZ	COPYQ		;COPY TO CLOSE QUOTE
 3093 FE23      	CPI	'#'
 3095 CAD930    	JZ	COPYH		;WATCH FOR KEYWORDS AFTER #
 3098 FE0D      	CPI	CR
 309A CABF30    	JZ	COPYA		;FINISHED IF CR -- COPY AND RETURN
 309D FE3F      	CPI	'?'
 309F CA7030    	JZ	COPYP		;? ABBREVIATION FOR PRINT
 30A2 C5        	PUSH	B		;SAVE TOKENIZED TEXT POINTER
 30A3 0E8F      	MVI	C,-NKEYS AND 0FFH	;TABLE LENGTH TO C
 30A5 11172C    	LXI	D,KEYTA		;TABLE ADDRESS TO DE
 30A8 CDF330    	CALL	TLKUP		;PERFORM TABLE LOOKUP
                	IF	KEY80
 30AB D2BB30    	JNC	TKIZC		;FOUND IT
 30AE 0EF4      	MVI	C,-NRWDS AND 0FFH
 30B0 11B42D    	LXI	D,RWDTA
 30B3 CDF330    	CALL	TLKUP		;CHECK FOR RESERVED WORD
 30B6 DABB30    	JC	TKIZC		;NOT A KEYWORD NOR A RESERVED WORD
 30B9 C61A      	ADI	RWDTK+NRWDS	;USE TOKENS STARTING AT RWDTK
                	ENDIF
 30BB C1        TKIZC:	POP	B		;RESTORE TEXT POINTER
 30BC C37230    	JMP	TKIZA		;COPY A AND KEEP TOKENIZING
                
                
                ;TOKENIZER ROUTINES.
                ;COPYA COPIES ONE CHAR FROM A THROUGH BC.
                ;COPYS COPIES SUCCESSIVE SPACES (IF ANY) FROM M THROUGH BC.
                ;COPYQ COPIES " FROM A THROUGH BC, THEN COPIES FROM M THROUGH BC UNTIL
                ;	" (INCLUSIVE, INCL. TRAILING SPACES) OR UNTIL <CR> (EXCLUSIVE).
                ;COPYH COPIES HEX DIGITS, SO E.G. #DEF AND #BIN TOKENIZE CORRECTLY.
                ;CALL:	BC	ADDRESS OF NEXT AVAILABLE DESTINATION
                ;	HL	ADDRESS OF NEXT AVAILABLE CHAR (I.E. SOURCE)
                ;RETN:	A	CHAR COPIED FOR COPY1,COPYA
                ;		FIRST CHAR NOT COPIED FOR COPYS, COPYQ
                ;	BC	NEXT AVAILABLE DESTINATION ADDRESS
                ;	DE	PRESERVED
                ;	HL	NEXT AVAILABLE SOURCE ADDRESS
                
 30BF 02        COPYA:	STAX	B		;STORE THROUGH BC
 30C0 03        	INX	B
 30C1 23        	INX	H
 30C2 C9        	RET
                
 30C3 57        COPYQ:	MOV	D,A
 30C4 02        COPYD:	STAX	B
 30C5 03        	INX	B
 30C6 23        	INX	H		;COPY CURRENT CHARACTER
 30C7 7E        CPYD1:	MOV	A,M
 30C8 FE0D      	CPI	CR
 30CA C8        	RZ			;RETURN WITHOUT COPYING IF CR
 30CB BA        	CMP	D
 30CC C2C430    	JNZ	COPYD		;KEEP COPYING IF NEITHER (D) NOR CR
 30CF 02        COPS0:	STAX	B
 30D0 03        	INX	B
 30D1 23        COPS1:	INX	H
 30D2 7E        COPYS:	MOV	A,M
 30D3 FE20      	CPI	' '
 30D5 C0        	RNZ			;RETURN AT FIRST NON-SPACE
                	IF	WILD AND RTPAK
                	JMP	COPS1		;SUPPRESS SPACES IN WILD RTPAK TOKENIZATION
                	ELSE
 30D6 C3CF30    	JMP	COPS0
                	ENDIF
                
 30D9 02        COPYH:	STAX	B
 30DA 03        	INX	B
 30DB 23        	INX	H		;COPY CHAR AND SPACES
 30DC 7E        	MOV	A,M
 30DD CDD617    	CALL	LDTST		;TEST IF LETTER OR DIGIT
 30E0 D2EB30    	JNC	CPYH1		;YES
 30E3 D620      	SUI	20H		;CONVERT FROM POSSIBLE LOWER CASE
 30E5 CDD617    	CALL	LDTST
 30E8 DA8B30    	JC	TKIZB		;NOT A LETTER OR DIGIT
 30EB FE47      CPYH1:	CPI	'F'+1
 30ED D28B30    	JNC	TKIZB		;LETTER BUT NOT LEGIT HEX DIGIT
 30F0 C3D930    	JMP	COPYH		;OK, COPY IT
                
                ;TLKUP PERFORMS TABLE LOOKUP FOR THE TOKENIZER.
                ;CALL:	C	- NUMBER OF TABLE ENTRIES
                ;	DE	ADDRESS OF FIRST TABLE BYTE
                ;	HL	ADDRESS OF FIRST TEXT BYTE
                ;RETN:	CARRY	SET IF NOT FOUND
                ;	A	TOKEN (POSITION OF MATCHED WORD FROM TABLE BOTTOM) IF FOUND,
                ;			FIRST TEXT BYTE IF NOT
                ;	B	PRESERVED
                ;	C	TOKEN IF FOUND, ZERO IF NOT
                ;	DE	ADDRESS OF FIRST TEXT BYTE IF FOUND,
                ;			OF FIRST BYTE FOLLOWING TABLE IF NOT
                ;	HL	ADDRESS OF LAST MATCHED TEXT BYTE IF FOUND,
                ;			OF FIRST TEXT BYTE (I.E. UNCHANGED) IF NOT
 30F3 E5        TLKUP:	PUSH	H		;SAVE TEXT POINTER
 30F4 7E        TLKU0:	MOV	A,M		;FETCH TEXT CHAR
 30F5 D620      	SUI	20H		;CONVERT LOWER CASE TO UPPER
 30F7 FE41      	CPI	'A'
 30F9 DA0231    	JC	TLKU1		;CHAR  < 'A'
 30FC FE5B      	CPI	'Z'+1
 30FE D20231    	JNC	TLKU1		;CHAR > 'Z'
 3101 77        	MOV	M,A		;STORE CONVERTED CHAR
 3102 1A        TLKU1:	LDAX	D		;TABLE BYTE TO A
 3103 BE        	CMP	M		;COMPARE TO TEXT BYTE
 3104 C20C31    	JNZ	TLKU2
 3107 13        	INX	D		;MATCHED -- TRY NEXT BYTE
 3108 23        	INX	H
 3109 C3F430    	JMP	TLKU0
 310C E67F      TLKU2:	ANI	7FH		;RESET SIGN BIT OF TABLE BYTE
 310E BE        	CMP	M		;COMPARE AGAIN
 310F C21531    	JNZ	TLKU3		;FAILED -- NO MATCH
 3112 79        	MOV	A,C		;MATCH -- RETURN TOKEN IN A, CARRY RESET
 3113 D1        	POP	D		;UNSTACK THE SAVED POINTER
 3114 C9        	RET
 3115 1A        TLKU3:	LDAX	D		;FAILED
 3116 13        	INX	D
 3117 E680      	ANI	80H		;LOOK AT SIGN BIT
 3119 CA1531    	JZ	TLKU3		;KEEP LOOKING FOR END OF ENTRY
 311C E1        	POP	H		;RESTORE TEXT POINTER
 311D 0C        	INR	C		;INCREMENT COUNT
 311E C2F330    	JNZ	TLKUP		;TRY NEXT TABLE ENTRY
 3121 7E        	MOV	A,M		;RETURN TEXT CHAR IF NO MATCH
 3122 37        	STC			;RETURN CARRY ON FAILURE
 3123 C9        	RET
                	ENDIF			;END OF WILD OR NOT COMPL CONDITIONAL
                
                	IF	NOT COMPL
                ;ADDL ADDS A TOKENIZED LINE TO SOURCE TEXT.
                ;CALL:	(LNNUM)	LINE #
                ;	(LNLEN)	LINE LENGTH, 0 TO DELETE
                ;	(NEWLN)	ADDRESS OF FIRST BYTE OF NEW LINE
                ;	(EOFAD)	END OF SOURCE FILE ADDRESS
                ;IF LINE # IS ALREADY IN TEXT, THE OLD LINE IS REPLACED WITH THE NEW.
                ;IF NOT, THE NEW LINE IS SIMPLY INSERTED.
                ;BRANCHES OUT IF MEMORY FULL, I.E. IF SOURCE TOP OVERLAPS SYMBOL TABLE BOTTOM.
                ;CLOBBERS ALL REGISTERS.
                ADDLN:	IF	ROMSQ
                	LXI	D,SRCAD
                	LHLD	SOURC
                	CALL	CMDHU		;ZERO SET IFF ADDRESSING WORKING SPACE
                	CNZ	LNNU0		;NOT IN WORKING SPACE, RESET LNNUM TO 0
                	JNZ	ROERR		;AND ISSUE FATAL RO ERROR
                	ENDIF
 3124 2A4B40    	LHLD	LNNUM
 3127 EB        	XCHG			;LINE # TO DE
 3128 CDC131    	CALL	FINDL		;LOOK FOR IT
 312B E5        	PUSH	H		;SAVE POINTER FOR LINE INSERTION LATER
 312C 010000    	LXI	B,0		;LENGTH OF OLD LINE TO BC
 312F DA3331    	JC	ADDL0		;0 IF NO SUCH LINE,
 3132 4E        	MOV	C,M		;  ELSE LENGTH FROM POINTER
 3133 09        ADDL0:	DAD	B		;ADDRESS OF NEXT  LINE = OLD + LENGTH TO HL
 3134 22B941    	SHLD	TEMP		;SAVE IT FOR OLD > NEW CASE BELOW
 3137 EB        	XCHG
 3138 CD6502    	CALL	CPLDE		;- NEXT LINE ADDRESS TO DE
 313B 2A8642    	LHLD	EOFAD		;END OF FILE ADDRESS TO HL
 313E 23        	INX	H
 313F 19        	DAD	D		;EOF - NEXT LINE + 1 = COUNT TO HL
 3140 EB        	XCHG			;COUNT TO DE FOR BLOCK MOVE
 3141 3A7F42    	LDA	LNLEN		;NEW LINE LENGTH TO A, 0 TO DELETE
 3144 91        	SUB	C		;NEW - OLD = OFFSET
 3145 4F        	MOV	C,A		;OFFSET TO C
 3146 DA9A31    	JC	ADDL4		;OLD > NEW
 3149 CA7431    	JZ	ADDL2		;OLD = NEW, SO JUST INSERT IT
                ;BLOCK MOVE TEXT BELOW LONGER NEW LINE
 314C D5        	PUSH	D		;OLD < NEW
 314D 2AC641    	LHLD	SYMTA
 3150 11F7FF    	LXI	D,-9
 3153 19        	DAD	D		;LEAVE ENOUGH ROOM TO COMPUTE TRIVIAL EXPRS
 3154 EB        	XCHG			;SYMBOL TABLE ADDRESS TO DE
 3155 2A8642    	LHLD	EOFAD
 3158 E5        	PUSH	H
 3159 09        	DAD	B		;HL GETS EOFAD + OFFSET = DESTINATION
 315A 44        	MOV	B,H
 315B 4D        	MOV	C,L
 315C CD8002    	CALL	CMBDU		;COMPARE DESTINATION TO SYMBOL TABLE ADDR
 315F D4AB31    	CNC	LNNU0		;OUT OF MEMORY -- RESET LNNUM TO 0
 3162 D2011B    	JNC	OMERR		;AND ISSUE FATAL OM ERROR
 3165 228642    	SHLD	EOFAD		;RESET EOF ADDRESS
 3168 C1        	POP	B		;BC GETS OLD EOF ADDRESS = SOURCE
 3169 D1        	POP	D		;RESTORE COUNT
 316A 0A        ADDL1:	LDAX	B		;FETCH BYTE FROM BC
 316B 77        	MOV	M,A		;STORE THROUGH HL
 316C 0B        	DCX	B
 316D 2B        	DCX	H
 316E 1B        	DCX	D
 316F 7A        	MOV	A,D
 3170 B3        	ORA	E
 3171 C26A31    	JNZ	ADDL1		;MOVE MORE BYTES
                ;INSERT CURRENT LINE INTO SOURCE
 3174 D1        ADDL2:	POP	D		;RECOVER INSERTION ADDRESS
 3175 3A7F42    	LDA	LNLEN
 3178 B7        	ORA	A
 3179 CA9431    	JZ	ADDL3		;DONE IF LENGTH = 0
 317C 12        	STAX	D		;ELSE STORE LENGTH
 317D D604      	SUI	4		;LENGTH - OVERHEAD = LENGTH TO MOVE
 317F 01D941    	LXI	B,TLNAD		;SOURCE ADDRESS TO BC
 3182 2A4B40    	LHLD	LNNUM
                	IF	EDITC
 3185 224D40    	SHLD	ERRLN		;SET ERRLN
                	ENDIF
 3188 EB        	XCHG			;INSERTION ADDR TO HL, LNNUM TO DE
 3189 CD1F1D    	CALL	MOMDE		;STORE LINE #
 318C 23        	INX	H
 318D 3600      	MVI	M,0		;STORE ZERO BREAK BYTE
 318F 23        	INX	H		;HL NOW HAS DESTINATION
 3190 5F        	MOV	E,A		;ACTUAL LENGTH TO E FOR INSERTION
 3191 CDB431    	CALL	MOVD0		;COPY NEW LINE INTO TEXT
                ;RESET STACKS AND RETURN
 3194 2A8642    ADDL3:	LHLD	EOFAD		;EOF ADDRESS TO HL
 3197 C33822    	JMP	NEW1		;RESET STACKS AND RETURN
                ;BLOCK MOVE TEXT BELOW SHORTER NEW LINE
 319A 2AB941    ADDL4:	LHLD	TEMP		;RECOVER NEXT TEXT LINE ADDRESS
 319D E5        	PUSH	H
 319E 05        	DCR	B		;B BECOMES 255, SINCE OFFSET IN BC IS < 0
 319F 09        	DAD	B		;HL GETS NEXT + OFFSET = DESTINATION
 31A0 C1        	POP	B		;BC GETS NEXT = SOURCE
 31A1 CDB631    	CALL	MOVED		;MOVE TEXT DOWN IN MEMORY
 31A4 2B        	DCX	H
 31A5 228642    	SHLD	EOFAD		;RESET EOF ADDRESS
 31A8 C37431    	JMP	ADDL2		;AND INSERT CURRENT LINE
                
                ;LNNU0 RESETS LNNUM TO 0.
 31AB 210000    LNNU0:	LXI	H,0
 31AE 224B40    	SHLD	LNNUM
 31B1 C9        	RET
                
                	ENDIF			;END OF NOT COMPL CONDITIONAL
                
                ;MOVED PERFORMS BLOCK MOVE OF MEMORY DOWN.
                ;CALL:	BC	SOURCE ADDRESS
                ;	DE	COUNT (# OF BYTES TO MOVE)
                ;	HL	DESTINATION ADDRESS
                ;RETN:	A	CLOBBERED
                ;	BC	ADDRESS OF LAST SOURCE BYTE + 1
                ;	DE	ZERO
                ;	HL	ADDRESS OF LAST DESTINATION BYTE + 1
                ;MOVEB MOVES 2 OR 4 BYTES WITH MOVED.
                MOVEB:	IF	FLOAT		;BYTE COUNT TO DE
 31B2 1E04      	MVI	E,VBYTS-1
                	ELSE
                	MVI	E,2
                	ENDIF			;AND FALL THROUGH TO MOVD0
 31B4 1600      MOVD0:	MVI	D,0
 31B6 0A        MOVED:	LDAX	B		;BC CONTAINS SOURCE
 31B7 77        	MOV	M,A		;HL CONTAINS DESTINATION
 31B8 03        	INX	B
 31B9 23        	INX	H
 31BA 1B        	DCX	D		;DE CONTAINS COUNT
 31BB 7A        	MOV	A,D
 31BC B3        	ORA	E		;TEST IF (DE) = 0
 31BD C2B631    	JNZ	MOVED
 31C0 C9        	RET
                
                ;FINDL FINDS LINE WITH GIVEN LINE # IN USER SOURCE TEXT.
                ;CALL:	DE	DESIRED LINE #
                ;RETN:	A	CLOBBERED
                ;	BC	VALUE OF HL WHEN CALLED
                ;	DE	PRESERVED, I.E. DESIRED LINE #
                ;	HL	ADDRESS OF A USER SOURCE LINE LENGTH BYTE, NAMELY:
                ;			SUCCESS, LENGTH BYTE OF DESIRED LINE # IN SOURCE
                ;			FAILURE, LENGTH BYTE OF FIRST GREATER LINE #, OR EOF
                ;	CARRY	SET IFF NOT FOUND
                ;	ZERO	SET IF FOUND OR IF AT END OF TABLE
 31C1 E5        FINDL:	PUSH	H
                	IF	ROMSQ
                	LHLD	SOURC
                	ELSE
 31C2 218B42    	LXI	H,SRCAD		;SEARCH FROM START
                	ENDIF
 31C5 7E        FNDL1:	MOV	A,M		;LENGTH BYTE TO A
 31C6 B7        	ORA	A
 31C7 CAE031    	JZ	FNDL2		;NOT FOUND IF AT END OF TABLE
 31CA 23        	INX	H
 31CB 4E        	MOV	C,M
 31CC 23        	INX	H
 31CD 46        	MOV	B,M		;SOURCE LINE # TO BC
 31CE 2B        	DCX	H
 31CF 2B        	DCX	H		;POINT TO LENGTH BYTE AGAIN
 31D0 CD8002    	CALL	CMBDU		;COMPARE TO DESIRED LINE #
 31D3 CAE131    	JZ	FNDL3		;EQUAL -- SUCCESS
 31D6 D2E031    	JNC	FNDL2		;GREATER -- FAILURE
 31D9 4E        	MOV	C,M		;LESS, KEEP TRYING -- LENGTH TO BC
 31DA 0600      	MVI	B,0
 31DC 09        	DAD	B		;LET HL POINT TO ADDRESS OF NEXT ENTRY
 31DD C3C531    	JMP	FNDL1
 31E0 37        FNDL2:	STC			;FAILURE -- RETURN WITH CARRY SET
 31E1 C1        FNDL3:	POP	B		;RETURN OLD HL IN BC
 31E2 C9        	RET
                
                ;FDLNO DOES A FINDL, ISSUES FATAL US ERROR IF NOT FOUND.
 31E3 CDC131    FDLNO:	CALL	FINDL
 31E6 D0        	RNC
 31E7 C33518    	JMP	USERR
                
                ;END OF TOKENIZE
                	PAGE
                
                ;XMATH 06/09/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;FLOATING POINT EXTENDED FUNCTION PACKAGE
                
                
                	IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)
                
                
                ;8080 FLOATING POINT POLYNOMIAL EXPANDER - FPOLY
                ;  THIS ROUTINE EVALUATES A POLYNOMIAL OF THE FORM
                ;F(X) = A(0) + A(1)*X^(1*(K+J)) + A(2)*X^(2*(K+J))
                ;		+ A(2)*X^(2*(K+J)) + ...
                ; WHERE
                ;	A(0) IS AN INITIAL SUM VALUE IN THE
                ;	     THE FLOATING POINT ACCUMULATOR
                ;	A(N) IS A TERM CONSTANT FROM A LIST, THE
                ;	     ADDRESS OF WHICH IS SUPPLIED IN HL
                ; AND K AND J ARE INTEGER VALUES SIMULATED BY
                ; A SUPPLIED VALUE FOR THE INITIAL POWER TERM, AND
                ; A SUPPLIED VALUE FOR THE POWER TERM TO BE
                ; MULTIPLIED BY AFTER EACH TERM CALCULATION.
                ;    THE EVALUATION IS TERMINATED BY ONE OF TWO EVENTS.
                ;	1. IF THE SUPPLIED SIGNIFICANCE STOP VALUE
                ;	   IS EVER LESS THAN THE SIGNIFICANCE INDEX
                ;	   RETURNED BY THE FLOATING POINT ADD ROUTINE
                ;	   (INDICATING THE TERM WOULD NOT AFFECT THE RESULT)
                ;OR
                ;	2. A TERM CONSTANT WITH AN EXPONENT OF ZERO
                ;	   IS ENCOUNTERED.
                ;
                ;DETAILED CALLING SEQUENCE ...
                ;
                ;	LXI	H,INPWR		;ADDRESS OF POWER LIST
                ;	PUSH	H		;ON STACK
                ;	LXI	H,KLIST		;ADDRESS OF CONSTANT LIST
                ;	CALL	FPOLY
                	;	...		;RETURN HERE WITH F(X) INFACC
                ;
                ;INPWR:	DS	4		;INITIAL POWER OF X
                ;	DS	4		;TERM POWER MULTIPLIER
                ;
                ;	...
                ;
                ;KLIST:	DB	-1		;SIGNIFICANCE STOP VALUE
                ;	DW	K,K		;TERM CONSTANT A(1)
                ;	DW	K,K		;TERM CONSTANT A(2)
                ;	...
                ;	DW	K,K		;TERM CONSTANT A(N)
                ;	DB	0		;TERMINATOR
                ;
                ;   A SIGNIFICANCE STOP VALUE OF -1 WILL CAUSE THE
                ;ROUTINE TO UNCONDITIONALLY CALCULATE ALL TERMS IN
                ;THE LIST.  A VALUE OF 16 IS USED IN THE SIN/COS
                ;ROUTINE WITH NO EFFECT ON THE ACCURACY.
                ;  SEE THE DESCRIPTION OF THE INDEX IN THE MATH PACKAGE WRITEUP.
                
 31EA 11C340    FPOLY:	LXI	D,SIG		;MOVE ARGS OVER
 31ED 7E        	MOV	A,M		;GET SIG
 31EE 12        	STAX	D		;AND SAVE
 31EF 23        	INX	H
 31F0 22D040    	SHLD	VECT		;SAVE TERM TABLE ADDRESS
 31F3 E1        	POP	H		;POP OFF RETURN ADDRESS
 31F4 E3        	XTHL			;AND EXCHANGE WITH ARGUMENT
 31F5 0E08      	MVI	C,8
 31F7 7E        FPOL0:	MOV	A,M
 31F8 23        	INX	H
 31F9 13        	INX	D
 31FA 12        	STAX	D
 31FB 0D        	DCR	C
 31FC C2F731    	JNZ	FPOL0
 31FF CDD70D    	CALL	FTEST		;RESTORE
 3202 21CC40    	LXI	H,FPSUM		;AND SAVE
 3205 E5        	PUSH	H
 3206 CDBE0D    	CALL	FSTOR		; SUM
 3209 21C440    	LXI	H,FPTXN
 320C CDEB0D    	CALL	FLOAD		;GET CURRENT POWER
 320F 2AD040    FPOL1:	LHLD	VECT		;AND CURRENT TERM
 3212 CD080E    	CALL	FMUL		;A(N)*X^(N+K)
 3215 E1        	POP	H
 3216 E5        	PUSH	H
 3217 CD550E    	CALL	FADD		;ADD IT IN
 321A F5        	PUSH	PSW
 321B 3AC340    	LDA	SIG
 321E BB        	CMP	E		;CHECK FOR NO SIGNIFICANCE
 321F DA4D32    	JC	FPOL2
 3222 F1        	POP	PSW
 3223 E1        	POP	H
 3224 E5        	PUSH	H
 3225 CDBE0D    	CALL	FSTOR
 3228 2AD040    	LHLD	VECT 
 322B 110400    	LXI	D,4
 322E 19        	DAD	D
 322F 22D040    	SHLD	VECT 
 3232 7E        	MOV	A,M
 3233 A7        	ANA	A
 3234 E1        	POP	H
 3235 CAEB0D    	JZ	FLOAD
 3238 E5        	PUSH	H
 3239 21C440    	LXI	H,FPTXN
 323C E5        	PUSH	H
 323D CDEB0D    	CALL	FLOAD
 3240 21C840    	LXI	H,FPTXN+4
 3243 CD080E    	CALL	FMUL
 3246 E1        	POP	H
 3247 CDBE0D    	CALL	FSTOR
 324A C30F32    	JMP	FPOL1
                
 324D F1        FPOL2:	POP	PSW
 324E E1        	POP	H
 324F C9        	RET
                
                
                ;8080 INTEGER/FRACTIONAL PART - FINT
                ;	CALL FINT	;ARGUMENT IN FAC
                ;	...
                ;RETURNS WITH SIGNED INTEGER PART IN HL
                ;	   AND SIGNED FRACIONAL PART IN FAC
                ;
                ;OVERFLOW CONDITIONS SET IF
                ;  -32767 > VALUE > 32767
                
 3250 CDD70D    FINT:	CALL	FTEST		;SET UP ABCD TO FAC
 3253 5F        	MOV	E,A		;SAVE EXP
 3254 78        	MOV	A,B		;GET M0
 3255 E680      	ANI	80H		;AND ISOLATE SIGN BIT
 3257 32D240    	STA	FINSN		;SAVE SIGN
 325A 7B        	MOV	A,E		;GET EXPONENT
 325B FE81      	CPI	129		;AND CHECK RANGE
 325D D26432    	JNC	FINT0		;NOT TOO SMALL
 3260 210000    	LXI	H,0		;VALUE .LT. 1.0
 3263 C9        	RET
 3264 FE90      FINT0:	CPI	144		;SEE IF TOO LARGE
 3266 DA7B32    	JC	FINT2		;VALUE IS IN RANGE
 3269 3AD240    	LDA	FINSN		;OVERFLOW
 326C 07        	RLC			;SET HL
 326D 21FF7F    	LXI	H,7FFFH		;TO +/-
 3270 D27432    	JNC	$+4		; FULL SCALE
 3273 23        	INX	H
 3274 E5        	PUSH	H
 3275 CDD70D    	CALL	FTEST		;RESTORE ABCD
 3278 E1        	POP	H		;AND
 3279 37        	STC			;SET OFLOW AND
 327A C9        	RET			;EXIT
                
                ;SET UP MANTISSA FOR SHIFTING AND CLEAR INTEGER
 327B EB        FINT2:	XCHG			;D->H
 327C C5        	PUSH	B		;MOV BC
 327D D1        	POP	D		;TO DE
 327E D680      	SUI	80H		;MAKE SHIFT COUNT
 3280 4F        	MOV	C,A		;INTO C
 3281 44        	MOV	B,H		;MOVE M2
 3282 7A        	MOV	A,D		;SET
 3283 F680      	ORI	80H		;MANTISSA
 3285 57        	MOV	D,A		; B23
 3286 210000    	LXI	H,0		;CLEAR INTEGER
                ;MANTISSA (M0,M1,M2) IN DEB, INTEGER (I0,I1) IN HL
                ;SHIFT  H  L  D  E  B   LEFT 'C' BITS
                ;      I0,I1,M0,M1,M2
 3289 29        FINT3:	DAD	H		;I0,I1 LEFT
 328A EB        	XCHG
 328B 29        	DAD	H		;M0,M1 LEFT INTO CY
 328C D29032    	JNC	$+4
 328F 13        	INX	D		;CY PROPAGATE INTO I0,I1
 3290 EB        	XCHG
 3291 AF        	XRA	A		;CLEAR A & CY
 3292 80        	ADD	B		;GET M2
 3293 17        	RAL			;LEFT B7->CY, 0->B0
 3294 47        	MOV	B,A		; AND RESTORE
 3295 D29932    	JNC	$+4
 3298 13        	INX	D		;CY PROPAGATE INTO M0,M1
 3299 0D        	DCR	C		;DECREMENT EXP
 329A C28932    	JNZ	FINT3		;AND CONTINUE
 329D EB        	XCHG			;I0,I1 <-> M0',M1'
                ;CHECK NEW MANTISSA (M0',M1',M2') FOR ZERO
 329E B4        	ORA	H		;CHECK
 329F B5        	ORA	L		;MN'
 32A0 CAC132    	JZ	FINT6		;MN' IS ZERO
                ;NORMALISE NEW MANTISSA IN HLB
                ; DECREMENTING EXPONENT IN C
 32A3 7C        FINT4:	MOV	A,H		;GET M0'
 32A4 07        	RLC			;CHECK HIGH ORDER BIT B23
 32A5 DAB432    	JC	FINT5		;NORMALIZATION COMPLETE
 32A8 29        	DAD	H		;SHIFT M0',M1' LEFT
 32A9 78        	MOV	A,B		;GET M2'
 32AA 17        	RAL			;M2' LEFT B7->CY, 0->B0
 32AB 47        	MOV	B,A		;RESTORE
 32AC D2B032    	JNC	$+4		;NO DATA
 32AF 23        	INX	H		;PROPAGATE BIT
 32B0 0D        	DCR	C		;DECREMENT EXPONENT
 32B1 C3A332    	JMP	FINT4		;AND CONTINUE
                ;PREPARE FRACTIONAL PART FOR STORAGE
 32B4 7C        FINT5:	MOV	A,H		;GET M0'
 32B5 E67F      	ANI	127		;KILL B23
 32B7 67        	MOV	H,A		;(SIGN)
 32B8 3AD240    	LDA	FINSN		;GET SIGN OF INPUT
 32BB B4        	ORA	H		;AND MOVE TO B23
 32BC 65        	MOV	H,L		;SWAP FOR
 32BD 6F        	MOV	L,A		;SHLD LATER
 32BE 79        	MOV	A,C		;GET EXPONENT
 32BF C680      	ADI	80H		;AND BIAS UP
                ;STORE FRACIONAL PART FOR RE-LOAD
 32C1 32D340    FINT6:	STA	FINFP		;STORE EXP
 32C4 22D440    	SHLD	FINFP+1		;STORE M0',M1'
 32C7 78        	MOV	A,B		;GET M2'
 32C8 32D640    	STA	FINFP+3		;AND STORE
                ;TRANSFER SIGN TO INTEGER
 32CB 3AD240    	LDA	FINSN		;GET SIGN
 32CE 07        	RLC
 32CF D2D932    	JNC	FINT7		;POSITIVE
 32D2 7A        	MOV	A,D		;NEGATE
 32D3 2F        	CMA			;INTEGER
 32D4 57        	MOV	D,A		; BY
 32D5 7B        	MOV	A,E		;  COMPLEMENTING
 32D6 2F        	CMA			;   AND
 32D7 5F        	MOV	E,A		;    ADDING
 32D8 13        	INX	D		;     ONE
 32D9 D5        FINT7:	PUSH	D		;SAVE INTEGER
 32DA 21D340    	LXI	H,FINFP		;RE-LOAD
 32DD CDEB0D    	CALL	FLOAD		;FRACTION TO FAC
 32E0 E1        	POP	H		;RESTORE INTEGER
 32E1 C9        	RET			;AND EXIT
                
                
                ;FSQR - 8080 FLOATING POINT SQUARE ROOT
                ;METHOD:	APPROXIMATION FOLLOWED BY THREE
                ;		NEWTON ITERATIONS
                ;
                ; SQUARE ROOT (X)
                ;
                ;LET X=2^(2B)*F WHEN .25<=F<1
                ;THEN SQR(X)=2^B*SQR(F)
                ;WHERE SQR(F)=P(I)   I=NUMBER OF ITERATION
                ;
                ; P(1)=A*F+B   AS A FIRST APPROXIMATION
                ;   WHERE A=.875, B=.27863 WHEN .25<=F<.5
                ;    OR
                ;	   A=.578125, B=.421875 WHEN .5<=F<1
                ;AND THEN
                ;	P(I+1)=(P(I)+F/P(I))/2
                ;  AND P(4) IS FINAL RESULT FOR SQR(F)
                ;
                ;CALLING SEQUENCE WITH 8008/8080 MATH PACKAGE
                ;	CALL	FSQR		;SQR(FPAC) -> FPAC
                ;
                ;NEGATIVE INPUTS WILL BE TREATED AS POSITIVE AFTER CALLING FCERN
 32E2 CDD70D    FSQR:	CALL	FTEST		;RESTORE
 32E5 C8        	RZ			;ZERO
 32E6 FC9A12    	CM	FCERN		;NEGATIVE ERROR
 32E9 FCCF0D    	CM	FABS		;SET FLAG AND USE ABS VALUE
 32EC 21D740    	LXI	H,FPTXX		;AND SAVE
 32EF CDBE0D    	CALL	FSTOR		;X
 32F2 1E80      	MVI	E,80H		;CALCULATE
 32F4 0F        	RRC			;EXPONENT
 32F5 D2F932    	JNC	$+4		; FOR
 32F8 1D        	DCR	E		;  F
 32F9 7B        	MOV	A,E		;AND
 32FA 21DB40    	LXI	H,FPTF		;STORE
 32FD CDBE0D    	CALL	FSTOR		; F
 3300 0F        	RRC			;DECIDE
 3301 215033    	LXI	H,FPTA1
 3304 D20A33    	JNC	$+6		;WHICH
 3307 215833    	LXI	H,FPTA2		; A AND B
 330A E5        	PUSH	H		;    TO USE
 330B CDEB0D    	CALL	FLOAD		; AND FETCH A
 330E 21DB40    	LXI	H,FPTF		;CALCULATE
 3311 CD080E    	CALL	FMUL		;AF
 3314 E1        	POP	H		; AND
 3315 23        	INX	H		;  THEN
 3316 23        	INX	H		;   GET
 3317 23        	INX	H		;    B
 3318 23        	INX	H
 3319 CD550E    	CALL	FADD		;AF+B
 331C 21DF40    	LXI	H,FPTP		;AND
 331F E5        	PUSH	H
 3320 CDBE0D    	CALL	FSTOR		; SAVE P1
 3323 CD3933    	CALL	NEWTN		;THREE
 3326 CD3933    	CALL	NEWTN		;NEWTON
 3329 CD3933    	CALL	NEWTN		; ITERATIONS
 332C 67        	MOV	H,A		;SAVE RESULT EXPONENT
 332D 3AD740    	LDA	FPTXX		;CALCULATE
 3330 D67F      	SUI	127		;EXPONENT
 3332 1F        	RAR			; FOR
 3333 84        	ADD	H		;  RESULT
 3334 E1        	POP	H
 3335 77        	MOV	M,A		;AND SET IT
 3336 C3EB0D    	JMP	FLOAD		;LOAD RESULT
                
 3339 21DB40    NEWTN:	LXI	H,FPTF		;GET
 333C CDEB0D    	CALL	FLOAD		;F
 333F 21DF40    	LXI	H,FPTP
 3342 E5        	PUSH	H
 3343 CD330E    	CALL	FDIV		;F/P
 3346 E1        	POP	H
 3347 E5        	PUSH	H
 3348 CD550E    	CALL	FADD		;F/P+P
 334B 3D        	DCR	A		;(F/P+P)/2
 334C E1        	POP	H		;AND
 334D C3BE0D    	JMP	FSTOR		; SAVE P(I+1)
                
                
 3350 80600000  FPTA1:	DB	80H,60H,0,0		;.875
 3354 7F0EA898  	DB	7FH,0EH,0A8H,98H	;.27863
                
 3358 80140000  FPTA2:	DB	80H,14H,0,0		;.578125
 335C 7F580000  	DB	7FH,58H,0,0		;.421875
                
                
                ;********* END - FSQR *********
                
                
                ;8080 FLOATING POINT EXPONENTIAL - FEXP
                ;	CALL	FEXP		;E^(FAC) -> FAC
                ;
                ; **** INTERNAL OVER/UNDERFLOW WILL OCCUR FOR INPUT
                ;	VALUES GREATER THAN LN(2^127)/(LOGBASE2(E)).
                ;	OR APPROXIMATELY
                ;	      -61 < VALUE < 61
                ;
                ; IF OVERFLOW OCCURS THEN 'ERROR' WILL BE CALLED AND
                ; FAC WILL BE SET TO FULL SCALE VALUE.
                ;
                ;METHOD:
                ; POLYNOMIAL APPROXIMATION
                ;TO FIND E^X THE FOLLOWING IDENTITY IS USED.
                ;TO REDUCE THE RANGE, WE LET
                ;	X LOG2 E = N + D + Z
                ;WHERE ...
                ;	N IS THE INTEGRAL PORTION OF THE REAL NUMBER,
                ;	D IS A DISCRETE FRACTION (1/8, 3/8, 5/8, OR
                ;	  7/8) OF THE REAL NUMBER (FRAC PART), AND
                ;	Z IS THE REMAINDER WHICH IS IN THE RANGE 
                ;	  -1/8 <= Z <= 1/8
                ; THUS,
                ;		E^X = 2^N * 2^D * 2^Z
                ;AND IT IS NECCESSARY TO ONLY APPROXIMATE 2^Z FOR
                ;-1/8 <= Z <= 1/8 BY USING THE POLYNOMIAL F(Z).
                ;
                ; F(Z) = A0 + A1*Z + A2*Z^2 + A3*Z^3 + A4*Z^4 +
                ;				A5*Z^5
                ;WHERE ...
                ;	A0 = 1.0
                ;	A1 = .69314718057
                ;	A2 = .24022648580
                ;	A3 = .055504105406
                ;	A4 = .0096217398747
                ;	A5 = .0013337729375
                ;
 3360 CDD70D    FEXP:	CALL	FTEST		;SET ABCD TO FAC
 3363 78        	MOV	A,B		;GET SIGN
 3364 32E840    	STA	FPSGN		;AND SAVE
 3367 CDCF0D    	CALL	FABS		;TAKE ABS VALUE
 336A 213C34    	LXI	H,LOG2E		;X=X*LOG2(E)
 336D CD080E    	CALL	FMUL
 3370 CD5032    	CALL	FINT		;INTEGER TO HL, FRAC IN FAC
 3373 E5        	PUSH	H		;SAVE INTEGER
 3374 21E340    	LXI	H,FPTX		;AND
 3377 CDBE0D    	CALL	FSTOR		; FRACTION
 337A E1        	POP	H		;RESTORE INTEGER
 337B 7C        	MOV	A,H		;TO CHECK RANGE
 337C A7        	ANA	A
 337D CA8A33    	JZ	FEXP1		;CAN'T BE > 256
                
 3380 3AE840    FEXP0:	LDA	FPSGN		;NUMBER TOO LARGE
 3383 07        	RLC			;SO RETURN
 3384 DAC60D    	JC	FZRO		; 0 OR FULL SCALE
 3387 C3470E    	JMP	FOVER		;NONFATAL OV ERROR, TAKE MAX AND RETURN
 338A 7D        FEXP1:	MOV	A,L		;CHECK N
 338B FE7F      	CPI	127		;LARGEST THAT WILL FIT
 338D D28033    	JNC	FEXP0		;E^88 = 1.7 E+38
 3390 32E740    	STA	FPTN		;SAVE INT PART N
                ;SELECT VALUE FOR 'D'
 3393 3AE340    	LDA	FPTX		;GET EXPONENT OF FRAC
 3396 110400    	LXI	D,4
 3399 210C34    	LXI	H,FPTDF
 339C FE7F      	CPI	127
 339E DAAF33    	JC	FEXP5		;FRAC < .25
 33A1 19        	DAD	D		;FPTDF+4 TO HL
 33A2 CAAF33    	JZ	FEXP5		;.25 <= FRAC < .5
 33A5 19        	DAD	D		;FPTDF+8 TO HL
 33A6 3AE440    	LDA	FPTX+1		;GET M0
 33A9 07        	RLC			;SHIFT B6
 33AA 07        	RLC			;TO CARRY
 33AB D2AF33    	JNC	FEXP5		;.5 <= FRAC < .75
 33AE 19        	DAD	D		;.75 <= FRAC < 1, FPTDF+12 TO HL
 33AF E5        FEXP5:	PUSH	H		;HL POINTS TO SELECTED D
 33B0 21E340    	LXI	H,FPTX		;X TO FAC
 33B3 CDEB0D    	CALL	FLOAD
 33B6 E1        	POP	H		;ADDRESS OF D
 33B7 E5        	PUSH	H		;SAVED AGAIN
 33B8 CD520E    	CALL	FSUB		;CALCULATE Z
 33BB 5F        	MOV	E,A		;AND
 33BC 3AE840    	LDA	FPSGN		; TRANSFER
 33BF 07        	RLC			;  SIGN
 33C0 7B        	MOV	A,E		;   TO Z
 33C1 DCCC0D    	CC	FCHS
 33C4 21E940    	LXI	H,FPTZ0		;SAVE Z
 33C7 E5        	PUSH	H		;PUSH FOR FPOLY
 33C8 CDBE0D    	CALL	FSTOR		; IN
 33CB 21ED40    	LXI	H,FPTZ1		;  POLY
 33CE CDBE0D    	CALL	FSTOR		;   TABLE
 33D1 21B00B    	LXI	H,FPONE		;GET TERM
 33D4 CDEB0D    	CALL	FLOAD		;A0 = 1.0
 33D7 214434    	LXI	H,EXPLY		; AND DO THE
 33DA CDEA31    	CALL	FPOLY		;  POLYNOMIAL F(Z)
 33DD E1        	POP	H		;SELECT
 33DE 111000    	LXI	D,16		;SIGNED
 33E1 EB        	XCHG			; VALUE
 33E2 3AE840    	LDA	FPSGN		;  FOR
 33E5 07        	RLC			;   2^D
 33E6 D2EA33    	JNC	$+4
 33E9 29        	DAD	H		;2^-D TABLE
 33EA 19        	DAD	D		;HL HAS ADDRESS
 33EB E5        	PUSH	H		;OF 2^D
 33EC CDD70D    	CALL	FTEST		;RESTORE
 33EF E1        	POP	H		;AND CALCULATE
 33F0 CD080E    	CALL	FMUL		;2^D * F(Z)
                ;NOW MULTIPLY BY 2^N
 33F3 5F        	MOV	E,A		;SAVE EXP
 33F4 3AE840    	LDA	FPSGN		;AND
 33F7 07        	RLC			;TRANSFER
 33F8 3AE740    	LDA	FPTN		;SIGN
 33FB D20034    	JNC	$+5		; TO N
 33FE 2F        	CMA
 33FF 3C        	INR	A		;NEGATE N
 3400 83        	ADD	E		;RESULT = 2^N * 2^D * F(Z)
 3401 21ED40    	LXI	H,FPTZ1		;STORE TEMP
 3404 E5        	PUSH	H
 3405 CDBE0D    	CALL	FSTOR		;FOR RELOAD
 3408 E1        	POP	H		; TO
 3409 C3EB0D    	JMP	FLOAD		;  EXIT WITH FAC = E^X
                
                
                ;D TEST VALUES AND 2^D TABLES
 340C 7E000000  FPTDF:	DW	7EH,0		;.125
 3410 7F400000  	DW	407FH,0		;.375
 3414 80200000  	DW	2080H,0		;.625
 3418 80600000  	DW	6080H,0		;.875
                
                ;2^D FOR PLUS D VALUES
 341C 810B95C2  	DW	0B81H,0C295H	;2^(1/8)
 3420 8125FED7  	DW	2581H,0D7FEH	;2^(3/8)
 3424 8145672A  	DW	4581H,2A67H	;2^(5/8)
 3428 816AC0C7  	DW	6A81H,0C7C0H	;2^(7/8)
                
                ;2^D FOR MINUS D VALUES
 342C 806AC0C7  	DW	6A80H,0C7C0H	;2^(-1/8)
 3430 8045672A  	DW	4580H,2A67H	;2^(-3/8)
 3434 8025FED7  	DW	2580H,0D7FEH	;2^(-5/8)
 3438 800B95C2  	DW	0B80H,0C295H	;2^(-7/8)
                
                ;MISC. CONSTANTS
 343C 8138AA3B  LOG2E:	DW	3881H,3BAAH	;LOG2(E) 1.442695041
 3440 FF7FFFFF  FPMAX:	DW	7FFFH,-1	;POS FULL SCALE
                
                
 3444 FF        EXPLY:	DB	-1		;POLY TABLE
                
 3445 80317218  	DW	3180H,1872H	;A1 .69314718057
 3449 7E75FDEF  	DW	757EH,0EFFDH	;A2 .24022648580
 344D 7C635846  	DW	637CH,4658H	;A3 .055504105406
 3451 7A1DA481  	DW	1D7AH,81A4H	;A4 .0096217398747
 3455 772ED1FE  	DW	2E77H,0FED1H	;A5 .0013337729375
                
 3459 00        	DB	0		;TABLE TERMINATOR
                
                ;****** END - FEXP ******
                
                
                ;8080 FLOATING POINT NATURAL LOGARITHM - FLN
                ;  THIS ROUTINE CALCULATES THE NATURAL LOGARITHM
                ;OF THE NUMBER IN THE FLOATING POINT ACCUMULATOR.
                ;
                ;	LN(FAC) -> FAC
                ;
                ;METHOD - POLYNOMIAL APPROXIMATION
                ;
                ; GIVEN A NORMALISED REAL NUMBER
                ;	X = 2^K * F
                ;WHERE THE RANGE OF F IS .5 <= F < 1, AND J AND G
                ;ARE FOUND SUCH THAT X = 2^J * G WHERE
                ;(SQR(2)/2) <= G < SQR(2).  THIS IS DONE BY SETTING
                ;J=K-1, G=2*F IF F < SQR(2)/2 AND J=K, G=F OTHER-
                ;WISE.
                ;
                ; THUS:
                ;	LN(X) = J * LN(2) + LN(G)
                ;
                ;   THE APPROXIMATION FOR LN(G), WHERE
                ;SQR(2)/2 <= G < SQR(2), IS BASED ON THE SERIES
                ; LN((V+X)/(V-X) = 2((X/V) + (X^3/(3*V^3)) +
                ;			(X^5/(5*V^5)) + ... )
                ;WHICH CONVERGES FOR (-V<X<V).
                ;
                ;   WITH THE TRANSFORMATION
                ;     X = V((G-1)/(G+1)), V = (SQR(2)+1)^2
                ;SO THAT -1 <= X < 1 FOR SQR(2)/2  <= G < SQR(2).
                ;
                ; SUBSTITUTING
                ;	LN(G) = 2(Z + Z^3/3 + Z^5/5 + ... )
                ; WHERE  Z = X/V = (G-1)/G+1).
                ;
                ;  THE APPROXIMATION USED IS G(Z) FOR LN(G)/Z IN
                ;THE RANGE SQR(2)/2 <= G < SQR(2).
                ; THUS THE REQUIRED CALCULATION IS
                ;	LN(X) = J * LN(2) + Z * G(Z)
                ;  G(Z) = B0 + B2*Z^2 + B4*Z^4 + B6*Z^6 + B8*Z^8
                ;WHERE
                ;	B0 = 2.0
                ;	B2 = .666666564181
                ;	B4 = .400018840613
                ;	B6 = .28453572660
                ;	B8 = .125
                
 345A CDD70D    FLN:	CALL	FTEST		;RESTORE
 345D FC9A12    	CM	FCERN
 3460 CA9A12    	JZ	FCERN		;FC ERROR AND RETURN IF ZERO
 3463 FCCF0D    	CM	FABS		;MAKE INPUT POSITIVE AFTER ERROR
 3466 32F940    	STA	FLNK		;SAVE EXPONENT
 3469 3E80      	MVI	A,80H		;SAVE
 346B 21FA40    	LXI	H,FLNF		;FRACTIONAL
 346E E5        	PUSH	H
 346F CDBE0D    	CALL	FSTOR		; PART
 3472 E1        	POP	H		;RELOAD
 3473 E5        	PUSH	H		; AND RESAVE
 3474 CDEB0D    	CALL	FLOAD		;  TO FACC
 3477 21F034    	LXI	H,FLNR2		;CHECK RANGE
 347A CD520E    	CALL	FSUB		;NEG IF F < SQR(2)/2
 347D E1        	POP	H		;POINT TO F
 347E F28534    	JP	FLNA		;JMP IF F >= SQR(2)/2
 3481 2B        	DCX	H		;POINT TO K
 3482 35        	DCR	M		;J = K-1
 3483 23        	INX	H		;BACK TO F
 3484 34        	INR	M		;G = 2 * F
 3485 CDEB0D    FLNA:	CALL	FLOAD		;GET G
 3488 21B00B    	LXI	H,FPONE		;GET 1.0
 348B CD550E    	CALL	FADD		;G+1
 348E 21F140    	LXI	H,FLNZI		;AND
 3491 E5        	PUSH	H
 3492 CDBE0D    	CALL	FSTOR		; SAVE
 3495 21F834    	LXI	H,FLNM2		;GET -2.0
 3498 CD550E    	CALL	FADD		;G-1
 349B E1        	POP	H
 349C E5        	PUSH	H
 349D CD330E    	CALL	FDIV		;(G-1)/(G+1)
 34A0 21FA40    	LXI	H,FLNF		;SAVE
 34A3 E5        	PUSH	H
 34A4 CDBE0D    	CALL	FSTOR		;Z
 34A7 E1        	POP	H
 34A8 CD080E    	CALL	FMUL		;Z^2
 34AB E1        	POP	H
 34AC E5        	PUSH	H		;SAVE FOR FPOLY
 34AD CDBE0D    	CALL	FSTOR		;SAVE
 34B0 21F540    	LXI	H,FLNZ2		;SAVE
 34B3 CDBE0D    	CALL	FSTOR		;TERM POWER
 34B6 CDC60D    	CALL	FZRO		;CLEAR SUM
 34B9 21FC34    	LXI	H,FLNPL		;AND
 34BC CDEA31    	CALL	FPOLY		; CALC POLYNOMIAL
 34BF 21F834    	LXI	H,FLNM2		;ADD
 34C2 CD520E    	CALL	FSUB		;2.0
 34C5 21FA40    	LXI	H,FLNF		;AND
 34C8 E5        	PUSH	H
 34C9 CD080E    	CALL	FMUL		;Z*G(Z)
 34CC E1        	POP	H
 34CD E5        	PUSH	H
 34CE CDBE0D    	CALL	FSTOR		;Z*G(Z)
                ;FLOAT J, CALCULATE J * LN(2)
 34D1 3AF940    	LDA	FLNK		;GET J
 34D4 D680      	SUI	80H		;UN-BIAS EXP
 34D6 1E20      	MVI	E,32		;SET INTEGER SCALING
 34D8 57        	MOV	D,A		;INTEGER TO I3
 34D9 01FFFF    	LXI	B,-1		;INTEGER
 34DC 3EFF      	MVI	A,-1		;NEGATIVE
 34DE FAE334    	JM	$+5		;GO FLOAT
 34E1 03        	INX	B		;INTEGER
 34E2 3C        	INR	A		;NEGATIVE
 34E3 CD8C10    	CALL	FFLOT		;FLOAT J
 34E6 21F434    	LXI	H,FLNL2
 34E9 CD080E    	CALL	FMUL		;J*LN(2)
 34EC E1        	POP	H
 34ED C3550E    	JMP	FADD		;Z*G(Z)
                
                
 34F0 803504F3  FLNR2:	DW	3580H,0F304H	;SQR(2)/2
 34F4 80317218  FLNL2:	DW	3180H,1872H	;LN(2)
 34F8 82800000  FLNM2:	DW	8082H,0		;-2.0
                
 34FC 10        FLNPL:	DB	16		;SIG INDEX STOPPER
 34FD 802AAAA9  	DW	2A80H,0A9AAH 	;B2 .666666564181
 3501 7F4CCF45  	DW	4C7FH,45CFH	;B4 .400018840613
 3505 7F11AEAB  	DW	117FH,0ABAEH 	;B6 .28453572660
 3509 7E000000  	DW	7EH,0		;B8 .125
                
 350D 00        	DB	0		;TERMINATOR
                
                ;******* END - FLN ******
                
                
                ;8080 FLOATING POINT SIN/COS ROUTINE - FSIN, FCOS
                ;  THIS ROUTINE WILL CALCULATE THE SINE OR COSINE
                ;OF THE ANGLE IN THE FLOATING POINT ACCUMULATOR.
                ;
                ;  THE ANGLE MUST BE IN RADIANS AND MAY HAVE ANY
                ;MAGNITUDE.
                ;
                ;	SIN(FAC) -> FAC
                ;	COS(FAC) -> FAC
                ;
                ;METHOD:
                ;	POLYNOMIAL APPROXIMATION
                ;
                ;   GIVEN A REAL NUMBER, X, N, AND Y ARE DEFINED
                ;SUCH THAT
                ;	X/(2*PI) = N + Y
                ;WHERE N IS AN INTEGER AND 0 <= Y < 1.
                ;THUS, X = 2*PI*N + 2*PI*Y, AND THE IDENTITIES ARE
                ;  SIN(X) = SIN(2*PI*Y) AND COS(X) = COS(2*PI*Y)
                ;
                ;THE POLYNOMIAL APPROXIMATION, F(Z), FOR THE
                ;FUNCTION SIN(2*PI*Z)/Z IS USED WHERE
                ;-.25 <= Z < .25.
                ;
                ;   THE PROPERTIES OF SINES AND COSINES ARE USED TO
                ;COMPUTE THESE FUNCTIONS AS FOLLOWS:
                ;
                ;	COS(2*PI*Y) = F(Z)
                ;WHERE
                ;	Z = .25-Y IN THE RANGE 0 <= Y < .5
                ;	Z = Y-.75 IN THE RANGE .5 <= Y < 1
                ;
                ;	SIN(2*PI*Y) = F(Z)
                ;WHERE
                ;	Z = Y IN THE RANGE 0 <=Y < .25
                ;	Z = .5-Y IN THE RANGE .25 <= Y < .75
                ;	Z = Y-1 IN THE RANGE .75 <= Y < 1
                ;
                ; F(Z) = A1*Z + A2*Z^3 + A3*Z^5 + A4*Z^7 + A5*Z^9
                ;WHERE
                ;	A1 = 6.2831853
                ;	A2 = -41.341681
                ;	A3 = 81.602481
                ;	A4 = -76.581285
                ;	A5 = 39.760722
                
 350E 3E        FSIN:	DB	3EH		;(MVI A,0AFH) FN CODE FOR SIN
 350F AF        FCOS:	XRA	A		;0 FN CODE FOR COS
 3510 32FE40    	STA	FSCFX		;SAVE FUNCTION CODE
 3513 CDD70D    	CALL	FTEST		;RESTORE
 3516 78        	MOV	A,B		;GET M0
 3517 E680      	ANI	80H		;STRIP OFF
 3519 32FF40    	STA	FSCSG		; AND SAVE
 351C CDCF0D    	CALL	FABS		;GET ABS(FAC)
 351F 21AB35    	LXI	H,F2PI
 3522 CD330E    	CALL	FDIV		;X/(2*PI)
 3525 FE81      	CPI	129
 3527 D45032    	CNC	FINT		;Y >= 1, GET FRACTIONAL PART
 352A 5F        	MOV	E,A		;SAVE EXPONENT
 352B 3AFE40    	LDA	FSCFX		;CHECK
 352E 07        	RLC			;FUNCTION CODE
 352F 7B        	MOV	A,E		;RESTORE EXPONENT
 3530 DA4735    	JC	FSC3		;FUNCTION IS SIN
 3533 FE80      	CPI	80H
 3535 DA3E35    	JC	FSC2		;Y < .5
 3538 219E35    	LXI	H,FSC75		;Y - .75
 353B C36835    	JMP	FSC6
 353E CDCC0D    FSC2:	CALL	FCHS		;-Y
 3541 21A235    	LXI	H,FSC25		;.25-Y
 3544 C35F35    	JMP	FSC4A
 3547 FE7F      FSC3:	CPI	127		;Y < .25 ?
 3549 DA6B35    	JC	FSC7		;YES, GO DO POLY
 354C FE80      	CPI	80H
 354E DA5935    	JC	FSC4		;Y < .5
 3551 5F        	MOV	E,A		;SAVE EXP
 3552 78        	MOV	A,B		;CHECK
 3553 07        	RLC			;B22
 3554 07        	RLC			; FOR
 3555 7B        	MOV	A,E		;  .75, RESTORE EXPONENT
 3556 DA6535    	JC	FSC5		;Y >= .75
 3559 CDCC0D    FSC4:	CALL	FCHS		;Y < .75 SO -Y
 355C 21A635    	LXI	H,FSC50
 355F CD550E    FSC4A:	CALL	FADD		;.5-Y
 3562 C36B35    	JMP	FSC7
 3565 21B00B    FSC5:	LXI	H,FPONE
 3568 CD520E    FSC6:	CALL	FSUB		;Y-1
 356B 210041    FSC7:	LXI	H,FSCZ		;SAVE
 356E E5        	PUSH	H
 356F CDBE0D    	CALL	FSTOR		;Z
 3572 E1        	POP	H
 3573 E5        	PUSH	H		;SAVE FOR FPOLY
 3574 CD080E    	CALL	FMUL		;Z^2
 3577 210441    	LXI	H,FSCZ2
 357A CDBE0D    	CALL	FSTOR		;SAVE Z^2
 357D CDC60D    	CALL	FZRO		;ZERO SUM
 3580 21AA35    	LXI	H,FSCPL		;AND
 3583 CDEA31    	CALL	FPOLY		; DO POLY
 3586 5F        	MOV	E,A		;SAVE EXP
 3587 3AFE40    	LDA	FSCFX		;AND CHECK
 358A 07        	RLC			; FUNCTION
 358B 7B        	MOV	A,E		;RESTORE EXPONENT
 358C D0        	RNC			;AND EXIT IF COS FUNCTION
 358D 3AFF40    	LDA	FSCSG		;GET INPUT SIGN
 3590 07        FSC8:	RLC			;TO CY -- FATN ENTRY POINT
 3591 7B        	MOV	A,E		;RESTORE EXPONENT
 3592 D0        	RNC			;RETURN IF INPUT +
 3593 C3CC0D    	JMP	FCHS		;ELSE CHANGE RESULT SIGN
                
                
 3596 82490FDB  FPI:	DW	4982H,0DB0FH	;PI
 359A 81490FDB  FHPI:	DW	4981H,0DB0FH	;PI/2
 359E 80400000  FSC75:	DW	4080H,0		;.75
 35A2 7F000000  FSC25:	DW	7FH,0		;.25
 35A6 80000000  FSC50:	DW	80H,0		;.5
                
 35AA 10        FSCPL:	DB	16		;SIN/COS POLY SIG STOPPER
 35AB 83490FDB  F2PI:	DW	4983H,0DB0FH	;A1 PI*2
 35AF 86A55DE2  	DW	0A586H,0E25DH	;A2 -41.341681
 35B3 87233478  	DW	2387H,7834H	;A3 81.602481
 35B7 8799299E  	DW	9987H,9E29H	;A4 -76.581285
 35BB 861F0AFB  	DW	1F86H,0FB0AH	;A5 39.760722
 35BF 00        	DB	0		;TERMINATOR
                
                
                ;****** END - FSIN/FCOS ******
                
                
                ;8080 FLOATING POINT REAL BASE TO REAL EXPONENT
                ;		FAX
                ;  THIS ROUTINE RAISES A REAL NUMBER TO A REAL POWER. 
                ;	***** NOTE *****
                ;  BECAUSE OF OVERFLOW CONDITIONS IN THE ROUTINE
                ;FLN, THE FOLLOWING LIMITS ARE PLACED ON THE
                ;INPUTS TO FAX:
                ;
                ;	A > 0
                ;AND
                ;	ABS(X*LN(A)) < 50.0
                ;
                ;CALLING SEQUENCE ...
                ;	LXI H,X		;ADDRESS OF X
                ;	CALL FAX	;FAC ^ X  ->  FAC
                ;
                ;METHOD
                ;IF X IS A POSITIVE INTEGER < 256, ITERATED MULTIPLICATION IS USED.
                ;OTHERWISE THE IDENTITY  A^X = E^(X*LN(A)) IS USED.
                
 35C0 EB        FATOX:	XCHG
 35C1 23        	INX	H		;ARG2 POINTER TO HL
 35C2 E5        FAX:	PUSH	H
 35C3 CDD70D    	CALL	FTEST		;LOAD REGISTERS
 35C6 210841    	LXI	H,FTMPA
 35C9 CDBE0D    	CALL	FSTOR		;SAVE A IN FTMPA
 35CC E1        	POP	H
 35CD E5        	PUSH	H
 35CE CDEB0D    	CALL	FLOAD		;GET X TO FACC
 35D1 CD5032    	CALL	FINT		;CHECK IF X IS INTEGER
 35D4 F5        	PUSH	PSW
 35D5 E5        	PUSH	H		;SAVE INTEGER PART
 35D6 210841    	LXI	H,FTMPA
 35D9 CDEB0D    	CALL	FLOAD		;RESTORE A TO FACC
 35DC D1        	POP	D		;INTEGER PART TO DE
 35DD F1        	POP	PSW
 35DE E1        	POP	H		;X POINTER TO HL
 35DF B2        	ORA	D		;ZERO SET IFF A POSITIVE INTEGER < 256
 35E0 C2FA35    	JNZ	FAX2		;RAISE TO REAL POWER
 35E3 1C        	INR	E
 35E4 D5        	PUSH	D		;SAVE THE INTEGER POWER+1
 35E5 21B00B    	LXI	H,FPONE		;INITIALIZE RESULT TO 1.0
 35E8 CDEB0D    	CALL	FLOAD
 35EB D1        FAX1:	POP	D
 35EC 1D        	DCR	E		;DECREMENT MULTIPLY COUNT
 35ED CAD70D    	JZ	FTEST		;DONE, SET REGISTERS AND RETURN
 35F0 D5        	PUSH	D
 35F1 210841    	LXI	H,FTMPA
 35F4 CD080E    	CALL	FMUL		;MULTIPLY RESULT BY A
 35F7 C3EB35    	JMP	FAX1		;AND CONTINUE MULTIPLYING
 35FA E5        FAX2:	PUSH	H		;RAISING TO REAL, LARGE OR NEGATIVE POWER
 35FB CD5A34    	CALL	FLN		;LN(A)
 35FE E1        	POP	H
 35FF CD080E    	CALL	FMUL		;X*LN(A)
 3602 C36033    	JMP	FEXP		;E^(X*LN(A))
                
                
                	IF	FALSE
                ;8080 FLOATING POINT COMMON LOGARITHM - FLOG
                ;  THIS ROUTINE CALCULATES THE COMMON OR BASE 10
                ;LOGARITHM OF THE NUMBER IN THE FLOATING POINT
                ;ACCUMULATOR.
                ;
                ;	LOG(FAC) -> FAC
                ;
                ;METHOD
                ;	 THE FOLLOWING IDENTITY IS USED.
                ;
                ;	LOG(X) = LN(X)/LN(10)
                
                FLOG:	CALL FLN	;LN(ABS(X))
                	LXI H,FLGTI	;1/LN(10)
                	JMP FMUL	;LN(X)/LN(10)
                
                
                ;8080 FLOATING POINT ANTILOG - FALOG
                ;
                ; THIS ROUTINE CALCULATES THE BASE 10 ANTILOG OF
                ;THE NUMBER IN THE FLOATING POINT ACCUMULATOR.
                ;
                ;	ALOG(FAC) -> FAC
                ;
                ;METHOD
                ;	 THE FOLLOWING IDENTITY IS USED
                ;	10^X = E^(X*LN(10))
                
                FALOG:	CALL FTEST	;RESTORE
                	LXI H,FLOGT	;LN(10)
                	CALL FMUL	;X*LN(10)
                	JMP FEXP	;E^(X*LN(10))
                
                
                ;8080 DEGREE>RADIAN AND RADIAN>DEGREE - FCDR, FCRD
                ; THESE ROUTINES CONVERT THE NUMBER IN THE FLOATING
                ;POINT ACCUMULATOR FROM DEGREES TO RADIANS (FCDR)
                ;OR FROM RADIANS TO DEGREES (FCRD).
                ;
                ;	FAC;DEGREES -> FAC;RADIANS
                ;	FAC;RADIANS -> FAC;DEGREES
                ;
                ;METHOD
                ;	 THE FOLLOWING IDENTITIES ARE USED.
                ;
                ;	X;RADIANS = X;DEGREES * PI/180
                ;	X;DEGREES = X;RADIANS * 180/PI
                
                FCDR:	CALL FTEST	;RESTORE
                	LXI H,FXDR
                	JMP FMUL	;X*PI/180
                
                FCRD:	CALL FTEST	;RESTORE
                	LXI H,FXRD
                	JMP FMUL	;X*180/PI
                
                	ENDIF
                
                ;8080 FLOATING POINT TANGENT - FTAN
                ;   THIS ROUTINE CALCULATES THE TANGENT OF THE ANGLE
                ;IN THE FLOATING POINT ACCUMULATOR.
                ;   THE ANGLE MUST BE EXPRESSED IN RADIANS.
                ;
                ;	TAN(FAC) -> FAC
                ;
                ;METHOD
                ;	 THE FOLLOWING IDENTITY IS USED.
                ;
                ;	TAN(X) = SIN(X)/COS(X)
                ;
                ;	***** NOTE *****
                ; FOR VALUES OF X CLOSE TO 0 OR CLOSE TO A MULTIPLE
                ;OF 2*PI, EITHER THE SIN OR COS OF X WILL BE CLOSE
                ;TO UNITY.  THIS CONDITION WILL AFFECT THE ACCURACY
                ;USING THE IDENTITY ABOVE AND IT IS SUGGESTED
                ;THAT OTHER METHODS BE USED TO COMPUTE THE FUNCTION
                ;TAN(X) IF THIS INACCURACY CAN NOT BE TOLERATED.
                
 3605 CDD70D    FTAN:	CALL	FTEST		;RESTORE
 3608 C8        	RZ
 3609 210841    	LXI	H,FTMPA
 360C E5        	PUSH	H
 360D CDBE0D    	CALL	FSTOR		;SAVE X
 3610 CD0F35    	CALL	FCOS		;COS(X)
 3613 210C41    	LXI	H,FTMPB
 3616 CDBE0D    	CALL	FSTOR		;SAVE COS(X)
 3619 E1        	POP	H
 361A CDEB0D    	CALL	FLOAD		;GET X
 361D CD0E35    	CALL	FSIN		;SIN(X)
 3620 210C41    	LXI	H,FTMPB
 3623 C3330E    	JMP	FDIV		;SIN(X)/COS(X)
                
                
                	IF	FALSE
                FLGTI:	DW 5E7FH,0D95BH	;1/LN(10)
                FLOGT:	DW 1382H,8E5DH	;LN(10)
                
                FXDR:	DW 0E7BH,35FAH	;PI/180
                FXRD:	DW 6586H,0E12EH	;180/PI
                	ENDIF
                
                
                ;****** END -FAX, FLOG, FALOG, FCDR, FCRD, FTAN *****
                
                
                	IF	NOT CAMAC
                ;8080 FLOATING POINT ARCTANGENT - FATAN
                ;   THIS ROUTINE CALCULATES THE ARCTANGENT OF THE
                ;NUMBER IN THE FLOATING POINT ACCUMULATOR.
                ;
                ;	ATAN(FAC) -> FAC
                ;
                ;METHOD
                ;	 POLYNOMIAL APPROXIMATION
                ;
                ;   THIS ROUTINE IS BUILT AROUND A POLYNOMIAL, F(X),
                ;THAT APPROXIMATES ATAN(Z) IN THE RANGE
                ;-.25 <= Z <= .25.  THE ATAN(Z) FOR VALUES OF Z
                ;OUTSIDE THIS RANGE IS FOUND BY USING THE FOLLOWING
                ;IDENTITIES:
                ;	      ATAN(-Z) = -ATAN(Z)
                ;AND
                ;	ATAN(Z) = A(K) + ATAN((Z-B(K))/(Z*B(K)+1))
                ;WHERE
                ;	A(K) = K*PI/7, B(K) = TAN(A(K))
                ;AND K IS DETERMINED SO THAT
                ;TAN((2*K-1)*PI/14) <= ABS(Z) <= TAN((2*K+1)*PI/14)
                ;WITH K = 1, 2, OR 3.
                ;
                ;  HAVING DETERMINED THE VALUE OF K APPROPRIATE
                ;TO Z, THE TRANSFORMATION
                ;	X = (Z-B(K))/(Z*B(K)+1)
                ;PUTS X IN THE RANGE -TAN(PI/14) < X < TAN(PI/14).
                ;THE POLYNOMIAL WORKS OVER A SLIGHTLY LARGER RANGE
                ;TO ALLOW DETERMINATION OF K USING THE VALUES
                ;	K=0  IF ABS(Z) < .25
                ;	K=1  IF .25 < ABS(Z) < .75
                ;	K=2  IF .75 < ABS(Z) < 2
                ;	K=3  IF ABS(Z) > 2
                ;THEN
                ;	ATAN(Z) = A(K) + F(X)   IF Z >= 0
                ;	ATAN(Z) = -A(K) - F(X)  IF Z < 0
                ;F(X) = X*(1 - Q1*X^2 + Q2*X^4 - Q3*X^6)
                ;WHERE
                ;	Q1 = .333329573
                ;	Q2 = .199641035
                ;	Q3 = .131779888
                
 3626 CDD70D    FATAN:	CALL	FTEST		;RESTORE
 3629 C8        	RZ
 362A 5F        	MOV	E,A		;SAVE EXPONENT
 362B 78        	MOV	A,B		;GET M0
 362C E680      	ANI	80H		;ISOLATE SIGN, B23
 362E 321C41    	STA	FATSG		;AND SAVE
 3631 CDCF0D    	CALL	FABS
 3634 5F        	MOV	E,A		;SAVE EXP
 3635 211D41    	LXI	H,FATK
 3638 3600      	MVI	M,0		;K=0
 363A FE7F      	CPI	127
 363C CA5336    	JZ	FAT4		;.25 <= Z < .5, SO K=1
 363F DA9336    	JC	FAT7		;Z < .25, SO K=0 AND DO F(X), X=Z
 3642 3602      	MVI	M,2
 3644 FE81      	CPI	129
 3646 CA5436    	JZ	FAT6		;.75 <= Z < 1, K=2
 3649 D25336    	JNC	FAT4		;Z > 2, K=3
 364C 78        	MOV	A,B
 364D 07        	RLC
 364E 07        	RLC			;CHECK 1/4 BIT
 364F 35        	DCR	M
 3650 D25436    	JNC	FAT6		;.5 <= Z <.75, K=1
 3653 34        FAT4:	INR	M
 3654 7E        FAT6:	MOV	A,M		;FETCH K
 3655 F5        	PUSH	PSW		;SAVE K
 3656 7B        	MOV	A,E		;GET EXPONENT
 3657 211041    	LXI	H,FATZX		;SAVE
 365A CDBE0D    	CALL	FSTOR		;Z
 365D F1        	POP	PSW		;GET K
 365E 3D        	DCR	A		;K-1
 365F 87        	ADD	A		;(K-1)*2
 3660 87        	ADD	A		;(K-1)*4
 3661 87        	ADD	A		;(K-1)*8
 3662 21D136    	LXI	H,FATC1		;START OF TABLE
 3665 5F        	MOV	E,A		;CALCULATE
 3666 1600      	MVI	D,0		;ADDRESS
 3668 19        	DAD	D		; OF A(K)
 3669 E5        	PUSH	H		;AND SAVE IT
 366A 110400    	LXI	D,4
 366D 19        	DAD	D		;ADDRESS OF B(K)
 366E E5        	PUSH	H		;SAVED ALSO
 366F CDEB0D    	CALL	FLOAD		;GET B(K)
 3672 211041    	LXI	H,FATZX
 3675 E5        	PUSH	H
 3676 CD080E    	CALL	FMUL		;Z*B(K)
 3679 21B00B    	LXI	H,FPONE
 367C CD550E    	CALL	FADD		;Z*B(K)+1
 367F 211441    	LXI	H,FATXM
 3682 CDBE0D    	CALL	FSTOR		;SAVE Z*B(K)+1
 3685 E1        	POP	H
 3686 CDEB0D    	CALL	FLOAD		;GET Z
 3689 E1        	POP	H		;ADDRESS OF B(K)
 368A CD520E    	CALL	FSUB		;Z-B(K)
 368D 211441    	LXI	H,FATXM
 3690 CD330E    	CALL	FDIV		;(Z-B(K))/(Z*B(K)+1)
 3693 211041    FAT7:	LXI	H,FATZX
 3696 E5        	PUSH	H
 3697 CDBE0D    	CALL	FSTOR		;SAVE X
 369A E1        	POP	H
 369B CD080E    	CALL	FMUL		;X^2
 369E 211441    	LXI	H,FATXM
 36A1 E5        	PUSH	H		;SAVE FOR FPOLY
 36A2 CDBE0D    	CALL	FSTOR		;SAVE INITIAL POWER
 36A5 211841    	LXI	H,FATX2		;SAVE TERM POWER MULTIPLIER
 36A8 CDBE0D    	CALL	FSTOR
 36AB 21B00B    	LXI	H,FPONE
 36AE CDEB0D    	CALL	FLOAD		;INITIALISE SUM
 36B1 21E936    	LXI	H,FATPL
 36B4 CDEA31    	CALL	FPOLY		;F(X)
 36B7 211041    	LXI	H,FATZX
 36BA CD080E    	CALL	FMUL		;X*F(X)
 36BD 5F        	MOV	E,A		;SAVE EXPONENT
 36BE 3A1D41    	LDA	FATK		;GET K
 36C1 A7        	ANA	A		;SEE IF 0
 36C2 7B        	MOV	A,E		;RESTORE EXPONENT
 36C3 CACA36    	JZ	FAT8		;K=0, NO A(K)
 36C6 E1        	POP	H		;ADDRESS OF A(K)
 36C7 CD550E    	CALL	FADD		;A(K)+F(X)
 36CA 5F        FAT8:	MOV	E,A		;SAVE EXP
 36CB 3A1C41    	LDA	FATSG		;GET INPUT SIGN
 36CE C39035    	JMP	FSC8		;EXIT AS FOR SIN AND COS
                
 36D1 7F65C8FA  FATC1:	DW	657FH,0FAC8H	;A(1) PI/7 .4487989506
 36D5 7F7690F3  	DW	767FH,0F390H	;B(1) TAN(A(1)) .4815746188
 36D9 8065C8FA  	DW	6580H,0FAC8H	;A(2) 2*PI/7 .8975979011
 36DD 812081C6  	DW	2081H,0C681H	;B(2) TAN(A(2)) 1.253960337
 36E1 812C56BB  	DW	2C81H,0BB56H	;A(3) 3*PI/7 1.346396852
 36E5 830C337F  	DW	0C83H,7F33H	;B(3) TAN(A(3)) 4.381286272
                
 36E9 FF        FATPL:	DB	-1		;ATAN POLY TABLE
 36EA 7FAAAA2D  	DW	0AA7FH,2DAAH	;Q1  -.333329573
 36EE 7E4C6EB3  	DW	4C7EH,0B36EH	;Q2  .199641035
 36F2 7E86F14F  	DW	867EH,4FF1H	;Q3  -.131779888
 36F6 00        	DB	0		;TERMINATOR
                
                
                ;****** END - FATAN ******
                	ENDIF			;END OF NOT CAMAC CONTDITIONAL
                
                
                	IF	FALSE
                ;8080 FLOATING POINT INVERSE SIN/COS - FASIN, FACOS
                ;   THESE ROUTINES CALCULATE THE INVERSE
                ;SINE AND COSINE OF A NUMBER IN THE FLOATING
                ;POINT ACCUMULATOR.
                ;   THE RESULTANT ANGLE IS IN RADIANS.
                ;
                ;	ASIN(FAC) -> FAC
                ;	ACOS(FAC) -> FAC
                ;
                ;METHOD
                ;	  THE FOLLOWING IDENTITIES ARE USED
                ;
                ;	ASIN(X) = ATAN(X/SQR(1-X^2))
                ;	ACOS(X) = ATAN(SQR(1-X^2)/X)
                ;AND
                ;	ASIN(-X) = -ASIN(X)
                ;	ACOS(-X) = ACOS(X) + PI
                
                FASIN:	CALL FTEST	;RESTORE
                	CPI 129
                	JC FAS4		;ABS(X) < 1
                	JZ FAS1		;ABS(X) MAY = 1
                
                FAS0:	CALL FTEST
                	JMP FCERN
                FAS1:	MOV E,A		;SAVE EXP
                	MOV A,B		;CHECK
                	ANI 127		;FOR
                	JZ FAS3		; UNITY
                FAS2:	MOV A,E		;RESTORE EXP
                	JMP FAS0	;ERROR ABS(X) > 1
                FAS3:	ADD C
                	JNZ FAS2	;> 1
                	ADD D		;CHECK M3
                	JNZ FAS2	;> 1
                	MOV A,B		;X = +- 1
                FSETP:	PUSH PSW	;SAVE SIGN
                	LXI H,FHPI
                	CALL FLOAD	;GET PI/2
                	MOV E,A		;SAVE EXP
                	POP PSW		;GET SIGN
                	JMP FSC8	;EXIT AS FOR SIN AND COS
                
                FAS4:	CALL FR1X2	;SQR(1-X^2)
                	LXI H,FASCT
                	CALL FSTOR	;SAVE
                	LXI H,FASCX
                	CALL FLOAD	;GET X
                	LXI H,FASCT
                	CALL FDIV	;X/SQR(1-X^2)
                	JMP FATAN	;ATAN(X/SQR(1-X^2))
                
                
                FACOS:	CALL FTEST	;RESTORE
                	ANA A		;SET FLAGS
                	JZ FSETP	;X=0, SET PI/2
                	CPI 129
                	JC FAC1		;ABS(X) < 1 CONTINUE
                	MOV E,A		;SAVE EXP
                FAC0:	MOV A,E		;RESTORE EXPONENT
                	STC		;SET ERROR FLAG
                	JNZ FCERN	;AND RET IF ABS(X) > 1
                	MOV A,B		;CHECK
                	ANI 127		;FOR
                	JNZ FAC0	; X
                	ADD C		;  =
                	JNZ FAC0	;   1
                	ADD D
                	JNZ FAC0	;> 1
                	JMP FZRO	;X=1 SO RETURN 0
                FAC1:	CALL FR1X2	;SQR(1-X^2)
                	LXI H,FASCX
                	CALL FDIV	;SQR(1-X^2)/X
                	CALL FATAN	;ATAN(SQR(-1X^2))
                	RP		;LEAVE IF +
                	LXI H,FPI
                	JMP FADD	;ADD PI
                
                ;ROUTINE TO CALCULATE SQR(1-X^2)
                
                FR1X2:	LXI H,FASCX
                	CALL FSTOR	;SAVE X
                	LXI H,FASCX
                	CALL FMUL	;X^2
                	CALL FCHS	;-X^2
                	LXI H,FPONE
                	CALL FADD	;1-X^2
                	JMP FSQR	;SQR(1-X^2)
                
                
                ;****** END - FASIN, FACOS ******
                	ENDIF
                
                
                	ENDIF		;END OF FLOAT CONDITIONAL
                
                ;****** END - XMATH PACKAGE ******
                
                ;END OF XMATH
                	PAGE
                
                ;ROM 12/12/80
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980 BY MARK WILLIAMS COMPANY, CHICAGO
                ;RAM EQUATES FOR ROM VERSION
                
                	IF	ROM
                
                	IF	COMPL AND NOT RTPAK
                PATCH:	DZ	30		;COMPILER PATCH AREA
                	ENDIF
                
                ;VALUES  FOR BLOCK MOVE INTO NONZERO RAM LOCATIONS
                NZRAM:	IF	CAMAC		;IMPURE ROUTINES FOR CAMAC COMMAND EXECUTION
                	MOV	A,M		;CAMWR, WRITE DATA
                	OUT	0
                	INX	H
                	MOV	A,M
                	OUT	1
                	INX	H
                	MOV	A,M
                	OUT	2
                	RET
                	MOV	A,M		;CAMFN, PERFORM FUNCTION
                	OUT	3
                	INX	H
                	MOV	A,M
                	OUT	4
                	INX	H
                	MOV	A,M
                	OUT	5
                	RET
                	IN	6		;CAMRD, READ DATA
                	MOV	M,A
                	INX	H
                	IN	7
                	MOV	M,A
                	INX	H
                	IN	8
                	MOV	M,A
                	RET
                	DB	255 AND -120, 255 AND -60, 255 AND -24	;TIMEX
                	ELSE
                	IF	NOT WILD
 36F7 00        	DB	0		;IOBYT IN FIRST RAM LOCATION
 36F8 C35401    	JMP	JMPTA+60	;CSTAT, CONSOLE STATUS
                	ENDIF
                	IF	REALT		;TIMEX, TIME COUNTS
                	DB	255 AND -20, 255 AND -60, 255 AND -60, 255 AND -24
                	ELSE
 36FB 138C      	DW	TIMEM
 36FD 12FE      	DW	TIMEN
 36FF 73        	DB	TIMEH
                	ENDIF
                	ENDIF
 3700 DB00      	IN	0		;RPORT
 3702 C9        	RET
 3703 D300      	OUT	0		;WPORT
 3705 C9        	RET
                	IF	BENDX AND SDISK
                	JMP	0		;BRCHA
                	ENDIF
                	IF	ROMSQ
                	DW	SRCAD		;SOURC
                	ENDIF
                	IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)
                ;IMPURE CODE FOR FMULT AND FDIV ROUTINES
                ;MULX4, RAM MULTIPLY SUBROUTINE
 3706 C600      	ADI	0		;ADD OPERAND 3RD FRACTION
 3708 5F        	MOV	E,A		;4TH PARTIAL PRODUCT
 3709 7A        	MOV	A,D		;3RD PARTIAL PRODUCT
 370A CE00      	ACI	0		;ADD OPERAND 2ND FRACTION
 370C 57        	MOV	D,A		;3RD PARTIAL PRODUCT
 370D 79        	MOV	A,C		;2ND PARTIAL PRODUCT
 370E CE00      	ACI	0		;ADD OPERAND 1ST FRACTION
 3710 C9        	RET			;TO ROM CODE
                ;DIVX5, RAM DIVIDE SUBROUTINE
 3711 D600      	SUI	0		;SUBTRACT DIVISOR 4TH FRACTION
 3713 7D        	MOV	A,L		;REMAINDER 3RD FRACTION
 3714 DE00      	SBI	0		;SUBTRACT DIVISOR 3RD FRACTION
 3716 6F        	MOV	L,A		;REMAINDER 3RD FRACTION
 3717 7C        	MOV	A,H		;REMAINDER 2ND FRACTION
 3718 DE00      	SBI	0		;SUBTRACT DIVISOR 2ND FRACTION
 371A 67        	MOV	H,A		;REMAINDER 2ND FRACTION
 371B 7B        	MOV	A,E		;REMAINDER 1ST FRACTION
 371C DE00      	SBI	0		;SUBTRACT DIVISOR 1ST FRACTION
 371E 5F        	MOV	E,A		;REMAINDER 1ST FRACTION
 371F 3E00      	MVI	A,0		;REMAINDER 4TH FRACTION
 3721 C9        	RET 			;TO ROM CODE
                ;DIVX6, RAM DIVIDE SUBROUTINE
 3722 C600      	ADI	0		;ADD DIVISOR 3RD FRACTION
 3724 6F        	MOV	L,A		;REMAINDER 3RD FRACTION
 3725 7C        	MOV	A,H		;REMAINDER 2ND FRACTION
 3726 CE00      	ACI	0		;ADD DIVISOR 2ND FRACTION
 3728 67        	MOV	H,A		;REMAINDER 2ND FRACTION
 3729 7B        	MOV	A,E		;REMAINDER 1ST FRACTION
 372A CE00      	ACI	0		;ADD DIVISOR 1ST FRACTION
 372C 5F        	MOV	E,A		;REMAINDER 1ST FRACTION
 372D 3E00      	MVI	A,0		;REMAINDER 4TH FRACTION
 372F C9        	RET			;TO ROM CODE
                	ENDIF
                	IF	COMPL AND NOT RTPAK	;COMPILER VALUES
                	DW	ROMEND		;TEXTP
                	DW	ROMEND		;RDPTR
                	DW	RAMEND+1	;EOFAD
                	DB	0		;COLUM
                	DB	0		;WIDTH
                	DW	0		;MEMT
                ROMEND:	DB	CR		;CR PRECEDES SOURCE TEXT
                SRCAD	EQU	ROMEND+1	;SOURCE TEXT LOCATION
                	ELSE			;RTPAK OR NOT COMPL
                	IF	NOT RTPAK
 3730 C34237    	JMP	INIT		;DMODC
                	IF	(NOT EPSTN) AND (NOT CAMAC) AND (NOT BENDX)	;HEADR
                	IF	NOT GENMC
 3733 3A00202020	DB	STBYT,TYBYT,'        XYB'
                	ELSE
                	DB	CR, LF, '''', '        .BAS', CR, LF OR 80H
                	ENDIF
                	ENDIF
                	ENDIF			;END OF NOT RTPAK CONDITIONAL
 3740 00        	DB	0		;COLUM
 3741 FF        	DB	255		;WIDTH
                	ENDIF
 004B =         NZLEN	EQU	$-NZRAM		;NUMBER OF NONZERO BYTES TO BLOCK MOVE
                
                
                ;RAM LOCATION EQUATES
                	IF	ASM80
                	DSEG			;START OF RELOCATABLE DATA SEGMENT
                	ELSE
 3742 =         SAVPC	EQU	$		;SAVE ROM PC LOCATION
 4000           	ORG	RAMORG		;AND RESET PC TO START OF RAM
                	ENDIF
                
                ;FIRST LOCATIONS WHICH MUST GET NONZERO VALUES BY BLOCK MOVE
                	IF	CAMAC
                CAMWR	DS	12
                CAMFN	DS	12
                CAMRD	DS	12
                TIMEX	DS	3
                	ELSE			;NOT CAMAC
                	IF	NOT WILD
 4000           IOBYT	DS	1
 4001           CSTAT	DS	3
                	ENDIF
                	IF	REALT
                TIMEX	DS	4
                	ELSE
 4004           TIMEX	DS	5
                	ENDIF
                	ENDIF			;END OF NOT CAMAC CONDITIONAL
 4009           RPORT	DS	3
 400C           WPORT	DS	3
                	IF	BENDX AND SDISK
                BRCHA	DS	3
                	ENDIF
                	IF	ROMSQ
                SOURC	DS	2
                	ENDIF
                	IF	FLOAT AND (NOT F9511) AND (NOT FPBCD)
 400F           MULX4	DS	11
 401A           DIVX5	DS	17
 402B           DIVX6	DS	14
                	ENDIF
                	IF	COMPL AND NOT RTPAK
                TEXTP	DS	2
                RDPTR	DS	2
                EOFAD	DS	2
                COLUM	DS	1
                WIDTH	DS	1
                MEMT	DS	2
                	ELSE
                	IF	NOT RTPAK
 4039           DMODC	DS	3
                	IF	NOT (EPSTN OR CAMAC OR BENDX)
 403C           HEADR	DS	HEADL
                	ENDIF
                	ENDIF
 4049           COLUM	DS	1
 404A           WIDTH	DS	1
                	ENDIF
                
                ;NEXT THE LOCATIONS WHICH MUST BE ZEROED
 404B           LNNUM	DS	2
                	IF	NOT COMPL
                	IF	EDITC
 404D           ERRLN	DS	2
                	ENDIF
 404F           TRAP	DS	1
 4050           TRACE	DS	1
 4051           INLHS	DS	1
 4052           VTRAC	DS	1
                	ENDIF
                	IF	CAMAC
                CMDAT	DS	3
                CMCRA	DS	1
                CMSLO	DS	2
                CMFNC	DS	1
                SCRTE	DS	1
                SDRVR	DS	1
                CAMQR	DS	1
                CAMXR	DS	3
                	IF	C3908
                CMBLK	DS	7
                	ENDIF
                CVCNT	DS	2
                CVLOC	DS	2
                XNABL	DS	1
                IMODE	DS	1
                FMODE	DS	1
                	ENDIF
                	IF	BENDX AND SDISK
                BWTCT	DS	3
                BREOF	DS	2
                BFILP	DS	1
                BFBLK	DS	9
                	ENDIF
                	IF	NOT WILD
 4053           LMODE	DS	1
                	ENDIF
                	IF	PACKI
                PAONL	DS	1
                	ENDIF
 4054           OMODE	DS	1
                	IF	NOT WILD
 4055           INTTC	DS	1
 4056           INTAD	DS	INTTL
 4097           RANDX	DS	2
 4099           NULLS	DS	1
                	ENDIF
 409A           GCHAR	DS	1
                	IF	STRNG
 409B           STEMP	DS	1
                	ENDIF
 0051 =         ZLEN	EQU	$-LNNUM		;NUMBER OF BYTES TO ZERO
                
                ;FOLLOWED BY LOCATIONS WHICH MAY COME UP RANDOMLY
                	IF	STRNG
 409C           	DS	STMAX+STMAX
 40A4           STRT	DS	2
 40A6           STRPT	DS	2
 40A8           STRP2	DS	2
 40AA           GCMIN	DS	2
 40AC           GCLST	DS	2
 40AE           GCLOC	DS	2
                	ENDIF
                	IF	EDITC AND (NOT COMPL)
                	IF	STRNG
 40AA =         RNNEW	EQU	GCMIN
 40AC =         RNINC	EQU	GCLST
 40AE =         RNOLD	EQU	GCLOC
                	ELSE
                RNNEW	DS	2
                RNINC	DS	2
                RNOLD	DS	2
                	ENDIF
                	ENDIF
                	IF	BENDX
                	IF	SDISK
                BFNAM	DS	15
                BFNA2	DS	15
                	ELSE
                BFNAM	DS	11
                	ENDIF
                BMEPS	DS	3
                	ENDIF
                	IF	WILD AND RTPAK	;WTOKE TEMP STORAGE
                WMEMT	DS	2
                WEOF	DS	2
                WLAST	DS	2
                WNEXT	DS	2
                	ENDIF
                	IF	CAMAC AND NONST AND (NOT RTPAK)	;NORTHSTAR DOS
                DUNIT	DS	1
                FNAME	DS	9
                DRBUF	DS	256
                NXTAD	DS	2
                NXTBL	DS	2
                LSTBL	DS	2
                LSTFL	DS	1
                	ENDIF
                	IF	PACKI
                PAIGN	DS	1
                PACNT	DS	1
                PAMOD	DS	1
                PAFNO	DS	1
                PAFBP	DS	2
                PAFLD	DS	PAFCT
                PADAT	DS	PADCT
                PADP0	DS	2
                PADP1	DS	2
                PADP2	DS	2
                PADP3	DS	2
                	ENDIF
                	IF	FLOAT		;FLOATING POINT SYSTEM RAM
 40B0           ARGAD	DS	2
                	IF	F9511
                FPTMP	DS	3
                	ELSE
                	IF	FPBCD
                FACC 	DS 	6  		;FLOATING POINT ACCUMULATOR
                ACALT 	DS 	6  		;ALTERNATE ACCUMULATOR
                HOLD1 	DS 	6  		;FLOATING POINT MULTIPLY BUFFERS
                HOLD2 	DS 	6
                HOLD3 	DS 	6
                HOLD4 	DS 	6
                FTEMP	DS 	6  		;FLOATING POINT WORK AREAS
                FTMP1 	DS 	6
                FTMP2 	DS 	6
                FTMP3 	DS 	6
                FTMP4 	DS 	6
                EXP1 	DS 	1 		;EXPONENT WORK AREAS
                EXP2 	DS 	1  
                EXP3 	DS 	1
                EXP4 	DS 	1
                SIGN 	DS 	1 		;SIGN WORK AREAS
                SIGN1 	DS 	1
                FLEN 	DS 	1 		;LENGTH OF SUBTRACT FIELD
                RSLT 	DS 	2 		;ADDRESS STORAGE
                	ELSE
                ;FIRST THE FMATH RAM
 40B2           PREX	DS	1
 40B3           ACCE	DS	1
 40B4           ACCS	DS	1
 40B5           ACC1	DS	1
 40B6           ACC2	DS	1
 40B7           ACC3	DS	1
 40B8           SFLAG	DS	1
 40B9           ADRL	DS	2
 40BB           TMP1	DS	1
 40BC           TMP2	DS	1
 40BD           TMP3	DS	1
 40BE           VALE	DS	4
 40C2           TMP4	DS	1
                ;AND THEN THE XMATH RAM
 40C3           SIG	DS	1
 40C4           FPTXN	DS	8
 40CC           FPSUM	DS	4
 40D0           VECT	DS	2
 40D2           FINSN	DS	1
 40D3           FINFP	DS	4
 40D7           FPTXX	DS	4
 40DB           FPTF	DS	4
 40DF           FPTP	DS	4
 40E3           FPTX	DS	4
 40E7           FPTN	DS	1
 40E8           FPSGN	DS	1
 40E9           FPTZ0	DS	4
 40ED           FPTZ1	DS	4
 40F1           FLNZI	DS	4
 40F5           FLNZ2	DS	4
 40F9           FLNK	DS	1
 40FA           FLNF	DS	4
 40FE           FSCFX	DS	1
 40FF           FSCSG	DS	1
 4100           FSCZ	DS	4
 4104           FSCZ2	DS	4
 4108           FTMPA	DS	4
 410C           FTMPB	DS	4
                	IF	NOT CAMAC
 4110           FATZX	DS	4
 4114           FATXM	DS	4
 4118           FATX2	DS	4
 411C           FATSG	DS	1
 411D           FATK	DS	1
                	ENDIF
                	ENDIF
                	ENDIF
                	ENDIF
                
                	IF	ASM80
                	STKLN	STAKL
                	ELSE
 411E           	DS	STAKL
 419E           STACK	DS	0
                	ENDIF
                
 419E           VARTY	DS	1
                	IF	STRNG OR FLOAT
 419F           TYBUF	DS	26
                	ENDIF
 41B9           TEMP	DS	2
 41BB           TXTP2	DS	2
 41BD           SAVTP	DS	2
 41BF           LHSTY	DS	1
 41C0           LHSAD	DS	2
 41C2           CSTKP	DS	2
 41C4           ESTKP	DS	2
 41C6           SYMTA	DS	2
 41C8           BUFAD	DS	MAXNL+MAXNL
 41D8           	DS	1
                	IF	EDITC
 41D9           TLNAD	DS	NLMAX+3
                	ELSE
                TLNAD	DS	0
                	ENDIF
                	IF	(SDISK OR (CAMAC AND NONST)) AND (NOT RTPAK)
                NLNAD	DS	256
                	ELSE
 422C           NLNAD	DS	NLMAX+3
                	ENDIF
                	IF	COMPL AND NOT RTPAK
                RAMEND	EQU	$
                	ELSE
                	IF	WILD OR NOT RTPAK
 427F           LNLEN	DS	1
                	ENDIF
                	IF	NOT RTPAK
 4280           CSTKD	DS	1
 4281           TRACL	DS	1
                	ENDIF
 4282           TEXTP	DS	2
 4284           RDPTR	DS	2
 4286           EOFAD	DS	2
 4288           MEMT	DS	2
 428A           	DS	1
 428B =         SRCAD	EQU	$
                	ENDIF
                
                	IF	NOT ASM80
 3742           	ORG	SAVPC		;RESTORE PREVIOUS ROM PC
                	ENDIF
                
                	ENDIF			;END OF ROM CONDITIONAL
                
                ;END OF ROM
                	PAGE
                
                ;INITIAL 05/20/81
                ;XYBASIC INTERPRETER SOURCE MODULE
                ;COPYRIGHT (C) 1978, 1979, 1980, 1981 BY MARK WILLIAMS COMPANY, CHICAGO
                ;INITIALIZATION DIALOG
                
                
                	IF	ASM80
                	CSEG			;RELOCATABLE CODE SEGMENT
                	ENDIF
                
                ;XYBASIC PERFORMS A JMP INIT FROM ROMORG ON INITIAL ENTRY.
                ;THE USER PROGRAM SOURCE AND WORKING SPACE OVERLAY THE CODE
                ;IN THIS MODULE AFTER INITIALIZATION IN RAM VERSIONS.
                
 3742 319E41    INIT:	LXI	SP,STACK	;INITIALIZE SP
                
                ;SAVE A ON ENTRY IN WILD VERSION
                	IF	WILD
                	PUSH	PSW
                	ENDIF
                
                ;SET UP RAM LOCATIONS IF ROM VERSION
                	IF	ROM
 3745 01F736    	LXI	B,NZRAM		;SOURCE ADDRESS TO BC
 3748 114B00    	LXI	D,NZLEN		;BYTE COUNT TO DE
 374B 210040    	LXI	H,RAMORG	;DESTINATION ADDRESS TO HL
 374E CDB631    	CALL	MOVED		;BLOCK MOVE NONZERO BYTES TO RAM
 3751 015100    	LXI	B,ZLEN		;0 TO B, BYTES TO ZERO TO C
 3754 CD351E    	CALL	FILLM		;FILL RAM LOCATIONS WITH 0
 3757 3E3A      	MVI	A,':'
 3759 21D841    	LXI	H,TLNAD-1
 375C 77        	MOV	M,A		;COLON PRECEDES TOKENIZED INPUT BUFFER
 375D 23        	INX	H
 375E 3E0D      	MVI	A,CR
 3760 77        	MOV	M,A		;CR TO TOKENIZED INPUT BUFFER
                	IF	EDITC
 3761 322C42    	STA	NLNAD		;AND CR TO INPUT BUFFER IN EDITC VERSION
                	ENDIF
 3764 328A42    	STA	SRCAD-1		;CR PRECEDES SOURCE TEXT
                	ENDIF			;END OF ROM CONDITIONAL
                
                ;INITIALIZE RUNTIME PACKAGE POINTERS
                	IF	RTPAK		;INITIALIZE SOUCE TEXT POINTERS
                	LXI	H,SRCAD
                	MVI	M,0		;SOURCE TEXT EMPTY
                	SHLD	EOFAD		;INITIALIZE EOFAD
                	CALL	CSPST		;RESET CSTACK AND ESTACK
                	ENDIF			;END OF RTPAK CONDITIONAL
                
                ;SET UP I/O JMP VECTOR IF CP/M VERSION
                	IF	CPM
                	LHLD	CPMBA+1		;3E03H + BASE
                	LXI	D,3
                	DAD	D		;3E06H + BASE
                	SHLD	CSTAT+1		;STORE TO ALLOW CONSOLE STATUS NOT VIA BDOS
                	DAD	D		;3E09H + BASE
                	SHLD	CONIN+1		;STORE TO ALLOW CONSOLE READING WITHOUT ECHO
                	DAD	D		;3E0CH + BASE
                	SHLD	CNOUT+1		;STORE TO ALLOW CONSOLE WRITING
                	DAD	D		;3E0FH + BASE
                	SHLD	LOUT+1		;STORE TO ALLOW LIST DEVICE WRITING
                	IF	AMD		;ALSO DEFINE PUN AND RDR IN AMD VERSION
                	DAD	D
                	SHLD	POUT+1		;3E12H + BASE IS PUN OUT
                	DAD	D
                	SHLD	RDRIN+1		;3E15H + BASE IS RDR IN
                	ENDIF			;END OF AMD CONDITIONAL
                	ENDIF			;END OF CPM CONDITIONAL
                
                ;INITIALIZE THE REAL TIME CLOCK FOR REALT VERSION
                	IF	REALT
                	MVI	A,0C3H
                	STA	10H		;JMP TO RST 2
                	LXI	H,CLOCK
                	SHLD	11H		;SO RST 2 DOES A JMP CLOCK
                	EI			;ENABLE INTERRUPTS SO CLOCK RUNS
                	ENDIF
                
                ;INITIALIZE THE REAL TIME CLOCK FOR CAMAC VERSION
                	IF	CAMAC
                	LXI	H,101H
                	SHLD	SCRTE		;SET SERIAL CRATE AND DRIVER TO 1
                	IF	C3885 AND NOT DEBUG	;CLOCK INITIALIZATION FOR 3885
                ;INITIALIZE RST 7.5 AT 3CH TO JMP CLOCK
                	MVI	A,0C3H
                	STA	3CH		;JMP TO 3CH
                	LXI	H,CLOCK
                	SHLD	3DH		;CLOCK TO 3DH
                ;INITIALIZE COUNTER MODE AND SET INTERRUPT MASK
                	MVI	A,74H
                	OUT	0BH		;SET COUNTER 1 TO MODE 2
                	LXI	B,800
                	MOV	A,C
                	OUT	9
                	MOV	A,B
                	OUT	9		;INITIALIZE COUNTER
                	MVI	A,0BH
                	SIM			;SET INTERRUPT MASK
                	EI
                	ENDIF
                ;CLOCK INITIALIZATION IN OLD NONST VERSION
                	IF	NONST AND (NOT RTPAK) AND FALSE
                	MVI	A,0C3H
                	STA	1008H		;JMP TO 1008H
                	LXI	H,CLOCK
                	SHLD	1009H		;CLOCK TO 1009H SO INTERRUPTS WILL JMP CLOCK
                	MVI	A,255
                	OUT	4
                	MVI	A,0A6H
                	OUT	11
                	OUT	19
                	MVI	A,18H
                	OUT	2
                	EI
                	ENDIF
                	ENDIF
                
                ;PACKARD INSTRUMENTS VERSION INITIALIZATION
                	IF	PACKI AND NOT DEBUG
                	MVI	A,5
                	STA	NULLS		;INITIALIZE NULLS FOR TI SILENT 700
                	RIM			;READ INTERRUPT MASK
                	ANI	4
                	ORI	8		;SET
                	SIM			;RESET INTERRUPT MASK
                	EI			;ENABLE INTERRUPTS
                	ENDIF
                
                ;PRINT INITIAL MESSAGE
                	IF	NOT (WILD AND RTPAK)
 3767 CDC116    	CALL	PRNTM
                	IF	EPSTN
                	DB	0FH, 13H
                	ENDIF
 376A 0D0A      	DB	CR, LF
                	IF	COMPL
                	IF	RTPAK
                	DB	'RUNTIME '
                	ELSE
                	DB	'COMPILED '
                	ENDIF
                	ENDIF
                	IF	(NOT STRNG) AND (NOT FLOAT)
                	DB	'INTEGER '
                	ENDIF
                	IF	AMD
                	DB	'AMD '
                	ENDIF
                	IF	BENDX
                	DB	'BENDIX '
                	ENDIF
                	IF	PACKI
                	DB	'PACKARD INSTRUMENTS '
                	ENDIF
                	IF	WILD
                	DB	'WILD '
                	ENDIF
 376C 5859424153	DB	'XYBASIC '
                	IF	EPSTN
                	DB	12H
                	ENDIF
                	IF	CPM AND (NOT CAMAC)
                	DB	'CP/M '
                	ENDIF
                	IF	ISIS2
                	DB	'ISIS-II '
                	ENDIF
                	IF	SDISK AND (NOT CAMAC)
                	DB	'DISK '
                	ENDIF
                	IF	EDITC
 3774 4544495420	DB	'EDIT '
                	ENDIF
 3779 5245562032	DB	'REV ', VERSN/10000+'0', '.'
                	IF	((VERSN/1000) MOD 10) NE 0
 377F 31        	DB	(VERSN/1000) MOD 10 + '0'
                	ENDIF
 3780 34        	DB	(VERSN/100) MOD 10 +'0'
                	IF	(VERSN MOD 100) NE 0
                	DB	'.'
                	IF	((VERSN/10) MOD 10) NE 0
                	DB	(VERSN/10) MOD 10 + '0'
                	ENDIF
                	DB	VERSN MOD 10+'0'
                	ENDIF
                	IF	DEBUG
                	DB	'D'
                	ENDIF
 3781 0D8A      	DB	CR, LF OR 80H
                
                ;PRINT COPYRIGHT MESSAGE UNLESS CAMAC VERSION
                	IF	NOT CAMAC
 3783 21E52D    	LXI	H,MWCMA
 3786 CDB016    	CALL	PRTST		;PRINT COPYRIGHT MESSAGE
                	ENDIF
                	ENDIF			;END OF NOT (WILD AND RTPAK) CONDITIONAL
                
                ;IF COMPILER, FIND TOP OF MEMORY AND EXECUTE PROGRAM DIRECTLY
                	IF	COMPL AND NOT RTPAK
                	LHLD	MEMT		;PASSED MEMT VALUE TO HL
                	MOV	A,H
                	ORA	L		;ZERO SET IFF DEFAULT TO FOUND VALUE
                	CZ	EOMEM		;TAKE DEFAULT VALUE
                	IF	STRNG
                	SHLD	STRT		;STORE TOP OF STRING SPACE
                	DCR	H		;LEAVE 100H BYTES OF STRING SPACE
                	ENDIF
                	SHLD	MEMT
                	MVI	M,0		;INITIALIZE SYMBOL TABLE
                	CALL	CLEA1		;INITIALIZE
                	MVI	M,0		;INITIALIZE CSTACK
                	JMP	NEXTS		;AND EXECUTE THE PROGRAM
                	ELSE			;(NOT COMPL) OR RTPAK
                
                ;CHECK DEFAULT WIDTH IF ROMSQ OR CP/M VERSION
                	IF	ROMSQ AND NOT WILD
                	LDA	DFLTW		;DEFAULT WIDTH TO A
                	ORA	A
                	JNZ	INIT2		;TAKE SPECIFIED WIDTH
                	ENDIF
                	IF	CPM AND NOT COMPL
                	LDA	FCBAD+1
                	CPI	' '		;CHECK IF FILENAME SPECIFIED ON COMMAND LINE
                	MVI	A,72
                	JNZ	INIT2		;YES, DEFAULT WIDTH TO 72
                	ENDIF
                
                ;PROMPT FOR WIDTH
                	IF	WILD AND RTPAK
                	MVI	A,255
                	STA	WIDTH
                	ELSE
 3789 110100    INIT1:	LXI	D,1		;TERMINAL WIDTH MIN  = 1
 378C CDF937    	CALL	INITP		;PRINT MESSAGE, GET WIDTH
 378F 5749445448	DB	'WIDTH?', ' ' OR 80H
 3796 DA8937    	JC	INIT1		;ILLEGAL VALUE
 3799 3E50      	MVI	A,NLMAX		;DEFAULT WIDTH TO A
 379B CAA437    	JZ	INIT2		;TAKE DEFAULT VALUE
 379E 7C        	MOV	A,H
 379F B7        	ORA	A
 37A0 C28937    	JNZ	INIT1		;TOO BIG -- TRY AGAIN
 37A3 7D        	MOV	A,L
 37A4 324A40    INIT2:	STA	WIDTH
                	ENDIF			;END OF NOT (WILD AND RTPAK) CONDITIONAL
                
                INIT3:	IF	ROM		;MIN MEMTOP VALUE TO DE
 37A7 119543    	LXI	D,SRCAD+DBYTS
                	ELSE
                	LXI	D,EORAM+DBYTS
                	ENDIF
                
                ;CHECK DEFAULT MEMTOP VALUE IF ROMSQ OR CP/M VERSION
                	IF	ROMSQ AND NOT WILD
                	LHLD	DFLTM		;DEFAULT END OF MEMORY TO HL
                	CALL	CMDHU
                	JC	INIT4		;CHECK SPECIFIED VALUE
                	MOV	A,H
                	ORA	L		;ZERO SET IFF DEFAULT TO MAX
                	JZ	INIT5		;TAKE MAX VALUE
                	ENDIF
                	IF	CPM AND NOT COMPL
                	LDA	FCBAD+1
                	CPI	' '
                	JNZ	INIT5		;TAKE MAX
                	ENDIF
                
                ;PROMPT FOR END OF MEMORY
                	IF	WILD AND RTPAK
                	LHLD	WEOM
                	CALL	CMDHU		;COMPARE TO LEAST
                	JC	INIT6		;TAKE GIVEN VALUE
                	ELSE
 37AA CDF937    	CALL	INITP		;PRINT MESSAGE, GET MEM TOP
 37AD 454E44204F	DB	'END OF MEMORY?', ' ' OR 80H
 37BC DAA737    	JC	INIT3		;BAD VALUE, RETRY
 37BF CACB37    	JZ	INIT5		;TAKE DEFAULT VALUE
 37C2 CD8701    INIT4:	CALL	RTEST		;TEST IF SPECIFIED LOCATION IS RAM
 37C5 C2A737    	JNZ	INIT3		;NOT RAM, RETRY
 37C8 C3CE37    	JMP	INIT6		;ELSE TAKE SPECIFIED LOCATION
                	ENDIF			;END OF NOT (WILD AND RTPAK) CONDITIONAL
 37CB CD1638    INIT5:	CALL	EOMEM		;FIND DEFAULT END OF MEMORY
                
                ;INITIALIZE RAM POINTERS
 37CE AF        INIT6:	XRA	A
                	IF	SDISK AND CPM AND (NOT RTPAK)
                	SHLD	FILET		;STORE END OF FILE SPACE
                	MOV	M,A		;INITIALIZE FIRST DEFAULT FILE AREA
                	LXI	D,-FILEN
                	DAD	D
                	MOV	M,A		;INITIALIZE SECOND DEFAULT FILE AREA
                	DAD	D
                	ENDIF
                	IF	STRNG
 37CF 22A440    	SHLD	STRT		;STORE TOP OF STRING SPACE
 37D2 25        	DCR	H		;LEAVE 100H BYTES OF STRING SPACE
                	ENDIF
 37D3 77        	MOV	M,A		;INITIALIZE SYMBOL TABLE
 37D4 228842    	SHLD	MEMT
                	IF	RTPAK
                	CALL	CLEA1		;INITIALIZE
                	ELSE			;NOT RTPAK
 37D7 CD2A22    	CALL	NEW		;INITIALIZE SOURCE, INTERRUPT
                	IF	BENDX AND NOT DEBUG
                	LXI	H,DMOD2
                	SHLD	BRSAD		;RESET REENTRY ADDRESS TO DMODE
                	ENDIF
 37DA 212B26    	LXI	H,STOP
 37DD 223A40    	SHLD	DMODC+1		;CHANGE ^C BRANCH FROM JMP INIT TO JMP STOP
                	ENDIF
                	IF	NOT ROM
                	LXI	H,DMOD2
                	SHLD	START+1		;CHANGE JMP INIT TO JMP DMOD2 TO ALLOW REENTRY
                	ENDIF
                
                ;LOAD PROGRAM IF SPECIFIED ON CP/M COMMAND LINE
                	IF	CPM AND NOT COMPL
                	LDA	FCBAD+1
                	CPI	' '		;CHECK IF FILENAME SPECIFIED ON COMMAND LINE
                	JZ	INIT7		;NO
                	LXI	H,FCBFT
                	MVI	M,'X'
                	INX	H
                	MVI	M,'Y'
                	INX	H
                	MVI	M,'B'		;RESET FILETYPE TO .XYB
                	CALL	LOADZ		;RESET LNNUM AND TEXTP IN CASE NOT FOUND
                	CALL	CDKOP		;OPEN THE FILE
                	LXI	H,NEXTS
                	PUSH	H		;PUSH NORMAL STATEMENT RETURN FOR RUN
                	MVI	B,1		;SET B FOR ,R TO RUN AFTER LOADING
                	JMP	LOD0B		;AND LOAD IT
                	ENDIF
                
                ;PRINT BYTES FREE MESSAGE
                	IF	NOT (WILD AND RTPAK)
 37E0 CDBB14    INIT7:	CALL	FRE		;FREE MEMORY BYTES TO BC
 37E3 CDFB15    	CALL	WRTBU		;WRITE (BC) UNSIGNED
 37E6 CDC116    	CALL	PRNTM		;PRINT BYTES FREE MESSAGE
 37E9 2042595445	DB	' BYTES FREE', CR, LF OR 80H
                	ENDIF			;END OF NOT (WILD AND RTPAK) CONDITIONAL
                
                ;WILD VERSION DEFAULT PROGRAM EXECUTION
                	IF	WILD
                	POP	PSW		;RECOVER INITIAL A VALUE
                	IF	NOT RTPAK
                	ORA	A
                	JZ	DMODE		;0 GETS DIRECT MODE IN DEVELOPMENT VERSION
                	ENDIF
                	MOV	C,A
                	MVI	B,0		;DESIRED PROGRAM # TO BC
                	CALL	EXECW		;FIND SELECTED PROGRAM
                	LHLD	SOURC
                	DCX	H
                	SHLD	TEXTP		;RESET TEXTP TO SELECTED PROGRAM
                	JMP	NEXTS		;AND EXECUTE IT
                	ELSE			;NOT WILD
                
                ;BEGIN AT DIRECT MODE OR EXECUTE SPECIFIED PROGRAM
                	IF	ROMSQ
                	LHLD	DFLTA		;DEFAULT PROG ADDRESS TO HL
                	IF	RTPAK		;RUNTIME VERSION
                	MOV	A,M		;FETCH FIRST CHAR
                	CPI	CR
                	JZ	INIT8		;FIRST CHAR IS CR, CONTINUE AS BELOW
                	CALL	PRNTM		;ELSE PRINT ERROR MESSAGE
                	DB	'PROGRAM NOT FOUND', CR, LF OR 80H
                	JMP	BOOT		;AND EXIT
                INIT8:	SHLD	RDPTR		;INITIALIZE THE DATA POINTER
                	INX	H
                	SHLD	SOURC		;SET SOURC TO PROGRAM ADDRESS
                	ELSE
                	MOV	A,H
                	ORA	L
                	JZ	DMODE		;NONE SPECIFIED
                	CALL	EXEC0		;RESET SOURC TO SPECIFIED ADDRESS
                	LHLD	SOURC
                	ENDIF
                	DCX	H
                	SHLD	TEXTP		;RESET TEXTP TO PROGRAM
                	JMP	NEXTS		;AND EXECUTE FROM THERE
                	ELSE			;NOT ROMSQ
 37F6 C34E06    	JMP	DMODE
                	ENDIF
                	ENDIF			;END OF NOT WILD CONDITIONAL
                
                	IF	NOT (WILD AND RTPAK)
                ;INITP PROMPTS THE USER AND GETS A VALUE FOR WIDTH OR END OF MEMORY.
                ;CALL:	DE			MIN VALUE -1
                ;	LOCATION AFTER CALL	MESSAGE TO PRINT
                ;RETN:	CARRY			SET IFF VALUE BAD
                ;	ZERO, NO CARRY		IF <CR> TYPED
                ;	NO ZERO, NO CARRY	VALUE OK,  RETURNED IN HL
 37F9 E1        INITP:	POP	H		;MESSAGE ADDRESS TO HL
 37FA CDB016    	CALL	PRTST		;PRINT MESSAGE
 37FD E5        	PUSH	H		;SAVE RETURN ADDR
 37FE D5        	PUSH	D		;SAVE MIN VALUE -1
 37FF CD342E    	CALL	GTLIN		;GET A LINE FROM CONSOLE
 3802 CDF217    	CALL	GTDEC		;AND GET DECIMAL VALUE TO DE
 3805 EB        	XCHG			;VALUE TYPED TO HL
 3806 D1        	POP	D		;MIN -1 TO DE
 3807 DA1138    	JC	INIP1		;NO DIGIT -- CHECK FOR <CR>
 380A 37        	STC
 380B C8        	RZ			;TOO BIG, RETURN CARRY
 380C CD8602    	CALL	CMDHU
 380F 3F        	CMC			;CARRY SET IFF MIN >= VALUE TYPED
 3810 C9        	RET
 3811 FE0D      INIP1:	CPI	CR
 3813 C8        	RZ			;<CR>, RETURN ZERO AND NO CARRY
                	IF	CAMAC
                	LXI	H,MWCMA
                	CALL	PRTST		;PRINT COPYRIGHT MESSAGE IN CAMAC VERSION
                	ENDIF
 3814 37        	STC
 3815 C9        	RET			;RETURN CARRY
                	ENDIF			;END OF NOT (WILD AND RTPAK) CONDITIONAL
                
                	ENDIF			;END OF NOT COMPL OR RTPAK CONDITIONAL
                
                ;EOMEM GETS DEFAULT END OF RAM TO HL.
                EOMEM:	IF	CPM		;FETCH END OF MEMORY FROM BDOS
                	LHLD	BDOS+1
                	DCX	H
                	ENDIF
                	IF	ISIS2
                	CALL	MECHK		;TOP OF MEMORY TO AB
                	MOV	H,B
                	MOV	L,A		;THEN TO HL
                	ENDIF
                	IF	NONST		;SEARCH FOR END OF RAM
                	IF	COMPL		;FIRST LOC TO TEST TO HL
                	LHLD	EOFAD
                	ELSE
                	IF	ROM
 3816 218B42    	LXI	H,SRCAD
                	ELSE
                	LXI	H,EORAM
                	ENDIF
                	ENDIF
 3819 23        EOME1:	INX	H
 381A 7C        	MOV	A,H
 381B B5        	ORA	L
 381C CA2538    	JZ	EOME2		;QUIT IF AT 64K BOUNDARY
 381F CD8701    	CALL	RTEST		;CHECK IF RAM AT LOCATION
 3822 CA1938    	JZ	EOME1		;RAM, TRY NEXT
 3825 2B        EOME2:	DCX	H		;TOP OF MEMORY TO HL
                	ENDIF
 3826 C9        EORAM:	RET
                
                	IF	ROM AND (RTPAK OR NOT COMPL)
 3827 =         PATCH	EQU	EORAM+1		;PATCH AREA FOR ROM VERSIONS
                	ENDIF
                
 3827           	END			;END OF XYBASIC SOURCE
