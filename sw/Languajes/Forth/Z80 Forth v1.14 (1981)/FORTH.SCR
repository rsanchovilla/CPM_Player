( Laboratory Microsystems Z-80 FORTH )                          ;S                                                                                                                              FORTH interpreter/compiler for Z-80 microcomputers.             Requires Digital Research CP/M 2.2 or MP/M 1.1 operating system.                                                                Copyright 1980,1981 by                                          Laboratory Microsystems                                         4147 Beethoven Street                                           Los Angeles, CA 90066                                                                                                           For technical assistance call Ray Duncan at (213) 390-9292.                                                                     This screen file updated 15 October 1981.                                                                                                                                                       ( Reallocate disk buffers under CP/M )                          FORTH DEFINITIONS DECIMAL                                       0 VARIABLE CP/M B/BUF 4 + VARIABLE BUFLEN                       32 VARIABLE MAX.BUFFERS                                         : MEMORY                                                          6 @ DUP CP/M ! FIRST -                                          0 BUFLEN @ U/ SWAP DROP                                         MAX.BUFFERS @ MIN DUP BUFLEN @ * FIRST + ;                    MEMORY ( grab available memory, leave result on stack )         ( now set interpreter constants to reflect expansion  )         -FIND LIMIT DROP DROP ! ( upper limit of disk buffers )         -FIND #BUFF DROP DROP ! ( number of available buffers )         FIRST DUP PREV ! USE !  ( initialize buffer pointers )          EMPTY-BUFFERS ( zero out the new virtual memory )               2 LOAD CONFIGURATION     ( display system status )              DECIMAL  ;S                                                     ( Display system configuration )                                117 LOAD                                                                                                                        : CONFIGURATION                                                 CR                                                              CR ." Characters/line = " C/L .                                 CR ." Bytes/disk buffer = " B/BUF .                             CR ." Disk buffers/screen = " B/SCR .                           CR ." Disk buffers available = " #BUFF .                        MAP ;                                                           ;S                                                                                                                                                                                                                                                                                                                                                                                              ( Utility to create new COM file )                              ( May be used to add new compiled functions to the load )       ( file.  To execute type:  3 LOAD <return>              )       FORTH DEFINITIONS DECIMAL                                       LATEST 12 +ORIGIN ! ( top NFA )                                 HERE 28 +ORIGIN ! ( FENCE )                                     HERE 30 +ORIGIN ! ( DP )                                        VOC-LINK @      32 +ORIGIN ! ( VOC-LINK )                                                                                       CR CR                                                           ." When you see the CP/M cue > then type : "                    ." SAVE  " HERE 256 / . ." filename.COM <return> "              CR CR FLUSH BYE ;S                                                                                                                                                                                                                                              ( System messages )                                             empty stack                                                     dictionary full                                                 has incorrect address mode                                      isn't unique                                                                                                                    disc range ?                                                    full stack                                                      disc error !                                                                                                                                                                                                                                                                                                                    BASE must be DECIMAL                                            missing decimal point                                           Z-80 FORTH                               Laboratory Microsystems( System messages )                                             compilation only, use in definition                             execution only                                                  conditionals not paired                                         definition not finished                                         in protected dictionary                                         use only when loading                                           off current editing screen                                      declare vocabulary                                                                                                                                                                                                                                              illegal dimension in array definition                           negative array index                                            array index too large                                                                                                           ( Error messages for Z-80 Assembler )                           16 bit register not allowed                                     8 bit register not allowed                                      index register not allowed                                      immediate data value not allowed                                missing source register                                         missing destination register                                    illegal operation                                               illegal operand                                                 instruction not implemented                                     illegal destination register                                    illegal source register                                         illegal condition code                                          register mismatch                                                                                                                                                                               ( Error messages for Data Base Management System )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( 1 and 2 dimensional integer array definitions )                                                                               ( integer one dimensional array )                               : ARRAY  ( size ARRAY )                                           <BUILDS 0 DO 0 , LOOP                                           DOES> SWAP DUP + + ;                                                                                                          ( integer two dimensional array )                               : 2ARRAY ( x-dimension y-dimension 2ARRAY )                       <BUILDS 2DUP SWAP , , * 0 DO 0 , LOOP                           DOES> DUP @ ROT * DUP + + SWAP DUP + + 4 + ;                  ;S                                                                                                                                                                                                                                                                                                                              ( Screen printing utility SHOW )                                ( displays triads on list device )                              ( command format:  n1 n2 SHOW )                                 0 VARIABLE FF.FLAG                                              : SHOW                                                            FF.FLAG @ 0=                                                    IF CR                                                           ." Does your printer have form feed capability? (Y/N)  " KEY    DUP EMIT 32 OR 121 = IF 2 ELSE 1 ENDIF FF.FLAG ! CR ENDIF       SWAP PRINTER                                                    DO I TRIAD                                                         FF.FLAG @ 1 =                                                   IF 7 0 DO CR LOOP ENDIF                                      3 +LOOP                                                         CONSOLE                                                         ;                                                             ( fig-FORTH portable editor, by William F. Ragsdale )           FORTH DEFINITIONS HEX                                           : TEXT                                                            HERE C/L 1+ BLANKS WORD HERE PAD C/L 1+ CMOVE ;               : LINE                                                            DUP FFF0 AND 17 ?ERROR SCR @ (LINE) DROP ;                    VOCABULARY EDITOR IMMEDIATE HEX                                 : WHERE ( PRINT SCREEN # AND IMAGE OF ERROR )                     DUP B/SCR / DUP SCR ! ." Screen # " DECIMAL .                   SWAP C/L /MOD C/L * ROT BLOCK + CR C/L TYPE                     CR HERE C@ - SPACES 5E EMIT [COMPILE] EDITOR QUIT ;           EDITOR DEFINITIONS                                              : #LOCATE R# @ C/L /MOD ;                                       : #LEAD #LOCATE LINE SWAP ;                                     : #LAG #LEAD DUP >R + C/L R> - ;                                : -MOVE LINE C/L CMOVE UPDATE ;   -->                           ( fig-FORTH portable editor, continued )                        : H                                                               LINE PAD 1+ C/L DUP PAD C! CMOVE ;                            : E                                                               LINE C/L BLANKS UPDATE ;                                      : S                                                               DUP 1 - 0E DO I LINE I 1+ -MOVE -1 +LOOP E ;                  : D                                                               DUP H 0F DUP ROT DO I 1+ LINE I -MOVE LOOP E ;                : M                                                               R# +! CR SPACE #LEAD TYPE 5F EMIT                               #LAG TYPE #LOCATE . DROP ;                                    : T                                                               DUP C/L * R# ! DUP H 0 M ;                                    : L                                                               SCR @ LIST 0 M ;      -->                                     ( fig-FORTH portable editor, continued )                        : R                                                               PAD 1+ SWAP -MOVE ;                                           : P                                                               1 TEXT R ;                                                    : I                                                               DUP S R ;                                                     : TOP                                                             0 R# ! ;                                                      : CLEAR                                                           SCR ! 10 0 DO FORTH I EDITOR E LOOP ;                         : COPY                                                            B/SCR *            SWAP B/SCR * B/SCR OVER + SWAP               DO DUP FORTH I BLOCK 2 - ! 1+ UPDATE LOOP                       DROP FLUSH ;                                                    -->                                                           ( fig-FORTH portable editor, continued )                        : 1LINE ( scan line with cursor for match to PAD text )                 ( update cursor, return boolean )                         #LAG PAD COUNT MATCH R# +! ;                                  : FIND ( string at PAD over full screen, else error )             BEGIN 3FF R# @ < IF TOP PAD HERE C/L 1+ CMOVE 0 ERROR           ENDIF 1LINE UNTIL ;                                           : DELETE ( backwards at cursor by count-1 )                       >R #LAG + FORTH R -    ( save blank fill location )             #LAG R MINUS R# +!     ( backup cursor )                        #LEAD + SWAP CMOVE R> BLANKS UPDATE ; ( fill from end )       : N ( find next occurence of previous text  )                     FIND 0 M ;                                                    : F ( find occurence of text )                                   1 TEXT N ;                                                     -->                                                             ( fig-FORTH portable editor, continued )                        : B ( BACKUP CURSOR BY TEXT IN PAD )                              PAD C@ MINUS M ;                                              : X ( delete following text )                                     1 TEXT FIND PAD C@ DELETE 0 M ;                               : TILL ( delete from cursor to text end on this line )            #LEAD + 1 TEXT 1LINE 0= 0 ?ERROR                                #LEAD + SWAP - DELETE 0 M ;                                   : C ( spread at cursor and copy in following text )               1 TEXT PAD COUNT #LAG ROT OVER MIN >R FORTH R R# +!             R - >R DUP HERE R CMOVE HERE #LEAD + R> CMOVE                   R> CMOVE UPDATE 0 M ;                                         FORTH DEFINITIONS DECIMAL   LATEST 12 +ORIGIN ! ( TOP NFA )     HERE 28 +ORIGIN ! ( FENCE ) HERE 30 +ORIGIN ! ( DP )            ' EDITOR 6 + 32 +ORIGIN ! ( VOC-LINK )                          HERE FENCE ! ;S                                                 ( fig-FORTH portable editor extensions, by Kim Harris )         ( from FORTH Dimensions Vol II No 6 page 161        )           EDITOR DEFINITIONS DECIMAL                                                                                                      : ENTER?  ( start-line# current-line# -> f ) OVER = ;           : ENTER   ( -> )  QUERY 1 TEXT ;                                : NULL?   ( -> f )  TIB @ C@ 0= ;                               : .BS     ( -> )  8 EMIT ;                                                                                                      : NEW     ( start-line# -> ) FORTH  16 0 DO CR I 3 .R SPACE       I ENTER? IF ENTER NULL? IF .BS I SCR @ .LINE ELSE               I EDITOR R FORTH 1+ THEN ELSE I SCR @ .LINE THEN LOOP DROP ;  : UNDER   ( start-line# -> ) FORTH 1+ 16 0 DO CR I 3 .R SPACE     I ENTER? IF ENTER NULL? IF .BS I SCR @ .LINE ELSE               I EDITOR I FORTH 1+ THEN ELSE I SCR @ .LINE THEN LOOP DROP ;  FORTH DEFINITIONS ;S                                            ( Example auto-load screen for FORTH 1.14 )                                                                                     CR ." Auto load:  "                                             101 LOAD        ." DUMP "                                       63 LOAD         ." .STACK "                                     117 LOAD        ." MAP "                                        CR                                                              ;S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( INTERFACE AGE Benchmark program )                             : BENCH DUP 2 / 1+ SWAP ." Starting " CR                                1 DO DUP I 1 ROT                                                  2 DO DROP DUP I /MOD                                               DUP 0= IF DROP DROP 1 LEAVE                                       ELSE 1 = IF DROP 1                                                ELSE DUP 0 > IF DROP 1                                            ELSE 0= IF 0 LEAVE                                                ENDIF                                                         ENDIF                                                         ENDIF                                                         ENDIF                                                         LOOP                                                       IF 4 .R ELSE DROP ENDIF                                         LOOP DROP CR ." Finished " ;                            ( see FORTH DIMENSIONS Vol II, No. 4, page 112 )                ( Execution variables and arrays     M. A. McCourt )            ( From FORTH DIMENSIONS II/4, page 109             )            : PICK        SP@ SWAP 2 * + @ ;                                : 0>=         0< 0= ;                                           : 2DROP       DROP DROP ;                                       : DUMMY ;                    ( dummy XEQ routine )              : ()XEQ                      ( # of vectors ->   )                <BUILDS DUP ,              ( 1st param = max # vectors )        2 * DUP HERE SWAP 0 FILL ALLOT  ( all vectors zeroed )          DOES> DUP @ 3 PICK >       ( check for max > index )                        3 PICK 0>=     ( and for index >= zero )                        AND IF 2+ SWAP 2 * + @ EXECUTE                                  ELSE 2DROP 33 ABORT ENDIF ;                       : XEQ <BUILDS ,              ( create execution vector )              DOES> @ EXECUTE ;                                         -->                                                             ( Execution variables and arrays, continued )                   ( for installation:  INSTALL <routine-name> IN <XEQ-name> )     : ]'[ [COMPILE] ' ;  ( non-immediate version of tick )                                                                          : INSTALL  ( install <NAME> in 'XEQ' variable -- set vector )     ]'[   STATE @ IF  COMPILE  CFA ELSE CFA THEN ; IMMEDIATE                                                                      : IN ( XEQ-addr -> )                                              ]'[ 2+ STATE @ IF  COMPILE  ! ELSE ! THEN ;   IMMEDIATE                                                                       : OFFSET.IN ( XEQ-addr XEQ-array-word-offset + 1 -> )             DUP 0>= IF 1+ 2 *  ]'[  + ! ( can't use in compile state )      ELSE 2DROP THEN ;                                             ;S                                                                                                                                                                                              ( Screen Editor for CRT's with cursor addressing )              ( adapted from FORTH Dimensions II/3 page 83     )              : TASK ; 52 LOAD 46 LOAD 22 LOAD                                HEX 0 VARIABLE CUR            05 CONSTANT ERASEFLAG             15 CONSTANT UPCURSOR          12 CONSTANT RIGHTCURSOR ( CTL/R ) 04 CONSTANT DOWNCURSOR        0C CONSTANT LEFTCURSOR ( CTL/L )  1B CONSTANT EXITFLAG 0D CONSTANT NEWLINE 09 CONSTANT HORIZTAB   : .CUR CUR @ 40 /MOD 1 + SWAP 3 + SWAP GOTOXY ;                 : !CUR 0 MAX 3FF MIN CUR ! ;                                    : +CUR CUR @ + !CUR ;                                           : +.CUR +CUR .CUR ;                                             : +LIN CUR @ 40 / + 40 * !CUR ;                                 : HOM 0 CUR ! .CUR ;                                            : !BLK SCR @ 8 * CUR @ 80 /MOD ROT + BLOCK + C! UPDATE 1 +.CUR ;  : S.ERASE HOM 400 0 DO 20 DUP EMIT !BLK LOOP HOM .CUR ;       -->                                                             ( Screen Oriented Editor, continued )                           : EDIT                                                            CLEARSCREEN LIST HOM EDITOR-INS .CUR BEGIN                      KEY CASE                                                        ERASEFLAG      OF S.ERASE ENDOF                                 EXITFLAG       OF 0 11 GOTOXY CR CLREOS FF EMIT                                FF EMIT FF EMIT CR ."  OK " QUIT ENDOF           DOWNCURSOR     OF 40 +.CUR ENDOF                                7F OF -1 +.CUR ENDOF 5F OF -1 +.CUR ENDOF                       LEFTCURSOR     OF -1 +.CUR ENDOF                                NEWLINE        OF 1 +LIN .CUR ENDOF                             UPCURSOR       OF -40 +.CUR ENDOF                               RIGHTCURSOR    OF 1 +.CUR ENDOF                                 HORIZTAB       OF CUR @ 8 / 8 * 8 + !CUR .CUR ENDOF             DUP 20 < IF 7 EMIT ELSE  DUP DUP EMIT !BLK ENDIF                ENDCASE AGAIN ; DECIMAL ;S                                    ( Screen Oriented Editor, continued )                           : EDITOR-INS                                                      0 17 GOTOXY CR                                                ." Ctl/U = cursor up               DEL   = backspace " CR       ." Ctl/D = cursor down             Ctl/E = erase screen " CR    ." Ctl/R = cursor right            ESC   = exit editor " CR     ." Ctl/L = cursor left             CTL/I = horizontal tab " CR  ;                                                               CR CR                                                           ." To edit screen #n type:  n EDIT <return> " CR                                                                                                                                                                                                                                                                                                                                                DECIMAL ;S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( ENIUQ A 'Self-Rep' after Douglas R. Hofstadter 17 Aug 80 )    ( From FORTH Dimensions II/5 page 140                      )    ( Contributed by Lyall Morrill, San Francisco, CA          )    FORTH DEFINITIONS DECIMAL                                                                                                       ( Self-reproducing source code in two lines of fig-FORTH.  )    ( When loaded, types a copy of itself.  Note the 128th char. )                                                                  : ENIUQ CR 34 WORD HERE COUNT 2DUP TYPE CR TYPE 34 EMIT ; ENIUQ : ENIUQ CR 34 WORD HERE COUNT 2DUP TYPE CR TYPE 34 EMIT ; ENIUQ"                                                                                                                                ( See "Godel, Escher, Bach:  An Eternal Golden Braid", by    )  ( Douglas R. Hofstadter, Basic Books, Inc. 1979, p. 498      )  ;S                                                                                                                              ( The Theory that Jack Built, by Frederick Winsor )             ( from The Space Child's Mother Goose             )             ( Forth Dimensions II/1 page 9                    )                                                                             ( to view the poem, type 25 LOAD                  )             ( the computer's recitation occurs stanza by      )             ( stanza, with the operator indicating his        )             ( interest and approval by pushing any key after  )             ( each stanza ...                                 )             : TASK ;   -->                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( The Theory that Jack Built, continued )                       : RECITE      28 LOAD QUIT ;                                    : THE         ." the "  ;                                       : THAT        CR ." that " ;                                    : THIS        CR ." This is " THE ;                             : JACK        ." Jack built" ;                                  : SUMMARY     ." summary" ;                                     : FLAW        ." flaw" ;                                        : MUMMERY     ." mummery" ;                                     : K           ." constant K" ;                                  : HAZE        ." erudite verbal haze" ;                         : PHRASE      ." turn of a plausible phrase" ;                  : BLUFF       ." chaotic confusion and bluff" ;                 : STUFF       ." cybernetics and stuff" ;                       : THEORY      ." theory " JACK ;                                -->                                                             ( The Theory that Jack Built, continued )                       : BUTTON         ." button to start the machine" ;              : CHILD          ." space child with brow serene" ;             : CYBERNETICS    ." cybernetics and stuff" ;                    : HIDING         CR ." hiding " THE FLAW ;                      : LAY            THAT ." lay in " THE THEORY ;                  : BASED          CR ." based on " THE MUMMERY ;                 : SAVED          THAT ." saved " THE SUMMARY ;                  : CLOAK          CR ." cloaking " K ;                           : THICK IF THAT ELSE CR ." and " THEN ." thickened " THE HAZE ; : HUNG           THAT ." hung on " THE PHRASE ;                 : COVER IF THAT ." covered " ELSE CR ." to cover " THEN BLUFF ; : MAKE           CR ." to make with " THE CYBERNETICS ;         : PUSHED         CR ." who pushed " BUTTON ;                    : REST           46 EMIT 10 SPACES KEY DROP CR CR CR ;          : WITHOUT CR ." without confusion, exposing the bluff" ; RECITE ( The Theory that Jack Built, continued )                       CR CR CR THIS THEORY REST                                       THIS FLAW LAY REST                                              THIS MUMMERY HIDING LAY REST                                    THIS SUMMARY BASED HIDING LAY REST                              THIS K SAVED BASED HIDING LAY REST                              THIS HAZE CLOAK SAVED BASED HIDING LAY REST                     THIS PHRASE 1 THICK CLOAK SAVED BASED HIDING LAY REST           THIS BLUFF HUNG 1 THICK CLOAK SAVED BASED HIDING LAY REST       THIS STUFF 1 COVER HUNG 0 THICK CLOAK SAVED BASED HIDING             LAY REST                                                   THIS BUTTON MAKE 0 COVER HUNG 0 THICK CLOAK SAVED                    BASED HIDING LAY REST                                      THIS CHILD PUSHED CR ." that made with " CYBERNETICS WITHOUT    HUNG CR ." and, shredding " THE HAZE CLOAK CR ." wrecked " THE  SUMMARY BASED HIDING CR ." and demolished " THEORY REST         ( Eight Queens Problem, by Jerry Levan )                        ( Exercise in Recursion from                         )          ( FORTH DIMENSIONS II/1 page 6                       )          : 2* DUP + ; ( double a value )                                 : MYSELF ( allow a word to call itself by recursion  )            LATEST PFA CFA , ; IMMEDIATE                                  : IARRAY ( makes an array of 1's, as given by input  )            <BUILDS 0 DO 1 , LOOP                                           DOES> SWAP 2* + ; ( leave indexed address in array )          8 IARRAY A ( these form workspace for solutions      )          16 IARRAY B 16 IARRAY C 8 IARRAY X                              : SAFE                                                            SWAP OVER OVER OVER OVER - 7 + C @ >R                           + B @ >R DROP A @ R> R> * * ;                                 -->                                                                                                                             ( Eight Queens Problem, continued )                             : MARK                                                            SWAP OVER OVER OVER OVER - 7 + C 0 SWAP !                       + B 0 SWAP ! DROP A 0 SWAP ! ;                                : UNMARK                                                          SWAP OVER OVER OVER OVER - 7 + C 1 SWAP !                       + B 1 SWAP ! DROP A 1 SWAP ! ;                                0 VARIABLE TRIES                                                : PRINTSOL ." found on try " TRIES @ 6 .R 8 0                     DO I X @ 1+ 5 .R LOOP CR ;                                    : TRY 8 0 DO 1 TRIES +! ?TERMINAL IF QUIT THEN DUP I              SAFE IF DUP I MARK DUP I SWAP X ! DUP 7 <                       IF DUP 1+ ?STACK MYSELF ELSE PRINTSOL THEN                      DUP I UNMARK THEN LOOP DROP ;                                 : DO-IT 0 TRIES ! 0 CR TRY ;                                    DO-IT ;S                                                        ( Cursor control functions for TVI 912C terminal )              ( Tested and contributed by R. L. DuBose         )              FORTH DEFINITIONS DECIMAL                                       : GOTOXY 27 EMIT 61 EMIT                                          0 MAX 23 MIN 33 + EMIT 0 MAX 79 MIN 33 + EMIT ;               : CLEARSCREEN 26 EMIT ;                                         : CLREOS 27 EMIT 89 EMIT ;                                      : CLREOL 27 EMIT 84 EMIT ;                                      : HOME 30 EMIT ;                                                ;S                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( Towers of Hanoi, by Peter Midnight )                          ( from FORTH DIMENSIONS, Vol II, No. 2, page 32 )               FORTH DEFINITIONS DECIMAL : TASK ;                              46 LOAD ( get CRT cursor control functions )                    : MYSELF ( recursive use of new word )                            LATEST PFA CFA , ; IMMEDIATE                                  : 2DROP DROP DROP ;                                             : PICK SP@ SWAP 2 * + @ ;                                       : 4DUP 4 PICK 4 PICK 4 PICK 4 PICK ;                            10 CONSTANT NMAX ( maximum permissible no. of rings )           NMAX VARIABLE (N) : N (N) @ ; ( formerly a constant )           0 CONSTANT HELL.FREEZES.OVER                                    43 CONSTANT COLOR ( + )                                         0 VARIABLE RING                                                 N 2 - ALLOT ( array [1...n] of bytes )                          -->                                                             ( Towers of Hanoi, continued )                                  : DELAY ( centiseconds delay )                                    0 DO 17 0 DO 127 127 * DROP LOOP LOOP ;                       : POS ( location pos -> coordinate )                              2 N * 1+ * N + ;                                              : HALFDISPLAY ( color size --- )                                  0 DO DUP EMIT LOOP DROP ;                                     : <DISPLAY> ( line color size --- )                               2DUP HALFDISPLAY ROT 3 < IF BL ELSE 124 ( | )                   THEN EMIT HALFDISPLAY ;                                       : DISPLAY ( size pos line color --- )                             SWAP >R ROT ROT OVER - R ( color size pos-size line )           GOTOXY R> ( color size line )  ROT ROT <DISPLAY> ;            -->                                                                                                                                                                                             ( Towers of Hanoi, continued )                                  : PRESENCE ( tower ring presence -> boolean )                     RING + C@ = ;                                                 : LINE ( tower line -> display-line-of-top )                      4 SWAP N 0 DO DUP I PRESENCE 0= ROT + SWAP LOOP DROP ;                                                                        : RAISE ( size tower --- )                                        DUP POS SWAP LINE 1 SWAP DO                                     2DUP I BL DISPLAY 2DUP I 1- COLOR DISPLAY                       -1 +LOOP 2DROP ;                                              : LOWER ( size tower --- )                                        DUP POS SWAP LINE 1+ 2 DO                                       2DUP I 1- BL DISPLAY 2DUP I COLOR DISPLAY                       LOOP 2DROP ;                                                  -->                                                                                                                             ( Towers of Hanoi, continued )                                  : MOVELEFT ( size source.tower destiny.tower --- )                POS 1- SWAP POS 1- DO DUP R 1+ 1 BL DISPLAY                     DUP R 1 COLOR DISPLAY -1 +LOOP DROP ;                         : MOVERIGHT ( size source.tower destiny.tower --- )               POS 1+ SWAP POS 1+ DO DUP R 1- 1 BL DISPLAY                     DUP R 1 COLOR DISPLAY LOOP DROP ;                             : TRAVERSE ( size source.tower destiny.tower --- )                2DUP > IF MOVELEFT ELSE MOVERIGHT THEN ;                      : MOVE ( size source.tower destiny.tower --- )                    ?TERMINAL IF 0 N 4 + GOTOXY ABORT THEN                          ROT ROT 2DUP RAISE >R 2DUP R> ROT TRAVERSE                      2DUP RING + 1- C! SWAP LOWER ;                                -->                                                                                                                                                                                             ( Towers of Hanoi, continued )                                  : MULTIMOV ( size source destiny spare --- )                      4 PICK 1 = IF DROP MOVE ELSE                                    >R >R SWAP 1- SWAP R> R> 4DUP SWAP MYSELF                       4DUP DROP ROT 1+ ROT ROT MOVE                                   ROT ROT SWAP MYSELF THEN ;                                    : MAKETOWER ( tower --- )                                         POS 4 N + 3 DO DUP I GOTOXY 124 EMIT LOOP DROP ;              : MAKEBASE ( no arguments )                                       0 N 4 + GOTOXY N 6 * 3 + 0 DO 45 EMIT LOOP ;                  : MAKERING ( tower size --- )                                     2DUP RING + 1- C! SWAP LOWER ;                                : SETUP ( no arguments ) CLEARSCREEN                              N 1+ 0 DO 1 RING I + C! LOOP 3 0 DO I MAKETOWER LOOP            MAKEBASE 0 N DO 0 I MAKERING -1 +LOOP ;                       -->                                                             ( Towers of Hanoi, continued )                                  : TOWERS ( quantity --- )                                         1 MAX NMAX MIN (N) !                                            SETUP N 2 0 1 BEGIN                                             OVER POS N 4 + GOTOXY N 0 DO 7 EMIT 25 DELAY LOOP               ROT 4DUP MULTIMOV HELL.FREEZES.OVER UNTIL ;                   ;S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( Breakforth adapted from Arnold Schaeffer, BYTE Aug 1980 )     : TASK ; 45 LOAD 46 LOAD 47 LOAD 8 LOAD                         400 ARRAY BLOCKMAP                                              0 VARIABLE SPEED 0 VARIABLE SPVAR 0 VARIABLE SCORE              0 VARIABLE XPOS  0 VARIABLE YPOS  0 VARIABLE PPOS               1 VARIABLE YDIR  1 VARIABLE XDIR  0 VARIABLE BEST               : LINE 0 SWAP GOTOXY CLREOL ;                                   : BALLSET GOTOXY 42 EMIT ;                                      : BALLCLR GOTOXY 32 EMIT ;                                      : PDLSET PPOS @ 22 GOTOXY 61 DUP DUP EMIT EMIT EMIT ;           : PDLCLR PPOS @ 22 GOTOXY 32 DUP DUP EMIT EMIT EMIT ;            -->                                                                                                                                                                                                                                                                                                                            ( Breakforth, continued )                                       : MOVEPADDLE KEY 44 = PDLCLR                                      IF -1 PPOS @ + 20 MAX PPOS !                                    ELSE 1 PPOS @ + 57 MIN PPOS ! ENDIF PDLSET ;                  : PADDLE 0 P@ 64 AND IF MOVEPADDLE HOME ENDIF ;                 : BEEP 7 EMIT ; : BOP 100 0 DO BEEP LOOP ;                      : BLOCKMAPINDEX 40 * SWAP 2 / + ;                               : BLKTST YPOS @ 8 < IF XPOS @ YPOS @ BLOCKMAPINDEX                BLOCKMAP @ ELSE 0 ENDIF ;                                     : BLKCLR 2DUP SWAP 126 AND SWAP GOTOXY 32 EMIT 32 EMIT            BLOCKMAPINDEX BLOCKMAP 0 SWAP ! ;                             : BLKSET 2DUP GOTOXY 91 EMIT 93 EMIT BLOCKMAPINDEX                BLOCKMAP 1 SWAP ! ;                                           : WALLSET 59 20 DO I 1 AND 0= IF I 2 BLKSET I 3 BLKSET            I 4 BLKSET I 5 BLKSET I 6 BLKSET ENDIF LOOP ;                 -->                                                             ( Breakforth, continued )                                       DECIMAL   : INIT                                                CLEARSCREEN 0 LINE ." Speed (1-10, 1 is fastest) : "            #IN 1 MAX 10 MIN 10 U* DROP SPEED !                             0 LINE ." Number of balls desired: " #IN                        CLEARSCREEN 61 18 DO I 1 GOTOXY 95 EMIT LOOP                                22 1 DO  18 I GOTOXY 124 EMIT                                            19 I GOTOXY 124 EMIT                                            60 I GOTOXY 124 EMIT                                            61 I GOTOXY 124 EMIT LOOP                  WALLSET 0 SCORE ! 0 LINE                                        20 0 GOTOXY ." Score: 0 " 35 0 GOTOXY ." Best: " BEST @ .       50 0 GOTOXY ." Ball: " ;                                        -->                                                                                                                                                                                             ( Breakforth, continued )                                       : XCHK                                                          XPOS @ 20 < IF XDIR @ MINUS XDIR ! 20 XPOS ! BOP ENDIF          XPOS @ 59 > IF XDIR @ MINUS XDIR ! 59 XPOS ! BOP ENDIF ;        : YCHK                                                          YPOS @ 7 < IF SPVAR @ 8 MIN SPVAR ! ENDIF                       YPOS @ 6 < IF SPVAR @ 7 MIN SPVAR ! ENDIF                       YPOS @ 5 < IF SPVAR @ 6 MIN SPVAR ! ENDIF                       YPOS @ 4 < IF SPVAR @ 5 MIN SPVAR ! ENDIF                       YPOS @ 3 < IF SPVAR @ 4 MIN SPVAR ! ENDIF                       YPOS @ 2 < IF 1 YDIR ! 2 YPOS ! 1 SPVAR ! BOP ENDIF             ;                                                               -->                                                                                                                                                                                                                                                             ( Breakforth, continued )                                       10 ARRAY PDLVEC                                                 -2 0 PDLVEC !     -1 1 PDLVEC !                                 0 2 PDLVEC !      1 3 PDLVEC !   2 4 PDLVEC !                   : PCHK                                                            0 YPOS @ 21 >                                                   IF 21 YPOS ! XPOS @ PPOS @ - 1+ DUP 0< 0= OVER 5 < AND          IF -1 YDIR ! BOP PDLVEC @ DUP 0= IF DROP ELSE XDIR ! ENDIF      ELSE DROP 1+ ENDIF                                              ENDIF ;                                                       -->                                                                                                                                                                                                                                                                                                                                                                                             ( Breakforth, continued )                                       : CLR                                                             XPOS @ YPOS @ BLKCLR                                            YPOS @ 27 - ABS SCORE +! 27 0 GOTOXY SCORE @ . BOP              YDIR @ MINUS YDIR ! ;                                         : BALLCHK YDIR @ YPOS +! XDIR @ XPOS +! XCHK YCHK PCHK            BLKTST IF CLR ENDIF ;                                         : BALL XPOS @ YPOS @ BALLCLR                                      BALLCHK DUP 0= IF XPOS @ YPOS @ BALLSET HOME ENDIF ;          : GAMECHK SCORE @ 0= 0= IF SCORE @ 1800 MOD 0=                    IF WALLSET ENDIF ENDIF ;                                      -->                                                                                                                                                                                                                                                                                                                             ( Breakforth, continued )                                       : DELAY SPEED @ SPVAR @ U* DROP 0 DO LOOP ;                     : BREAKFORTH                                                      BEGIN 40 PPOS ! INIT PDLSET                                     0 DO 2000 SPEED @ / 0 DO DELAY PADDLE LOOP                      56 0 GOTOXY I 1+ . 10 SPVAR !                                   2 RANDOM 1 = IF 1 ELSE -1 ENDIF XDIR ! 1 YDIR !                 35 RANDOM 22 + XPOS ! 8 YPOS !                                  BEGIN 10 0 DO PADDLE DELAY LOOP                                 BALL GAMECHK UNTIL                                              LOOP SCORE @ BEST @ MAX BEST !                                  18 8 GOTOXY ." Run game again? " KEY                            89 = 0= UNTIL ;                                                                                                                                                                               ;S                                                              ( Random number generator, J. E. Rickenbacker )                 ( FORTH DIMENSIONS II/2 PAGE 34               )                                                                                 FORTH DEFINITIONS DECIMAL                                                                                                       0 VARIABLE SEED                                                                                                                 : (RAND) SEED @ 259 * 3 + 32767 AND DUP SEED ! ;                                                                                : RANDOM (RAND) 32767 */ ;                                                                                                                                                                                                                                                                                                                                                                                                                                      ( CRT Cursor control functions for demo programs )              FORTH DEFINITIONS DECIMAL                                       : GOTOXY HEX 27 EMIT 125 EMIT 25 + 25 MAX 48 MIN BASE @ /MOD     64 + EMIT 64 + EMIT 0 MAX 79 MIN 1+ BASE @ /MOD 64 + EMIT 64 +     EMIT   DECIMAL  ;                                           : NEXTPAGE 27 EMIT 85 EMIT ;                                    : CLEARSCREEN 27 EMIT 74 EMIT NEXTPAGE ;                        : CLREOS 27 EMIT 74 EMIT ;  ( CLREOS, CLREOL, and HOME are )    : CLREOL 27 EMIT 75 EMIT ;  ( not necessary for operation )     : HOME 27 EMIT 72 EMIT ;    ( of demonstration programs )       ;S                                                              ( the CLEARSCREEN function must clear the CRT screen and )      ( leave the cursor in the upper left corner.  On some models )  ( this requires two separate escape sequences )                 ( the GOTOXY function is used as follows:  x y GOTOXY )         ( stack effect:  2 -> 0 )                                       ( Console integer input )                                                                                                       0 VARIABLE <#IN>                                                                                                                : #IN   0 <#IN> ! 0 BEGIN KEY DUP 13 =                                  IF <#IN> @                                                              IF DROP 1                                                       ELSE DROP 7 EMIT 0                                              ENDIF                                                   ELSE DUP 10 DIGIT                                                       IF SWAP EMIT SWAP 10 * + 1 <#IN> +! 0                           ELSE 7 EMIT DROP 0                                              ENDIF                                                   ENDIF                                                           UNTIL   ;                                               ;S                                                              ( Cursor control functions for ADDS Regent 25 CRT )             FORTH DEFINITIONS DECIMAL                                       : GOTOXY 27 EMIT 89 EMIT                                          0 MAX 23 MIN 32 + EMIT 0 MAX 79 MIN 32 + EMIT ;               : CLEARSCREEN 12 EMIT 255 DUP DUP EMIT EMIT EMIT ;              : CLREOS ;                                                      : CLREOL 27 EMIT 75 EMIT ;                                      : HOME 1 EMIT ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( Cursor control functions for Beehive B-100 CRT )              FORTH DEFINITIONS DECIMAL                                       : GOTOXY 27 EMIT 70 EMIT                                          0 MAX 23 MIN 33 + EMIT 0 MAX 79 MIN 33 + EMIT ;               : CLEARSCREEN 27 EMIT 69 EMIT 255 DUP DUP EMIT EMIT EMIT ;      : CLREOS 27 EMIT 74 EMIT ;                                      : CLREOL 27 EMIT 75 EMIT ;                                      : HOME 27 EMIT 72 EMIT ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ( Trig lookup routines with Sine * 10000 table )                : TABLE ( ... N -> , CREATE 'TABLE' DATA TYPE  )                  <BUILDS 0 DO , LOOP   ( COMPILE N ELEMENTS )                    DOES> SWAP 2 * + @    ( EXECUTE TABLE LOOKUP )                ;                                                               10000 9998 9994 9986 9976 9962 9945 9925 9903 9877               9848 9816 9781 9744 9703 9659 9613 9563 9511 9455               9397 9336 9272 9205 9135 9063 8988 8910 8829 8746               8660 8572 8480 8387 8290 8192 8090 7986 7880 7771               7660 7547 7431 7314 7193 7071 6947 6820 6691 6561               6428 6293 6157 6018 5878 5736 5592 5446 5299 5150               5000 4848 4695 4540 4384 4226 4067 3907 3746 3584               3420 3256 3090 2924 2756 2588 2419 2250 2079 1908               1736 1564 1391 1219 1045 0872 0698 0523 0349 0175               0000 ( 91 ELEMENTS OF TABLE PLACED ON STACK )                   91 TABLE SINTABLE -->                                          ( Trig table lookup routines, continued )                       : S180 ( N -> N  RETURNS SINE 0-180 DEGREES )                     DUP 90 >   ( IF GREATER THAN 90 DEGREES )                       IF 180 SWAP - ENDIF ( SUBTRACT FROM 180 )                       SINTABLE ( THEN TAKE SINE )                                   ;                                                               : SIN  ( N -> SINE  RETURN SINE OF ANY NO. OF DEGREES )           360 MOD   ( BRING WITHIN + OR - 360 )                           DUP 0< IF 360 + ENDIF ( IF NEGATIVE, ADD 360 )                  DUP 180 >  ( TEST IF GREATER THAN 180 )                         IF 180 - S180 MINUS ( IF SO, SUBTRACT 180, NEGATE SINE )        ELSE S180 ENDIF ( OTHERWISE, STRAIGHTFORWARD )                ;                                                               : COS  ( N -> COSINE )                                            360 MOD ( PREVENT OVERFLOW NEAR 32767 )                         90 + SIN ; ( COS IS SIN WITH 90 DEG PHASE SHIFT )             ( Case statement, by Charles E. Eaker )                         ( from FORTH DIMENSIONS II/3 page 37  )                         : CASE ?COMP CSP @ !CSP 4 ; IMMEDIATE                           : OF 4 ?PAIRS COMPILE OVER COMPILE = COMPILE 0BRANCH              HERE 0 , COMPILE DROP 5 ; IMMEDIATE                           : ENDOF 5 ?PAIRS COMPILE BRANCH HERE 0 ,                          SWAP 2 [COMPILE] ENDIF 4 ; IMMEDIATE                          : ENDCASE 4 ?PAIRS COMPILE DROP BEGIN SP@                         CSP @ = 0= WHILE 2 [COMPILE] ENDIF                              REPEAT CSP ! ; IMMEDIATE                                                                                                                                                                                                                                                                                                                                                                                                                                      ( Example string definition and console input )                 0 VARIABLE $.POINTER 0 VARIABLE $.COUNTER DECIMAL               : STRING  ( length STRING string-name -> )                        <BUILDS DUP , ALLOT                                             DOES>  2DUP @ U< IF + 2+                                               ELSE ." range error " OVER . @ . 2+ ENDIF ;            : $IN  ( offset string-name $IN -> # of characters input )        2 - $.POINTER ! 0 $.COUNTER !                                   $.POINTER @ DUP DUP @ + 2+ SWAP 2+ DO 0 I C! LOOP               80 0 DO KEY DUP DUP EMIT 13 = IF LEAVE                          ELSE $.POINTER @ $.COUNTER @ + 2+ C!                            1 $.COUNTER +!                                                  $.POINTER @ @ $.COUNTER @ =                                     IF ." string overflow " LEAVE ENDIF                             ENDIF LOOP $.COUNTER @ ;                                                                                                      ( Case statement by Karl Bochert and Dave Lion    )             ( FORTH Dimensions II/3 page 50                   )             : (CASE) ABS R> @ DUP 2+ >R SWAP 1+ DUP +                         OVER SWAP - SWAP @ MAX @ >R ;                                 : CASE COMPILE (CASE) HERE 0 , 0 ; IMMEDIATE                    : ENDCASE COMPILE ;S HERE ; IMMEDIATE                           : ENDCASES COMPILE ;S , HERE >R DUP IF BEGIN ,                    DUP 0= END THEN DROP DUP 2+ , HERE SWAP !                       R> 2 - , ; IMMEDIATE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ( Demo of Bochert/Lion Case statement )                         ( to try it, type: 54 LOAD 55 LOAD    )                         : TEST-WORD CR                                                    5 -4 DO ( TRY A RANGE OF PARAMETERS, SOME ILLEGAL )             I DUP . ( PRINT CASE # BEING TRIED )                            CASE                                                               ." This is the case # 0 code "        ENDCASE                   (  ---- case #1 does nothing ---- )   ENDCASE                   ." This is the case #2 code "         ENDCASE                   ." Default case "                                            ENDCASES                                                        CR LOOP ;                                                                                                                     TEST-WORD ;S                                                                                                                                                                                    ( Cursor control functions for Lear ADM3 CRT )                  : GOTOXY 27 EMIT 61 EMIT                                          0 MAX 23 MIN 33 + EMIT 0 MAX 79 MIN 33 + EMIT ;               : CLEARSCREEN 12 EMIT ;                                         : CLREOS ;                                                      : CLREOL ;                                                      : HOME ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ( Cursor control functions for Soroc IQ 120 CRT )               FORTH DEFINITIONS DECIMAL                                       : GOTOXY 27 EMIT 61 EMIT                                          0 MAX 23 MIN 33 + EMIT 0 MAX 79 MIN 33 + EMIT ;               : CLEARSCREEN 27 EMIT 42 EMIT 255 DUP DUP EMIT EMIT EMIT ;      : CLREOS 27 EMIT 89 EMIT ;                                      : CLREOL 27 EMIT 84 EMIT ;                                      : HOME 30 EMIT ;                                                ;S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( The Game of Life, adapted from Dave Boulton )                 ( FORTH Dimensions III/5 page 24 ) : TASK ;                     DECIMAL 39 CONSTANT XLEN 22 CONSTANT YLEN 46 LOAD 8 LOAD        XLEN YLEN 2ARRAY UNIVERSE                                       0 VARIABLE #GENERATION                                                                                                          : CHECK DUP 3 = IF DROP 2+ ELSE 2 = 0=                            IF 4 + ENDIF ENDIF ;                                          : CLEAR  YLEN 0 DO XLEN 0 DO I J UNIVERSE                         0 SWAP C! LOOP LOOP ;                                         : DISPLAY CLEARSCREEN ." Generation " #GENERATION @ .             YLEN 0 DO XLEN 0 DO                                             I J UNIVERSE C@   IF I 2 * J GOTOXY 42 EMIT ENDIF               LOOP LOOP HOME ;                                              -->                                                                                                                             ( The Game of Life, continued )                                 : X-      1-  DUP 0 < IF DROP XLEN 1-  ENDIF ;                  : X+      1+  DUP XLEN = IF DROP 0 ENDIF ;                      : Y-      1-  DUP 0 < IF DROP YLEN 1-  ENDIF ;                  : Y+      1+  DUP YLEN = IF DROP 0 ENDIF ;                      : CELL C@ 1 AND + ;                                             : GENERATE                                                        YLEN 0 DO XLEN 0 DO  0                                          I X- J UNIVERSE CELL I X+ J  UNIVERSE CELL                      I X- J Y+ UNIVERSE CELL I J Y+ UNIVERSE CELL                    I X+ J Y+ UNIVERSE CELL  I X- J Y- UNIVERSE CELL                I J Y- UNIVERSE CELL  I X+ J Y- UNIVERSE CELL                   I J UNIVERSE C@   1 AND SWAP CHECK   I J UNIVERSE C!            LOOP LOOP ;                                                   -->                                                                                                                             ( The Game of Life, continued )                                 0 VARIABLE CUR 0 VARIABLE SETUPFLAG 52 LOAD                     : .CUR CUR @ XLEN /MOD SWAP DUP + SWAP GOTOXY ;    : !CUR 0     MAX YLEN XLEN * 1 - MIN CUR ! ;   : +CUR CUR @ + !CUR ;         : +.CUR +CUR .CUR ; : +LIN CUR @ XLEN / + XLEN * !CUR ;         HEX 1B CONSTANT EXITFLAG 0A CONSTANT DOWNCURSOR                 0D CONSTANT NEWLINE 7F CONSTANT BACKCURSOR DECIMAL              : SETUPLIFE CLEARSCREEN ." Enter starting pattern     "         ."            push <ESC> when finished " CR                     0 SETUPFLAG ! 0 CUR ! .CUR BEGIN KEY CASE EXITFLAG OF 1         SETUPFLAG ! ENDOF DOWNCURSOR OF XLEN +.CUR ENDOF                BACKCURSOR OF -1 +.CUR ENDOF NEWLINE OF 1 +LIN .CUR ENDOF       32 OF 32 EMIT 0 CUR @ XLEN /MOD UNIVERSE C! 1 +.CUR ENDOF       42 OF 42 EMIT 1 CUR @ XLEN /MOD UNIVERSE C! 1 +.CUR ENDOF       ENDCASE SETUPFLAG @ UNTIL ;                                     -->                                                             ( The Game of Life, continued )                                 : NORMALIZE YLEN 0 DO XLEN 0 DO                                   I J UNIVERSE DUP C@ DUP                                         4 AND IF DROP 0 ELSE 3 AND IF 1 ELSE 0 ENDIF ENDIF              SWAP C!                                                         LOOP LOOP ;                                                                                                                   : GENERATIONS 1 #GENERATION ! CLEAR SETUPLIFE                     0 DO DISPLAY GENERATE                                           NORMALIZE 1 #GENERATION +! LOOP                                 DISPLAY ;                                                                                                                     ;S                                                                                                                                                                                                                                                              ( Simple timing functions )                                     : DELAY 0 DO 17 0 DO 127 127 * DROP LOOP LOOP ;                 : BEEPS 0 DO 7 EMIT 25 DELAY LOOP ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( FORTH debugging aids --- display stack )                      : .STACK   ( display stack )                                      SP@ S0 @ = IF CR ." <empty stack> " ELSE                        SP@ S0 @ SWAP DO CR I @ DUP DECIMAL 4 .R                        HEX ."    (" 0 4 D.R ." H)"                                     2 +LOOP CR ENDIF DECIMAL ;                                                                                                    : CRT.STACK  ( display stack )                                    SP@ S0 @ = IF ." <empty stack> " ELSE                           SP@ S0 @ SWAP DO I @ DUP                                        DECIMAL 4 .R HEX ."   (" 0 4 D.R ." H)"                         13 0 DO 8 EMIT LOOP 10 EMIT                                     2 +LOOP ENDIF DECIMAL ;                                                                                                                                                                                                                                       ( FORTH Decompiler, by Ray Duncan )                             CR ." Wait...  loading De-Compiler " CR                         DECIMAL    : TASK ;                                             ( CASE statement by Charles E. Eaker        )                   ( from FORTH DIMENSIONS II/3 page 37        )                   : CASE ?COMP CSP @ !CSP 4 ; IMMEDIATE                           : OF 4 ?PAIRS COMPILE OVER COMPILE = COMPILE 0BRANCH              HERE 0 , COMPILE DROP 5 ; IMMEDIATE                           : ENDOF 5 ?PAIRS COMPILE BRANCH HERE 0 ,                          SWAP 2 [COMPILE] ENDIF 4 ; IMMEDIATE                          : ENDCASE 4 ?PAIRS COMPILE DROP BEGIN SP@                         CSP @ = 0= WHILE 2 [COMPILE] ENDIF                              REPEAT CSP ! ; IMMEDIATE                                      DECIMAL -->                                                                                                                                                                                     ( FORTH Decompiler, continued )                                 ( find addresses of all special runtime routines )              ' (LOOP)        2 - CONSTANT    LOOP.ADR                        ' LIT           2 - CONSTANT    LIT.ADR                         ' :             2 - @ CONSTANT  DOCOL.ADR                       ' 0BRANCH       2 - CONSTANT    0BRANCH.ADR                     ' BRANCH        2 - CONSTANT    BRANCH.ADR                      ' (+LOOP)       2 - CONSTANT    PLOOP.ADR                       ' (.")          2 - CONSTANT    PDOTQ.ADR                       ' C/L           2 - @ CONSTANT  CONST.ADR                       ' BASE          2 - @ CONSTANT  USERV.ADR                       ' USE           2 - @ CONSTANT  VAR.ADR                         ' (;CODE)       2 - CONSTANT    PSCODE.ADR                      0 VARIABLE QUIT.FLAG    0 VARIABLE WORD.PTR                     : N. DUP DECIMAL . SPACE HEX 0 ." ( " D. ." H )"                  DECIMAL ;                                        -->          ( FORTH Decompiler, continued )                                 : PDOTQ.DSP ( display a text string )                             WORD.PTR @ 2+ DUP >R DUP C@ + 1 - WORD.PTR !                    R> COUNT TYPE ;                                               : WORD.DSP ( given CFA, display glossary name )                   3 - -1 TRAVERSE DUP 1+ C@ 59 = IF 1 QUIT.FLAG ! ENDIF           DUP C@ 160 AND 128 = IF ID. ELSE 1 QUIT.FLAG ! DROP ENDIF ;   : BRANCH.DSP ( get branch offset and decode it ) ." to "          WORD.PTR @ 2+ DUP WORD.PTR !     @   0 HEX D. DECIMAL ;       : USERV.DSP ( display a user variable )                           ." User variable, current value = "                             WORD.PTR @ 2+ C@ 38 +ORIGIN @ + @ N. 1 QUIT.FLAG ! ;          : VAR.DSP ( display a variable ) ." Variable, current value = "   WORD.PTR @ 2+ @ N. 1 QUIT.FLAG ! ;                            : CONST.DSP ( display constant) ." Constant, value = "            WORD.PTR @ 2+ @ N. 1 QUIT.FLAG ! ;                -->         ( FORTH Decompiler, continued )                                 : DIS                                                             -FIND 0=                                                        IF 3 SPACES ." ? not in glossary " CR                           ELSE DROP DUP DUP 2 - @ =                                       IF 3 SPACES ." <primitive>" CR                                  ELSE 0 QUIT.FLAG ! 2 - WORD.PTR ! CR CR                         BEGIN                                                           WORD.PTR @ DUP 0 HEX D. SPACE DECIMAL                           @ CASE                                                          LIT.ADR OF WORD.PTR @ 2+ DUP WORD.PTR ! @ N. ENDOF              DOCOL.ADR OF ." : " ENDOF                                       0BRANCH.ADR OF ." Branch if zero " BRANCH.DSP ENDOF             BRANCH.ADR OF ." Branch " BRANCH.DSP ENDOF                      LOOP.ADR OF ." Loop " BRANCH.DSP ENDOF                        -->                                                             ( FORTH Decompiler, continued )                                   PLOOP.ADR OF ." +Loop " BRANCH.DSP ENDOF                        PDOTQ.ADR OF ." Print text: " PDOTQ.DSP ENDOF                   USERV.ADR OF USERV.DSP ENDOF                                    VAR.ADR OF VAR.DSP ENDOF                                        CONST.ADR OF CONST.DSP ENDOF                                    PSCODE.ADR OF WORD.PTR @ @ WORD.DSP 1 QUIT.FLAG ! ENDOF         DUP WORD.DSP                                                    ENDCASE CR                                                      2 WORD.PTR +!                                                   QUIT.FLAG @ ?TERMINAL OR UNTIL                                  ENDIF ENDIF CR ;                                              CR ." Compilation completed. " SP@ DP @ - . ." bytes left." CR  ." To decompile word xxx type: DIS xxx <return> " CR            ;S                                                                                                                              ( Cursor control functions for Intertube CRT )                  ( contributed by John Williams, Ashland, Oregon )               FORTH DEFINITIONS DECIMAL                                                                                                       : GOTOXY 27 EMIT 89 EMIT                                          0 MAX 24 MIN 32 + EMIT 0 MAX 79 MIN 32 + EMIT ;               : CLEARSCREEN                                                     12 EMIT 255 DUP DUP EMIT EMIT EMIT ;                          : CLREOS ;  ( not available on Intertube )                      : CLREOL ;  ( ditto )                                           : HOME   1 EMIT ;                                               ;S                                                                                                                                                                                                                                                                                                                              ( FORTH-79 Vocabulary )                                         ( by compiling screens 70-73, the user may extend the Z-80 )    ( FORTH glossary to include all of the Required Word Set   )    ( as defined in the FORTH-79 standard, October 1980.       )    FORTH DEFINITIONS HEX                                                                                                                                                                                                                                           ( stack manipulation )                                          : PICK        SP@ SWAP 2 * + @ ;                                : ROLL        DUP >R PICK R> 0 SWAP DO                                        SP@ I 2 * + DUP 2 - @ SWAP ! -1 +LOOP DROP ;      : ?DUP        -DUP ;                                            : R@          R ;                                               : DEPTH       S0 @ SP@ - 2 - 2 / ; ( no. of items on stack )    -->                                                             ( FORTH-79, continued )                                         ( comparison operators )                                        : 0>   DUP IF 0< 0= ENDIF ;                                     : D<   DMINUS D+ SWAP DROP 0< ;                                 : NOT  0= ;                                                                                                                                                                                     ( arithmetic and logical )                                      ( 1- and 2- were added to version 1.14 )                                                                                        : U/MOD          U/ ;                                           : NEGATE         MINUS ;                                        : DNEGATE        DMINUS ;                                       -->                                                                                                                                                                                             ( FORTH-79, continued )                                         : MOVE    DUP + CMOVE ;                                                                                                         ( control structures )                                          ( J was added to version 1.14 )                                 : EXIT    R> DROP ;                                                                                                             ( numeric conversion )                                          : CONVERT (NUMBER) ;                                            ( FORTH-79 WORD leaves HERE on the stack )                      : WORD  WORD HERE ;                                             ( FORTH-79 variables are not initialized when created )         : VARIABLE      <BUILDS 0 ,                                                     DOES> ;                                                                                                         -->                                                             ( FORTH-79, continued )                                         ( mass storage input and output )                               : SAVE-BUFFERS   FLUSH ;                                                                                                        ( vocabularies )                                                : FIND   -FIND DUP IF DROP DROP ENDIF ;                                                                                         ( miscellaneous )                                               : >IN    IN ;                                                                                                                   ( defining words )                                              : CREATE <BUILDS ;                                                                                                                                                                                                                                              DECIMAL ;S                                                     ( String Stack Extension, by John Cassady )                     HEX FORTH DEFINITIONS                                           200 CONSTANT *$* ( number of bytes reserved for $STK )          *$* ALLOT        ( allocate the string stack )                  HERE CONSTANT $0 ( fixed base of $STK )                         $0 VARIABLE $P   ( $P returns address of var with $STK ptr )    : $P!  $0 $P ! ; ( $P! empties $STK by resetting $P to $0 )     : $P@  $P @ ;    ( Returns value of $P )                        : $DROP $P@ DUP @ + 2+ $P ! ;   ( drop top string )             : $@ DUP >R $P@ SWAP - SWAP OVER R CMOVE 2 - R> OVER ! $P ! ;     ( TA-2 QTY-1 --- fetch string to $STK )                       : $! DUP 2+ SWAP @ ROT SWAP CMOVE $DROP ;                       : $. $P@ DUP 2+ SWAP @ TYPE $DROP ; ( output string )           : $DUP $P@ DUP 2+ SWAP @ $@ ;       ( duplicate string )        -->                                                                                                                             ( String stack extension, continued )                           : (")  R DUP 2+ SWAP @ ( moves in-line string to $STK )           DUP 2+ R> + >R $@ ;                                           : "    ( if compiling emplace an in-line string to be )                ( moved to string stack at execution time, else )               ( put enclosed string on string stack. )                   22 STATE @                                                      IF COMPILE (") 0 C, WORD HERE C@ -1 ALLOT DUP , ALLOT           ELSE 0 C, WORD HERE C@ -1 ALLOT HERE !                               HERE DUP 2+ SWAP @ $@                                      ENDIF ; IMMEDIATE                                             -->                                                                                                                                                                                                                                                                                                                             ( String stack extension, continued )                           0E +ORIGIN @ CONSTANT BS  ( define backspace commands )         5F CONSTANT PBS                                                 : $INPUT PAD DUP   ( reads keyboard to CR into $STK )             BEGIN KEY DUP BS =                                              IF >R 2DUP = R> SWAP                                              IF DROP 0                                                       ELSE DROP 08 EMIT 1 - 0 ENDIF                                 ELSE DUP 0D =                                                     IF DROP 20 EMIT 1                                               ELSE DUP EMIT OVER C! 1+ 0 ENDIF                              ENDIF                                                           UNTIL OVER - $@ ;                                             -->                                                                                                                                                                                             ( String stack extension, continued )                           : $VARIABLE ( max-length  ---  e.g. 7 $VARIABLE TDATE )           <BUILDS DUP , DUP HERE SWAP BLANKS ALLOT DOES> ;              : $VARFILL  ( $A-2 BYTE-1 ---   fill $VAR with byte )             OVER @ ROT 2+ SWAP ROT FILL ;                                 : $VAR@     ( $A-1 --- fetches variable to string stack )         DUP 2+ SWAP @ $@ ;                                            : $VAR!     ( $A-1 ---  pops stack back to variable )             DUP BL $VARFILL   ( pads with blanks )                          DUP 2+ SWAP @ $P@ @ MIN  ( truncate if necessary )              $P@ 2+ ROT ROT CMOVE $DROP ;                                  DECIMAL ;S                                                                                                                                                                                                                                                                                                                      ( Z-80 Assembler --- Ray Duncan, Laboratory Microsystems )      52 LOAD   VOCABULARY ASSEMBLER IMMEDIATE HEX                    ASSEMBLER DEFINITIONS                                           0 VARIABLE C.CODE         0 VARIABLE C.FLAG                     0 VARIABLE R.SOURCE       0 VARIABLE R.DEST                     0 VARIABLE F.SOURCE       0 VARIABLE F.DEST                     : SLL   DUP + ;       : SLL2 SLL SLL ;    : SLL3 SLL2 SLL ;     : SLL4  SLL2 SLL2 ;   : SLL5 SLL4 SLL ;   : SLL6 SLL4 SLL2 ;    : SLL7  SLL4 SLL3 ;   : BYTE C, ;         : WORD , ;            : CODE       CREATE SMUDGE SP@ ;                                : NEXT       C3 C, NEXT-LINK , SP@ 2+ = 0=                                   IF ." code error, stack depth changed " ENDIF ;    : !DEST      R.DEST ! F.DEST ! ;                                : !SOURCE    R.SOURCE ! F.SOURCE ! ;                            : ?DEST      R.DEST @ F.DEST @ 0 F.DEST ! ;                     : ?SOURCE    R.SOURCE @ F.SOURCE @ 0 F.SOURCE ! ; -->           ( Z-80 Assembler --- register definitions )                     : B    1 0 !SOURCE ;         : B,    1 0 !DEST ;                : C    1 1 !SOURCE ;         : C,    1 1 SLL3 !DEST ;           : D    1 2 !SOURCE ;         : D,    1 2 SLL3 !DEST ;           : E    1 3 !SOURCE ;         : E,    1 3 SLL3 !DEST ;           : H    1 4 !SOURCE ;         : H,    1 4 SLL3 !DEST ;           : L    1 5 !SOURCE ;         : L,    1 5 SLL3 !DEST ;           : (HL) 1 6 !SOURCE ;         : (HL), 1 6 SLL3 !DEST ;           : A    1 7 !SOURCE ;         : A,    1 7 SLL3 !DEST ;                                                                           : BC   2 0 SLL4 !SOURCE ;    : BC,   2 0 !DEST ;                : DE   2 1 SLL4 !SOURCE ;    : DE,   2 1 !DEST ;                : HL   2 2 SLL4 !SOURCE ;    : HL,   2 2 !DEST ;                : SP   2 3 SLL4 !SOURCE ;    : SP,   2 3 !DEST ;                : AF   2 3 SLL4 !SOURCE ;    ( for PUSH and POP )               -->                                                             ( Z-80 Assembler --- register definitions )                                                                                     : IX      3 1 !SOURCE ;         : IX,     3 1 !DEST ;           : IY      3 3 !SOURCE ;         : IY,     3 3 !DEST ;           : (IX)    4 1 !SOURCE ;         : (IX),   4 1 !DEST ;           : (IY)    4 3 !SOURCE ;         : (IY),   4 3 !DEST ;           -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( Z-80 Assembler --- condition code definitions )                                                                               ( store condition code and set condition flag )                 : !COND     C.CODE ! 1 C.FLAG ! ;                               ( read condition code and clear condition flag )                : ?COND     C.CODE @ C.FLAG @ 0 C.FLAG ! ;                      ( define condition codes )                                      : NZ,     0 !COND ;                   : NZ    NZ, ;             : Z,      1 !COND ;                   : Z     Z,  ;             : NCY,    2 !COND ;                   : NCY   NCY, ;            : CY,     3 !COND ;                   : CY    CY, ;             : PO,     4 !COND ;                   : PO    PO, ;             : PE,     5 !COND ;                   : PE    PE, ;             : P,      6 !COND ;                   : P     P,  ;             : M,      7 !COND ;                   : M     M,  ;             -->                                                             ( Z-80 Assembler --- miscellaneous operations )                 : EXX    D9 BYTE ;                                              : LDI    ED BYTE A0 BYTE ;                                      : LDIR   ED BYTE B0 BYTE ;                                      : LDD    ED BYTE A8 BYTE ;                                      : LDDR   ED BYTE B8 BYTE ;                                      : CPI    ED BYTE A1 BYTE ;                                      : CPIR   ED BYTE B1 BYTE ;                                      : CPD    ED BYTE A9 BYTE ;                                      : CPDR   ED BYTE B9 BYTE ;                                      : DAA    27 BYTE ;                                              : CPL    2F BYTE ;                                              : NEG    ED BYTE 44 BYTE ;                                      : CCF    3F BYTE ;                                              : SCF    37 BYTE ;                                              -->                                                             ( Z-80 Assembler --- miscellaneous operations )                 : NOP     00 BYTE ;                                             : HALT    76 BYTE ;                                             : DI      F3 BYTE ;                                             : EI      FB BYTE ;                                             : RLCA    07 BYTE ;                                             : RLA     17 BYTE ;                                             : RRCA    0F BYTE ;                                             : RRA     1F BYTE ;                                             : RLD     ED BYTE 6F BYTE ;                                     : RRD     ED BYTE 67 BYTE ;                                     : INI     ED BYTE A2 BYTE ;                                     : INIR    ED BYTE B2 BYTE ;                                     : IND     ED BYTE AA BYTE ;                                     : INDR    ED BYTE BA BYTE ;                                     -->                                                             ( Z-80 Assembler --- miscellaneous operations )                                                                                 : OUTI      ED BYTE A3 BYTE ;                                   : OTIR      ED BYTE B3 BYTE ;                                   : OUTD      ED BYTE AB BYTE ;                                   : OTDR      ED BYTE BB BYTE ;                                   -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( Z-80 Assembler --- POP and PUSH )                             : POP    ?SOURCE CASE                                             0 OF 26 ERROR ENDOF     ( missing destination register )        1 OF 22 ERROR ENDOF     ( 8 bit register not allowed )          2 OF C1 + BYTE ENDOF    ( BC, DE, HL, or AF )                   3 OF 1 = IF DD BYTE     ( IX )                                           ELSE FD BYTE   ( IY ) ENDIF E1 BYTE ENDOF              28 ERROR ENDCASE ;                                            : PUSH    ?SOURCE CASE                                            0 OF 26 ERROR ENDOF     ( missing destination register )        1 OF 22 ERROR ENDOF     ( 8 bit register not allowed )          2 OF C5 + BYTE ENDOF    ( BC, DE, HL, or AF )                   3 OF 1 = IF DD BYTE     ( IX )                                           ELSE FD BYTE   ( IY ) ENDIF E5 BYTE ENDOF              28 ERROR ENDCASE ;                                            -->                                                             ( Z-80 Assembler --- 8 bit arithmetic operations )                                                                              0 VARIABLE *A,IX   0 VARIABLE *A,R   0 VARIABLE *A,N                                                                            : LOGIC8  ( general assembly routine, 8 bit operations )                  ( ADD, ADC, SUB, SBC, OR, XOR, AND, CP       )          ?SOURCE CASE                                                    0 OF      DROP *A,N @ BYTE BYTE ENDOF   ( 8 bit immed )         1 OF      *A,R @ + BYTE ENDOF           ( 8 bit reg   )         2 OF      21 ERROR ENDOF                ( 16 bit reg  )         3 OF      23 ERROR ENDOF                ( 16 bit indx )         4 OF      1 = IF DD BYTE ELSE FD BYTE ENDIF                               *A,IX @ BYTE 0 BYTE ENDOF                             ENDCASE ;                                                                                                                     -->                                                             ( Z-80 Assembler --- 8 bit arithmetic operations )                                                                              : !A,&    *A,IX ! *A,N ! *A,R ! ;                                                                                               : ADD8    80 C6 86 !A,& LOGIC8 ; ( called by ADD )              : ADC8    88 CE 8E !A,& LOGIC8 ; ( called by ADC )              : SUB     90 D6 96 !A,& LOGIC8 ;                                : SBC8    98 DE 9E !A,& LOGIC8 ; ( called by SBC )              : AND     A0 E6 A6 !A,& LOGIC8 ;                                : OR      B0 F6 B6 !A,& LOGIC8 ;                                : XOR     A8 EE AE !A,& LOGIC8 ;                                : CP      B8 FE BE !A,& LOGIC8 ;                                                                                                -->                                                                                                                                                                                             ( Z-80 Assembler --- 16 bit arithmetic operations )                                                                             : ADD                            ( 8 or 16 bit addition )         ?DEST CASE                                                      0 OF 26 ERROR ENDOF            ( missing destination reg )      1 OF DROP ADD8 ENDOF           ( use common 8 bit routine )     2 OF 2 = IF ( is destination HL? ) ?SOURCE 2 =                              IF 09 + BYTE ELSE 2B ERROR ENDIF                             ELSE 2A ERROR ( illegal dest register ) ENDIF ENDOF    3 OF 29 ERROR ENDOF            ( ADD IX, xx and ADD IY,xx )     4 OF 2A ERROR ENDOF            ( illegal destination reg )      28 ERROR ENDCASE ;                                            -->                                                                                                                                                                                                                                                             ( Z-80 Assembler --- 16 bit arithmetic operations )             : ADC ?DEST CASE            ( 8 or 16 bit add with carry )        0 OF 26 ERROR ENDOF       ( missing destination reg )           1 OF DROP ADC8 ENDOF      ( 8 bit common routine )              2 OF 2 = IF ?SOURCE 2 = IF ED BYTE 4A + BYTE                                            ELSE 2B ERROR ENDIF                              ELSE 2A ERROR ENDIF ENDOF                              2A ERROR ENDCASE ;                                            : SBC ?DEST CASE            ( 8 or 16 bit subtract with carry )   0 OF 26 ERROR ENDOF       ( missing destination reg )           1 OF DROP SBC8 ENDOF      ( 8 bit common routine )              2 OF 2 = IF ?SOURCE 2 = IF ED BYTE 42 + BYTE                                            ELSE 2B ERROR ENDIF                              ELSE 2A ERROR ENDIF ENDOF                              2A ERROR ENDCASE ;                                            -->                                                             ( Z-80 Assembler --- absolute jumps )                           : JP                                                              ?COND 0=                                                        IF DROP ?SOURCE CASE             ( unconditional jump )            0 OF DROP C3 BYTE WORD ENDOF  ( jump to address )               1 OF 6 = IF E9 BYTE ELSE 22 ERROR ENDIF ENDOF ( via HL )        4 OF 1 = IF DD BYTE E9 BYTE   ( via IX or IY )                           ELSE FD BYTE E9 BYTE ENDIF ENDOF                       28 ERROR                      ( other addressing illegal )      ENDCASE                                                      ELSE                             ( conditional jumps )             SLL3 C2 + BYTE WORD                                          ENDIF ;                                                                                                                                                                                       -->                                                             ( Z-80 Assembler --- relative jumps )                           : JR                                                              ?COND                                                           IF                                    ( conditionals )               CASE                                                            3 OF 38 BYTE ENDOF               ( C )                          2 OF 30 BYTE ENDOF               ( NC )                         1 OF 28 BYTE ENDOF               ( Z )                          0 OF 20 BYTE ENDOF               ( NZ )                         2C ERROR ( illegal condition code ) ENDCASE                ELSE DROP 18 BYTE                     ( unconditional )         ENDIF                                                           HERE - 1 - BYTE                       ( store offset )          ;                                                             -->                                                                                                                             ( Z-80 Assembler --- INC and DEC instructions )                                                                                 0 VARIABLE *R     0 VARIABLE *RR                                0 VARIABLE *IX    0 VARIABLE *(IX)                              : INC&DEC ?SOURCE CASE  ( common routine for INC and DEC )        0 OF 26 ERROR ENDOF ( missing destination register )            1 OF SLL3 *R @ + BYTE ENDOF ( 8 bit register )                  2 OF *RR @ + BYTE ENDOF ( 16 bit register )                     3 OF 1 = IF DD BYTE  ( IX )  ELSE FD BYTE  ( IY ) ENDIF              *IX @ BYTE ENDOF                                           4 OF 1 = IF DD BYTE  ( @IX )  ELSE FD BYTE  ( @IY ) ENDIF            *(IX) @ BYTE 0 BYTE ENDOF ( indirect indexed )             ENDCASE ;                                                     : INC 04 *R ! 03 *RR ! 23 *IX ! 34 *(IX) ! INC&DEC ;            : DEC 05 *R ! 0B *RR ! 2B *IX ! 35 *(IX) ! INC&DEC ;            -->                                                             ( Z-80 Assembler --- special register shifts )                  : *SHIFT ?SOURCE CASE ( common routine for Z-80 shifts )          0 OF 26 ERROR ENDOF ( missing destination register )            1 OF CB BYTE *R @ + BYTE ENDOF ( 8 bit register )               2 OF 21 ERROR ENDOF ( 16 bit register )                         3 OF 21 ERROR ENDOF ( indexes )                                 4 OF 1 = IF DD BYTE ( @IX ) ELSE FD BYTE ( @IY ) ENDIF               CB BYTE 0 BYTE *(IX) @ BYTE ENDOF ( indirect indexed )     ENDCASE ;                                                     : RLC 00 *R ! 06 *(IX) ! *SHIFT ;                               : RL  10 *R ! 16 *(IX) ! *SHIFT ;                               : RRC 08 *R ! 0E *(IX) ! *SHIFT ;                               : RR  18 *R ! 1E *(IX) ! *SHIFT ;                               : SLA 20 *R ! 26 *(IX) ! *SHIFT ;                               : SRA 28 *R ! 2E *(IX) ! *SHIFT ;                               : SRL 38 *R ! 3E *(IX) ! *SHIFT ;     -->                       ( Z-80 Assembler --- register transfer and load immediate )                                                                     : LD                                                                                                                              ?DEST CASE                                                                                                                      0 OF 29 ERROR ENDOF    ( store direct instructions )                                                                            1 OF ?SOURCE CASE      ( destination = 8 bit register )               0 OF DROP 06 + BYTE BYTE ENDOF ( load immediate )               1 OF 40 + + BYTE ENDOF ( register to register )                 2D ERROR ( register mismatch )                                  ENDCASE ENDOF                                           -->                                                                                                                                                                                             ( Z-80 Assembler --- register transfer and load immediate )       2 OF ?SOURCE CASE ( destination = BC, DE, HL, SP )                   0 OF DROP SLL4 01 + BYTE WORD ENDOF ( immediate )               1 OF 2D ERROR ENDOF ( register mismatch )                       2 OF 29 ERROR ENDOF ( not implemented yet )                     3 OF 29 ERROR ENDOF ( not implemented yet )                     4 OF 2D ERROR ENDOF ( register mismatch )                       ENDCASE ENDOF                                                                                                              3 OF ?SOURCE       ( destination = IX or IY )                        0= IF  ( load immediate )                                       DROP 1 = IF DD BYTE ( IX ) ELSE FD BYTE ( IY ) ENDIF            21 BYTE WORD                                                    ELSE 2D ERROR ENDIF ( register mismatch )                       ENDOF                                                    -->                                                             ( Z-80 Assembler --- register transfer and load immediate )                                                                       4 OF ?SOURCE CASE ( destination = indirect indexed )                0 OF DROP 1 = IF DD BYTE ELSE FD BYTE ENDIF                         36 BYTE 00 BYTE BYTE ENDOF ( 8 bit immediate )              1 OF SWAP 1 = IF DD BYTE ELSE FD BYTE ENDIF                         70 + BYTE 0 BYTE ENDOF ( 8 bit register to mem. )           2D ERROR ( register mismatch )                                  ENDCASE ENDOF                                                                                                               ENDCASE ;                                                     -->                                                                                                                                                                                                                                                                                                                             ( Z-80 Assembler --- register exchanges )                                                                                       : EX   ( exchange 16 bit registers )                              ?SOURCE 0= IF 25 ERROR ENDIF                                    ?DEST 0= IF 26 ERROR ENDIF                                      + CASE                                                          21 OF EB BYTE ENDOF  ( EX DE,HL )                               2D ERROR ( not implemented yet )                                ENDCASE                                                         ;                                                             -->                                                                                                                                                                                                                                                                                                                                                                                             ( Z-80 Assembler --- absolute subroutine CALL )                                                                                 : CALL                                                                                                                            ?SOURCE IF 28 ERROR ENDIF ( illegal addressing mode )           DROP ( discard register code )                                  ?COND IF SLL3 C4 + BYTE   ( conditional )                             ELSE DROP CD BYTE ENDIF ( unconditional )                 WORD ( store target address )                                   ;                                                                                                                             -->                                                                                                                                                                                                                                                                                                                             ( Z-80 Assembler --- control structures )                                                                                       CA CONSTANT 0#                FA CONSTANT 0>=                   C2 CONSTANT 0=                F2 CONSTANT 0<                                                                                    : IF            BYTE HERE 0 WORD ;                              : ELSE          0C3 BYTE HERE 0 WORD SWAP HERE SWAP ! ;         : ENDIF         HERE SWAP ! ;                                   : BEGIN         HERE ;                                          : UNTIL         BYTE WORD ;                                                                                                     FORTH DEFINITIONS DECIMAL                                       ' ASSEMBLER CFA ' ;CODE 08 + !                                  CR ." Compilation of Z-80 Assembler completed. " CR             SP@ DP @ - . ." bytes left in dictionary. " CR  ;S                                                                              ( Z-80 Assembler, demonstration screen )                        ( Example of using the Assembler to add a machine )             ( language primitive to the interpreter/compiler  )             ASSEMBLER ( select the Assembler vocabulary )                   CODE ADD5 ( primitive to increment the top number )                       ( on the stack by 5                     )                  HL        POP                                                   DE, 5     LD                                                    HL, DE    ADD                                                   HL        PUSH                                                            NEXT                                                                                                             CR ." 20 is placed on the stack "    20                         CR ." ADD5 is executed "             ADD5                       CR ." The top of the stack now = " .                            DECIMAL 100 LIST ;S                                             ( Memory Dump )                                                 ( display n memory locations in hex and ASCII, starting )       ( at addr rounded to next lower 16 byte boundary )              : DUMP   ( addr n DUMP ->   )                                     BASE @ >R HEX CR CR 5 SPACES      ( save current BASE )         16 0 DO I 3 .R LOOP 2 SPACES      ( print titles )              16 0 DO I 0 <# # #> TYPE LOOP CR                                OVER + SWAP DUP 15 AND XOR DO     ( round starting address )    CR I 0 4 D.R 1 SPACES             ( print address )             I 16 + I 2DUP                                                            DO I C@ SPACE 0 <# # # #> TYPE LOOP   ( hex )                   2 SPACES                                                        DO I C@ DUP 32 < IF DROP 46 ENDIF     ( ASCII )                      DUP 127 > IF DROP 46 ENDIF EMIT LOOP              16 +LOOP CR R> BASE !  ;           ( restore BASE )           ;S                                                              ( CP/M Disk Interface --- Ray Duncan, Laboratory Microsystems ) ( standard CP/M file control block description:         )       ( byte      contents                                    )       (  0        drive 0=default, 1=A, 2=B  etc.             )       (  1-8      filename                                    )       (  9-11     extension                                   )       (  12       current extent                              )       (  13-14    reserved for operating system               )       (  15       record count, current extent                )       (  16-31    reserved for operating system               )       (  32       current record, sequential access           )       (  33-34    current record, random access mode          )       (  35       overflow from current random record         )       FORTH DEFINITIONS DECIMAL                                       -->                                                                                                                             ( CP/M Disk Interface --- control block )                       ( Establish a file control block, control byte, )               ( and 128 byte disk buffer.                     )               : FCB   ( --- control-block-name )                                <BUILDS HERE 165 ERASE 165 ALLOT                                DOES> ;                                                                                                                       ( define the distance from the beginning of the     )           ( file control block to the disk buffer             )           37 CONSTANT BUFFER-OFFSET                                                                                                       -->                                                                                                                                                                                                                                                                                                                             ( CP/M Disk Interface --- format filename into fcb )            : FILENAME     ( fcb-address FILENAME nametext )                  DUP 37 ERASE 1+ DUP 11 BLANKS ( clear file control block )      BLK @ IF BLK @ BLOCK ELSE TIB @ ENDIF IN @ + ( text addr )      8 0 DO  ( first format filename ) DUP C@ DUP ( next char )      46 = IF DROP LEAVE ELSE  ( quit if dot )                        DUP 33 < IF DROP LEAVE   ( or if space or null )                ELSE ROT DUP I + ROT SWAP C! SWAP 1+ 1 IN +! ENDIF ENDIF LOOP   DUP C@ 46 = ( is there an extension? )                          IF SWAP 8 + SWAP 1+ 1 IN +! 3 0 DO  ( yes format it )           DUP C@ ( fetch next char. )                                     DUP 33 < IF DROP LEAVE  ( quit if null or space )               ELSE ROT DUP I + ROT SWAP C! SWAP 1+ 1 IN +! ENDIF LOOP         ENDIF ( done with extension )                                   DROP DROP  ( clean up stack ) ;                               -->                                                             ( CP/M Disk Interface --- file operations )                     ( for all file operations, status code = 0FF if  )              ( operation failed, 0-3 if operation successful  )              : OPEN-FILE   ( fcb-address --- status-code )                     15 SWAP FDOS DROP ;                                           : CLOSE-FILE  ( fcb-address --- status-code )                     16 SWAP FDOS DROP ;                                           : MAKE-FILE   ( fcb-address --- status-code )                     22 SWAP FDOS DROP ;                                           : DELETE-FILE ( fcb-address --- status-code )                     19 SWAP FDOS DROP ;                                           -->                                                                                                                                                                                                                                                                                                                             ( CP/M Disk Interface --- memory operations )                                                                                                                                                   ( set dma address to the dedicated disk buffer )                ( for this file control block                  )                : SET-DMA   ( fcb-address -> )                                    26 SWAP BUFFER-OFFSET + FDOS DROP DROP ;                      -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( CP/M Disk Interface --- sequential record operations )        ( all record operations return the disk buffer address )        ( if operation successful, else zero                   )                                                                        : READ-SEQ    ( fcb-address -> status-code )                      DUP DUP SET-DMA 20 SWAP FDOS DROP                               0= IF BUFFER-OFFSET + ELSE DROP 0 ENDIF ;                                                                                     : WRITE-SEQ   ( fcb-address -> status-code )                      DUP DUP SET-DMA 21 SWAP FDOS DROP                               0= IF BUFFER-OFFSET + ELSE DROP 0 ENDIF ;                     -->                                                                                                                                                                                                                                                                                                                             ( CP/M Disk Interface --- random record operations )                                                                            : READ-RANDOM   ( fcb-address record-no. -> status-code )         OVER 33 + ! DUP DUP SET-DMA 33 SWAP FDOS DROP                   0= IF BUFFER-OFFSET + ELSE DROP 0 ENDIF ;                                                                                     : WRITE-RANDOM  ( fcb-address record-no. -> status-code )         OVER 33 + ! DUP DUP SET-DMA 34 SWAP FDOS DROP                   0= IF BUFFER-OFFSET + ELSE DROP 0 ENDIF ;                     ;S                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( CP/M Disk Interface --- filename console input )              : INPUT-FILENAME    ( fcb-address  ->  )                          DUP DUP 37 ERASE 1+ 11 BLANKS ( clear out the fcb )             CR  ." Enter drive: "  KEY DUP                                  13 = 0= IF DUP EMIT ENDIF  64 - 1 MAX 4 MIN OVER C!             ."   Enter filename: "  1+ DUP                                  8 0 DO KEY DUP 13 = IF DROP LEAVE ELSE                                 DUP EMIT OVER C! 1+ ENDIF LOOP                           ."   Enter extension: " DROP 8 +                                3 0 DO KEY DUP 13 = IF DROP LEAVE ELSE                                 DUP EMIT OVER C! 1+ ENDIF LOOP                           DROP ;                                                        ;S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( fig-FORTH 8080 Assembler --- John J. Cassady )                VOCABULARY ASSEMBLER IMMEDIATE ASSEMBLER DEFINITIONS HEX        ' ASSEMBLER CFA ' ;CODE 08 + !  NEXT-LINK CONSTANT NEXT         : CODE          ?EXEC CREATE !CSP ; IMMEDIATE                   : C;            ?EXEC ?CSP SMUDGE ; IMMEDIATE                   : LABEL ?EXEC 0 VARIABLE SMUDGE -2 ALLOT [COMPILE]                ASSEMBLER !CSP ; IMMEDIATE                                    : 8* DUP + DUP + DUP + ;                                        4 CONSTANT H   5 CONSTANT L  7 CONSTANT A  6 CONSTANT PSW       2 CONSTANT D   3 CONSTANT E  0 CONSTANT B  1 CONSTANT C         6 CONSTANT M   6 CONSTANT SP                                    : 1MI <BUILDS C, DOES> C@ C, ;                                  : 2MI <BUILDS C, DOES> C@ + C, ;                                : 3MI <BUILDS C, DOES> C@ SWAP 8* + C, ;                        : 4MI <BUILDS C, DOES> C@ C, C, ;                               : 5MI <BUILDS C, DOES> C@ C, , ;  -->                           ( fig-FORTH 8080 Assembler, continued )                         00 1MI NOP   76 1MI HLT   F3 1MI DI    FB 1MI EI                07 1MI RLC   0F 1MI RRC   17 1MI RAL   1F 1MI RAR               E9 1MI PCHL  F9 1MI SPHL  E3 1MI XTHL  EB 1MI XCHG              27 1MI DAA   2F 1MI CMA   37 1MI STC   3F 1MI CMC               80 2MI ADD   88 2MI ADC   90 2MI SUB   98 2MI SBB               A0 2MI ANA   A8 2MI XRA   B0 2MI ORA   B8 2MI CMP               09 3MI DAD   C1 3MI POP   C5 3MI PUSH  02 3MI STAX              0A 3MI LDAX  04 3MI INR   05 3MI DCR   03 3MI INX               0B 3MI DCX   C7 3MI RST   D3 4MI OUT   DB 4MI IN                C6 4MI ADI   CE 4MI ACI   D6 4MI SUI   DE 4MI SBI               E6 4MI ANI   EE 4MI XRI   F6 4MI ORI   FE 4MI CPI               22 5MI SHLD  2A 5MI LHLD  32 5MI STA   3A 5MI LDA               C4 5MI CNZ   CC 5MI CZ    D4 5MI CNC   DC 5MI CC                E4 5MI CPO   EC 5MI CPE   F4 5MI CP    FC 5MI CM                CD 5MI CALL                                        -->          ( fig-FORTH 8080 Assembler, continued )                         C0 1MI RNZ   C8 1MI RZ    D0 1MI RNC   D8 1MI RC                E0 1MI RPO   E8 1MI RPE   F0 1MI RP    F8 1MI RM                C9 1MI RET   C3 5MI JMP   C2 CONSTANT 0=  D2 CONSTANT CS        E2 CONSTANT PE  F2 CONSTANT 0<                                  : NOT 8 + ;                                                     : MOV 8* 40 + + C, ;  : MVI 8* 6 + C, C, ;  : LXI 8* 1+ C, , ;  : ENDIF 2 ?PAIRS HERE SWAP ! ;  : THEN [COMPILE] ENDIF ;        : IF C, HERE 0 , 2 ;                                            : ELSE 2 ?PAIRS C3 IF ROT SWAP ENDIF 2 ;                        : BEGIN HERE 1 ;                                                : UNTIL SWAP 1 ?PAIRS C, , ;  : AGAIN 1 ?PAIRS C3 C, , ;        : WHILE IF 2+ ;                                                 : REPEAT >R >R AGAIN R> R> 2 - ENDIF ;                                                                                          FORTH DEFINITIONS DECIMAL ;S                                    ( Examples using fig-FORTH 8080 Assembler, John J. Cassady )    HEX ASSEMBLER                                                   CODE CSWAP  ( swaps high and low bytes of top stack word )        H POP   L A MOV  H L MOV   A H MOV  NEXT 1 - JMP C;                                                                           CODE LCFOLD ( from-2 qty-1 --- converts lower case to upper )     D POP  H POP                                                    BEGIN  D A MOV  E ORA  0= NOT                                   WHILE  M A MOV  60 CPI  CS NOT                                         IF 20 SUI  A M MOV   ENDIF                                      D  DCX  H INX                                            REPEAT NEXT JMP C;                                            FORTH DECIMAL ;S                                                                                                                                                                                                                                                ( VIEW command by George W. Shaw II )                           ( from FORTH Dimensions II/6 page 162 )                         FORTH DEFINITIONS                                               0 VARIABLE VIEW.FENCE                                           : VIEW  ( list source screen of definition )                      [COMPILE] ' DUP VIEW.FENCE @ <                                  IF CR ."  OK " QUIT ENDIF                                       NFA 2 - @ -DUP IF LIST ENDIF ;                                : >DOC< BLK @ B/SCR / , ;                                                                                                       : CONSTANT      >DOC< [COMPILE] CONSTANT     ;                  : VARIABLE      >DOC< [COMPILE] VARIABLE     ;                  : VOCABULARY    >DOC< [COMPILE] VOCABULARY   ;                  : :             >DOC< [COMPILE] :            ;                  : <BUILDS       >DOC< [COMPILE] <BUILDS      ;                  HERE VIEW.FENCE ! ;S                                            ( Greatest common divisor demonstration, R. L. Smith )          ( from FORTH Dimensions II/6 page 167                )          : GCD                                                             BEGIN                                                              SWAP OVER MOD -DUP 0=                                        UNTIL ;                                                       : G-C-D                                                           GCD CR ." The greatest common divisor is " . CR ;                                                                             CR ." Enter two numbers, then type G-C-D. "                     CR ." The greatest common divisor of these "                    CR ." numbers will be displayed. "                              CR                                                              ;S                                                                                                                                                                                              ( Memory allocation map )                                       FORTH DEFINITIONS HEX   : H. 0 4 D.R ." H" ;                    : MAP     HEX CR                                                  CR ." Address of NEXT =               " NEXT-LINK H.            CR ." Top of dictionary =             " DP @ H.                 CR ." Available room in dictionary =  " SP@ DP @ -                 DECIMAL . ." bytes " HEX                                     CR ." Base of data stack =            " S0 @  H.                CR ." Start of terminal buffer =      " TIB @ H.                CR ." Base of return stack =          " R0 @ H.                 CR ." Start of user variables =       " R0 @ H.                 CR ." Start of disk buffer area =     " FIRST H.                CR ." End of disk buffer area =       " LIMIT H.      DECIMAL   CR ." Disk buffers available =        " #BUFF .                 CR ." Size of CP/M user area =        " 6 @ 0 D. ." bytes "     CR CR ;     DECIMAL ;S                                        ( Cursor control functions for Hazeltine 1500, 1510, or 1520 )  ( Contributed by C. Whitmore, Irex Corp., Ramsey, NJ 5/15/81 )  FORTH DEFINITIONS DECIMAL  : LEADIN   126 EMIT ;                : GOTOXY        LEADIN   17 EMIT SWAP                                           0 MAX 79 MIN 1+ EMIT 0 MAX 23 MIN 1+ EMIT ;     : CLEARSCREEN   LEADIN   28 EMIT ;                              : CLREOS        LEADIN   24 EMIT ;                              : CLREOL        LEADIN   15 EMIT ;                              : HOME          LEADIN   18 EMIT ;                              : FOREGROUND    LEADIN   31 EMIT ;     ( bright display )       : BACKGROUND    LEADIN   25 EMIT ;     ( normal display )       ;S                                                                                                                                                                                                                                                                                                                              ( Reallocate RAM Workspace under CP/M )                         0 VARIABLE EM 0 VARIABLE #SCR 0 VARIABLE .R0 0 VARIABLE .S0     -FIND LIMIT DROP DROP CONSTANT .LIMIT                           -FIND FIRST DROP DROP CONSTANT .FIRST                           -FIND #BUFF DROP DROP CONSTANT .#BUFF   DECIMAL 47 LOAD         : REALLOCATE    6 @ 0 CR ." CP/M starts at " HEX D. CR DECIMAL  ." Enter kbyte size of system to build <16-48>: " #IN 1024 *    EM ! CR ." Enter # of screens to buffer: " #IN #SCR ! CR        EM @ DUP .LIMIT ! B/BUF 4 + #SCR @ 8 * * - DUP DUP              .FIRST ! PREV ! USE !  #SCR @ 8 * .#BUFF !                      FIRST 64 - DUP .R0 ! 160 - DUP .S0 ! TIB !                      .R0 @ DUP DUP DUP 16 +ORIGIN ! 20 +ORIGIN !                     38 +ORIGIN ! 40 +ORIGIN !                                       .S0 @ DUP 18 +ORIGIN ! 22 +ORIGIN ! VOC-LINK @ 32 +ORIGIN !     .R0 @ R0 ! .S0 @ S0 ! RP! SP! COLD ;                                                                                            ( Cursor control functions for IBM 3101-10 or 3101-20 CRT )     ( Contributed by C. Whitmore, IREX Corp., Ramsey, NJ      )                                                                     FORTH DEFINITIONS DECIMAL                                                                                                       : LEADIN        27 EMIT ;                                                                                                       : GOTOXY        LEADIN 89 EMIT                                                  0 MAX 23 MIN 33 + EMIT                                          0 MAX 79 MIN 33 + EMIT ;                        : CLEARSCREEN   LEADIN 76 EMIT ;                                : CLREOS        LEADIN 74 EMIT ;                                : CLREOL        LEADIN 73 EMIT ;                                : HOME          LEADIN 72 EMIT ;                                ;S                                                                                                                              ( Source for LIST, TRIAD )                                      FORTH DEFINITIONS DECIMAL                                       : LIST                                                            DECIMAL CR DUP SCR ! 4 SPACES ." Screen # " .                   16 0 DO                                                            CR R 3 .R SPACE R SCR @ .LINE                                   ?TERMINAL IF LEAVE ENDIF                                     LOOP CR ;                                                                                                                     : TRIAD                                                           12 EMIT                                                         3 / 3 * 3 OVER + SWAP DO                                          CR I LIST                                                       ?TERMINAL IF LEAVE ENDIF                                      LOOP CR 15 MESSAGE CR ;                                       ;S                                                              ( Source for GO, INDEX )                                        FORTH DEFINITIONS DECIMAL                                                                                                       : GO                                                              HERE ! HERE EXECUTE ;                                                                                                         : INDEX                                                           12 EMIT                                                         CR 1+ SWAP DO                                                     CR I 3 .R SPACE 0 I .LINE                                       ?TERMINAL IF LEAVE ENDIF                                      LOOP ;                                                        ;S                                                                                                                                                                                                                                                              ( Source for VLIST )                                            FORTH DEFINITIONS DECIMAL                                       : H. BASE @ SWAP HEX . BASE ! ;                                 : VLIST                                                           79  OUT !                                                       CONTEXT @ @ BEGIN                                                 79  OUT @ - OVER C@ 31 AND 9 + <                                IF CR 0 OUT ! ENDIF                                             DUP DUP H. ID.                                                  SPACE SPACE PFA LFA @ DUP 0=                                    ?TERMINAL OR UNTIL                                            DROP CR CR ;                                                  ;S                                                                                                                                                                                                                                                              ( Double precision variable and constant )                                                                                      : DVARIABLE                                                       <BUILDS HERE 2! 4 ALLOT                                         DOES> ;                                                                                                                       : DCONSTANT                                                       <BUILDS HERE 2! 4 ALLOT                                         DOES> 2@ ;                                                                                                                    ;S                                                                                                                                                                                                                                                                                                                                                                                              ( Hex and ASCII dump, by Joel Shprentz , the Software Farm )    HEX                                                             : DUMP.  ( dump 16 bytes from addr-1 in hex and ascii )           DUP ." : "                                                      10 0 DO   DUP C@ 0 <# # # #> TYPE                                         I 1 AND SPACES 1+ LOOP                                DROP SPACE                                                      10 0 DO   DUP C@ DUP BL < OVER 7F > OR                                    IF DROP 2E THEN EMIT 1+ LOOP ;                                                                                      : DUMP   ( dump memory from addr-2 for n-1 bytes )                BASE @ >R HEX                                                   0 DO  CR DUP 0 <# # # # # #> TYPE                                     DUMP. ?TERMINAL IF LEAVE ENDIF 10 +LOOP                   CR DROP R> BASE ! ;                                           -->                                                             ( Disk dump word, by Joel Shprentz, the Software Farm )                                                                         : DDUMP   ( dump block-1 in hex and ascii )                       BASE @ >R HEX BLOCK                                             B/BUF 0 DO                                                        CR I 0 <# # # #> TYPE DUMP. 10 +LOOP                          DROP R> BASE ! CR CR ;                                        DECIMAL                                                         ;S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( Multi-dimensional array definition, by Joel Shprentz )                                                                        : *ARRAY                                                          DUP 1 < 28 ?ERROR     ( must be at least 1 dimension )          DUP 255 > 28 ?ERROR   ( but less than 255 of them )             <BUILDS                                                           DUP C,              ( save # of dimensions )                    1 SWAP              ( initialize total size )                   0 DO                ( loop on # of dimensions )                   OVER ,            ( save dimension )                            *                 ( increase total size )                       LOOP                                                          1 ,                 ( save dummy dimension )                    2 * ALLOT           ( allocate space for words )            -->                                                                                                                             ( Multi-dimensional array definition, continued )                 DOES>                                                             COUNT               ( get # of dimensions )                     0 SWAP              ( initialize offset )                       0 DO                ( loop on # of dimensions )                   >R                ( save offset )                               OVER DUP 0< 29 ?ERROR     ( error if negative index )           OVER @ < 0= 30 ?ERROR     ( error if index too large )          2+ DUP @          ( advance to next dimension )                 ROT R> + *        ( calculate offset so far )                   LOOP                                                          2 *                 ( double offset for words )                 + 2+ ;              ( calculate element address )           ;S                                                              *** see next screen for examples ***                                                                                            ( Multi-dimensional arrays, examples )                          ;S                                                              To define an array, the vector size for each dimension          must be on the stack followed by the total # of dimensions.     Example:  to define a 3 dimensional array named MATRIX with     a vector length of 5 in each dimension (i.e. x, y, z = 0...4)   you would execute:                                                      5  5  5  3  *ARRAY  MATRIX                                                                                              To get an indexed address into the array, put the coordinates   on the stack followed by the name of the array.                 Example:  to retrieve the value stored in (x,y,x) = (1,2,3)     for the array above, you would execute:                                 1  2  3  MATRIX  @                                                                                                                                                                      ( Utility screen for NEC Spinwriter, by Glenn Burklund )        ( Sets left margin to 8 to allow for 3 hole punch and  )        ( right margin for no print on platen... to use type:  )        ( MARGINSET <cr>                                       )        FORTH DEFINITIONS HEX                                           : ZEROPRINTER   1B EMIT 4F EMIT CR ;                            : MARGINSET     PRINTER ZEROPRINTER 8 0 DO 20 EMIT LOOP                         1B EMIT 4D EMIT 5D 0 DO 20 EMIT LOOP                            1B EMIT 4A EMIT CR CONSOLE ;                    ( Print 3 screens on page, substitute for TRIAD )               : TRYAD         3 / 3 * 3 OVER + SWAP                                           DO CR I LIST LOOP                                               CR 0F MESSAGE CR 0C EMIT ;                      ( print series of triads ... n1 n2 SHOW )                       : SHOW          PRINTER 1 + SWAP DO I TRYAD 3 +LOOP CONSOLE ;   DECIMAL ;S                                                      ( Console string input )                                                                                                        FORTH DEFINITIONS DECIMAL                                                                                                       : IN$         ( first-byte-addr  max-length  ---  char-count )    OVER >R               ( save copy of f.b.a. )                   2DUP BLANKS           ( clear input area )                      0 DO                  ( loop on max. char. count )              KEY DUP 32 <          ( read one character )                    IF   DROP LEAVE       ( if CR all done, don't echo it )         ELSE DUP EMIT         ( else echo it )                            OVER C! 1+ ENDIF    ( and store into buffer )                 LOOP                                                            R> -                  ( calculate length of input )             ;                                                                                                                             ( Source for USING )                                                                                                            FORTH DEFINITIONS                                                                                                               : SCRTYPE       SCREEN-FCB 9 +     ( sets extension )                           83 OVER C! 1+      ( .SCR into )                                67 OVER C! 1+      ( file control block )                       82 SWAP C! ;                                                                                                    -->                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( Source for USING, continued )                                                                                                 : USING                         (  ---   file-name  )             ?EXEC                         ( can't be compiling )            FLUSH                         ( force all blocks to disk )      16 SCREEN-FCB FDOS DROP DROP  ( close previous screen file )    SCREEN-FCB DUP 37 ERASE       ( clear out file control blk )    1+ DUP 11 BLANKS              ( set file name to blanks )       TIB @ IN @ +                  ( input buffer offset )           8 0 DO                        ( file name max 8 char. )         DUP C@ DUP 48 <               ( fetch next character )          IF DROP LEAVE                 ( if not 0-Z quit )               ELSE 3 PICK I + C!            ( otherwise store into fcb )           1 IN +! 1+ ENDIF         ( update pointers )               LOOP                          ( loop until filename done )    -->                                                             ( Source for USING, continued )                                                                                                   DROP DROP                     ( clean up stack )                SCRTYPE                       ( set extension=SCR )             EMPTY-BUFFERS                 ( clear disk buffer area )        15 SCREEN-FCB FDOS DROP       ( request file opening )          255 =                         ( successful open? )              IF CR ." No such screen file. "                                    0 0 FDOS                   ( no, exit )                      ELSE 3 SPACES ." Current screen file --- "                          SCREEN-FCB .FCB CR ENDIF  ( yes, display fully )            ;                             ( qualified file name )                                                                                                                                                                                                                                                                         ( Trace colon words, adapted from Paul van der Eijk )           ( from FORTH Dimensions, Volume III, Number 2, page 58 )        FORTH DEFINITIONS                                               0 VARIABLE TFLAG        ( controls trace output )               : (TRACE)               ( inserted as 1st word of definition )    TFLAG @               ( trace output if non-zero )              IF BASE @ TFLAG ! HEX                                              CR R 2 - NFA DUP ID.       ( back to NFA for name )             C@ 31 AND 32 SWAP - SPACES ( tab over )                         SP@ S0 @ =                                                      IF ."  empty stack"                                             ELSE SP@ DUP 16 + S0 @ MIN SWAP    ( show up to top )           DO I @ 0 5 D.R 2 +LOOP ENDIF       ( 8 words of stack )         TFLAG @ BASE !                                               ENDIF ;                                                       -->                                                             ( Trace colon words, continued )                                                                                                : TRACE         1 TFLAG ! ;     ( turn on trace mode )          : NOTRACE       0 TFLAG ! ;     ( turn off trace mode )                                                                         : :             ( redefine colon to insert trace word )           ?EXEC         ( must be executing )                             !CSP          ( compiler security )                             CURRENT @ CONTEXT !   ( set context vocabulary )                CREATE        ( build the dictionary header )                   ' (TRACE)     ( find CFA of trace runtime routine )             CFA DUP @     ( and compile it )                                HERE 2 - ! ,                                                    ]             ( enter compilation mode )                        ; IMMEDIATE                                                   ;S                                                              ( TRACE function example )                                      ( after compiling screens #135-136, you may )                   ( type 137 LOAD <return> to demonstrate a trace )                                                                               : DROP          DROP ;  ( redefine with the trace enabled )                                                                     : TEST          5 0 DO                                                          I DUP DROP                                                      LOOP ;                                                                                                          TRACE TEST NOTRACE                                              ;S                                                                                                                                                                                                                                                                                                                              ( Source for .FCB )                                             FORTH DEFINITIONS DECIMAL                                       : .FCB                                                            DUP >R                                                          C@ DUP 0=                                                       IF DROP 25 0 FDOS DROP 1+ ENDIF 96 + EMIT                       58 EMIT                                                         R 1+ DUP 8 + SWAP                                               DO I C@ DUP 32 -                                                   IF DUP 64 > IF 32 OR ENDIF EMIT ELSE DROP ENDIF LOOP         46 EMIT                                                         R> 9 + DUP 3 + SWAP                                             DO I C@ DUP 32 -                                                   IF DUP 64 > IF 32 OR ENDIF EMIT ELSE DROP ENDIF LOOP         ;                                                                                                                             ( Source for .BUFS, by Timothy Huang )                          FORTH DEFINITIONS DECIMAL                                                                                                       : .BUFS         ( display address of all disk buffers )           CR CR ."  #  Address  Upd  Block #  Screen  -sub "              FIRST #BUFF 1+ 1 DO                                             CR I 2 .R 3 SPACES                                              DUP 2+ HEX 0 5 D.R DECIMAL 4 SPACES                             DUP @ 32768 AND IF 121 ELSE 32 ENDIF EMIT 2 SPACES              DUP @ 32767 =                                                   IF ."  unused " ELSE                                               DUP @ 32767 AND DUP 6 .R 4 SPACES                               B/SCR /MOD 5 .R 4 SPACES 2 .R ENDIF                          132 +                                                           ?TERMINAL IF LEAVE ENDIF                                        LOOP DROP CR CR ;                                             ( Utility to move many sequential screens to other areas JS )                                                                   : MOVE-SCREEN                   ( move screen-2 to screen-1 )     B/SCR * SWAP B/SCR *          ( convert to block numbers )      DUP B/SCR + OVER              ( limits of from screen )         DO I BLOCK DROP LOOP          ( get blocks in buffers )         DUP B/SCR + SWAP              ( limits of from screen )         DO  I BLOCK PAD B/BUF CMOVE   ( get from block )                    PAD OVER BLOCK B/BUF      ( save in to block )                  CMOVE UPDATE 1+ LOOP      ( increment from block )          DROP FLUSH ;                  ( write to block )                                                                              : MOVE-SCREENS   ( move screens-3 through-2 to screens at-1 )       SWAP 1+ ROT DO I OVER MOVE-SCREEN 1+ LOOP DROP ;            ;S                                                                                                                              ( Read time/date from Dual Clock-24 Board )                                                                                     0 VARIABLE $DAY                                                 0 VARIABLE $MONTH                                               0 VARIABLE $YEAR                                                0 VARIABLE $HOUR                                                0 VARIABLE $MINUTE                                              0 VARIABLE $SECOND                                                                                                              : BYTEARRAY     <BUILDS 0 DO 0 C, LOOP                                          DOES> + ;                                                                                                       13 BYTEARRAY <TIME>                                             -->                                                                                                                                                                                             ( Read time/date from Dual Clock-24 Board, continued )                                                                          240             CONSTANT $CLK-24-DATA                           $CLK-24-DATA 1+ CONSTANT $CLK-24-CTRL                                                                                                           ( read one byte from clock board )              : @CLK-24       $CLK-24-DATA P@ ;                                                                                                               ( send byte on top of stack to )                                ( clock control port )                          : !CLK-24       $CLK-24-CTRL P! ;                                                                                               -->                                                                                                                                                                                                                                                             ( Read time/date from Dual Clock-24 Board, continued )                                                                          : READ-CLOCK    128 !CLK-24             ( hold bit on )                         13 0 DO                                                         128 32 I + + !CLK-24    ( hold+read+addr )                      @CLK-24 15 AND          ( read this digit )                     I <TIME> C!             ( store into array )                    LOOP                                                            0 !CLK-24               ( hold bit off )                                                ( remove extra bits )                   5 <TIME> C@ 3 AND 5 <TIME> C!                   -->                                                                                                                                                                                                                                                                                                                             ( Read time/date from Dual Clock-24 Board, continued )                                                                                          12 <TIME> C@ 10 * 11 <TIME> C@ + $YEAR !                        10 <TIME> C@ 10 * 9 <TIME> C@ + $MONTH !                        8 <TIME> C@ 10 * 7 <TIME> C@ + $DAY !                           5 <TIME> C@ 10 * 4 <TIME> C@ + $HOUR !                          3 <TIME> C@ 10 * 2 <TIME> C@ + $MINUTE !                        ;                                               -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( Read time/date from Dual Clock-24 Board, continued )                                                                          : .TIME         READ-CLOCK                                                      $HOUR @ 100 * $MINUTE @ + 0                                     <# # # 58 HOLD # # #> TYPE ;                                                                                    : .DATE         READ-CLOCK                                                      $MONTH @ 100 * $DAY @ + 0                                       <# # # 47 HOLD # # #> TYPE                                      $YEAR @  0                                                      <# # # 47 HOLD #> TYPE ;                                                                                        ;S                                                                                                                                                                                                                                                              ( Screen listing utility for Laboratory Microsystems manuals )                                                                  141 LOAD        ( get time and date routines )                                                                                  : TRIAD         12 EMIT                                                         3 / 3 * 3 OVER + SWAP DO                                        CR I LIST                                                       LOOP CR CR                                                      0 OUT !                                                         ." Laboratory Microsystems Z-80 FORTH"                          48 OUT @ - SPACES                                               SCREEN-FCB .FCB 2 SPACES                                        .TIME 2 SPACES  .DATE CR ;                      -->                                                                                                                                                                                             ( Screen listing utility for Laboratory Microsystems manuals )                                                                  : SHOW                                                            SWAP PRINTER                                                    DO I TRIAD                                                      3 +LOOP                                                         CONSOLE                                                         ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( Cursor control functions for Synertek KTM-3/80 )              ( contributed by Ross Mills, Morgan Hill, CA 10/7/81 )                                                                          FORTH DEFINITIONS DECIMAL                                                                                                       : GOTOXY        27 EMIT 61 EMIT                                                 0 MAX 22 MIN 33 + EMIT                                          0 MAX 79 MIN 33 + EMIT ;                        : CLEARSCREEN   26 EMIT ;                                       : CLREOS        27 EMIT 74 EMIT ;                               : CLREOL        27 EMIT 75 EMIT ;                               : HOME          30 EMIT ;                                       ;S                                                                                                                                                                                                                                                              ( Eratosthenes Sieve Prime Number program in FORTH )            ( by Jim Gilbreath, BYTE September 1981 page 190 )              FORTH DEFINITIONS DECIMAL                                       8190 CONSTANT SIZE      0 VARIABLE FLAGS        SIZE ALLOT                                                                      : DO-PRIME      FLAGS SIZE 1 FILL                                               0 SIZE 0                                                        DO FLAGS I + C@                                                    IF I DUP + 3 + DUP I +                                               BEGIN DUP SIZE <                                                WHILE 0 OVER FLAGS + C! OVER + REPEAT                           DROP DROP 1+                                               THEN                                                         LOOP                                                            .  ." primes " ;                                ;S                                                              ( Cursor control functions for Micro-Term ACT-IV B )            ( Contributed by Matthew Halfant, Cold Spring, NY )                                                                             FORTH DEFINITIONS DECIMAL                                                                                                       : GOTOXY                20 EMIT                                                         0 MAX 23 MIN EMIT                                               0 MAX 79 MIN EMIT ;                     : CLEARSCREEN           12 EMIT 0 DUP DUP EMIT EMIT EMIT ;      : CLREOS                31 EMIT 0 DUP DUP EMIT EMIT EMIT ;      : CLREOL                30 EMIT ;                               : HOME                  29 EMIT ;                               ;S                                                                                                                                                                                                                                                              ( CRT Cursor control functions for Ramtek 8025G)                FORTH DEFINITIONS DECIMAL                                       : GOTOXY HEX 27 EMIT 125 EMIT 25 + 25 MAX 48 MIN BASE @ /MOD     64 + EMIT 64 + EMIT 0 MAX 79 MIN 1+ BASE @ /MOD 64 + EMIT 64 +     EMIT   DECIMAL  ;                                           : NEXTPAGE 27 EMIT 85 EMIT ;                                    : CLEARSCREEN 27 EMIT 74 EMIT NEXTPAGE ;                        : CLREOS 27 EMIT 74 EMIT ;  ( CLREOS, CLREOL, and HOME are )    : CLREOL 27 EMIT 75 EMIT ;  ( not necessary for operation )     : HOME 27 EMIT 72 EMIT ;    ( of demonstration programs )       ;S                                                              ( the CLEARSCREEN function must clear the CRT screen and )      ( leave the cursor in the upper left corner.  On some models )  ( this requires two separate escape sequences )                 ( the GOTOXY function is used as follows:  x y GOTOXY )         ( stack effect:  2 -> 0 )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       